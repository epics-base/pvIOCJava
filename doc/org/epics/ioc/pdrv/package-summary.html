<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0) on Wed Jul 15 14:25:51 GMT-05:00 2009 -->
<TITLE>
org.epics.ioc.pdrv
</TITLE>

<META NAME="date" CONTENT="2009-07-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.epics.ioc.pdrv";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/ioc/install/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/ioc/pdrv/interfaces/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/ioc/pdrv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.epics.ioc.pdrv
</H2>
<h1 style="text-align: center">EPICS JavaIOC: portDriver<br />
package: org.epics.ioc.pdrv<br />
2009.04.23
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/ConnectExceptionListener.html" title="interface in org.epics.ioc.pdrv">ConnectExceptionListener</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/Device.html" title="interface in org.epics.ioc.pdrv">Device</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/DeviceDriver.html" title="interface in org.epics.ioc.pdrv">DeviceDriver</A></B></TD>
<TD>This is implemented by a driver and is only called by org.epics.ioc.pdrv.Factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/LockPortNotify.html" title="interface in org.epics.ioc.pdrv">LockPortNotify</A></B></TD>
<TD>Interface for code that wants to be notified when port.lock or port.unlock are called.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/Port.html" title="interface in org.epics.ioc.pdrv">Port</A></B></TD>
<TD>Interface for a port.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/PortDriver.html" title="interface in org.epics.ioc.pdrv">PortDriver</A></B></TD>
<TD>This is implemented by a driver and is only called by org.epics.ioc.prev.Factory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/QueueRequestCallback.html" title="interface in org.epics.ioc.pdrv">QueueRequestCallback</A></B></TD>
<TD>The user callback that is called when the users request is dequeued,</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/Trace.html" title="interface in org.epics.ioc.pdrv">Trace</A></B></TD>
<TD>Interface for tracing pdrv requests.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/TraceOptionChangeListener.html" title="interface in org.epics.ioc.pdrv">TraceOptionChangeListener</A></B></TD>
<TD>Interface implemented by code that calls trace.optionChangeListenerAdd.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/User.html" title="interface in org.epics.ioc.pdrv">User</A></B></TD>
<TD>An interface for making PDRV (Port Driver) requests and for communication between driver
 and user.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/Factory.html" title="class in org.epics.ioc.pdrv">Factory</A></B></TD>
<TD>Factory for portDriver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/TraceFactory.html" title="class in org.epics.ioc.pdrv">TraceFactory</A></B></TD>
<TD>Factory for creating implementations of Trace.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/ConnectException.html" title="enum in org.epics.ioc.pdrv">ConnectException</A></B></TD>
<TD>Connection exception type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/QueuePriority.html" title="enum in org.epics.ioc.pdrv">QueuePriority</A></B></TD>
<TD>Priorities for queueRequest if the port can block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../org/epics/ioc/pdrv/Status.html" title="enum in org.epics.ioc.pdrv">Status</A></B></TD>
<TD>Status returned by many PDRV (Port Driver) methods.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.epics.ioc.pdrv Description
</H2>

<P>
<h1 style="text-align: center">EPICS JavaIOC: portDriver<br />
package: org.epics.ioc.pdrv<br />
2009.04.23</h1>
<hr />

<h2 style="text-align: center" id="Preface">Preface</h2>
<hr />

<p><b>portDriver</b> is a general purpose facility for interfacing support
code to low level drivers.</p>

<p>This package overview describes the portDriver framework but not
interfaces, drivers, or support for accessing a portDriver via JavaIOC
records. The following other packages are related to portDriver.</p>
<dl>
  <dt>org.epics.ioc.pdrv.interfaces</dt>
    <dd>The interfaces implemented by port drivers.</dd>
  <dt>org.epics.ioc.pdrv.serial</dt>
    <dd>Drivers that communicate with serial devices.</dd>
  <dt>org.epics.ioc.pdrv.vxi11</dt>
    <dd>A diver that communicates with vxi11 devices.</dd>
  <dt>org.epics.ioc.pdrv.testDriver</dt>
    <dd>Code that simulates devices.</dd>
  <dt>org.epics.ioc.support.pdrv</dt>
    <dd>The base support for connecting a JavaIOC record to a port
    driver.</dd>
  <dt>org.epics.ioc.support.pdrv.scalar</dt>
    <dd>Support for read/write of scalar values via a port driver.</dd>
  <dt>org.epics.ioc.support.pdrv.array</dt>
    <dd>Support for read/write of array values via a port driver.</dd>
  <dt>org.epics.ioc.support.pdrv.serial</dt>
    <dd>Support for sending command and query messages to a serial
    device.</dd>
  <dt>org.epics.ioc.support.pdrv.digital</dt>
    <dd>Support for Digital I/O.</dd>
</dl>

<p>CONTENTS</p>

<div class="toc">
<ul>
  <li><a href="#Preface">Preface</a></li>
  <li><a href="#Purpose">Purpose</a></li>
  <li><a href="#Status">Status</a></li>
  <li><a href="#Acknowledg">Acknowledgments</a></li>
  <li><a href="#Overview">Overview of portDriver</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#portDriver">portDriver Interfaces</a></li>
      <li><a href="#portDriver1">portDriver Factory</a></li>
      <li><a href="#Connection">Connection Management</a></li>
      <li><a href="#Protecting">Protecting a Thread from Blocking</a></li>
      <li><a href="#portThread">portThread</a></li>
      <li><a href="#Driver">Driver Can Also Be User</a></li>
      <li><a href="#Initializa">Initialization</a></li>
      <li><a href="#Requesting">Requesting access to a port</a></li>
    </ul>
  </li>
  <li><a href="#PortDriver">PortDriver Record Types</a>
    <ul>
      <li><a href="#portCreate">portCreate record</a></li>
      <li><a href="#portDevice">portDeviceControl record</a></li>
    </ul>
  </li>
  <li><a href="#portDriver2">portDriver Factory</a>
    <ul>
      <li><a href="#createUser">createUser</a></li>
      <li><a href="#createPort">createPort</a></li>
      <li><a href="#getPortNam">getPortNames</a></li>
      <li><a href="#getPort">getPort</a></li>
    </ul>
  </li>
  <li><a href="#User">User</a>
    <ul>
      <li><a href="#Status1">Status</a></li>
      <li><a href="#REASON">REASON</a></li>
      <li><a href="#duplicateU">duplicateUser</a></li>
      <li><a href="#User1">User Queue Request</a></li>
      <li><a href="#User2">User lock/unlock Port.</a></li>
      <li><a href="#User3">User connection to a port</a></li>
      <li><a href="#getPort1">getPort</a></li>
      <li><a href="#User4">User connection to a device</a></li>
      <li><a href="#getDevice">getDevice</a></li>
      <li><a href="#User5">User Messages</a></li>
      <li><a href="#L808">I/O Timeouts</a></li>
      <li><a href="#Driver1">Driver Private</a></li>
      <li><a href="#User6">User Private</a></li>
      <li><a href="#Passing">Passing Information Between User and
      Driver</a></li>
    </ul>
  </li>
  <li><a href="#Connect">Connect Exception</a></li>
  <li><a href="#Port">Port</a>
    <ul>
      <li><a href="#User7">User Locate Device</a></li>
      <li><a href="#User8">User Connection Methods</a></li>
      <li><a href="#Informatio">Informational Methods</a></li>
      <li><a href="#Connection1">Connection Methods</a></li>
      <li><a href="#Driver2">Driver Methods</a></li>
      <li><a href="#LockPortNo">LockPortNotify</a></li>
    </ul>
  </li>
  <li><a href="#Device">Device</a>
    <ul>
      <li><a href="#User9">User findInterface</a></li>
      <li><a href="#User10">User Connection Methods</a></li>
      <li><a href="#User11">User Blocking</a></li>
      <li><a href="#Informatio1">Informational Methods</a></li>
      <li><a href="#Connection2">Connection Methods</a></li>
      <li><a href="#Driver3">Driver Methods</a></li>
    </ul>
  </li>
  <li><a href="#Trace">Trace</a>
    <ul>
      <li><a href="#Trace1">Trace Mask Options</a></li>
      <li><a href="#TraceIO">TraceIO Options</a></li>
      <li><a href="#Trace2">Trace File</a></li>
      <li><a href="#Trace3">Trace Option Change Listener</a></li>
      <li><a href="#Generating">Generating Trace Messages</a></li>
    </ul>
  </li>
  <li><a href="#Driver4">Driver</a>
    <ul>
      <li><a href="#PortDriver1">PortDriver</a></li>
      <li><a href="#DeviceDriv">DeviceDriver</a></li>
    </ul>
  </li>
  <li><a href="#Appendix">Appendix: Java Definitions</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Purpose">Purpose</h2>
<hr />

<p><b>portDriver</b> is a general purpose facility for interfacing support
code to low level drivers. Devices are accessed via a port. portDriver allows
non-blocking support that works with both blocking and non-blocking
drivers.</p>

<p>A primary target for portDriver is support for fields of JavaIOC records.
However much of it is independent of the javaIOC.</p>

<p>portDriver has the following key concepts:</p>
<ul>
  <li>A port is a communication path to one or more devices, i.e. a device is
    accessed via a port.</li>
  <li>A driver implements interfaces PortDriver, DeviceDriver and I/O
    interfaces.</li>
  <li>portDriver implements interfaces User, Port, Device, and Trace.</li>
  <li>Interface User is an interface for support code to access portDriver
    and drivers.</li>
  <li>Interface Trace provides a general purpose diagnostic facility. 
    <p>Rules are defined for providing diagnostic messages. Provided support
    and drivers follow the rules, a user can obtain several levels of
    diagnostic information that can be displayed on the console, written to a
    file, or sent to an error logging facility.</p>
  </li>
  <li>A standard set of I/O interfaces are defined. 
    <p>Support code communicates with devices via the I/O interfaces. </p>
    <p>Drivers take care of the details of how to communicate with a device
    and implement interfaces for use by support. Interfaces are defined for
    both message and register based devices.</p>
  </li>
  <li>A port provides access to device instances 
    <p>A port, which has a portName, identifies a communication path to one
    or more device instances. For example a GPIB port can have up to 15
    devices connected to it. An RS232 port communicates with a single device.
    Drivers register a port. Support connects to a port.</p>
  </li>
  <li>Interface Port controls access to a port 
    <p>Port provides exclusive access to a driver via calls to
    user.queueRequest or user.lockPort/user.unlockPort. Once support has
    access, it can make an arbitrary number of calls to the I/O interfaces
    knowing that no other support can call the driver. Support and drivers do
    not need to implement queues or semaphores since Port does this for
    them.</p>
  </li>
  <li>portDeviceControl - A record that allows a user to interact with a port
    or a device connected to a port. The user can connect/disconnect,
    enable/disable the port or device. The user can set autoConnect,
    traceMask, and traceIOMask. The user can request a report. </li>
  <li>Extensive Serial Support - ONLY LIMITED SUPPORT HAS BEEN IMPLEMENTED
    AND TESTED 
    <p>portDriver provides many facilities for communicating with RS232,
    RS485, GPIB, and ethernet.</p>
  </li>
  <li>portDriverLinkSupport - This is discussed in other packages.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Status">Status</h2>
<hr />

<p>This version provides</p>
<ul>
  <li>Factory: Implementations of User, Port, Device, and Trace.</li>
  <li>Standard interfaces: Standard message and register based interfaces are
    defined. Low Level Drivers implement standard interfaces. Support
    communicates with low level drivers via standard interfaces.</li>
  <li>portDriver Link Support: Generic support for javaIOC records. This is
    part of package org.epics.ioc.support.pdrv and it's sub-packages. See it
    for details.</li>
</ul>

<p>Some hardware support is currently ready for use but testing so far is
minimal. Lots remains to be done. The CLS (Canadian Light Source) has kindly
lent me some xvi11 based hardware which has been used for the tests.</p>
<ul>
  <li>Java Support for VXI-11 network devices has been written and some
    testing has been done. </li>
  <li>IPSerialDriver has been used to talk to a serial port connected to a
    MOXA UIC7408 network to serial server. A null modem connector is attached
    to the serial port so no test involving a real serial device has been
    done.</li>
  <li>See the org.epics.ioc.support.pdrv documentation to see how serial
    protocol support is implemented. Rather than support for protocol files,
    like STREAMS implements, the support uses embeded structures and somewhat
    generic special support.</li>
</ul>

<p>Future</p>
<ul>
  <li>Serial support: Instead of support like STREAMS, portDriver uses
    embeded structures and special support to provide the same features. It
    has been tested with the xvi support to implement a few simple SCPI
    (Standard Commands for Programmable Instruments) commands. The same
    technique can be used to implement things like checksums, discarding
    output from devices that respond to writes, etc.</li>
  <li>???</li>
</ul>
<hr />

<h2 style="text-align: center" id="Acknowledg">Acknowledgments</h2>
<hr />

<p>portDriver is modeled after asynDriver. See <a
href="http://www.aps.anl.gov/epics/modules/soft/asyn/">asynDriver</a>. for
details about asynDriver.</p>

<p>Special thanks goes to Mark Rivers and Eric Norum who both made major
contributions to asynDriver and to Dirk Zimoch for developing STEAMS.</p>
<hr />

<h2 style="text-align: center" id="Overview">Overview of portDriver</h2>
<hr />

<h3 id="Definition">Definitions</h3>

<p>portDriver is a software layer between support code, e.g. javaIOC support,
and drivers that communicate with devices. It supports both blocking and
non-blocking communication and can be used with both register and message
based devices. portDriver uses the following terminology:</p>
<ul>
  <li>portDriver <br />
    The name for the code described in this package. </li>
  <li>port <br />
    A physical or logical entity which provides access to a device. A port
    provides access to one or more devices. </li>
  <li>Port <br />
    An interface, implemented by the Factory for this package, that manages
    the port. </li>
  <li>device <br />
    A device (instrument) is connected to a port. For example a GPIB
    interface can have up to 15 devices connected to it. Other ports, e.g.
    EIA232 serial ports, only support a single device. Whenever this document
    uses the word device without a qualifier, it means something that is
    connected to a port. </li>
  <li>Device <br />
    An interface, implemented by the Factory for this package, that manages a
    device. </li>
  <li>interface <br />
    All communication between software layers is done via Java interfaces.
  </li>
  <li>PortDriver <br />
    Interface implemented by a driver for the port. </li>
  <li>DeviceDriver <br />
    Interface implemented by a driver for a device connected to a port. </li>
  <li>support <br />
    The code that users portDriver. For example portDriverLinkSupport is
    portDriver support code for javaIOC records. </li>
  <li>User <br />
    An interface implemented by portDriver and used by support. It provide
    access to portDriver itself and driver I/O interfaces. It also allows a
    driver to pass error messages and other auxillary information to support
    code. </li>
  <li>Trace <br />
    An interface for diagnostic messages. </li>
  <li>portThread <br />
    If a port can block, a thread is created for the port, and all I/O is
    done via this thread. </li>
  <li>synchronous <br />
    Code that does not voluntarily give up control of the CPU, i.e. it does
    not block. Mutex operations are considered to be synchronous operations,
    i.e. they are permitted in synchronous code. </li>
  <li>asynchronous <br />
    Code that is not synchronous. Some examples of asynchronous operations
    are threadSleep, eventWait, and stdio operations. </li>
  <li>asynchronous Driver <br />
    A driver that blocks while communicating with a device. Typical examples
    are serial, gpib, and network based drivers. </li>
  <li>synchronous Driver <br />
    A driver that does not block while communicating with a device. Typical
    examples are register based devices. </li>
  <li>I/O Interface <br />
    An interface for performing Input or Output to a device. An I/O interface
    is implement by a DeviceDriver. </li>
  <li>interrupt <br />
    As implemented by portDriver, interrupt just means "I have a new value".
  </li>
</ul>

<p>Synchronous/asynchronous and message/register are orthogonal concepts. For
example a register based driver can be either synchronous or asynchronous.
The terminology register vs message is adapted from VXI.</p>

<p>Standard I/O interfaces are defined. For example if support does all its
communication via reads and writes consisting of 8 bit bytes (octets), then
it should work with any driver that implements interface Serial.</p>

<p>One or more devices can be attached to a port. For example, only one
device can be attached to an RS-232 port, but up to 15 devices can be
attached to a GPIB port.</p>

<p>A device driver can implement multiple interfaces.</p>

<p>portDriver uses some features of the javaIOC but it can be used by other
code, e.g. a sequence program when one is created for the javaIOC.</p>

<h3 id="portDriver">portDriver Interfaces</h3>
The interfaces implemented by port drivers are described in the overview for
package org.epics.ioc.pdrv.interfaces. 

<h3 id="portDriver1">portDriver Factory</h3>

<p>This implements Port, Device, User, and Trace. It has static methods
to:</p>
<ul>
  <li>Create a User.<br />
    Support code must create a User before it can access a port and it's
    associated devices.</li>
  <li>Create a Port.<br />
    This is called by a driver to register a port.</li>
</ul>

<h3 id="Connection">Connection Management</h3>

<p>Port and Device keep track of the following states:</p>
<ul>
  <li>connection 
    <p>Is the port or device connected? This state is initialized to
    disconnected.</p>
  </li>
  <li>enabled 
    <p>Is the port or device enabled? This state is initialized to
    enabled.</p>
  </li>
  <li>autoConnect 
    <p>Does Port or Device call connect if it finds the port or device
    disconnected? This is initialized to the state specified in the call to
    createPort. If autoConnect is true then Port and Device automatically
    connect. This is done by periodically calling the portDriver.connect or
    deviceDriver.connect.</p>
  </li>
</ul>

<p>Whenever any of the states change for a port or device, then all users
that previously called exceptionCallbackAdd for that port or device are
called.</p>

<p>Drivers must call exceptionConnect whenever they connect to a port or
device and exceptionDisconnect whenever they disconnect.</p>

<h3 id="Protecting">Protecting a Thread from Blocking</h3>

<p>The report methods can be called by any thread, but the caller is blocked
until the report finishes. lockPort, connect, disconnect and some other Port
and Device methods can block. See the documentation for these interfaces for
details.</p>

<p>Unless stated otherwise the methods of all I/O interfaces could block and
must only be called by QueueRequestCallback.callback or by calls between
lockPort/unlockPort.</p>

<h3 id="portThread">portThread</h3>

<p>If a driver calls Factory.createPort with canBlock true, then portDriver
creates a thread for the port. Each portThread has its own set of queues for
the calls to queueRequest. Three queues are maintained which provide
different priorities: low, medium, and high. portThread runs forever
implementing the following algorithm:</p>
<ol>
  <li>Wait for for an event. Other code such as queueRequest signals the
    event.</li>
  <li>If the port is disabled, go back to 1.</li>
  <li>If the port is still not connected, go back to 1.</li>
  <li>For each element of the queues asynQueuePriorityHigh,
    ...,asynQueuePriorityLow. 
    <ul>
      <li>If disabled, skip this element.</li>
      <li>If not connected, skip this element.</li>
      <li>If blocked by another thread, skip this element.</li>
      <li>If not blocked and user has requested blocking, then blocked.</li>
      <li>Remove from queue and: 
        <ul>
          <li>lockPort</li>
          <li>call user callback</li>
          <li>unlockPort</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>The actual code is more complicated because it unlocks before it calls
code outside asynManager. This means that the queues can be modified and
exceptions may occur.</p>

<h3 id="Driver">Driver Can Also Be User</h3>

<p>A driver can also be the user of another driver. For example a multi-drop
serial driver can use a standard serial driver to perform the actual I/O.
Such a driver implements interface LockPortNotify which is called whenever a
user locks the multi-drop port. The driver can than call lock/unlock for the
serial port so that it has exclusive access to the serial port which the
multi-drip user has access.</p>

<h3 id="Initializa">Initialization</h3>

<p>During initialization, drivers register each communication port as well as
all supported interfaces.</p>

<p>Support code creates a User, which is a "handle" for accessing portDriver
facilities, by calling</p>
<pre>    Factory.createUser(QueueRequestCallback);</pre>
An User has the following features: 
<ul>
  <li>An User is the means by which portDriver manages multiple requests for
    accessing a port.</li>
  <li>QueueRequestCallback, which is used by queueRequest described below,
    has a single method which is the callback that is called when a request
    is taken from a queue.</li>
  <li>Support code should create a User for each "atomic" access to a driver,
    i.e. a set of calls that must not be interlaced with other calls to the
    driver. For example support for javaIOC records creates a User for each
    record instance. instance.</li>
  <li>Support should NOT try to share a User between multiple sources of
    requests for access to a port. If this is done then support must itself
    handle contention issues that are already handled by portDriver.</li>
</ul>

<p>User code connects to a low level driver via a call to</p>
<pre>    Port port = user.connectPort(portName);
    Device device = user.connectDevice(deviceName);</pre>
This call must specify the name of the port and the name of the device It
then calls findInterface to locate the interfaces with which it calls the
driver. For example: 
<pre>     Octet octet = (Octet)device.findInterface(user,"octet",true);</pre>

<h3 id="Requesting">Requesting access to a port</h3>

<p>User code can request access to a port by two methods:</p>
<ul>
  <li>user.queueRequest - 
    <p>The processCallback passed to createAsynUser makes calls to the port
    interfaces.</p>
  </li>
  <li>user.lockPort/user.unlockPort - 
    <p>The caller can make calls to the I/O and also to Port and Device
    interfaces while the lock is held. The I/O methods and some of the
    Port/Device methods may block and thus should NOT be used by code that
    should not block, e.g. synchronous device support for EPICS records.</p>
  </li>
</ul>
<hr />

<h2 style="text-align: center" id="PortDriver">PortDriver Record Types</h2>
<hr />

<h3 id="portCreate">portCreate record</h3>

<p>A recordType and support portCreate is provided. An instance creates a
port. The recordType has the following fields:</p>
<dl>
  <dt style="font-family: courier;">factoryName</dt>
    <dd>The name of the Java Factory that can create the portDriver.</dd>
  <dt style="font-family: courier;">portName</dt>
    <dd>The port name.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>(false,true) if port (should not,should) auto connect. The default is
      true.</dd>
  <dt style="font-family: courier;">priority</dt>
    <dd>The priority. This field is a threadPriority structure.</dd>
  <dt style="font-family: courier;">driverParameters</dt>
    <dd>Driver specific parameters. This is a structure field. The default is
      a null structure but can be overridden for a port instance.</dd>
</dl>

<p>The following is an example port instance.</p>
<pre>&lt;record name = "syncInt32Port" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.testDriver.Int32DriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
    &lt;structure name = "driverParameters" type = "int32Driver" &gt;
        &lt;scalar name = "delay"&gt;0.0&lt;/scalar&gt;
        &lt;scalar name = "numberRegisters"&gt;2&lt;/scalar&gt;
        &lt;scalar name = "low"&gt;-2048&lt;/scalar&gt;
        &lt;scalar name = "high"&gt;2047&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h3 id="portDevice">portDeviceControl record</h3>

<p>A recordType and support portDeviceControl is provided. It allows a user
to interact with a port or a device connected to a port. The record has the
following fields:</p>
<dl>
  <dt style="font-family: courier;">message</dt>
    <dd>This is string field that has the results of a report request and any
      error messages generated by other requests. A Channel Access client can
      set a monitor on this field to see all messages.</dd>
  <dt style="font-family: courier;">portDevice</dt>
    <dd>This specifies the port or port and device for all the other fields.
      It has the syntax "port[addr]". If [addr] is not specified than the
      other fields refer to the port itself. Each time the user writes to
      this field a connection is made to the port and optionally the
    device.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>This is a boolean field. Putting a value of (false,true) issues a
      (disconnect,connect) request to the port or device.</dd>
  <dt style="font-family: courier;">enable</dt>
    <dd>This is a boolean field. Putting a value of (false,true) issues a
      (disable,enable) request to the port or device.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>This is a boolean field. Putting a value sets the autoConnect
    state.</dd>
  <dt style="font-family: courier;">traceMask</dt>
    <dd>This is an integer field. Issuing a put sets the traceMask.</dd>
  <dt style="font-family: courier;">traceIOMask</dt>
    <dd>This is an integer field. Issuing a put sets the traceIOMask.</dd>
  <dt style="font-family: courier;">report</dt>
    <dd>This is an integer field. Issuing a put requests a report with the
      specified details. The report is placed in the message field.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="portDriver2">portDriver Factory</h2>
<hr />

<p>This is the factory for creating portDriver objects.</p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver portDriver,String driverName,
            boolean canBlock,boolean autoConnect,ThreadPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
}</pre>

<h3 id="createUser">createUser</h3>
<pre>    User createUser(QueueRequestCallback asynQueueRequestCallback);</pre>

<p>Create a User. This is called by code that wants to access a port and/or
the devices connected to the port.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">asynQueueRequestCallback</dt>
    <dd>This is an interface implemented by the user. It is called when a
      queueRequest is dequeued. See Port for details. If the user does not
      want to call queueRequest a null is acceptable.</dd>
</dl>

<h3 id="createPort">createPort</h3>
<pre>    Port createPort(
            String portName,PortDriver portDriver,String driverName,
            boolean canBlock,boolean autoConnect,ThreadPriority priority);</pre>

<p>Create a port. This is called by a driver to register a new port. The Port
interface is created and returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port. If the port already exists an exception is
      thrown.</dd>
  <dt style="font-family: courier;">portDriver</dt>
    <dd>The interface for the port driver.</dd>
  <dt style="font-family: courier;">driverName</dt>
    <dd>The name of the driver.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Can the device block while performing I/O? If the answer is yes than
      a thread is created for the port and all queueRequest callbacks are
      called via this thread. If the answer is no than all queueRequests
      result in the port being locked and the queueRequest callback is called
      synchronously.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>An initial value for the autoConnect state for both the port and any
      devices connected to the port. Unless the driver has a good reason,
      this should be true. </dd>
  <dt style="font-family: courier;">priority</dt>
    <dd>The priority for the port thread if the port can block.</dd>
</dl>

<h3 id="getPortNam">getPortNames</h3>
<pre>    String[] getPortNames();</pre>

<p>Get an array containing the name of each port. </p>

<h3 id="getPort">getPort</h3>
<pre>    Port getPort(String portName);</pre>

<p>Get the Port for the specified portName. If the port does not exist null
is returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="User">User</h2>
<hr />

<p>User is the interface for accessing a port and/or device. It is created by
Factory and used by client code. </p>
<pre>public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(String deviceName);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setBoolean(boolean value);
    boolean getBoolean();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}</pre>

<h3 id="Status1">Status</h3>

<p>Many methods return a status which is defined by the following:</p>
<pre>public enum Status {
    success,
    timeout,
    overflow,
    error
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">success</dt>
    <dd>The request was satisfied.</dd>
  <dt style="font-family: courier;">timeout</dt>
    <dd>An I/O operation failed because of a timeout. An code returning this
      status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">overflow</dt>
    <dd>An request failed because of an overflow problem. An code returning
      this status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">error</dt>
    <dd>An request failed. An code returning this status must also call
      user.setMessage.</dd>
</dl>

<h3 id="REASON">REASON</h3>

<p>setReason,getReason described below have an integer argument. The
following are some generic reasons:</p>
<pre>    public static final int REASON_SIGNAL = -1;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">REASON_SIGNAL</dt>
    <dd>A signal occured.</dd>
</dl>

<h3 id="duplicateU">duplicateUser</h3>

<p>Create a new User that is connected to the same port and device. The new
user will also have the same reason and timeout as the orginal. </p>
<pre>    User duplicateUser(QueueRequestCallback queueRequestCallback);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>An existing user.</dd>
  <dt style="font-family: courier;">queueRequestCallback</dt>
    <dd>The callback for queueRequest. if queueRequest is never called this
      can be null.</dd>
</dl>

<h3 id="User1">User Queue Request</h3>

<p>Any user that wants to make asynchronous I/O requests but does not want to
block while making the request can call queueRequest. An example is link
support for javaIOC records. Such support must not block or it will block the
record instance itself.</p>

<p>If queueRequest is called for a port that can block than the request is
queued. The port has an associated thread. When the request is taken from the
queue, the port is locked and the requestors callback is called. If
queueRequest is called for a port that can not block then the port is locked
and the requestors callback is called synchronously.</p>

<p>The port thread keeps three FIFO queues with the following priorities:</p>
<pre>public enum QueuePriority {
    low,
    medium, 
    high
}</pre>

<p>The requestor must implement the following interface:</p>
<pre>public interface QueueRequestCallback {
    void callback(Status status,User user);
}</pre>

<p>This interface is passed to Factory.createUser. The arguments to callback
are:</p>
<dl>
  <dt style="font-family: courier;">status</dt>
    <dd>Unless this is Status.success than the request has failed. The user
      must not call any I/O interfaces. user.getMessage can be called to find
      why the request failed. user.getAlarmStratus and user.getAlarmMessage
      can get an alarm status and message.</dd>
  <dt style="font-family: courier;">user</dt>
    <dd>This is passed back to the user so that code can implement a single
      callback that handles multiple users.</dd>
</dl>

<p>If the callback is called with status success than it can make multiple
calls to the device I/O interfaces.</p>

<p>A queueRequest is made via a call to</p>
<pre>    void queueRequest(QueuePriority queuePriority);</pre>

<p>At any time a user can call</p>
<pre>    void cancelRequest();</pre>

<p>If a request is queued it is removed from the queue. If no request is
queued than nothing happens. Note that it is possible for the callback to be
called between the time when cancel is called and when it returns.</p>

<h3 id="User2">User lock/unlock Port.</h3>

<p>If a user is willing to block during asynchronous port I/O requests then
it can just call lockPort/unlockPort. </p>
<pre>    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();</pre>

<p>Code that uses lockPort should follow the pattern:</p>
<pre>     user.lockPort();
     try {
         // whatever
     } finally {
         user.unlockPort();
     }</pre>

<p>The other lock methods are for calling port.connect and device.connect.</p>

<h3 id="User3">User connection to a port</h3>
<pre>    Port connectPort(String portName);
    void disconnectPort();</pre>

<p>connectPort connects the user to a port and disconnect disconnects. If the
port does not exist connectPort returns null. If the user is also connected
to a device then disconnectPort calls disconnectDevice. Note that these
methods only connects/disconnects the user to/from the port. Thus it does not
effect the connect/disconnect state of the port itself.</p>

<h3 id="getPort1">getPort</h3>
<pre>    Port getPort();</pre>

<p>Get the port to which this user is connected. This can be null.</p>

<h3 id="User4">User connection to a device</h3>
<pre>    Device connectDevice(String deviceName);
    void disconnectDevice();</pre>
The user must be connected to a port before connecting to a device. If the
device does not exist connectDevice returns null. 

<p>connectDevice connects the user to a device and disconnect disconnects.
Note that these methods only connects/disconnects the user to/from the
device. Thus it does not effect the connect/disconnect state of the device
itself.</p>

<h3 id="getDevice">getDevice</h3>
<pre>    Device getDevice();</pre>

<p>Get the device to which this user is connected. This can be null.</p>

<h3 id="User5">User Messages</h3>
<pre>    void setMessage(String message);
    String getMessage();</pre>

<p>Methods that return a Status that does not have the value Status.success
must also call user.setMessage to explain why the method failed. The user can
then call getMessage to find the reason.</p>

<h3 id="L808">I/O Timeouts</h3>
<pre>    void setTimeout(double timeout);
    double getTimeout();</pre>

<p>Asynchronous I/O operations can block forever. For example a serial line
could break. Each user that makes asynchronous request must call setTimeout.
A timeout value of &lt;= 0.0 means infinity. A portDriver or deviceDriver
calls getTimeout to get the timeout. It is the timeout for an individual I/O
request. For example for a serial driver it could mean the time to read/write
a single byte.</p>

<h3 id="Driver1">Driver Private</h3>
<pre>    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();</pre>

<p>These are methods for the port or device driver. Some drivers may have to
keep data for each user. If a driver does than it must implement interface
<span style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces.DriverUser</span> and the user must find
and use it. It has the methods:</p>
<pre>    void create(User user,PVStructure drvParams);
    void dispose(User user);</pre>

<p>After the user connects to a port or device that implement DriverUser it
must call driverUser.create and when it disconnects it must call
driverUser.dispose. DriverUser.create can allocate data for the user and call
setPortDriverPvt or setDeviceDriverPvt. When the user calls a driver method
the driver can call getPortDriver or getDeviceDriver to get the private data
for the user. DriverUser.dispose should remove all provate state and data fot
the user.</p>

<h3 id="User6">User Private</h3>
<pre>    void setUserPvt(Object userPvt);
    Object getUserPvt();</pre>

<p>These are for private use by the user.</p>

<h3 id="Passing">Passing Information Between User and Driver</h3>

<p>The set/get methods are for passing data between a user and a driver.
Normally it is the driver that calls a set method and the user that calls a
get method but the reverse is also possible. Both user and driver must
understand when the methods are used. The interfaces defined in <span
style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces</span> make use of these methods. For
example the octet interface use setInt to tell the user how many elements
were transfered.</p>
<hr />

<h2 style="text-align: center" id="Connect">Connect Exception</h2>
<hr />

<p>Both Port and Device provide a methods exceptionListenerAdd and
exceptionListenerRemove. The listener is called whenever the connection state
of a device changes. i.e. the connect state itself, the enable state, or the
autoConnect state.</p>

<p>The type of exception is defined by: </p>
<pre>public enum ConnectException {
    connect,
    enable,
    autoConnect
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">connect</dt>
    <dd>The port or device has connected or disconnected. The listener can
      call isConnected to determine the state.</dd>
  <dt style="font-family: courier;">enable</dt>
    <dd>The enable state has changed. The listener can call isEnabled to
      determine the state.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>The autoConnect state has changed. The listener can call
      isAutoConnect to determine the state.</dd>
</dl>

<p>The listener must implement the interface:</p>
<pre>public interface ConnectExceptionListener {
    void exception(ConnectException connectException);
}</pre>
<hr />

<h2 style="text-align: center" id="Port">Port</h2>
<hr />

<p>A port manages user access to the I/O. All methods except
connecy/disconnect can be called without locking the port.</p>

<p>The complete set of definitions for Port are:</p>
<pre>public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    void scanQueues();
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, int addr);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h3 id="User7">User Locate Device</h3>

<p>After a user has connected to a port via a call to user.connectPort it can
connect to a device by calling port.getDevice.</p>
<pre>    Device getDevice(User user, int addr);</pre>

<h3 id="User8">User Connection Methods</h3>

<p>Most users do not ask the port to connect or disconnect but a specialized
client may. For example javaIOC link support is provided for
connect/disconnect requests. This allows a port to be connected or
disconnected via a Channel Access client. A client must either cann
queueRequest or call lockPort/unlockPort to call these methods.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h3 id="Informatio">Informational Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Interface[] getInterfaces();
    String getDriverName();
    String getPortName();
    boolean canBlock();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the port and if specified all devices
      connected to the port. This method blocks. It does not lock so report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getDevices</dt>
    <dd>Get an array of the devices connected to the port.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the portDriver. Note
      that most drivers do not implement port interfaces but only device
      interfaces.</dd>
  <dt style="font-family: courier;">getDriverName</dt>
    <dd>Get the driver name.</dd>
  <dt style="font-family: courier;">getPortName</dt>
    <dd>Get the port name.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Is it possible for the driver to block while doing I/O?</dd>
</dl>

<h3 id="Connection1">Connection Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the port. If the port is disabled then no
      queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the port is not
      connected when the first lockPort request is made than a connect
      request will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the port is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h3 id="Driver2">Driver Methods</h3>

<p>These are methods called by a driver.</p>
<pre>    Device createDevice(DeviceDriver deviceDriver, int addr);
    void exceptionConnect();
    void exceptionDisconnect(); 
    Trace getTrace();
    void scanQueues();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>The driver calls this as a result of a call to port.createDevice,
      that is port.createDevice must itself call portDriver.createDevice.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
  <dt style="font-family: courier;">scanQueues</dt>
    <dd>Not normally called by drivers</dd>
</dl>

<h3 id="LockPortNo">LockPortNotify</h3>

<p>A driver can be the user of another driver. For example a multidrop the
serial driver can use a serial port driver to do the actual I/O and just add
the multidrop protocal. In order to work properly the multidrop driver must
ensure that it has exclusive access to the serial driver whenever a user has
access to the multidrop driver. This it needs to know when a user has
successfully called lockPort. The driver that wants to be the user of another
driver must implement the following:</p>
<pre>public interface LockPortNotify {
    void lock(User user);
    void unlock();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">lock</dt>
    <dd>This is called each time a user obtains control of the port by
      successfully calling lockPort. The driver can call lockPort for the
      port it is using.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>This is called each time a user call unlockPort. The driver can call
      unlockPort for the driver it is using.</dd>
</dl>

<p>The port methods are :</p>
<pre>void registerLockPortNotify(LockPortNotify lockPortNotify);
void unregisterLockPortNotify(); </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerLockPortNotify</dt>
    <dd>Register to be notified of successful lockPort/unlockPort requests.
    </dd>
  <dt style="font-family: courier;">unregisterLockPortNotify</dt>
    <dd>Unregister the caller.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Device">Device</h2>
<hr />

<p>A device provides methods related to a device. The complete set of
definitions for Device are:</p>
<pre>public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName();
    String getFullName(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    Interface findInterface(User user,String interfaceName);
    Status lockPort(User user);
    Status connect(User user);
    Status disconnect(User user);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h3 id="User9">User findInterface</h3>

<p>This is used by a user to locate an interface for the device. If the
driver does not implement the requested interface null is returned.</p>
<pre>    Interface findInterface(User user,
        String interfaceName);</pre>

<p>where the arguments are:</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>The user.</dd>
  <dt style="font-family: courier;">interfaceName</dt>
    <dd>The name of the interface.</dd>
</dl>

<h3 id="User10">User Connection Methods</h3>

<p>Most users do not handle the device connecting or disconnecting but a
specialized client may. For example javaIOC link support is provided for
connect/disconnect requests. This allows a device to be connected or
disconnected via a Channel Access client.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h3 id="User11">User Blocking</h3>

<p>A user can block other users from accessing a device. This only works for
asynchronous drivers.</p>
<pre>Status blockOtherUsers(User user);
void unblockOtherUsers(User user);</pre>

<h3 id="Informatio1">Informational Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName(); 
    Port getPort();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the device. It does not lock so some report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the deviceDriver.</dd>
  <dt style="font-family: courier;">getDeviceName</dt>
    <dd>Get the name of this device.</dd>
  <dt style="font-family: courier;">getFullName</dt>
    <dd>Get the full name, which has the form portName[deviceName].</dd>
  <dt style="font-family: courier;">getPort</dt>
    <dd>Get the port to which this device is connected.</dd>
</dl>

<h3 id="Connection2">Connection Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    boolean isBlockedByOtherUser(User user);
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the device. If the device is disabled then
      no queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the device is not
      connected when the first lockPort request is made than a connect
      request will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the device is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">isBlockedByOtherUser</dt>
    <dd>Is the device blocked by another user.</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h3 id="Driver3">Driver Methods</h3>

<p>These are methods called by a driver.</p>
<pre>    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
    Trace getTrace();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerInterface</dt>
    <dd>A portDriver must call this for each interface it implements.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Trace">Trace</h2>
<hr />

<p>Both Port and Device provide access to a Trace facility, which allows
diagnostic messages to be generated on a port or device basis. Both support,
e.g. javaIOC record support, and drivers are expected to support the trace
facility.</p>

<p>The Java definitions for Trace are:</p>
<pre>public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    Status optionChangeListenerRemove(User user);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}

public class TraceFactory {
    public static Trace create() {
        return new TraceImpl();
    }
}</pre>

<p>TraceFactory is a factory that implements Trace. It can be used
independent of portDriver.</p>

<h3 id="Trace1">Trace Mask Options</h3>

<p>The trace mask specifies when to generate messages. </p>
<pre>    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    void setMask(int mask);
    int getMask();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">ERROR</dt>
    <dd>Generate a message whenever an error is detected. This is the only
      bit of the mask that is set by default.</dd>
  <dt style="font-family: courier;">SUPPORT</dt>
    <dd>Support level code should generate a message whenever it calls any
      interface method.</dd>
  <dt style="font-family: courier;">DRIVER</dt>
    <dd>A driver should generate a message whenever any of it's methods are
      called.</dd>
  <dt style="font-family: courier;">FLOW</dt>
    <dd>Port or Device should generate a message whenever it performs some
      action. For example when a request is queued and when it is taken from
      a queue.</dd>
  <dt style="font-family: courier;">setMask</dt>
    <dd>Set the mask to some combination of the maks values. For example: 
      <pre>    device.setMask(ERROR|SUPPORT|DRIVER);</pre>
      will cause message to be generated whenever an error detected, when
      support level code calls an interface method, and when a device driver
      method is called.</dd>
  <dt style="font-family: courier;">getMask</dt>
    <dd>Get the current value of the mask.</dd>
</dl>

<h3 id="TraceIO">TraceIO Options</h3>

<p>The traceIO mask specifies what to generate for octet data values.</p>
<pre>    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setIOMask(int mask);
    int getIOMask();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">IO_NODATA</dt>
    <dd>Don't print any data.</dd>
  <dt style="font-family: courier;">IO_ASCII</dt>
    <dd>Print with a "%s" style format.</dd>
  <dt style="font-family: courier;">IO_ESCAPE</dt>
    <dd>Print with a "%s" style format but show control characters as escape
      sequences. For example a carriage return is printed as "\r".</dd>
  <dt style="font-family: courier;">IO_HEX</dt>
    <dd>Print each byte with " %2.2x".</dd>
  <dt style="font-family: courier;">setIOMask</dt>
    <dd>Set the IOMask to saome combination of the above. Note that IO_NODATA
      should not be specified with any other bits since it has no
    meaning.</dd>
  <dt style="font-family: courier;">getIOMask</dt>
    <dd>Get the current IOMask.</dd>
  <dt style="font-family: courier;">setIOTruncateSize</dt>
    <dd>Set the truncation size for data output. For printIO it means the
      number of bytes to print. For array data it means the number of
      elements to display.</dd>
  <dt style="font-family: courier;">getIOTruncateSize</dt>
    <dd>Get the current truncation size.</dd>
</dl>

<h3 id="Trace2">Trace File</h3>

<p>The destination for trace messages.</p>
<pre>    void setFile(Writer file);
    Writer getFile();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">setFile</dt>
    <dd>Set the destination for trace messages. The default is a buffered
      writer to standard out.</dd>
  <dt style="font-family: courier;">getFile</dt>
    <dd>Get the current destination for trace messages,</dd>
</dl>

<h3 id="Trace3">Trace Option Change Listener</h3>

<p>Code that wants to listen for option change must implement the
following:</p>
<pre>public interface TraceOptionChangeListener {
    void optionChange(); 
}</pre>

<p>The Trace methods for a listener are:</p>
<pre>    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    Status optionChangeListenerRemove(User user);</pre>

<h3 id="Generating">Generating Trace Messages</h3>

<p><span style="font-family: courier;">print</span> is called to generate
messages and <span style="font-family: courier;">printIO</span> to generate
messages and also the value of octet data.</p>
<pre>    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">print</dt>
    <dd>Generate a trace message. <span
      style="font-family: courier;">reason</span> is one of the trace mask
      bits.</dd>
  <dt style="font-family: courier;">printIO</dt>
    <dd>Does the same as print an then prints the buffer data using the
      traceIO features.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Driver4">Driver</h2>
<hr />

<h3 id="PortDriver1">PortDriver</h3>

<p>Every driver must implement the following methods:</p>
<pre>public interface PortDriver {
    String report(int details);
    Device createDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the port.</dd>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>Create a device for the given address. The driver must implemnent
      interface DeviceDriver, call port.createDevice, and return the device
      it creates. If it can't create a device at the specified address, it
      should call user.setMessage and return null.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual port. If successful it must call
      port.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the port. If successfull call
      port.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>

<h3 id="DeviceDriv">DeviceDriver</h3>

<p>The driver implements the following for each device it acesses.</p>
<pre>public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the device.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual device. If successful it must call
      device.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the device. If successfull call
      device.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Appendix">Appendix: Java Definitions</h2>
<hr />

<p>The following is a complete list of all the Java definitions for <span
style="font-family: courier;">package org.epics.ioc.portDriver. </span></p>

<p>The I/O interfaces implemented by drivers (port or device) are defined in
package <span style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces</span></p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver portDriver,
            String driverName,boolean canBlock,
            boolean autoConnect,ThreadPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
}

public enum Status {
    success,
    timeout,
    overflow,
    error
}

public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(String deviceName);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setBoolean(boolean value);
    boolean getBoolean();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}

public enum ConnectException {
    connect,
    enable,
    autoConnect
}

public interface ConnectExceptionListener {
    void exception(ConnectException connectException);
}

public enum QueuePriority {
    low,
    medium, 
    high
}

public interface QueueRequestCallback {
    void callback(Status status,User user);
}

public interface LockPortNotify {
    void lock(User user);
    void unlock();
}

public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, String deviceName);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    void scanQueues();
    Status connect(User user);
    Status disconnect(User user);
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, String deviceName);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    Interface findInterface(User user,String interfaceName);
    Status connect(User user);
    Status disconnect(User user);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface TraceOptionChangeListener {
    void optionChange(); 
}

public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    void optionChangeListenerRemove(User user);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}

public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}

public interface PortDriver {
    String report(int details);
    Device createDevice(User user,String deviceName);
    Status connect(User user);
    Status disconnect(User user);
}</pre>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../org/epics/ioc/install/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../../org/epics/ioc/pdrv/interfaces/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html?org/epics/ioc/pdrv/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
