<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: portDriver Interfaces</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: portDriver Interfaces<br />
package: org.epics.ioc.pdrv.interfaces<br />
2009.03.24</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#miscellane">miscellaneous</a> 
    <ul>
      <li><a href="#Interface">Interface</a></li>
      <li><a href="#Option">Option</a></li>
      <li><a href="#DriverUser">DriverUser</a></li>
      <li><a href="#AbstractIn">AbstractInterface</a></li>
    </ul>
  </li>
  <li><a href="#serial">serial</a> 
    <ul>
      <li><a href="#SerialInte">SerialInterruptListener</a></li>
      <li><a href="#Serial">Serial</a></li>
      <li><a href="#AbstractSe">AbstractSerial</a></li>
    </ul>
  </li>
  <li><a href="#uint32Digi">uint32Digital</a> 
    <ul>
      <li><a href="#DigitalInt">DigitalInterruptReason</a></li>
      <li><a href="#UInt32Digi">UInt32DigitalInterruptListener</a></li>
      <li><a href="#UInt32Digi1">UInt32Digital</a></li>
      <li><a href="#AbstractUI">AbstractUInt32Digital</a></li>
    </ul>
  </li>
  <li><a href="#int32">int32</a> 
    <ul>
      <li><a href="#Int32Inter">Int32InterruptListener</a></li>
      <li><a href="#Int32">Int32</a></li>
      <li><a href="#AbstractIn1">AbstractInt32</a></li>
    </ul>
  </li>
  <li><a href="#int32Array">int32Array</a> 
    <ul>
      <li><a href="#Int32Array">Int32ArrayInterruptListener</a></li>
      <li><a href="#Int32Array1">Int32Array</a></li>
      <li><a href="#AbstractIn2">AbstractInt32Array</a></li>
    </ul>
  </li>
  <li><a href="#float64">float64</a> 
    <ul>
      <li><a href="#Float64Int">Float64InterruptListener</a></li>
      <li><a href="#Float64">Float64</a></li>
      <li><a href="#AbstractFl">AbstractFloat64</a></li>
    </ul>
  </li>
  <li><a href="#float64Arr">float64Array</a> 
    <ul>
      <li><a href="#Float64Arr">Float64ArrayInterruptListener</a></li>
      <li><a href="#Float64Arr1">Float64Array</a></li>
      <li><a href="#AbstractFl1">AbstractFloat64Array</a></li>
    </ul>
  </li>
  <li><a href="#GPIB">GPIB Interfaces</a> 
    <ul>
      <li><a href="#GpibContro">GpibController</a></li>
      <li><a href="#GpibDevice">GpibDevice</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package contains portDriver interfaces for communication with a port
or device. A driver implements one or more of these interfaces and a user
calls interface methods to communicate with a device..</p>

<p>For each interface, this package defines four components:</p>
<ol>
  <li>The interface itself.</li>
  <li>An interrupt listener interface<br />
    This is the interface implemented by a user that registers itself as an
    interrupt listener.</li>
  <li>An abstract base class that implements the interface.<br />
    This is used by drivers that implement the interface. The base class
    handles the interrupt listeners. It also provides a method
    interruptOccurred, which is called by the driver when an interrupt event
    occurs.</li>
</ol>

<p>This package overview has the following sections:</p>
<ul>
  <li>miscellaneous<br />
    Discusses some interfaces used by the other interfaces.</li>
  <li>serial<br />
    An interface for serial communication.</li>
  <li>uint32Digital<br />
    An interface for a Digital I/O register.</li>
  <li>int32<br />
    An interface for an integer register. For example ADC devices implement
    this interface.</li>
  <li>int32Array<br />
    An interface for an array of 32 bit integers.</li>
  <li>float64<br />
    An interface for double value.</li>
  <li>float64Array<br />
    An interface for an array of doubles.</li>
  <li>gpibController<br />
    An interface for a GPIB controller.</li>
  <li>gpibDevice<br />
    An interface for a GPIB device.</li>
</ul>
<hr />

<h2 style="text-align: center" id="miscellane">miscellaneous</h2>
<hr />

<h3 id="Interface">Interface</h3>

<p><span style="font-family: courier;">Interface</span> is the base interface
for all portDriver interfaces.</p>
<pre>public interface Interface {
    String getInterfaceName();
    Device getDevice();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Returns the name of the interface.</dd>
  <dt style="font-family: courier;">getDevice</dt>
    <dd>Returns the Device the interface supports.</dd>
</dl>

<h3 id="Option">Option</h3>

<p><span style="font-family: courier;">Option</span> is for drivers that
accept run time options.</p>
<pre>public interface Option extends Interface{
    Status setOption(User user,String key, String value);
    String getOption(User user,String key);
}</pre>

<p>It extends <span style="font-family: courier;">Interface</span> to include
the methods:</p>
<dl>
  <dt style="font-family: courier;">setOption</dt>
    <dd>Set an option. Each option is identified by a key and has an
      associated value.</dd>
  <dt style="font-family: courier;">getOption</dt>
    <dd>Get the option for the specified key.</dd>
</dl>

<h3 id="DriverUser">DriverUser</h3>

<p><span style="font-family: courier;">DriverUser</span> is an interface for
drivers that require per-user information. A user calls create when it
connects to the port or device and calls dispose when the user disconnects.
The driver can keep private data for each user.</p>
<pre>public interface DriverUser {
    void create(User user,PVStructure drvParams));
    void dispose(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Called by a user when it connects to a port or device.</dd>
  <dt style="font-family: courier;">dispose</dt>
    <dd>Called by a user when it disconnects from a port or device.</dd>
</dl>

<h3 id="AbstractIn">AbstractInterface</h3>

<p>An abstract class for drivers that implement interfaces.</p>
<pre>public abstract class AbstractInterface implements Interface {
    protected Device device;
    protected String interfaceName;
    protected Trace trace;
    protected AbstractInterface(Device device,String interfaceName);
    protected void print(int reason,String message);
    protected void print(int reason,String format, Object... args);
    public Device getDevice();
    public String getInterfaceName();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">device</dt>
    <dd>The device which the interface supports.</dd>
  <dt style="font-family: courier;">interfaceName</dt>
    <dd>The name of the interface.</dd>
  <dt style="font-family: courier;">trace</dt>
    <dd>The trace interface.</dd>
  <dt style="font-family: courier;">AbstractInterface</dt>
    <dd>The constructor.</dd>
  <dt style="font-family: courier;">print</dt>
    <dd>The print method for the interface.</dd>
  <dt style="font-family: courier;">print</dt>
    <dd>The print to print the array.</dd>
  <dt style="font-family: courier;">getDevice</dt>
    <dd>Get the device interfacd.</dd>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Get the interface name.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="serial">serial</h2>
<hr />

<p>This is the interface for serial communication. It supports I/O of 8 bit
bytes and also has support for control characters that terminate serial
messages.</p>

<h3 id="SerialInte">SerialInterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface SerialInterruptListener {
    void interrupt(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new message is provided when an interrupt occurs.</dd>
</dl>

<h3 id="Serial">Serial</h3>

<p>The interface methods are:</p>
<pre>public interface Serial extends Interface {
    public static final int EOM_CNT = 0x0001;
    public static final int EOM_EOS = 0x0002; 
    public static final int EOM_END = 0x0004; 
    Status write(User user,byte[] data,int nbytes);
    Status read(User user,byte[] data,int nbytes);
    Status flush(User user);
    Status setInputEos(User user,byte[] eos,int eosLen);
    Status getInputEos(User user,byte[] eos);
    Status setOutputEos(User user,byte[] eos,int eosLen);
    Status getOutputEos(User user,byte[] eos);
    Status addInterruptUser(User user,
        SerialInterruptListener serialInterruptListener);
    Status removeInterruptUser(User user,
        SerialInterruptListener serialInterruptListener);
    void interruptOccurred(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">EOM_CNT</dt>
    <dd>auxStatus that means the read/write terminated because the the number
      of bytes requested was transfered.</dd>
  <dt style="font-family: courier;">EOM_EOS</dt>
    <dd>auxStatus that means the read/write terminated with the EOS (End Of
      String).</dd>
  <dt style="font-family: courier;">EOM_END</dt>
    <dd>auxStatus that means the read/write terminated because the the end of
      a message Occurred.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. If
      setOutputEos has provided end of string characters they are written
      after the requested bytes are written. A driver should normally call
      interruptOccurred after writing a value. On a successful operation
      user.setInt is called to provide the number of bytes transfered and
      setAuxStatus gives the reason why the transfer terminated. The call to
      setInt does NOT include any eos characters. If Status.overflow is
      returned than auxStatus provides the number of bytes not transfered.
    </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver. If
      setInputEos has provided an end of string sequence then the EOS
      terminates the input if it is detected. On a successful operation
      user.setInt is called to provide the number of bytes transfered and
      setAuxStatus gives the reason why the transfer terminated. The call to
      setInt does NOT include the eos characters. If Status.overflow is
      returned than auxStatus provides the number of bytes not transfered.
    </dd>
  <dt style="font-family: courier;">flush</dt>
    <dd>Flush any characters residing in the input buffer.</dd>
  <dt style="font-family: courier;">setInputEos</dt>
    <dd>Provide end of string sequence for read requests.</dd>
  <dt style="font-family: courier;">getInputEos</dt>
    <dd>Get the input end of string sequence.</dd>
  <dt style="font-family: courier;">setOutputEos</dt>
    <dd>Provide end of string sequence for write requests.</dd>
  <dt style="font-family: courier;">getOutputEos</dt>
    <dd>Get the output end of string sequence.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
</dl>

<h3 id="AbstractSe">AbstractSerial</h3>
<pre>public abstract class AbstractSerial
extends AbstractInterface
implements Serial
{
    protected AbstractSerial(Device device);
    protected void interruptOccurred(byte[] data,int nbytes);
    public Status addInterruptUser(User user,
            SerialInterruptListener serialInterruptListener);
    public Status removeInterruptUser(User user,
            SerialInterruptListener serialInterruptListener);
    public abstract Status write(User user,byte[] data,int nbytes);
    public abstract Status read(User user,byte[] data,int nbytes);
    public abstract Status flush(User user) ;
    public Status setInputEos(User user,byte[] eos,int eosLen);
    public Status getInputEos(User user,byte[] eos);
    public Status setOutputEos(User user,byte[] eos,int eosLen);
    public Status getOutputEos(User user,byte[] eos);
    public void interruptOccurred(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractSerial</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">setInputEos</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getInputEos</dt>
    <dd>Returns Status.success and auxStatus = 0.</dd>
  <dt style="font-family: courier;">setOutputEos</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getOutputEos</dt>
    <dd>Returns Status.success an auxStatus = 0.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="uint32Digi">uint32Digital</h2>
<hr />

<h3 id="DigitalInt">DigitalInterruptReason</h3>

<p>The reason why an interrupt Occurred.</p>
<pre>public enum DigitalInterruptReason {
    zeroToOne,
    oneToZero,
    transition
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">zeroToOne</dt>
    <dd>A zero to one transition Occurred. This is used for devices that can
      detect such a transition.</dd>
  <dt style="font-family: courier;">oneToZero</dt>
    <dd>A one to zero transition Occurred. This is used for devices that can
      detect such a transition.</dd>
  <dt style="font-family: courier;">transition</dt>
    <dd>One or more mask bits have changed.</dd>
</dl>

<h3 id="UInt32Digi">UInt32DigitalInterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface UInt32DigitalInterruptListener {
    void interrupt(int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h3 id="UInt32Digi1">UInt32Digital</h3>

<p>The interface methods are:</p>
<pre>public interface UInt32Digital extends Interface{
    String[] getChoices(User user);
    Status write(User user, int value, int mask);
    Status read(User user, int mask);
    Status setInterrupt(User user, int mask, DigitalInterruptReason reason);
    Status getInterrupt(User user, int mask, DigitalInterruptReason reason);
    Status clearInterrupt(User user,int mask);
    Status addInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    Status removeInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    void interruptOccurred(int data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>Get choices.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. The mask
      bits specify the bits to change. All other bits must not be
    modified.</dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver. Only
      bits from mask are set. All other bits must be set to 0 .</dd>
  <dt style="font-family: courier;">setInterrupt</dt>
    <dd>Allow interrupts for the specified bits. The reason states the
      condition under which an interrupt is raised,</dd>
  <dt style="font-family: courier;">getInterrupt</dt>
    <dd>Get which bits can cause an interrupt for thew specified reason.</dd>
  <dt style="font-family: courier;">clearInterrupt</dt>
    <dd>Disallow interrupts for the specified bits.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h3 id="AbstractUI">AbstractUInt32Digital</h3>
<pre>public abstract class AbstractUInt32Digital
extends AbstractInterface
implements UInt32Digital
{
    protected AbstractUInt32Digital(Device device);
    public String[] getChoices(User user);
    protected void interruptOccurred(int data,DigitalInterruptReason reason);
    public Status setInterrupt(User user, DigitalInterruptReason reason);
    public Status addInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    public Status removeInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    public Status addInterruptUser(User user,
            UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    public Status removeInterruptUser(User user,
            UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    public Status setInterrupt(User user, int mask, DigitalInterruptReason reason);
    public Status getInterrupt(User user, int mask, DigitalInterruptReason reason);
    public Status clearInterrupt(User user,int mask);
    public void interruptOccurred(int data);
    abstract public Status read(User user, int mask);
    abstract public Status write(User user, int value, int mask);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractUInt32Digital</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>Returns null. The derived class should implement this if it knows the
      choices.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">setInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">clearInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Calls the registered listeners.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="int32">int32</h2>
<hr />

<p><span style="font-family: courier;">int32</span> is implemented by a
driver that supports a 32 bit integer. An example is a driver for an ADC
(Analog to Digital Converter). Unless it is more than a 32 bit ADC it can
support this interface by using the low order bits and sign extending the
high order bits..</p>

<h3 id="Int32Inter">Int32InterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Int32InterruptListener {
    void interrupt(int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h3 id="Int32">Int32</h3>

<p>The interface methods are:</p>
<pre>public interface Int32 extends Interface {
    Status write(User user, int value);
    Status read(User user);
    Status getBounds(User user, int[]bounds);
    Status addInterruptUser(User user,
               Int32InterruptListener int32InterruptListener);
    Status removeInterruptUser(User user,
               Int32InterruptListener int32InterruptListener);
    void interruptOccurred(int data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>This is implemented by a driver if it knows the bounds. For example a
      12 bit unipolor adc would set the bounds as: 
      <pre>    bounds[0] = 0; bounds[1] = 4095;</pre>
    </dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h3 id="AbstractIn1">AbstractInt32</h3>

<p>A driver implements int32 by extending the following abstract base
class:</p>
<pre>public abstract class AbstractInt32
extends AbstractInterface
implements Int32
{
    protected AbstractInt32(Device device);
    protected void interruptOccurred(int data);
    public Status getBounds(User user, int[] bounds);
    public Status addInterruptUser(User user,
            Int32InterruptListener int32InterruptListener);
    public Status removeInterruptUser(User user,
            Int32InterruptListener int32InterruptListener);
    public Status getBounds(User user, int[] bounds);
    public abstract Status read(User user);
    public abstract Status write(User user, int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractInt32</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>Calls user.setMessage and returns Status.error.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>Calls <span style="font-family: courier;">user.setMessage</span> and
      returns <span style="font-family: courier;">Status.error</span>.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="int32Array">int32Array</h2>
<hr />

<p><span style="font-family: courier;">int32Array</span> is implemented by a
driver that supports a array of 32 bit integers.</p>

<h3 id="Int32Array">Int32ArrayInterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Int32ArrayInterruptListener{
    void interrupt(Int32Array int32Array);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h3 id="Int32Array1">Int32Array</h3>

<p>The implementation must implement PVIntArray, which is used for all I/O.
In addition the following methods are implemented:</p>
<pre>public interface Int32Array extends Interface{
    PVIntArray getPVIntArray();
    Status startRead(User user);
    Status endRead(User user);
    Status startWrite(User user);
    Status endWrite(User user);
    Status addInterruptUser(User user,
        Int32ArrayInterruptListener int32ArrayListener);
    Status removeInterruptUser(User user,
        Int32ArrayInterruptListener int32ArrayListener);
    void interruptOccurred();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVIntArray</dt>
    <dd>Get the data interface.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>This is called each time the user starts reading. The driver
      implements this method so that it can save a reference to the user
      while the user is performing I/O via the PVIntArray methods, which do
      not have a user argument.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>The user calls this when it is done using the PVIntArray methods. The
      driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>This is called each time the user starts writing. The driver
      implements this method so that it can save a reference to the user
      while the user is performing I/O via the PVIntArray methods, which do
      not have a user argument.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>The user calls this when it is done using the PVIntArray methods. The
      driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h3 id="AbstractIn2">AbstractInt32Array</h3>

<p>A driver implements int32Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractInt32Array
extends AbstractArrayInterface
implements Int32Array
{
    protected AbstractInt32Array(PVIntArray pvIntArray,Device device);
    public PVIntArray getPVIntArray();
    public void interruptOccurred();
    public Status addInterruptUser(User user,
            Int32ArrayInterruptListener int32ArrayInterruptListener);
    public Status removeInterruptUser(User user,
            Int32ArrayInterruptListener int32ArrayInterruptListener);
    public Status startRead(User user);
    public Status endRead(User user);
    public Status startWrite(User user);
    public Status endWrite(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractInt32Array</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>Returns Status.success.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="float64">float64</h2>
<hr />

<p><span style="font-family: courier;">float64</span> is implemented by
drivers that support a double value.</p>

<h3 id="Float64Int">Float64InterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Float64InterruptListener {
    void interrupt(double value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h3 id="Float64">Float64</h3>

<p>The interface methods are:</p>
<pre>public interface Float64 extends Interface {
    double[] getDisplayLimits(User user);
    String getUnits(User user);
    Status write(User user, double value);
    Status read(User user);
    Status addInterruptUser(User user,
        Float64InterruptListener float64InterruptListener);
    Status removeInterruptUser(User user,
        Float64InterruptListener float64InterruptListener);
    void interruptOccurred(double data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDisplayLimits</dt>
    <dd>Get display limits.</dd>
  <dt style="font-family: courier;">getUnits</dt>
    <dd>Get the units.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h3 id="AbstractFl">AbstractFloat64</h3>

<p>A driver implements int32Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractFloat64
extends AbstractInterface
implements Float64
{
    protected AbstractFloat64(Device device);
    public double[] getDisplayLimits(User user);
    public String getUnits(User user);
    protected void interruptOccurred(double data);
    public Status addInterruptUser(User user,
            Float64InterruptListener float64InterruptListener);
    public Status removeInterruptUser(User user,
            Float64InterruptListener float64InterruptListener);
    public abstract Status read(User user);
    public abstract Status write(User user, double value) ;
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractFloat64</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">getDisplayLimits</dt>
    <dd>return null. Derived class should implement this if it knows
    limits.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="float64Arr">float64Array</h2>
<hr />

<p><span style="font-family: courier;">float64Array</span> is implemented by
a driver that supports a array of doubles.</p>

<h3 id="Float64Arr">Float64ArrayInterruptListener</h3>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Float64ArrayInterruptListener{
    void interrupt(Float64Array float64Array);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h3 id="Float64Arr1">Float64Array</h3>

<p>The implementation must implement PVDoubleArray, which is used for all
I/O. In addition the following methods are implemented:</p>
<pre>public interface Float64Array extends Interface{
    PVDoubleArray getPVDoubleArray();
    Status startRead(User user);
    Status endRead(User user);
    Status startWrite(User user);
    Status endWrite(User user);
    Status addInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayListener);
    Status removeInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayListener);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVDoubleArray</dt>
    <dd>Get the data interface.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>This is called each time the user starts reading. The driver
      implements this method so that it can save a reference to the user
      while the user is performing I/O via the PVDoubleArray methods, which
      do not have a user argument.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>The user calls this when it is done using the PVDoubleArray methods.
      The driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>This is called each time the user starts writing. The driver
      implements this method so that it can save a reference to the user
      while the user is performing I/O via the PVDoubleArray methods, which
      do not have a user argument.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>The user calls this when it is done using the PVDoubleArray methods.
      The driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
      method.</dd>
</dl>

<h3 id="AbstractFl1">AbstractFloat64Array</h3>

<p>A driver implements float64Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractFloat64Array
extends AbstractPVArray implements Float64Array
{
    protected AbstractFloat64Array(
            PVField parent,Array array,int capacity,boolean capacityMutable,
            Device device,String interfaceName);
    public Status endRead(User user);
    public Status endWrite(User user);
    public Status startRead(User user);
    public Status startWrite(User user);
    public void interruptOccurred();
    public String getInterfaceName();
    public Status addInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayInterruptListener);
    public Status removeInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayInterruptListener);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractFloat64Array</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Get the name of the interface, i.e. "float64Array". The derived class
      should not implement this method.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>Returns Status.success.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="GPIB">GPIB Interfaces</h2>
<hr />

<p>A driver that implements GPIB inplements both GpibController and
GpibDevice. For the controller it it implement a psuedo device which is
accessed via interface GpibController. The name for this device should be the
same as the port name. For each actual device it implements interface
GpibDevice.</p>

<h3 id="GpibContro">GpibController</h3>

<p><span style="font-family: courier;">gpibController</span> has the
definition:</p>
<pre>public interface GpibSrqHandler {
     public void srqHandler(GpibController controller);
}

public interface GpibController {
    Status ifc(User user);
    Status getBusAddress(User user);
    Status setBusAddress(User user,int address);
    Status isRemote(User user);
    Status isSRQ(User user);
    Status isNDAC(User user);
    Status isSystemController(User user);
    Status isControllerInCharge(User user);
    Status isTalker(User user);
    Status isListener(User user);
    Status setATN(User user,boolean state);
    Status setREN(User user,boolean state);
    Status passControl(User user,int addr);
    Status sendCommand(User user,byte data[]);
    Status enableSRQ (User user,boolean state);
    void registerSrqHandler(GpibSrqHandler srqHandler);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">srqHandler</dt>
    <dd>A user supplied method that is called when the controller detects an
      SRQ.</dd>
  <dt style="font-family: courier;">ifc</dt>
    <dd>Issue an interface clear.</dd>
  <dt style="font-family: courier;">getBusAddress</dt>
    <dd>Get the bus address on the controller itself.</dd>
  <dt style="font-family: courier;">setBusAddress</dt>
    <dd>Set the bus address for the controller itself. This is required if
      the default bus address for the controller conflicts with the address
      of a device connected to the controller.</dd>
  <dt style="font-family: courier;">isRemote</dt>
    <dd>Is the remote line asserted?</dd>
  <dt style="font-family: courier;">isSRQ</dt>
    <dd>Is SRQ asserted?</dd>
  <dt style="font-family: courier;">isNDAC</dt>
    <dd>Is NDAC asserted?</dd>
  <dt style="font-family: courier;">isSystemController</dt>
    <dd>Is this controller the system controller?</dd>
  <dt style="font-family: courier;">isControllerInCharge</dt>
    <dd>Is this controller the controller in charge?</dd>
  <dt style="font-family: courier;">isTalker</dt>
    <dd>Is talker asserted?</dd>
  <dt style="font-family: courier;">isListener</dt>
    <dd>Is listener asserted?</dd>
  <dt style="font-family: courier;">setATN</dt>
    <dd>Set ATN line</dd>
  <dt style="font-family: courier;">setREN</dt>
    <dd>Set REN line</dd>
  <dt style="font-family: courier;">passControl</dt>
    <dd>Pass control to the specified address.</dd>
  <dt style="font-family: courier;">sendCommand</dt>
    <dd>Send the commands to the controller.</dd>
  <dt style="font-family: courier;">enableSRQ</dt>
    <dd>Allow SRQs.</dd>
  <dt style="font-family: courier;">registerSrqHandler</dt>
    <dd>Register a handler to be called when an SRQ is detected.</dd>
</dl>

<h3 id="GpibDevice">GpibDevice</h3>

<p><span style="font-family: courier;">gpibDevice</span> has the
definition:</p>
<pre>public interface GpibDevice {
    Status trigger(User user);
    Status clear(User user);
    Status lock(User user);
    Status unlock(User user);
    boolean getEOI();
    void setEOI(boolean eoi);
    Status getStatusByte(User user);
    Status remote(User user);
    Status local(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">trigger</dt>
    <dd>Issue a trigger command.</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Issue a clear command.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the device or controller</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the device or controller</dd>
  <dt style="font-family: courier;">getEOI</dt>
    <dd>Get the current state of EOI</dd>
  <dt style="font-family: courier;">setEOI</dt>
    <dd>Should EOI be asserted when the last byte is sent.</dd>
  <dt style="font-family: courier;">getStatusByte</dt>
    <dd>Get the status byte.</dd>
  <dt style="font-family: courier;">remote</dt>
    <dd>Set the device or controller to remote control.</dd>
  <dt style="font-family: courier;">local</dt>
    <dd>Set the device or controller to locale control.</dd>
</dl>
</body>
</html>
