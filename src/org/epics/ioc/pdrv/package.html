<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: portDriver</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: portDriver<br />
package: org.epics.ioc.pdrv<br />
2007.11.14</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Purpose">Purpose</a></li>
  <li><a href="#Status">Status</a></li>
  <li><a href="#Acknowledg">Acknowledgments</a></li>
  <li><a href="#Overview">Overview of PDRV</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#PDRV">PDRV Interfaces</a></li>
      <li><a href="#PDRV1">PDRV Factory</a></li>
      <li><a href="#Generic">Generic Interfaces</a></li>
      <li><a href="#Multiple">Multiple Device vs Single Device Port
        Drivers</a></li>
      <li><a href="#Connection">Connection Management</a></li>
      <li><a href="#Protecting">Protecting a Thread from Blocking</a></li>
      <li><a href="#portThread">portThread</a></li>
      <li><a href="#Driver">Driver Can Also Be User</a></li>
      <li><a href="#Initializa">Initialization</a></li>
      <li><a href="#Requesting">Requesting access to a port</a></li>
    </ul>
  </li>
  <li><a href="#PDRV2">PDRV Factory</a>
    <ul>
      <li><a href="#createUser">createUser</a></li>
      <li><a href="#createPort">createPort</a></li>
      <li><a href="#getPortNam">getPortNames</a></li>
      <li><a href="#getPort">getPort</a></li>
    </ul>
  </li>
  <li><a href="#User">User</a>
    <ul>
      <li><a href="#Status1">Status</a></li>
      <li><a href="#REASON">REASON</a></li>
      <li><a href="#duplicateU">duplicateUser</a></li>
      <li><a href="#User1">User Queue Request</a></li>
      <li><a href="#User2">User lock/unlock Port</a></li>
      <li><a href="#User3">User connection to a port</a></li>
      <li><a href="#getPort1">getPort</a></li>
      <li><a href="#User4">User connection to a device</a></li>
      <li><a href="#getDevice">getDevice</a></li>
      <li><a href="#User5">User Messages</a></li>
      <li><a href="#Alarms">Alarms</a></li>
      <li><a href="#L740">I/O Timeouts</a></li>
      <li><a href="#Driver1">Driver Private</a></li>
      <li><a href="#User6">User Private</a></li>
      <li><a href="#Passing">Passing Information Between User and
      Driver</a></li>
    </ul>
  </li>
  <li><a href="#Connect">Connect Exception</a></li>
  <li><a href="#Port">Port</a>
    <ul>
      <li><a href="#User7">User Locate Interface/Device</a></li>
      <li><a href="#User8">User Connection Methods</a></li>
      <li><a href="#Informatio">Informational Methods</a></li>
      <li><a href="#Connection1">Connection Methods</a></li>
      <li><a href="#Driver2">Driver Methods</a></li>
      <li><a href="#LockPortNo">LockPortNotify</a></li>
    </ul>
  </li>
  <li><a href="#Device">Device</a>
    <ul>
      <li><a href="#User9">User findInterface</a></li>
      <li><a href="#User10">User Connection Methods</a></li>
      <li><a href="#User11">User Blocking</a></li>
      <li><a href="#Informatio1">Informational Methods</a></li>
      <li><a href="#Connection2">Connection Methods</a></li>
      <li><a href="#Driver3">Driver Methods</a></li>
    </ul>
  </li>
  <li><a href="#Trace">Trace</a>
    <ul>
      <li><a href="#Trace1">Trace Mask Options</a></li>
      <li><a href="#TraceIO">TraceIO Options</a></li>
      <li><a href="#Trace2">Trace File</a></li>
      <li><a href="#Trace3">Trace Option Change Listener</a></li>
      <li><a href="#Generating">Generating Trace Messages</a></li>
    </ul>
  </li>
  <li><a href="#Driver4">Driver</a>
    <ul>
      <li><a href="#PortDriver">PortDriver</a></li>
      <li><a href="#DeviceDriv">DeviceDriver</a></li>
    </ul>
  </li>
  <li><a href="#Appendix">Appendix: Java Definitions</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Purpose">Purpose</h2>
<hr />

<p><b>portDriver</b> (PDRV) is a general purpose facility for interfacing
support code to low level drivers. Devices are accessed via a port. PDRV
allows non-blocking support that works with both blocking and non-blocking
drivers.</p>

<p>A primary target for PDRV is support for fields of JavaIOC records.
However much of it is independent of EPICS.</p>

<p>PDRV has the following key concepts:</p>
<ul>
  <li>A port is a communication path to one or more devices, i.e. a device is
    accessed via a port.</li>
  <li>A driver implements interfaces PortDriver, DeviceDriver and I/O
    interfaces.</li>
  <li>PDRV implements interfaces User, Port, Device, and Trace.</li>
  <li>Interface User is an interface for support code to access PDRV and
    drivers.</li>
  <li>Interface Trace provides a general purpose diagnostic facility. 
    <p>Rules are defined for providing diagnostic messages. Provided support
    and drivers follow the rules, a user can obtain several levels of
    diagnostic information that can be displayed on the console, written to a
    file, or sent to an error logging facility.</p>
  </li>
  <li>A standard set of I/O interfaces are defined. 
    <p>Support code communicates with devices via the I/O interfaces. </p>
    <p>Drivers take care of the details of how to communicate with a device
    and implement interfaces for use by support. Interfaces are defined for
    both message and register based devices.</p>
  </li>
  <li>A port provides access to device instances 
    <p>A port, which has a portName, identifies a communication path to one
    or more device instances. For example a GPIB port can have up to 15
    devices connected to it. An RS232 port communicates with a single device.
    Drivers register a port. Support connects to a port.</p>
  </li>
  <li>Interface Port controls access to a port 
    <p>Port provides exclusive access to a driver via calls to
    user.queueRequest or user.lockPort/user.unlockPort. Once support has
    access, it can make an arbitrary number of calls to the I/O interfaces
    knowing that no other support can call the driver. Support and drivers do
    not need to implement queues or semaphores since Port does this for
    them.</p>
  </li>
  <li>PDRVRecord - Connect/Enable/Trace commands for a port/device <br />
    NOT IMPLEMENTED. </li>
  <li>Extensive Serial Support - NOT IMPLEMENTED 
    <p>PDRV provides many facilities for communicating with RS232, RS485,
    GPIB, and ethernet.</p>
  </li>
  <li>PDRVLinkSupport</li>
</ul>
<hr />
<hr />

<h2 style="text-align: center" id="Status">Status</h2>
<hr />

<p>This version provides</p>
<ul>
  <li>Factory: Implementations of User, Port, Device, and Trace.</li>
  <li>Standard interfaces: Standard message and register based interfaces are
    defined. Low Level Drivers implement standard interfaces. Support
    communicates with low level drivers via standard interfaces.</li>
  <li>PDRVLinkSupport: Generic support for javaIOC records. This is part of
    package org.epics.ioc.support.</li>
</ul>

<p>The following are tasks that remain:</p>
<ul>
  <li>No hardware drivers have been implemented. BIG JOB REMAINING.</li>
  <li>Convert STREAMS, which is the protocol file-based support for
    serial/GPIB/CAN from Dirk Zimoch, to Java and interface to it. BIG JOB
    REMAINING</li>
  <li>Support gpib including Java support for the VXI11 protocal.</li>
</ul>

<p>NOTE: The initial plan is to use JNI to communicate with an EPICS IOC so
that the JavaIOC can use the asynDriver drivers.</p>
<hr />
<hr />

<h2 style="text-align: center" id="Acknowledg">Acknowledgments</h2>
<hr />

<p>PDRV is modeled after asynDriver. See <a
href="http://www.aps.anl.gov/epics/modules/soft/asyn/">asynDriver</a>. for
details about asynDriver.</p>

<p>Special thanks goes to Mark Rivers and Eric Norum who both made major
contributions to asynDriver and to Dirk Zimoch for developing STEAMS.</p>
<hr />
<hr />

<h2 style="text-align: center" id="Overview">Overview of PDRV</h2>
<hr />

<h3 id="Definition">Definitions</h3>

<p>PDRV is a software layer between support code, e.g. javaIOC support, and
drivers that communicate with devices. It supports both blocking and
non-blocking communication and can be used with both register and message
based devices. PDRV uses the following terminology:</p>
<ul>
  <li>port <br />
    A physical or logical entity which provides access to a device. A port
    provides access to one or more devices. </li>
  <li>device 
    <p>A device (instrument) is connected to a port. For example a GPIB
    interface can have up to 15 devices connected to it. Other ports, e.g.
    EIA232 serial ports, only support a single device. Whenever this document
    uses the word device without a qualifier, it means something that is
    connected to a port.</p>
  </li>
  <li>interface <br />
    All communication between software layers is done via Java interfaces.
  </li>
  <li>PDRV 
    <p>The name for the code described in this package.</p>
  </li>
  <li>Port 
    <p>An interface, implemented by the Factory for this package, that
    manages the port.</p>
  </li>
  <li>Device 
    <p>An interface, implemented by the Factory for this package, that
    manages a device.</p>
  </li>
  <li>PortDriver 
    <p>Interface implemented by a driver for the port.</p>
  </li>
  <li>DeviceDriver 
    <p>Interface implemented by a driver for a device connected to a port.</p>
  </li>
  <li>support 
    <p>The code that users PDRV. For example PDRVLinkSupport is PDRV support
    code for javaIOC records.</p>
  </li>
  <li>User 
    <p>An interface implemented by PDRV and used by support. It provide
    access to PDRV itself and driver I/O interfaces. It also allows a driver
    to pass error messages and other auxillary information to support
    code.</p>
  </li>
  <li>Trace 
    <p>An interface for diagnostic messages.</p>
  </li>
  <li>portThread 
    <p>If a port can block, a thread is created for the port, and all I/O is
    done via this thread.</p>
  </li>
  <li>synchronous 
    <p>Code that does not voluntarily give up control of the CPU, i.e. it
    does not block.</p>
    <p>Mutex operations are considered to be synchronous operations, i.e.
    they are permitted in synchronous code.</p>
  </li>
  <li>asynchronous 
    <p>Code that is not synchronous. Some examples of asynchronous operations
    are threadSleep, eventWait, and stdio operations. </p>
  </li>
  <li>asynchronous Driver 
    <p>A driver that blocks while communicating with a device. Typical
    examples are serial, gpib, and network based drivers.</p>
  </li>
  <li>synchronous Driver 
    <p>A driver that does not block while communicating with a device.
    Typical examples are register based devices.</p>
  </li>
  <li>I/O Interface 
    <p>An interface for performing Input or Output to a device.</p>
  </li>
  <li>interrupt 
    <p>As implemented by PDRV, interrupt just means "I have a new value".</p>
  </li>
  <li>interpose 
    <p>Multiple layers can exist between support code and a port driver. A
    software layer calls interposeInterface in order to be placed between
    support code and a driver. For more complicated protocols, additional
    layers can be created.</p>
  </li>
</ul>

<p>Synchronous/asynchronous and message/register are orthogonal concepts. For
example a register based driver can be either synchronous or asynchronous.
The terminology register vs message is adapted from VXI.</p>

<p>Standard I/O interfaces are defined. For example if support does all its
communication via reads and writes consisting of 8 bit bytes (octets), then
it should work with any driver that implements interface Octet.</p>

<p>One or more devices can be attached to a port. For example, only one
device can be attached to an RS-232 port, but up to 15 devices can be
attached to a GPIB port.</p>

<p>A driver can implement multiple interfaces.</p>

<p>PDRV uses some features of the javaIOC but it can be used by other code,
e.g. a sequence program when one is created for the javaIOC.</p>

<h3 id="PDRV">PDRV Interfaces</h3>

<p>The following are interfaces defined in org.epics.ioc.pdrv:</p>
<dl>
  <dt style="font-weight: bold">User</dt>
    <dd>A "handle" that support code uses to access PDRV. It is create by
      Factory. A user can call queueRequest or lockPort.unlockPort to receive
      exclusive access for performing I/O. It also allows a driver to pass
      error messages and other auxillary data to the user.</dd>
  <dt style="font-weight: bold">Port</dt>
    <dd>An interface that provides many services to a user.</dd>
  <dt style="font-weight: bold">PortDriver</dt>
    <dd>Standard interface implemented by a driver. Methods are report,
      createDevice, connect, and disconnect.</dd>
  <dt style="font-weight: bold">Device</dt>
    <dd>An interface that provides many services to a user.</dd>
  <dt style="font-weight: bold">DeviceDriver</dt>
    <dd>Standard interface implemented by a driver. Methods are report,
      connect, and disconnect.</dd>
  <dt style="font-weight: bold">Trace</dt>
    <dd>Standard interface that allows a user to generate diagnostic
      information for a device.</dd>
  <dt style="font-weight: bold">QueueRequestCallback</dt>
    <dd>The interface umplemented by support code that calls <span
      style="font-weight: bold">user.queueRequest.</span></dd>
</dl>

<h3 id="PDRV1">PDRV Factory</h3>

<p>This implements Port, Device, User, and Trace. It has static methods
to:</p>
<ul>
  <li>Create a User.<br />
    Support code must create a User before it can access a port and it's
    associated devices.</li>
  <li>Create a Port.<br />
    This is called by a driver to register a port.</li>
</ul>

<h3 id="Generic">Generic Interfaces</h3>

<p>Package org.epics.ioc.pdrv.interfaces defines the following generic I/O
interfaces:.</p>
<dl>
  <dt style="font-weight: bold">Octet</dt>
    <dd>methods for message based devices</dd>
  <dt style="font-weight: bold">Float64</dt>
    <dd>methods for devices that read/write IEEE float values</dd>
  <dt style="font-weight: bold">float64Array</dt>
    <dd>methods for devices that read/write arrays of IEEE float values</dd>
  <dt style="font-weight: bold">Int32</dt>
    <dd>methods for devices that read/write integer values. Many analog I/O
      drivers can use this interface.</dd>
  <dt style="font-weight: bold">Int32Array</dt>
    <dd>methods for devices that read/write arrays of integer values</dd>
  <dt style="font-weight: bold">UInt32Digital</dt>
    <dd>methods for devices that read/write arrays of digital values. This
      interface provides a mask to address individual bits within
    registers.</dd>
</dl>

<h3 id="Multiple">Multiple Device vs Single Device Port Drivers</h3>

<p>When a low level driver calls registerPort, it declares if it handles
multiple devices. A single device port should always implement a single
device with address 0.</p>

<h3 id="Connection">Connection Management</h3>

<p>Port and Device keep track of the following states:</p>
<ul>
  <li>connection 
    <p>Is the port or device connected? This state is initialized to
    disconnected.</p>
  </li>
  <li>enabled 
    <p>Is the port or device enabled? This state is initialized to
    enabled.</p>
  </li>
  <li>autoConnect 
    <p>Does Port or Device call connect if it finds the port or device
    disconnected? This is initialized to the state specified in the call to
    createPort.</p>
  </li>
</ul>

<p>Whenever any of the states change for a port or device, then all users
that previously called exceptionCallbackAdd for that port or device are
called.</p>

<p>Low level drivers must call exceptionConnect whenever they connect to a
port or device and exceptionDisconnect whenever they disconnect.</p>

<h3 id="Protecting">Protecting a Thread from Blocking</h3>

<p>The report methods can be called by any thread, but the caller is blocked
until the report finishes. lockPort, connect, disconnect and some other Port
and Device methods can block. See the documentation for these interfaces for
details.</p>

<p>Unless stated otherwise the methods of all I/O interfaces could block and
must only be called by QueueRequestCallback.callback or by calls between
lockPort/unlockPort.</p>

<h3 id="portThread">portThread</h3>

<p>If a driver calls Factory.createPort with canBlock true, then PDRV creates
a thread for the port. Each portThread has its own set of queues for the
calls to queueRequest. Three queues are maintained which provide different
priorities: low, medium, and high. portThread runs forever implementing the
following algorithm:</p>
<ol>
  <li>Wait for for an event. Other code such as queueRequest signals the
    event.</li>
  <li>If the port is disabled, go back to 1.</li>
  <li>If the port is not connected and autoConnect is true for the port, then
    attempt to connect to the port.</li>
  <li>If the port is still not connected, go back to 1.</li>
  <li>For each element of the queues asynQueuePriorityHigh,
    ...,asynQueuePriorityLow. 
    <ul>
      <li>If disabled, skip this element.</li>
      <li>If not connected and autoConnect is true for the device, then
        attempt to connect to the device.</li>
      <li>If not connected, skip this element.</li>
      <li>If blocked by another thread, skip this element.</li>
      <li>If not blocked and user has requested blocking, then blocked.</li>
      <li>Remove from queue and: 
        <ul>
          <li>lockPort</li>
          <li>call user callback</li>
          <li>unlockPort</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>The actual code is more complicated because it unlocks before it calls
code outside asynManager. This means that the queues can be modified and
exceptions may occur.</p>

<h3 id="Driver">Driver Can Also Be User</h3>

<p>A driver can also be the user of another driver. For example a multi-drop
serial driver can use a standard serial driver to perform the actual I/O.
Such a driver implements interface LockPortNotify which is called whenever a
user locks the multi-drop port. The driver can than call lock/unlock for the
serial port so that it has exclusive access to the serial port which the
multi-drip user has access.</p>

<h3 id="Initializa">Initialization</h3>

<p>During initialization, drivers register each communication port as well as
all supported interfaces.</p>

<p>Support code creates a User, which is a "handle" for accessing PDRV
facilities, by calling</p>
<pre>    Factory.createUser(QueueRequestCallback);</pre>
An User has the following features: 
<ul>
  <li>An User is the means by which PDRV manages multiple requests for
    accessing a port.</li>
  <li>QueueRequestCallback, which is used by queueRequest described below,
    has a single method which is the callback that is called when a request
    is taken from a queue.</li>
  <li>Support code should create a User for each "atomic" access to a driver,
    i.e. a set of calls that must not be interlaced with other calls to the
    driver. For example support for javaIOC records creates a User for each
    record instance. instance.</li>
  <li>Support should NOT try to share a User between multiple sources of
    requests for access to a port. If this is done then support must itself
    handle contention issues that are already handled by PDRV.</li>
</ul>

<p>User code connects to a low level driver via a call to</p>
<pre>    Port port = user.connectPort(portName);
    Device device = user.connectDevice(addr);</pre>
This call must specify the name of the port and the address of the device. It
then calls findInterface to locate the interfaces with which it calls the
driver. For example: 
<pre>     Octet octet = (Octet)device.findInterface(user,"octet",true);</pre>

<h3 id="Requesting">Requesting access to a port</h3>

<p>User code can request access to a port by two methods:</p>
<ul>
  <li>user.queueRequest - 
    <p>The processCallback passed to createAsynUser makes calls to the port
    interfaces.</p>
  </li>
  <li>user.lockPort/user.unlockPort - 
    <p>The caller can make calls to the I/O and also to Port and Device
    interfaces while the lock is held. The I/O methods and some of the
    Port/Device methods may block and thus should NOT be used by code that
    should not block, e.g. synchronous device support for EPICS records.</p>
  </li>
</ul>
<hr />

<h2 style="text-align: center" id="PDRV2">PDRV Factory</h2>
<hr />

<p>This is the factory for creating PDRV objects.</p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver PDRV,
            String driverName,
            boolean isMultiDevicePort,boolean canBlock,
            boolean autoConnect,ScanPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
    public static Trace createTrace();
}</pre>

<h3 id="createUser">createUser</h3>
<pre>    User createUser(QueueRequestCallback asynQueueRequestCallback);</pre>

<p>Create a User. This is called by code that wants to access a port and/or
the devices connected to the port.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">asynQueueRequestCallback</dt>
    <dd>This is an interface implemented by the user. It is called when a
      queueRequest is dequeued. See Port for details.</dd>
</dl>

<h3 id="createPort">createPort</h3>
<pre>    Port createPort(
            String portName,PortDriver portDRiver,
            String driverName,
            boolean isMultiDevicePort,boolean canBlock,
            boolean autoConnect,ScanPriority priority);</pre>

<p>Create a port. This is called by a driver to register a new port. The Port
interface is created and returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port. If the port already exists an exception is
      thrown.</dd>
  <dt style="font-family: courier;">portDriver</dt>
    <dd>The interface for the port driver.</dd>
  <dt style="font-family: courier;">driverName</dt>
    <dd>The name of the driver.</dd>
  <dt style="font-family: courier;">isMultiDevicePort</dt>
    <dd>Does the port support multiple devices? If the port only supports a
      single device, the device should have address 0.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Can the device block while performing I/O? If the answer is yes than
      a thread is created for the port and all queueRequest callbacks are
      called via this thread. If the answer is no than all queueRequests
      result in the port being locked and the queueRequest callback is called
      synchronously.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>An initial value for the autoConnect state for both the port and any
      devices connected to the port. Unless the driver has a good reason,
      this should be true. </dd>
  <dt style="font-family: courier;">priority</dt>
    <dd>The priority for the port thread if the port can block.</dd>
</dl>

<h3 id="getPortNam">getPortNames</h3>
<pre>    String[] getPortNames();</pre>

<p>Get an array containing the name of each port. </p>

<h3 id="getPort">getPort</h3>
<pre>    Port getPort(String portName);</pre>

<p>Get the Port for the specified portName. If the port does not exist null
is returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="User">User</h2>
<hr />
User is the interface for accessing a port and/or device. It is created by
Factory and used by client code. 
<pre>public enum Status {
    success,
    timeout,
    overflow,
    error
}

public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(int addr);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setAlarm(AlarmSeverity alarmSeverity,String message);
    AlarmSeverity getAlarmSeverity();
    String getAlarmMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object PDRVPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}</pre>

<h3 id="Status1">Status</h3>

<p>Many methods return a status which is defined by the following:</p>
<pre>public enum Status {
    success,
    timeout,
    overflow,
    error
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">success</dt>
    <dd>The request was satisfied.</dd>
  <dt style="font-family: courier;">timeout</dt>
    <dd>An I/O operation failed because of a timeout. An code returning this
      status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">overflow</dt>
    <dd>An request failed because of an overflow problem. An code returning
      this status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">error</dt>
    <dd>An request failed. An code returning this status must also call
      user.setMessage.</dd>
</dl>

<h3 id="REASON">REASON</h3>

<p>setReason,getReason described below have an integer argument. The
following are some generic reasons:</p>
<pre>    public static final int REASON_SIGNAL = -1;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">REASON_SIGNAL</dt>
    <dd>A signal occured.</dd>
</dl>

<h3 id="duplicateU">duplicateUser</h3>

<p>Create a new User that is connected to the same port and device. The new
user will also have the same reason and timeout as the orginal. </p>
<pre>    User duplicateUser(QueueRequestCallback queueRequestCallback);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>An existing user.</dd>
  <dt style="font-family: courier;">queueRequestCallback</dt>
    <dd>The callback for queueRequest. if queueRequest is never called this
      can be null.</dd>
</dl>

<h3 id="User1">User Queue Request</h3>

<p>Any user than wants to make asynchronous I/O requests but do not want to
block while making the request can call queueRequest. An example is link
support for javaIOC records. Such support must not block or it will block the
record instance itself.</p>

<p></p>

<p>If queueRequest is called for a port that can block than the request is
queued. The port has an associated thread. When the request is taken from the
queue, the port is locked and the requestors callback is called. If
queueRequest is called for a port that can not block then the port is locked
and the requestors callback is called synchronously.</p>

<p>The port thread keeps three FIFO queues with the following priorities:</p>
<pre>public enum QueuePriority {
    low,
    medium, 
    high
}</pre>

<p>The requestor must implement the following interface:</p>
<pre>public interface QueueRequestCallback {
    void callback(Status status,User user);
}</pre>

<p>This interface is passed to Factory.createUser. The arguments to callback
are:</p>
<dl>
  <dt style="font-family: courier;">status</dt>
    <dd>Unless this is Status.success than the request has failed. The user
      must not call any I/O interfaces. user.getMessage can be called to find
      why the request failed.</dd>
  <dt style="font-family: courier;">user</dt>
    <dd>This is passed back to the user so that code can implement a single
      callback that handles multiple users.</dd>
</dl>

<p>If the callback is called with status = success than it can make multiple
calls to the port or device interfaces.</p>

<p>A queueRequest is made via a call to</p>
<pre>    void queueRequest(QueuePriority queuePriority);</pre>

<p>At any time a user can call</p>
<pre>    void cancelRequest();</pre>

<p>If a request is queued it is removed from the queue. If no request is
queued than nothing happens. Note that it is possible for the callback to be
called between the time when cancel is called and when it returns.</p>

<h3 id="User2">User lock/unlock Port</h3>

<p>If a user is willing to block during asynchronous port I/O requests then
it can just call lockPort/unlockPort.</p>
<pre>    Status lockPort();
    void unlockPort();</pre>

<p>Code that uses lockPort should follow the pattern:</p>
<pre>     port.lockPort();
     try {
         // whatever
     } finally {
         port.unlockPort();
     }</pre>

<h3 id="User3">User connection to a port</h3>
<pre>    Port connectPort(String portName);
    void disconnectPort();</pre>

<p>connectPort connects the user to a port and disconnect disconnects. If the
port does not exist connectPort returns null. If the user is also connected
to a device than disconnectPort calls disconnectDevice. Note that these
methods only connects/disconnects the user to/from the port. Thus it does not
effect the connect/disconnect state of the port itself.</p>

<h3 id="getPort1">getPort</h3>
<pre>    Port getPort();</pre>

<p>Get the port to which this user is connected. This can be null.</p>

<h3 id="User4">User connection to a device</h3>
<pre>    Device connectDevice(int addr);
    void disconnectDevice();</pre>
The user must be connected to a port before connecting to a device. If the
device does not exist connectDevice returns null. 

<p>connectDevice connects the user to a device and disconnect disconnects.
Note that these methods only connects/disconnects the user to/from the
device. Thus it does not effect the connect/disconnect state of the device
itself.</p>

<h3 id="getDevice">getDevice</h3>
<pre>    Device getDevice();</pre>

<p>Get the device to which this user is connected. This can be null.</p>

<h3 id="User5">User Messages</h3>
<pre>    void setMessage(String message);
    String getMessage();</pre>

<p>Methods that return a Status that does not have the value Status.success
must also call user.setMessage to explain why the method failed. The user can
then call getMessage to find the reason.</p>

<h3 id="Alarms">Alarms</h3>
<pre>
    void setAlarm(AlarmSeverity alarmSeverity,String message);
    AlarmSeverity getAlarmSeverity();
    String getAlarmMessage();</pre>

<p>Methods that set and get alarms. </p>

<h3 id="L740">I/O Timeouts</h3>
<pre>    void setTimeout(double timeout);
    double getTimeout();</pre>

<p>Asynchronous I/O operations can block forever. For example a serial line
could break. Each user that makes asynchronous request must call setTimeout.
A timeout value of &lt;= 0.0 means infinity. A PDRV or deviceDriver calls
getTimeout to get the timeout. It is the timeout for an individual I/O
request. For example for a serial driver it could mean the time to read/write
a single byte.</p>

<h3 id="Driver1">Driver Private</h3>
<pre>    void setPortDriverPvt(Object PDRVPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();</pre>

<p>These are methods for the port or device driver. Some drivers may have to
keep data for each user. If a driver does than it must implement interface
<span style="font-family: courier;">package
org.epics.ioc.pdrv.interfaces.DriverUser</span> and the user must find and
use it. It has the methods:</p>
<pre>    void create(User user,PVStructure drvParams);
    void dispose(User user);</pre>

<p>After the user connects to a port or device that implement DriverUser it
must call driverUser.create and when it disconnects it must call
driverUser.dispose. DriverUser.create can allocate data for the user and call
setPortDriverPvt or setDeviceDriverPvt. When the user calls a driver method
the driver can call getPortDriver or getDeviceDriver to get the private data
for the user. DriverUser.dispose should remove all provate state and data fot
the user.</p>

<h3 id="User6">User Private</h3>
<pre>    void setUserPvt(Object userPvt);
    Object getUserPvt();</pre>

<p>These are for private use by the user.</p>

<h3 id="Passing">Passing Information Between User and Driver</h3>
<pre>    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();</pre>

<p>The above are for passing data between a user and a driver. Normally it is
the driver that calls a set method and the user that calls a get method but
the reverse is also possible. Both user and driver must understand when the
methods are used. The interfaces defined in <span
style="font-family: courier;">package org.epics.ioc.pdrv.interfaces</span>
make use of these methods. For example the octet interface use setInt to tell
the user how many elements were transfered.</p>
<hr />

<h2 style="text-align: center" id="Connect">Connect Exception</h2>
<hr />

<p>Both Port and Device provide a methods exceptionListenerAdd and
exceptionListenerRemove. The listener is called whenever the connection state
of a device changes. i.e. the connect state itself, the eneble state, or the
autoConnect state.</p>

<p>The type of exception is defined by: </p>
<pre>public enum ConnectException {
    connect,
    enable,
    autoConnect
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">connect</dt>
    <dd>The port or device has connected or disconnected. The listener can
      call isConnected to determine the state.</dd>
  <dt style="font-family: courier;">enable</dt>
    <dd>The enable state has changed. The listener can call isEnabled to
      determine the state.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>The autoConnect state has changed. The listener can call
      isAutoConnect to determine the state.</dd>
</dl>

<p>The listener must implement the interface:</p>
<pre>public interface ConnectExceptionListener {
    void exception(ConnectException connectException);
}</pre>
<hr />

<h2 style="text-align: center" id="Port">Port</h2>
<hr />

<p>A port manages user access to the I/O. At any given time at most one user
can call the I/O interfaces implemented by a port driver, which also includes
all the devices connected to the port. A user can only call a driver
interface via a call to user.queueRequest or a call to user.lockPort.</p>

<p>The complete set of definitions for Port are:</p>
<pre>public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Interface[] getInterfaces();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean isMultiDevicePort();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);
    Interface findInterface(User user,String interfaceName,
        boolean interposeInterfaceOK);
    void scanQueues();
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, int addr);
    void registerInterface(Interface iface);
    Interface interposeInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h3 id="User7">User Locate Interface/Device</h3>

<p>After a user has connected to a port via a call to user.connectPort it can
connect to a device by calling port.getDevice. If a PDRV implements
interfaces than they can be found via a call to port.findInterface. Most
drivers will implement interfaces for devices but not for the port.</p>
<pre>    Interface findInterface(User user,String interfaceName,
        boolean interposeInterfaceOK);
    Device getDevice(User user, int addr);</pre>

<h3 id="User8">User Connection Methods</h3>

<p>Most users do not ask the port to connect or disconnect but a specialized
client may. For example javaIOC link support is provided for
connect/disconnect requests. This allows a port to be connected or
disconnected via a Channel Access client. These methods can block. They also
call lockPort/unlockPort.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h3 id="Informatio">Informational Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Interface[] getInterfaces();
    String getDriverName();
    String getPortName();
    boolean isMultiDevicePort();
    boolean canBlock();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the port and if specified all devices
      connected to the port. This method blocks. It does not lock so report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getDevices</dt>
    <dd>Get an array of the devices connected to the port.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the PDRV. Note that
      most drivers do not implement port interfaces but only device
      interfaces.</dd>
  <dt style="font-family: courier;">getDriverName</dt>
    <dd>Get the driver name.</dd>
  <dt style="font-family: courier;">getPortName</dt>
    <dd>Get the port name.</dd>
  <dt style="font-family: courier;">isMultiDevicePort</dt>
    <dd>Does this driver support multiple devices?.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Is it possible for the driver to block while doing I/O?</dd>
</dl>

<h3 id="Connection1">Connection Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the port. If the port is disabled then no
      queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the port is not
      connected when the first lockPort request is made than a connect
      request will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the port is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h3 id="Driver2">Driver Methods</h3>

<p>These are methods called by a driver.</p>
<pre>    Device createDevice(DeviceDriver deviceDriver, int addr);
    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect(); 
    Interface interposeInterface(Interface iface);
    Trace getTrace();
    void scanQueues();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>The driver calls this as a result of a call to port.createDevice,
      that is port.createDevice must itself call portDriver.createDevice.</dd>
  <dt style="font-family: courier;">registerInterface</dt>
    <dd>A portDriver must call this for each interface it implements.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">interposeInterface</dt>
    <dd>This is for any code that wants to interpose a port interface.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
  <dt style="font-family: courier;">scanQueues</dt>
    <dd>Not normally called by drivers</dd>
</dl>

<h3 id="LockPortNo">LockPortNotify</h3>

<p>A driver can be the user of another driver. For example a multidrop the
serial driver can use a serial port driver to do the actual I/O and just add
the multidrop protocal. In order to work properly the multidrop driver must
ensure that it has exclusive access to the serial driver whenever a user has
access to the multidrop driver. This it needs to know when a user has
successfully called lockPort. The driver that wants to be the user of another
driver must implement the following:</p>
<pre>public interface LockPortNotify {
    void lock(User user);
    void unlock();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">lock</dt>
    <dd>This is called each time a user obtains control of the port by
      successfully calling lockPort. The driver can call lockPort for the
      port it is using.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>This is called each time a user call unlockPort. The driver can call
      unlockPort for the driver it is using.</dd>
</dl>

<p>The port methods are :</p>
<pre>void registerLockPortNotify(LockPortNotify lockPortNotify);
void unregisterLockPortNotify(); </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerLockPortNotify</dt>
    <dd>Register to be notified of successful lockPort/unlockPort requests.
    </dd>
  <dt style="font-family: courier;">unregisterLockPortNotify</dt>
    <dd>Unregister the caller.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Device">Device</h2>
<hr />

<p>A device provides methods related to a device. The complete set of
definitions for Device are:</p>
<pre>public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    int getAddr(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);
    Interface findInterface(User user,String interfaceName,boolean interposeInterfaceOK);
    Status lockPort(User user);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    Interface interposeInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h3 id="User9">User findInterface</h3>

<p>This is used by a user to locate an interface for the device. If the
driver does not implement the requested interface null is returned.</p>
<pre>    Interface findInterface(User user,
        String interfaceName,boolean interposeInterfaceOK);</pre>

<p>where the arguments are:</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>The user.</dd>
  <dt style="font-family: courier;">interfaceName</dt>
    <dd>The name of the interface.</dd>
  <dt style="font-family: courier;">interposeInterfaceOK</dt>
    <dd>Is it OK to returns an interpose interface. If the value is true then
      the last interface to interpose itself is returned. If the value is
      false then only an interface implemented by the driver is returned.</dd>
</dl>

<h3 id="User10">User Connection Methods</h3>

<p>Most users do not handle the device connecting or disconnecting but a
specialized client may. For example javaIOC link support is provided for
connect/disconnect requests. This allows a device to be connected or
disconnected via a Channel Access client.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h3 id="User11">User Blocking</h3>

<p>A user can block other users from accessing a device. This only works for
asynchronous drivers.</p>
<pre>Status blockOtherUsers(User user);
void unblockOtherUsers(User user);</pre>

<h3 id="Informatio1">Informational Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(int details);
    Interface[] getInterfaces();
    int getAddr(); 
    Port getPort();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the device. It does not lock so some report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the deviceDriver.</dd>
  <dt style="font-family: courier;">getAddr</dt>
    <dd>Get the address of this device.</dd>
  <dt style="font-family: courier;">getPort</dt>
    <dd>Get the port to which this device is connected.</dd>
</dl>

<h3 id="Connection2">Connection Methods</h3>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    boolean isBlockedByOtherUser(User user);
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the device. If the device is disabled then
      no queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the device is not
      connected when the first lockPort request is made than a connect
      request will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the device is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">isBlockedByOtherUser</dt>
    <dd>Is the device blocked by another user.</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h3 id="Driver3">Driver Methods</h3>

<p>These are methods called by a driver.</p>
<pre>    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
    Interface interposeInterface(Interface iface);
    Trace getTrace();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerInterface</dt>
    <dd>A PDRV must call this for each interface it implements.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">interposeInterface</dt>
    <dd>This is for any code that wants to interpose a port interface.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Trace">Trace</h2>
<hr />

<p>Both Port and Device provide access to a Trace facility, which allows
diagnostic messages to be generated on a port or device basis. Both support,
e.g. javaIOC record support, and drivers are expected to support the trace
facility.</p>

<p>The Java definitions for Trace are:</p>
<pre>public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int INTERPOSE = 0x0004;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    void optionChangeListenerAdd(
         TraceOptionChangeListener traceOptionChangeListener);
    void optionChangeListenerRemove(
         TraceOptionChangeListener traceOptionChangeListener);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}</pre>

<h3 id="Trace1">Trace Mask Options</h3>

<p>The trace mask specifies when to generate messages. </p>
<pre>    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int INTERPOSE = 0x0004;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    void setMask(int mask);
    int getMask();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">ERROR</dt>
    <dd>Generate a message whenever an error is detected. This is the only
      bit of the mask that is set by default.</dd>
  <dt style="font-family: courier;">SUPPORT</dt>
    <dd>Support level code should generate a message whenever it calls any
      interface method.</dd>
  <dt style="font-family: courier;">INTERPOSE</dt>
    <dd>An interpose method should generate a message whenever any of it's
      methods are called.</dd>
  <dt style="font-family: courier;">DRIVER</dt>
    <dd>A driver should generate a message whenever any of it's methods are
      called.</dd>
  <dt style="font-family: courier;">FLOW</dt>
    <dd>Port or Device should generate a message whenever it performs some
      action. For example when a request is queued and when it is taken from
      a queue.</dd>
  <dt style="font-family: courier;">setMask</dt>
    <dd>Set the mask to some combination of the maks values. For example: 
      <pre>    device.setMask(ERROR|SUPPORT|DRIVER);</pre>
      will cause message to be generated whenever an error detected, when
      support level code calls an interface method, and when a device driver
      method is called.</dd>
  <dt style="font-family: courier;">getMask</dt>
    <dd>Get the current value of the mask.</dd>
</dl>

<h3 id="TraceIO">TraceIO Options</h3>

<p>The traceIO mask specifies what to generate for octet data values.</p>
<pre>    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setIOMask(int mask);
    int getIOMask();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">IO_NODATA</dt>
    <dd>Don't print any data.</dd>
  <dt style="font-family: courier;">IO_ASCII</dt>
    <dd>Print with a "%s" style format.</dd>
  <dt style="font-family: courier;">IO_ESCAPE</dt>
    <dd>Print with a "%s" style format but show control characters as escape
      sequences. For example a carriage return is printed as "\r".</dd>
  <dt style="font-family: courier;">IO_HEX</dt>
    <dd>Print each byte with " %2.2x".</dd>
  <dt style="font-family: courier;">setIOMask</dt>
    <dd>Set the IOMask to saome combination of the above. Note that IO_NODATA
      should not be specified with any other bits since it has no
    meaning.</dd>
  <dt style="font-family: courier;">getIOMask</dt>
    <dd>Get the current IOMask.</dd>
  <dt style="font-family: courier;">setIOTruncateSize</dt>
    <dd>Set the truncation size for data output. For printIO it means the
      number of bytes to print. For array data it means the number of
      elements to display.</dd>
  <dt style="font-family: courier;">getIOTruncateSize</dt>
    <dd>Get the current truncation size.</dd>
</dl>

<h3 id="Trace2">Trace File</h3>

<p>The destination for trace messages.</p>
<pre>    void setFile(Writer file);
    Writer getFile();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">setFile</dt>
    <dd>Set the destination for trace messages. The default is a buffered
      writer to standard out.</dd>
  <dt style="font-family: courier;">getFile</dt>
    <dd>Get the current destination for trace messages,</dd>
</dl>

<h3 id="Trace3">Trace Option Change Listener</h3>

<p>Code that wants to listen for option change must implement the
following:</p>
<pre>public interface TraceOptionChangeListener {
    void optionChange(); 
}</pre>

<p>The Trace methods for a listener are:</p>
<pre>    void optionChangeListenerAdd(
         TraceOptionChangeListener traceOptionChangeListener);
    void optionChangeListenerRemove(
         TraceOptionChangeListener traceOptionChangeListener);</pre>

<h3 id="Generating">Generating Trace Messages</h3>

<p><span style="font-family: courier;">print</span> is called to generate
messages and <span style="font-family: courier;">printIO</span> to generate
messages and also the value of octet data.</p>
<pre>    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">print</dt>
    <dd>Generate a trace message. <span
      style="font-family: courier;">reason</span> is one of the trace mask
      bits.</dd>
  <dt style="font-family: courier;">printIO</dt>
    <dd>Does the same as print an then prints the buffer data using the
      traceIO features.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Driver4">Driver</h2>
<hr />

<h3 id="PortDriver">PortDriver</h3>

<p>Every driver must implement the following methods:</p>
<pre>public interface PortDriver {
    String report(int details);
    Device createDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the port.</dd>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>Create a device for the given address. The driver must implemnent
      interface DeviceDriver, call port.createDevice, and return the device
      it creates. If it can't create a device at the specified address, it
      should call user.setMessage and return null.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual port. If successful it must call
      port.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the port. If successfull call
      port.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>

<h3 id="DeviceDriv">DeviceDriver</h3>

<p>The driver implements the following for each device it acesses.</p>
<pre>public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the device.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual device. If successful it must call
      device.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the device. If successfull call
      device.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Appendix">Appendix: Java Definitions</h2>
<hr />

<p>The following is a complete list of all the Java definitions for <span
style="font-family: courier;">package org.epics.ioc.pdrv. </span></p>

<p>The I/O interfaces implemented by drivers (port or device) are defined in
package <span style="font-family: courier;">package
org.epics.ioc.pdrv.interfaces</span></p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver PDRV,
            String driverName,
            boolean isMultiDevicePort,boolean canBlock,
            boolean autoConnect,ScanPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
}

public enum Status {
    success,
    timeout,
    overflow,
    error
}

public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(int addr);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object PDRVPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}

public enum ConnectException {
    connect,
    enable,
    autoConnect
}

public interface ConnectExceptionListener {
    void exception(ConnectException connectException);
}

public enum QueuePriority {
    low,
    medium, 
    high
}

public interface QueueRequestCallback {
    void callback(Status status,User user);
}

public interface LockPortNotify {
    void lock(User user);
    void unlock();
}

public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Interface[] getInterfaces();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean isMultiDevicePort();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);
    Interface findInterface(User user,String interfaceName,boolean interposeInterfaceOK);
    void scanQueues();
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, int addr);
    void registerInterface(Interface iface);
    Interface interposeInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    int getAddr(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    void exceptionListenerAdd(ConnectExceptionListener connectExceptionListener);
    void exceptionListenerRemove(ConnectExceptionListener connectExceptionListener);
    Interface findInterface(User user,String interfaceName,boolean interposeInterfaceOK);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    Interface interposeInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface TraceOptionChangeListener {
    void optionChange(); 
}

public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int INTERPOSE = 0x0004;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    void optionChangeListenerAdd(
         TraceOptionChangeListener traceOptionChangeListener);
    void optionChangeListenerRemove(
         TraceOptionChangeListener traceOptionChangeListener);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}

public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}

public interface PortDriver {
    String report(int details);
    Device createDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
}</pre>
</body>
</html>
