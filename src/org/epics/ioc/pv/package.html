<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: pv<br />
package: org.epics.ioc.pv<br />
2007.01.05</h1>
CONTENTS

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a>
    <ul>
      <li><a href="#Process">Process Variable</a></li>
      <li><a href="#Process1">Process Variable Data Types</a></li>
      <li><a href="#Process2">Process Variable Reflection</a></li>
    </ul>
  </li>
  <li><a href="#Type">Type</a></li>
  <li><a href="#Reflection">Reflection</a></li>
  <li><a href="#PVData">PVData Interfaces</a>
    <ul>
      <li><a href="#PVData1">PVData</a></li>
      <li><a href="#Primitive">Primitive PVData types</a></li>
      <li><a href="#PVString">PVString</a></li>
      <li><a href="#PVEnum">PVEnum</a></li>
      <li><a href="#PVMenu">PVMenu</a></li>
      <li><a href="#PVLink">PVLink</a></li>
      <li><a href="#PVStructur">PVStructure</a></li>
      <li><a href="#PVRecord">PVRecord</a></li>
      <li><a href="#PVArray">PVArray</a></li>
      <li><a href="#FieldCreat">FieldCreate</a></li>
    </ul>
  </li>
  <li><a href="#Base">Base Introspection Classes</a></li>
  <li><a href="#AbstractPV">AbstractPVData</a></li>
  <li><a href="#Convert">Convert</a></li>
  <li><a href="#Field">Field Factory</a></li>
  <li><a href="#Convert1">Convert Factory</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>A Process Variable (PV) Database is a "smart" database because it has
records together with support code:</p>
<ul>
  <li>Each record has a unique record name.</li>
  <li>A record is a data structure, i.e. a set of fields holding data.</li>
  <li>Each record has associated record support.</li>
  <li>Each field can optionally have associated support.</li>
</ul>

<p>A PV Data has one of the following types:</p>
<dl>
  <dt>primitive</dt>
    <dd>All Java primitive types except char, i.e. boolean, byte, short, int,
      float, and double.</dd>
  <dt>string</dt>
    <dd>A Java String. NOTE: primitive and string types are considered scalar
      types.</dd>
  <dt>enum</dt>
    <dd>A enum is an array of choices and an index that selects a choice.</dd>
  <dt>menu</dt>
    <dd>Like an enum except that it has a menuName and the array of choices
      is immutable.</dd>
  <dt>structure</dt>
    <dd>A structure has a name and contains an array of fields of any
      supported type.</dd>
  <dt>array</dt>
    <dd>A one dimensional array. The element type is any of the supported
      types.</dd>
  <dt>link</dt>
    <dd>A link has no data but can have support and a configuration
    structure.</dd>
</dl>

<p>In addition to the Java IOC, PV data is intended for use by 1) Channel
Access client, 2) interface from client to network, 3) interface from network
to Channel Access server, 4) interface from server to IOC database. Since it
is the interface to data, it could also be used by other systems, e.g. TANGO,
TINI, DOOCS, etc.</p>

<p>This package provides the following:</p>
<dl>
  <dt>Type</dt>
    <dd>An enum that describes the valid types.</dd>
  <dt>Reflection Interfaces</dt>
    <dd>These are interfaces that describe a PV. They are designed so that
      characteristics of a PV can be discovered without requiring access to
      the data associated with it.</dd>
  <dt>Data Interfaces</dt>
    <dd>These are interfaces for accessing the data associated with a PV.</dd>
  <dt>Conversion Facility</dt>
    <dd>Conversion of the data from any PV to a string is provided.</dd>
    <dd>Conversion from a string to a scalar or array of srings to an array
      of scaler types is supported.</dd>
    <dd>Conversion between a PV and numeric primitive types is supported. The
      PV must contain scalar numeric type.</dd>
    <dd>Conversion between a PV and an array of numeric primitive types is
      supported. The PV must contain an array of a numeric type.</dd>
    <dd>Copy, with conversion if the types differ, between compatible scalar
      PVs.</dd>
    <dd>Copy, with conversion if the element types differ, between compatible
      arrays of PVs.</dd>
    <dd>Copy between compatable structures.</dd>
  <dt>Field Factory</dt>
    <dd>This is an object factory that creates objects implementing the
      reflection interfaces.</dd>
  <dt>Abstract and Base Field Classes</dt>
    <dd>Abstract and Base classes for implementing Field objects.</dd>
  <dt>Convert Factory</dt>
    <dd>An object factory that provides an implementation of the conversion
      facility.</dd>
</dl>

<p>This package does not provide any facilities to create objects that
implement the Data Interfaces. This is the responsibility of a particular
implementation. For a javaIOC, db provides an implementation.</p>

<h3 id="Process">Process Variable</h3>

<p>Definitions:</p>
<dl>
  <dt>Processs Variable (PV)</dt>
    <dd>The name used to specify the data this package supports.</dd>
  <dt>Field</dt>
    <dd>A Field has a name and a type that is any of the supported types. It
      can also have properties.</dd>
  <dt>Property</dt>
    <dd>A property has a name and an associated field within the PV for the
      data.</dd>
  <dt>Attribute</dt>
    <dd>Each field has a fixed set of attributes: default, isReadOnly,
      isDesign, isLink, asl.</dd>
</dl>

<p>Examples of fields are: value, rawValue.</p>

<p>Examples of properties are: status, timeStamp, alarmSeverity,
displayLimits, controlLimits, alarmLimits</p>

<p>For example a PV could define properties for value and rawValue as
follows:</p>
<dl>
  <dt>value</dt>
    <dd>status, timeStamp, alarmSeverity, displayLimits, controlLimits, and
      alarmLimits.</dd>
  <dt>rawValue</dt>
    <dd>status, timeStamp, and alarmSeverity.</dd>
</dl>

<h3 id="Process1">Process Variable Data Types</h3>

<p>The following types are supported:</p>
<dl>
  <dt>primitive</dt>
    <dd><dl>
        <dt>byte</dt>
          <dd>An 8 bit signed byte</dd>
        <dt>boolean</dt>
          <dd>true or false</dd>
        <dt>short</dt>
          <dd>16 bit signed integer</dd>
        <dt>int</dt>
          <dd>32 bit signed integer</dd>
        <dt>long</dt>
          <dd>64 bit signed integer</dd>
        <dt>float</dt>
          <dd>32 bit IEEE float</dd>
        <dt>double</dt>
          <dd>64 bit IEEE float</dd>
      </dl>
    </dd>
  <dt>string</dt>
    <dd>A Java String</dd>
  <dt>enum</dt>
    <dd>A String array of choices and an index selecting a choice.</dd>
  <dt>menu</dt>
    <dd>An enum with a menuName and immutable choices.</dd>
  <dt>link</dt>
    <dd>No data is associated with a link but each support can define a
      structure that contains configuration information.</dd>
  <dt>structure</dt>
    <dd>A struture with fields of type primitive, string, enum, menu,
      structure, or array</dd>
  <dt>array</dt>
    <dd>a one dimensional array of type primitive, string,enum, structure, or
      array</dd>
</dl>

<h3 id="Process2">Process Variable Reflection</h3>

<p>Given a PV it is possible to introspect its fields. The reflection
interface does not provide access to data. Other interfaces, e.g. Channel
Access provide access to the data. The reason is that the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures.</p>
<hr />

<h2 style="text-align: center" id="Type">Type</h2>
<hr />

<p>The types are defined by:</p>
<pre>    enum Type {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray,
        pvMenu,
        pvLink;

        //Convenience methods
        boolean isNumeric();    // pvByte,...pvDouble
        boolean isPrimitive();  // pvBoolean,...pvDouble
        boolean isScalar();     //pvBoolean,...pvString
    }</pre>

<p>Note that a string is a scalar.</p>
<hr />

<h2 style="text-align: center" id="Reflection">Reflection</h2>
<hr />

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    interface Property {
        String getPropertyName();
        String getAssociatedFieldName();
        String toString();
        String toString(int indentLevel);
    }

    public interface FieldAttribute {
        String getDefault();
        boolean isReadOnly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    } 

    interface Enum extends Field {
        boolean isChoicesMutable();
    }

    interface Menu extends Enum {
        String getMenuName();
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<p>The above definitions support the following:</p>
<ul>
  <li>Property
    <ul>
      <li>A property has a name.</li>
      <li>A property has a an associated field that holds the data.</li>
      <li>A property can be converted to a string.</li>
    </ul>
  </li>
  <li>FieldAttribute<br />
    Each field has the following attributes:
    <ul>
      <li>default<br />
        A string default value, which can be null.</li>
      <li>readOnly<br />
        Can the data value be changed?</li>
      <li>isDesign<br />
        Can this field be configurable by Database Configuration Tools.</li>
      <li>isLink<br />
        Is this field a link to another record. This can only be true for a
        pvString field.</li>
      <li>asl<br />
        Access security level. Currently access security is not
      implemented.</li>
    </ul>
  </li>
  <li>Field
    <ul>
      <li>A field has a name.</li>
      <li>A field can have an arbitrary number of associated properties
        including none.</li>
      <li>A field has a Type.</li>
      <li>A field can optionally have support identified via a name.</li>
      <li>A field can be made immutable. This means that the data associated
        with the field is immutable.</li>
      <li>A field has attributes.</li>
      <li>A field can be converted to a string.</li>
    </ul>
  </li>
  <li>Enum
    <ul>
      <li>A enum is a field that can have mutable or immutable choices.</li>
    </ul>
  </li>
  <li>Menu
    <ul>
      <li>A menu is an enum that has immutable choices and also has a
        menuName.</li>
    </ul>
  </li>
  <li>Structure
    <ul>
      <li>Has a name.</li>
      <li>Has fields that can be any of the supported types.</li>
    </ul>
  </li>
  <li>Array - The array has elements of any of the supported types.</li>
</ul>
<hr />

<h2 style="text-align: center" id="PVData">PVData Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing fields within a PV
record.</p>

<h3 id="PVData1">PVData</h3>

<p>The following is the base interface for accessing data.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requestor {
        String getRequestorName();
        void message(String message, MessageType messageType);
    }

    interface PVData extends Requestor {
        String getFullFieldName();
        Field getField();
        PVData getParent();
        PVRecord getPVRecord();
        String getSupportName();
        String setSupportName(String name);
        String toString();
        String toString(int indentLevel);
    }</pre>
where
<ul>
  <li>MessageType<br />
    This is defined in org.epics.ioc.util.</li>
  <li>Requestor<br />
    Requestor is defined in package org.epics.ioc.util. For an IOC database
    the methods are implemented as follows:
    <ul>
      <li>getRequestorName<br />
        This is the full field name concatenated to the record name.</li>
      <li>message<br />

        <ul>
          <li>PVData prepends the full field name to the message and calls
            PVRecord.message. Note that this means that the PVRecord
            implementation must also implement message.</li>
          <li>PVRecord prepends the record name and passes the message to
            IOCDB.message.</li>
          <li>For now IOCDB just calls System.out. It will be extended to
            support a general purpose message handling facility.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>getFullFieldName<br />
    Get the full field name. This returns a name in the form
  ".name.name".</li>
  <li>getField<br />
    Get the reflection interface for the data.</li>
  <li>getParent<br />
    Get the interface for the parent or null if this is the PVRecord
  itself.</li>
  <li>getPVRecord<br />
    Get the interface for the record that contains this field.</li>
  <li>getSupportName<br />
    Get the name of the support for this PV.</li>
  <li>setSupportName<br />
    Set the name of the support for this field. The supportName methods are
    available so that support can be changed remotely. For an IOC database
    only PVLink fields allow the support to be modified after record
    initialization.</li>
  <li>toString<br />
    Converts the field data to a string. This is mostly for debugging
    purposes.</li>
</ul>

<h3 id="Primitive">Primitive PVData types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVData {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVData {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVData {
        short get();
        void put(short value);
    }

    interface PVInt extends PVData {
        int get();
        void put(int value);
    }

    interface PVLong extends PVData {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVData {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVData {
        double get();
        void put(double value);
    }</pre>

<h3 id="PVString">PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVData {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVEnum">PVEnum</h3>

<p>The interface for enum is:</p>
<pre>    interface PVEnum extends PVData{
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }</pre>

<p>where</p>
<dl>
  <dt>getIndex</dt>
    <dd>Get the index of the currently selected choice.</dd>
  <dt>setIndex</dt>
    <dd>Select a choice</dd>
  <dt>setChoices</dt>
    <dd>Change the set of choices. This returns false if the choices can not
      be changed</dd>
</dl>

<h3 id="PVMenu">PVMenu</h3>

<p>The interface for a menu is:</p>
<pre>    interface PVMenu extends PVEnum {}</pre>

<p>The difference from an enum is that the reflection interface provides a
menuName and the choices can not be modified.</p>

<h3 id="PVLink">PVLink</h3>

<p>The interface for a link is:</p>
<pre>    interface PVLink extends PVData {
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }</pre>

<p>Packages db and process allow custom support code for any field of any
record instance of an IOC database. A PVLink field can also have an
associated structure that contains configuration information.. A Channel
Access client can change the support for a PVLink field as follows. This
assumes that the client has permission to change the support:</p>
<ul>
  <li>Call setSupportName</li>
  <li>Call getSupportName. If the new name is what the client specified then
    the client knows that it has successfully changed the support for the
    field.</li>
  <li>Call getConfigurationStructure. If a null is returned it means that the
    support does not require any configuration. If access to a configuration
    structure is returned the client can use it to provide the configuration
    information.</li>
  <li>Call setConfigurationStructure to set the new configuration.</li>
</ul>

<h3 id="PVStructur">PVStructure</h3>

<p>The interface for structure is:</p>
<pre>    interface PVStructure extends PVData {
        PVData[] getFieldPVDatas();
        boolean replaceStructureField(String fieldName,String structureName)
        void beginPut();
        void endPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getFieldPVDatas</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>replaceStructureField</dt>
    <dd>Replace a subfield. The implementation must know how to find a
      reflection interface for structureName and how to create a PVStructure
      for the subfield. In addition it must create a new Structure reflection
      interface for itself.</dd>
  <dt>beginPut endPut</dt>
    <dd>Code that puts to multiple fields of a structure should call beginPut
      before the first put and endPut after the last put.</dd>
</dl>

<h3 id="PVRecord">PVRecord</h3>

<p>Each PVData is a field within a PVRecord:</p>
<pre>    interface PVRecord extends PVStructure
        String getRecordName();
        void message(String message, MessageType messageType);
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This will be called any code that has access to the record instance.
      The implementation should prepend the record name to the message and
      then call a more generic message handler. For example package
      org.epics.ioc.db calls iocdb.message.</dd>
</dl>

<h3 id="PVArray">PVArray</h3>

<p>The interfaces for array are:</p>
<pre>    interface PVArray extends PVData {
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
    }

    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
    }

    public class EnumArrayData {
        public PVEnum[] data;
        public int offset;
    }
    interface PVEnumArray extends PVArray {
        int get(int offset, int len, EnumArrayData data);
        int put(int offset, int len, PVEnum[]from, int fromOffset);
    }

    public class MenuArrayData {
        public PVMenu[] data;
        public int offset;
    }
    interface PVMenuArray extends PVArray {
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, PVMenu[]from, int fromOffset);
    }

    public class LinkArrayData {
        public PVLink[] data;
        public int offset;
    }
    interface PVLinkArray extends PVArray {
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, PVLink[]from, int fromOffset);
    }

    public class ArrayArrayData {
        public PVArray[] data;
        public int offset;
    }
    interface PVArrayArray extends PVArray {
        int get(int offset, int len, ArrayArrayData data);
        int put(int offset, int len, PVArray[]from, int fromOffset);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }
    interface PVStructureArray extends PVArray {
        int get(int offset, int len, StructureArrayData data);
        int put(int offset, int len, PVStructure[]from, int fromOffset);
    }</pre>

<p>The interface for each array type has the same form except for the type.
For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects shold not expose their internal data but is done so
that copying between arrays with identical element types can be implemented
via a call to System.arraycopy without requiring an intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt><span style="font-family: courier">offset</span></dt>
    <dd>The offset in the PV array.</dd>
  <dt><span style="font-family: courier">len</span></dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt style="font-family: courier;">data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt><span style="font-family: courier">from</span></dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt><span style="font-family: courier">fromOffset</span></dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller can always accept or put partial arrays. For example
the following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>

<h3 id="FieldCreat">FieldCreate</h3>

<p>This is an interface for creating introspection objects that implement the
introspection interfaces. The methods are:</p>
<pre>    public interface FieldCreate {
        public Type getType(Map&lt;String,String&gt;attributes);
        public Type getElementType(Map&lt;String,String&gt; attributes);
        public Type getType(String value);

        public static FieldAttribute createFieldAttribute();
        public static FieldAttribute createFieldAttribute(
            Map&lt;String,String&gt; attributes);

        public static Property createProperty(String name, String fieldName);

        public static Field createField(String fieldName,Type type);
        public static Field createField(String fieldName,Type type,
            Property[] property,FieldAttribute fieldAttribute);

        public static Array createArrayField(String fieldName,Type elementType);
        public static Array createArrayField(String fieldName,Type elementType,
            Property[] property,FieldAttribute fieldAttribute);

        public static Enum createEnumField(String fieldName,boolean choicesMutable);
        public static Enum createEnumField(String fieldName,boolean choicesMutable,
            Property[] property,FieldAttribute fieldAttribute);

        public static Menu createMenuField(String fieldName,String menuName);
        public static Menu createMenuField(String fieldName,String menuName,
            Property[]property,FieldAttribute fieldAttribute);

        public static Structure createStructureField(String fieldName,
            String structureName, Field[] field);
        public static Structure createStructureField(String fieldName,
            String structureName, Field[] field,
            Property[] property,FieldAttribute fieldAttribute);
    }</pre>

<p>where</p>
<dl>
  <dt>getType(Map&lt;String,String&gt;attributes)</dt>
    <dd>Look for a map is expected to contain a key,value pair with key =
      "type". If found getType(value) is called an returned.</dd>
    <dd>Like getType except that the key must be "elementType"</dd>
  <dt>getType(String value)</dt>
    <dd>Looks for value to be one of the following: "boolean", "byte",
      "short", "int", "long", "float", "double", "string", "enum", "menu",
      "structure", "array",or "link". If found the Type associated with the
      value is returned. If not found a null is returned.</dd>
  <dt>createFieldAttribute()</dt>
    <dd>Create a default set of field attributes. The defaults are: asl = 1,
      default = null, isDesign = true, isLink = false, isReadOnly =
    false.</dd>
  <dt>createFieldAttribute(Map&lt;String,String&gt; attributes)</dt>
    <dd>Looks for keys that have the values: "default", "asl", "design",
      "link", or "readonly". If a key is found than the value determines the
      attribute value. And attributes not found are set the the default
    value.</dd>
  <dt>createProperty</dt>
    <dd>Create a property.</dd>
  <dt>createField(String fieldName,Type type)</dt>
    <dd>create a Field with the specified type, no properties, and default
      attributes. The type must be a scalar or a link.</dd>
  <dt>createField(String fieldName,Type type,<br />
  Property[] property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Field with the specified type, properties, and attributes.
      The type must be a scalar or a link.</dd>
  <dt>createArrayField(String fieldName,Type elementType)</dt>
    <dd>create an Array with the specified elementType, no properties, and
      default attributes. The elementType can be any Type but must not be
      null.</dd>
  <dt>createArrayField(String fieldName,Type elementType,<br />
  Property[] property,FieldAttribute fieldAttribute)</dt>
    <dd>create an Array with the specified elementType, properties, and
      attributes. The elementType can be any Type but must not be null.</dd>
  <dt>createEnumField(String fieldName,boolean choicesMutable)</dt>
    <dd>create an Enum with no properties and default attributes.</dd>
  <dt>createEnumField(String fieldName,boolean choicesMutable,<br />
  Property[] property,FieldAttribute fieldAttribute)</dt>
    <dd>create an Enum with properties and attributes.</dd>
  <dt>createMenuField(String fieldName,String menuName)</dt>
    <dd>create a Menu with no properties and default attributes.</dd>
  <dt>createMenuField(String fieldName,String menuName,<br />
  Property[]property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Menu with properties and attributes.</dd>
  <dt>createStructureField(String fieldName,<br />
  String structureName, Field[] field)</dt>
    <dd>create a Structure with no properties and default attributes. The
      structureName must not be null. It is permissible to have a Field[]
      with length 0.</dd>
  <dt>createStructureField(String fieldName,<br />
  String structureName, Field[] field,<br />
  Property[] property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Structure with properties and attributes. The structureName
      must not be null. It is permissible to have a Field[] with length
    0.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Base">Base Introspection Classes</h2>
<hr />

<p>This section describes base classes for implementimg Field objects , i.e.
introspection objects. For many applications they provide a complete
introspection implementation but they could be extended if necessary.</p>
<pre>    public class FieldBase implements Field {
        public FieldBase(String fieldName,
            Type type,Property[] property,FieldAttribute fieldAttribute);
        public static void newLine(StringBuilder builder, int indentLevel);
        public String getFieldName();
        public Property[] getPropertys();
        public Property getProperty(String propertyName);
        public FieldAttribute getFieldAttribute();
        public Type getType();
        public String getSupportName();
        public void setSupportName(String name);
        public boolean isMutable();
        public void setMutable(boolean value);
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class EnumBase extends FieldBase implements Enum{
        public EnumBase(String fieldName,boolean choicesMutable,
            Property[] property,FieldAttribute fieldAttribute);
        public boolean isChoicesMutable();
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class MenuBase extends FieldBase implements Menu{
        public MenuBase(String fieldName,String menuName,
            Property[] property,FieldAttribute fieldAttribute);
        public String getMenuName();
        public boolean isChoicesMutable();
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class StructureBase extends FieldBase implements Structure {
        public StructureBase(String fieldName,String structureName,Field[] field,
             Property[] property,FieldAttribute fieldAttribute);
        public Field getField(String name);
        public int getFieldIndex(String name);
        public String[] getFieldNames();
        public Field[] getFields();
        public String getStructureName();
        public String toString();
        public String toString(int indentLevel);
    }

    public class ArrayBase extends FieldBase implements Array {
        public ArrayBase(String fieldName,Type elementType,
            Property[] property,FieldAttribute fieldAttribute);
        public Type getElementType();
        public String toString();
        public String toString(int indentLevel);      
        private String getString(int indentLevel);
    }
}</pre>

<p>These classes are used to create instances of the reflection
interfaces.</p>
<hr />

<h2 style="text-align: center" id="AbstractPV">AbstractPVData</h2>
<hr />

<p>The following is an abstract base class for implementing PVData
interfaces:</p>
<pre>public abstract class AbstractPVData implements PVData{
    protected AbstractPVData(PVData parent, Field field);
    protected void replaceField(Field field);
    protected void setRecord(PVRecord record);
    protected static void newLine(StringBuilder builder, int indentLevel);
    public String getRequestorName();
    public void message(String message, MessageType messageType);
    public String getFullFieldName();
    public Field getField();
    public PVData getParent();
    public PVRecord getPVRecord();
    public String getSupportName();
    public String setSupportName(String name);
    public String toString(int indentLevel);
}</pre>

<p>where</p>
<dl>
  <dt>AbstractPVData</dt>
    <dd>The constructor which must be called by any derived class.</dd>
  <dt>replaceField</dt>
    <dd>This is called by a derived PVStructure implementation when it wants
      to change the introspection interface for one of it's fields. This is
      necessary because an IOC database allows the definition of a structure
      field to be defined during record initialization.</dd>
  <dt>setRecord</dt>
    <dd>This is called a derived PVStructure implementation to specify the
      record containing the field.</dd>
  <dt>newLine</dt>
    <dd>This is used by derived classes to implement toString</dd>
  <dt>getFullFieldName,...,getPVRecord</dt>
    <dd>The implementation should be sufficient for all derived classes.</dd>
  <dt>getSupportName and setSupportName</dt>
    <dd>With the exception of PVLink the implementation should be sufficient
      for all derived classes.</dd>
  <dt>toString</dt>
    <dd>Should be called by derived classes to add the supportName.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays with element type that are scalar and satisfy one
    of the following.
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVData pv, int indentLevel);
        String getString(PVData pv);
        void fromString(PVData pv,String from);
        int fromStringArray(PVData pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVData from, PVData to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVData pv);
        short toShort(PVData pv);
        int   toInt(PVData pv);
        long  toLong(PVData pv);
        float toFloat(PVData pv);
        double toDouble(PVData pv);
        void fromByte(PVData pv, byte from);
        void  fromShort(PVData pv, short from);
        void  fromInt(PVData pv, int from);
        void  fromLong(PVData pv, long from);
        void  fromFloat(PVData pv, float from);
        void  fromDouble(PVData pv, double from);
        // For the following the element type must be PVByte, ...., PVDouble
        int toByteArray(PVData pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVData pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVData pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVData pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVData pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVData pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVData pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVData pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVData pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVData pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVData pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVData pv,
            int offset, int len, double[]from, fromOffset);
    }</pre>
The array methods all return the number of elements copied or converted. This
can be less than <span style="font-family: courier;">len</span> if the PVData
array contains less than len elements.
<hr />

<h2 style="text-align: center" id="Field">Field Factory</h2>
<hr />

<p>The field factory creates objects for each on the interspection
interfaces. It has the following public methods:</p>
<pre>public final class FieldFactory {
    public static FieldCreate getFieldCreate();
}</pre>
<hr />

<h2 style="text-align: center" id="Convert1">Convert Factory</h2>
<hr />

<p>The convert factory provides an implementation of the <span
style="font-family: courier;">Convert</span> interface.</p>
<pre>    public final class ConvertFactory {
        public static Convert getConvert();
    }</pre>

<p>It provides a single implementation which is returned by getConvert.</p>
</body>
</html>
