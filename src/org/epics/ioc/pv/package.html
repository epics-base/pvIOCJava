<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: pv<br />
package: org.epics.ioc.pv<br />
2006.12.21</h1>
<hr />

<h2 style="text-align: center">Overview</h2>
<hr />
<p>Process Variable (PV) Data supports any data consisting of the following
types:</p>
<dl>
  <dt>primitive</dt>
    <dd>All Java primitive types except char, i.e. boolean, byte, short, int,
      float, and double.</dd>
  <dt>string</dt>
    <dd>A Java String.</dd>
  <dt>enum</dt>
    <dd>A enum is an array of choices and an index that selects a choice.</dd>
  <dt>menu</dt>
    <dd>Like an enum except that it has a menuName and the array
     of choices can not be modified.</dd>
  <dt>structure</dt>
    <dd>A structure has a name and contains an arbitrary number of fields of
      an supported type</dd>
  <dt>array</dt>
    <dd>A one dimensional array. The element type is any of the supported
      types</dd>
   <dt>link</dt>
    <dd>A link has no data but can have support and an associated
     structure of configuration information.</dd>
</dl>

<p>In addition to the Java IOC, PV data is intended for use by 1) Channel
Access client, 2) interface from client to network, e.g. ICE, 3) interface
from network to Channel Access server, 4) interface from server to IOC
database. Since it is the interface to data, it could also be used by other
systems, e.g. TANGO, TINI, DOOCS, etc.</p>

<p>This package provides the following:</p>
<dl>
  <dt>Type</dt>
    <dd>An enum that describes the valid types.</dd>
  <dt>Reflection Interfaces</dt>
    <dd>These are interfaces that describe a PV. They are designed so that
      characteristics of a PV can be discovered without requiring access to
      the data associated with it.</dd>
  <dt>Data Interfaces</dt>
    <dd>These are interfaces for accessing the data associated with a PV.</dd>
  <dt>Conversion Facility</dt>
    <dd>Conversion of the data from any PV to a string is provided.</dd>
    <dd>Conversion from a string to any scalar or array of srings to an array
      of scaler types is supported.</dd>
    <dd>Conversion between a PV and numeric primitive types is supported. The
      PV must contain scalar numeric type.</dd>
    <dd>Conversion between a PV and an array of numeric primitive types is
      supported. The PV must contain an array of a numeric type.</dd>
    <dd>Copy, with conversion if the types differ, between compatible scalar
      PVs.</dd>
    <dd>Copy, with conversion if the element types differ, between compatible
      arrays of PVs.</dd>
  <dt>Field Factory</dt>
    <dd>This is an object factory that creates objects implementing the
      reflection interfaces.</dd>
  <dt>Abstract Field Classes</dt>
    <dd>Abstract base classes for implementing Field objects.</dd>
  <dt>Convert Factory</dt>
    <dd>An object factory that provides an implementation of the conversion
      facility.</dd>
</dl>

<p>This package does not provide any facilities to create objects that
implement the Data Interfaces. This is the responsibility of a particular
implementation. For a javaIOC, db provides an implementation.</p>

<h3>Process Variable</h3>

<p>Definitions:</p>
<dl>
  <dt>Processs Variable (PV)</dt>
    <dd>The name used to specify the type of data this package supports.</dd>
  <dt>Field</dt>
    <dd>A Field has a name and a type that is any of the supported types. It
      can also have properties.</dd>
  <dt>Property</dt>
    <dd>A property has a name and an associated field within the PV for the
      data.</dd>
</dl>

<p>Examples of fields are: value, rawValue. Examples of properties are:
status, timeStamp, alarmSeverity, displayLimits, controlLimits,
alarmLimits</p>

<p>For example a PV could define properties for value and rawValue as
follows:</p>
<dl>
  <dt>value</dt>
    <dd>status, timeStamp, alarmSeverity, displayLimits, controlLimits, and
      alarmLimits.</dd>
  <dt>rawValue</dt>
    <dd>status, timeStamp, and alarmSeverity.</dd>
</dl>

<h3>Process Variable Data Types</h3>

<p>The following types are supported:</p>
<dl>
  <dt>primitive</dt>
    <dd><dl>
        <dt>byte</dt>
          <dd>An 8 bit signed byte</dd>
        <dt>boolean</dt>
          <dd>true or false</dd>
        <dt>short</dt>
          <dd>16 bit signed integer</dd>
        <dt>int</dt>
          <dd>32 bit signed integer</dd>
        <dt>long</dt>
          <dd>64 bit signed integer</dd>
        <dt>float</dt>
          <dd>32 bit IEEE float</dd>
        <dt>double</dt>
          <dd>64 bit IEEE float</dd>
      </dl>
    </dd>
  <dt>string</dt>
    <dd>A Java String</dd>
  <dt>enum</dt>
    <dd>a String array of choices and an index selecting a choice.</dd>
  <dt>menu</dt>
    <dd>An enum with a menuName and immutable choices.</dd>
   <dt>link</dt>
     <dd>No data is associated with a link but each support
     can define a structure that contains configuration information.</dd>
  <dt>structure</dt>
    <dd>A struture with fields of type primitive, string, enum, menu,
        structure, or array</dd>
  <dt>array</dt>
    <dd>a one dimensional array of type primitive, string,enum, structure, or
      array</dd>
</dl>

<h3>Process Variable Reflection</h3>

<p>Given a PV it is possible to introspect its fields. The reflection
interface does not provide access to data. Other interfaces, e.g. Channel
Access provide access to the data. The reason is that the data may not be
available. For example when a client connects to a PV, the client library can
obtain the reflection information without obtaining any data. Only when a
client issues an I/O request will data be available. This separation is
especially important for arrays and structures.</p>
<hr />

<h2 style="text-align: center">Type</h2>
<hr />

<p>The types are defined by:</p>
<pre>    enum Type {
        pvUnknown,
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray,
        pvMenu,
        pvLink;

        //Convenience methods
        boolean isNumeric();
        boolean isPrimitive();
        boolean isScalar();
    }</pre>
<hr />

<h2 style="text-align: center">Reflection</h2>
<hr />

<p>The following provide reflection.</p>
<pre>
    interface Property {
        String getName(); // Property name
        String getFieldName(); // name of the field that has the property data
        String toString();
        String toString(int indentLevel);
    }

    public interface FieldAttribute {
        String getDefault();
        boolean isReadOnly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        String toString(int indentLevel);
    }


    interface Field{
        String getName();
        Field getParent();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        String toString();
        String toString(int indentLevel);
        FieldAttribute getFieldAttribute();
    } 

    interface Enum extends Field {
        boolean isChoicesMutable();
    }

    interface Menu extends Enum {
        String getMenuName();
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
        Structure copy();
        boolean replaceField(String name,Field field);
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<p>The above definitions support the following:</p>
<ul>
  <li>Field
    <ul>
      <li>A field has a name.</li>
      <li>A field can have a parent. In particular each field of a structure
        has the structure as it's parent.</li>
      <li>A field has a Type.</li>
      <li>A field can have an arbitrary number of associated properties
        including none.</li>
      <li>A field can optionally have support identified via a name.</li>
      <li>A field can be made immutable. This means that the data associated
        with the field is immutable.</li>
      <li>A field can be converted to a string.</li>
    </ul>
  </li>
  <li>Property
    <ul>
      <li>A property has a name.</li>
      <li>A property has a an associated field that holds the data.</li>
      <li>A property can be converted to a string.</li>
    </ul>
  </li>
  <li>Structure
    <ul>
      <li>Has a name.</li>
      <li>Has fields that can be any of the supported types.</li>
    </ul>
    <p>NOTE: An implementation may defer the definition of a structure until
    a field instance is being created.</p>
    <ol>
      <li>getStructureName, and getField both returns null</li>
      <li>getFieldNames and getFields return a 0 length array</li>
      <li>getFieldIndex returns a value less than 0.</li>
    </ol>
  </li>
  <li>Array - The array has elements of any of the supported types.</li>
</ul>
<hr />

<h2 style="text-align: center">DataAccess</h2>
<hr />

<p>The following is the base interface for accessing data.</p>
<pre>    interface PVData {
        String getFullFieldName();
        void message(String message, MessageType messageType);
        Field getField();
        PVData getParent();
        String getSupportName();
        String setSupportName(String name);
        String toString();
        String toString(int indentLevel);
    }</pre>
where
<ul>
  <li>getField
    <p>Returns the reflection interface for the data</p>
  </li>
  <li>getSupportName
    <p>Get the name of the support for this PV.</p>
  </li>
  <li>setSupportName
    <p>Set the name of the support for this field.</p>
  </li>
  <li>toString
    <p>Converts the field data to a string. This is mostly for debugging
    purposes.</p>
  </li>
</ul>

<p>Packages db and process allow custom support code for any field of any
record instance of an IOC database. In order to allow the support code to be
changed via Channel Access pv provides the methods getSupportName,
setSupportName, and getConfiguration Structure. If a client has permission to
change the support the procedure is:</p>
<ul>
  <li>Call setSupportName</li>
  <li>Call getSupportName. If the new name is what the client specified then
    the client knows that it has successfully changed the support for the
    field.</li>
  <li>Call getConfigurationStructure. If a null is returned it means that the
    support does not require any configuration. If access to a configuration
    structure is returned the client can use it to provide the configuration
    information.</li>
</ul>

<h3>Primitive Types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVData {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVData {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVData {
        short get();
        void put(short value);
    }

    interface PVInt extends PVData {
        int get();
        void put(int value);
    }

    interface PVLong extends PVData {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVData {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVData {
        double get();
        void put(double value);
    }</pre>

<h3>String</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVData {
        String get();
        void put(String value);
    }</pre>

<h3>Enum</h3>

<p>The interface for enum is:</p>
<pre>    interface PVEnum extends PVData{
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }</pre>
<h3>Menu</h3>
<p>The interface for a menu is:</p>
<pre>
    interface PVMenu extends PVEnum {}
</pre>
<h3>Menu</h3>
<p>The interface for a link is:</p>
<pre>
    interface PVLink extends PVData {
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }
</pre>

<h3>Structure</h3>

<p>The interface for structure is:</p>
<pre>    interface PVStructure extends PVData {
        PVData[] getFieldPVDatas();
        boolean replaceField(String fieldName,PVData pvData);
        void beginPut();
        void endPut();
    }</pre>

<h3>Array</h3>

<p>The interfaces for array are:</p>
<pre>    interface PVArray extends PVData {
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
    }

    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
    }

    public class EnumArrayData {
        public PVEnum[] data;
        public int offset;
    }
    interface PVEnumArray extends PVArray {
        int get(int offset, int len, EnumArrayData data);
        int put(int offset, int len, PVEnum[]from, int fromOffset);
    }

    public class MenuArrayData {
        public PVMenu[] data;
        public int offset;
    }
    interface PVMenuArray extends PVArray {
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, PVMenu[]from, int fromOffset);
    }

    public class LinkArrayData {
        public PVLink[] data;
        public int offset;
    }
    interface PVLinkArray extends PVArray {
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, PVLink[]from, int fromOffset);
    }

    public class ArrayArrayData {
        public PVArray[] data;
        public int offset;
    }
    interface PVArrayArray extends PVArray {
        int get(int offset, int len, ArrayArrayData data);
        int put(int offset, int len, PVArray[]from, int fromOffset);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }
    interface PVStructureArray extends PVArray {
        int get(int offset, int len, StructureArrayData data);
        int put(int offset, int len, PVStructure[]from, int fromOffset);
    }</pre>

<p>The interface for each array type has the same form except for the type.
For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects shold not expose their internal data but is done so
that copying between arrays with identical element types can be implemented
via a call to System.arraycopy without requiring an intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt><span style="font-family: courier">offset</span></dt>
    <dd>The offset in the PV array.</dd>
  <dt><span style="font-family: courier">len</span></dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt style="font-family: courier;">data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt><span style="font-family: courier">from</span></dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt><span style="font-family: courier">fromOffset</span></dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller can always accept or put partial arrays. For example
the following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>
<hr />

<h2 style="text-align: center">Abstract Field Classes</h2>
<hr />

<p>The following are base classes for implementimg Field objects:</p>
<pre>    public class AbstractField implements Field {
        public AbstractField(String name, Type type,Property[] property);
        public static void newLine(StringBuilder builder, int indentLevel);
        public String getName();
        public Field getParent();
        protected void setParent(Field field);
        public Property[] getPropertys();
        public Property getProperty(String propertyName);
        public Type getType();
        public String getSupportName();
        public void setSupportName(String name);
        public boolean isMutable();
        public void setMutable(boolean value);
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class AbstractEnum extends AbstractField implements Enum{
        public AbstractEnum(String name,Property[] property,boolean choicesMutable);
        public boolean isChoicesMutable();
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class AbstractStructure extends AbstractField implements Structure {
        public AbstractStructure(String name,Property[] property,
             String structureName,Field[] field);
        public Field getField(String name);
        public int getFieldIndex(String name);
        public String[] getFieldNames();
        public Field[] getFields();
        public String getStructureName();
        public String toString();
        public String toString(int indentLevel);
    }

    public class AbstractArray extends AbstractField implements Array {
        public AbstractArray(String name, Property[] property,Type elementType);
        public Type getElementType();
        public String toString();
        public String toString(int indentLevel);      
        private String getString(int indentLevel);
    }
}</pre>

<p>These classes are used by FieldFactory, described below, to create
instances of the reflection onterfaces.</p>
<hr />

<h2 style="text-align: center">Convert</h2>
<hr />

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs
    <ul>
      <li>PVBoolean to PVBoolean or PVString</li>
      <li>PVString to any scalar type</li>
      <li>Numeric type to another numeric type</li>
      <li>Other scalar types To PVString</li>
    </ul>
  </li>
  <li>Copy between PVArrays with the following element types
    <ul>
      <li>Numeric to numeric</li>
      <li>The types are identical including types pvUnknown, pvArray, and
        pvStructure</li>
      <li>Any type to pvString</li>
      <li>pvString to any scalar type.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
</ul>
<pre>    interface Convert {
        String getString(PVData pv, int indentLevel);
        String getString(PVData pv);
        void fromString(PVData pv,String from);
        int fromStringArray(PVData pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVData from, PVData to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVData pv);
        short toShort(PVData pv);
        int   toInt(PVData pv);
        long  toLong(PVData pv);
        float toFloat(PVData pv);
        double toDouble(PVData pv);
        void fromByte(PVData pv, byte from);
        void  fromShort(PVData pv, short from);
        void  fromInt(PVData pv, int from);
        void  fromLong(PVData pv, long from);
        void  fromFloat(PVData pv, float from);
        void  fromDouble(PVData pv, double from);
        // For the following the element type must be PVByte, ...., PVDouble
        int toByteArray(PVData pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVData pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVData pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVData pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVData pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVData pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVData pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVData pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVData pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVData pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVData pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVData pv,
            int offset, int len, double[]from, fromOffset);
    }</pre>
The array methods all return the number of elements copied or converted. This
can be less than <span style="font-family: courier;">len</span> if the PVData
array contains less than len elements.
<hr />

<h2 style="text-align: center">Field Factory</h2>
<hr />

<p>The field factory creates objects for each on the interspection
interfaces. It has the following public methods:</p>
<pre>public final class FieldFactory {
    public static Property createProperty(String name, String fieldName);

    public static Field createField(String name,
        Type type,Property[] property);

    public static Enum createEnumField(String name,
        boolean choicesMutable,Property[] property);

    public static Array createArrayField(String name,
        Type elementType,Property[] property);
 
    public static Structure createStructureField(String name,
        String structureName, Field[] field,Property[] property);
}</pre>
<hr />

<h2 style="text-align: center">Convert Factory</h2>
<hr />

<p>The convert factory provides an implementation of the <span
style="font-family: courier;">Convert</span> interface.</p>
<pre>    public final class ConvertFactory {
        public static Convert getConvert();
    }</pre>

<p>It provides a single implementation no matter how many times getConvert is
called.</p>
</body>
</html>
