<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: pv<br />
package: org.epics.ioc.pv<br />
2007.02.27</h1>
CONTENTS
<hr />

<h2 style="text-align: center">Overview</h2>
<hr />

<p>A Process Variable (PV) Database is a "smart" database because it has
records together with support code:</p>
<ul>
  <li>Each record has a unique record name.</li>
  <li>A record is a data structure, i.e. a set of fields holding data.</li>
  <li>Each record has associated record support.</li>
  <li>Each field can optionally have associated support.</li>
</ul>

<p>PVField, which is an interface for accessing the data residing in a field
of a database record, has one of the following types:</p>
<dl>
  <dt>primitive</dt>
    <dd>All Java primitive types except char, i.e. boolean, byte, short, int,
      float, and double.</dd>
  <dt>string</dt>
    <dd>A Java String. Primitive and string types are considered scalar
    types.</dd>
  <dt>enum</dt>
    <dd>A enum is an array of choices and an index that selects a choice.</dd>
  <dt>menu</dt>
    <dd>Like an enum except that it has a menuName and the array of choices
      is immutable.</dd>
  <dt>structure</dt>
    <dd>A structure has a name and contains an array of fields of any
      supported type.</dd>
  <dt>array</dt>
    <dd>A one dimensional array. The element type is any of the supported
      types.</dd>
  <dt>link</dt>
    <dd>A link has no data but can have support and a configuration
    structure.</dd>
</dl>

<p>In addition to the Java IOC, PV data is intended for use by 1) Channel
Access client, 2) interface from client to network, 3) interface from network
to Channel Access server, 4) interface from server to IOC database. Since it
is the interface to data, it could also be used by other systems, e.g. TANGO,
TINI, DOOCS, etc.</p>

<p>This package provides the following:</p>
<dl>
  <dt>Type</dt>
    <dd>An enum that describes the valid types.</dd>
  <dt>Reflection Interfaces</dt>
    <dd>Interfaces that describe a PV. Characteristics of a PV can be
      discovered without requiring access to the data associated with it.</dd>
  <dt>Data Interfaces</dt>
    <dd>Interfaces for accessing the data associated with a PV.</dd>
  <dt>Conversion Facility</dt>
    <dd>Conversion of the data from any PV to a string is provided.</dd>
    <dd>Conversion from a string to a scalar or array of srings to an array
      of scaler types is supported.</dd>
    <dd>Conversion between a PV and numeric primitive types is supported. The
      PV must contain scalar numeric type.</dd>
    <dd>Conversion between a PV and an array of numeric primitive types is
      supported. The PV must contain an array of a numeric type.</dd>
    <dd>Copy, with conversion if the types differ, between compatible scalar
      PVs.</dd>
    <dd>Copy, with conversion if the element types differ, between compatible
      arrays of PVs.</dd>
    <dd>Copy between compatable structures.</dd>
  <dt>Field and PVField Factories</dt>
    <dd>An object factory that creates objects implementing the reflection
      interfaces and an object factory for implementing PVField
    interfaces.</dd>
  <dt>Base Field Classes</dt>
    <dd>Base classes for implementing Field objects.</dd>
  <dt>Abstract and Base Classes for creating PVField objects.</dt>
    <dd>An abstract base class for creating PVField implementations.</dd>
  <dt>Convert Factory</dt>
    <dd>An object factory that provides an implementation of the conversion
      facility.</dd>
  <dt>PVAccess</dt>
    <dd>An interface for locating fields within a record instance.</dd>
</dl>

<h3>Process Variable</h3>

<p>Definitions:</p>
<dl>
  <dt>Processs Variable (PV)</dt>
    <dd>The name used to specify the data this package supports.</dd>
  <dt>Field</dt>
    <dd>A Field has a name and a type that is any of the supported types. It
      has attributes and can also have properties.</dd>
  <dt>Property</dt>
    <dd>A property has a name and an associated field within the PV for the
      data.</dd>
  <dt>Attribute</dt>
    <dd>Each field has a fixed set of attributes: default, isReadOnly,
      isDesign, isLink, asl.</dd>
</dl>

<p>Examples of fields are: value, rawValue.</p>

<p>Examples of properties are: status, timeStamp, alarmSeverity,
displayLimits, controlLimits, alarmLimits</p>

<p>For example a PV could define properties for value and rawValue as
follows:</p>
<dl>
  <dt>value</dt>
    <dd>status, timeStamp, alarmSeverity, displayLimits, controlLimits, and
      alarmLimits.</dd>
  <dt>rawValue</dt>
    <dd>status, timeStamp, and alarmSeverity.</dd>
</dl>

<p>The associatedField of a property is is used to locate a field that has
the value for the property. Examples are given later in this document. An
associatedField must be one of the following:</p>
<dl>
  <dt>/name</dt>
    <dd>If the associatedField value starts with '/' then the search will
      start at the record not with the field that has the property.</dd>
  <dt>name</dt>
    <dd>The name of a structure field.</dd>
  <dt>name1.name2</dt>
    <dd>name1 must be the name of a structure field. name2 must be a property
      or field in the structure field.</dd>
</dl>

<p>Properties can also be used to create "device" abstractions. For example a
powerSupply record type can be created that has properties like "current",
"voltage", and "power".</p>

<h3>Process Variable Data Types</h3>

<p>The following types are supported:</p>
<dl>
  <dt>primitive</dt>
    <dd><dl>
        <dt>byte</dt>
          <dd>An 8 bit signed byte</dd>
        <dt>boolean</dt>
          <dd>true or false</dd>
        <dt>short</dt>
          <dd>16 bit signed integer</dd>
        <dt>int</dt>
          <dd>32 bit signed integer</dd>
        <dt>long</dt>
          <dd>64 bit signed integer</dd>
        <dt>float</dt>
          <dd>32 bit IEEE float</dd>
        <dt>double</dt>
          <dd>64 bit IEEE float</dd>
      </dl>
    </dd>
  <dt>string</dt>
    <dd>A Java String</dd>
  <dt>enum</dt>
    <dd>A String array of choices and an index selecting a choice.</dd>
  <dt>menu</dt>
    <dd>An enum with a menuName and immutable choices.</dd>
  <dt>link</dt>
    <dd>No data is associated with a link but each support can define a
      structure that contains configuration information.</dd>
  <dt>structure</dt>
    <dd>A struture with fields of type primitive, string, enum, menu,
      structure, or array</dd>
  <dt>array</dt>
    <dd>a one dimensional array of type primitive, string,enum, structure, or
      array</dd>
</dl>

<h3>Process Variable Reflection</h3>

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field. The reflection interface does not provide
access to data. The PVField and derived PV interfaces provide access to the
data. The reflection and data interfaces are separate because the data may
not be available. For example when a client connects to a PV, the client
library can obtain the reflection information without obtaining any data.
Only when a client issues an I/O request will data be available. This
separation is especially important for arrays and structures.</p>
<hr />

<h2 style="text-align: center">Type</h2>
<hr />

<p>The types are defined by:</p>
<pre>    enum Type {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray,
        pvMenu,
        pvLink;

        //Convenience methods
        boolean isNumeric();    // pvByte,...pvDouble
        boolean isPrimitive();  // pvBoolean,...pvDouble
        boolean isScalar();     //pvBoolean,...pvString
    }</pre>

<p>Note that a string is a scalar.</p>
<hr />

<h2 style="text-align: center">Reflection</h2>
<hr />

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    interface Property {
        String getPropertyName();
        String getAssociatedFieldName();
        String toString();
        String toString(int indentLevel);
    }

    public interface FieldAttribute {
        String getDefault();
        boolean isReadOnly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    } 

    interface Enum extends Field {
        boolean isChoicesMutable();
    }

    interface Menu extends Enum {
        String getMenuName();
        String[] getMenuChoices();
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<p>The above definitions support the following:</p>
<ul>
  <li>Property
    <ul>
      <li>A property has a name.</li>
      <li>A property has an associated field that holds the data. The
        associated field must be one of the following:
        <dl>
          <dt>name</dt>
            <dd>If the field is a structure and name is a subfield of the
              structure than it is the associated field. If field is not a
              structure but name is a subfield of the parent structure it is
              the associated field.</dd>
          <dt>name1.name2</dt>
            <dd>name1 is located just like name above. The meaning for name2
              depends of the type of name 1. If name1 is a structure than
              name2 must be a subfield of name1. If name 1 is a link than the
              following is done: The link is assumed to have a configuration
              structure that has a field with a "isLink" attribute (call this
              field pvname). The pvname is the name of a field in another
              record. In the other record the field located by pvname acts
              just like name1 and name2 is handled just like it is for the
              local record.</dd>
          <dt>/name</dt>
            <dd>name must be a subfield of the record instance.</dd>
          <dt>/name1.name2</dt>
            <dd>This is like name1.name2 except that the search is relative
              to the record instance itself instead if the field that has the
              property.</dd>
        </dl>
      </li>
      <li>A property can be converted to a string.</li>
      <li>Properties can be used for two purposes:
        <ol>
          <li>Reference other fields related to a field. For example the
            "value" field of many record types will have properties with
            names "status", "severity", and "timeStamp".</li>
          <li>"device" abstractions. For example a powerSupply record would
            define properties "current", "voltage", and "Power".</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>FieldAttribute<br />
    Each field has the following attributes:
    <ul>
      <li>default<br />
        A string default value, which can be null.</li>
      <li>readOnly<br />
        Can the data value be changed?</li>
      <li>isDesign<br />
        Can this field be configurable by Database Configuration Tools.</li>
      <li>isLink<br />
        Is this field a link to another record. The field type must be
      string.</li>
      <li>asl<br />
        Access security level. Currently access security is not
      implemented.</li>
    </ul>
  </li>
  <li>Field
    <ul>
      <li>A field has a name.</li>
      <li>A field can have an arbitrary number of associated properties
        including none.</li>
      <li>A field has a Type.</li>
      <li>A field can optionally have support identified via a name.</li>
      <li>A field can be made immutable. This means that the data associated
        with the field is immutable.</li>
      <li>A field has attributes.</li>
      <li>A field can be converted to a string.</li>
    </ul>
  </li>
  <li>Enum
    <ul>
      <li>A enum is a field that can have mutable or immutable choices.</li>
    </ul>
  </li>
  <li>Menu
    <ul>
      <li>A menu is an enum that has immutable choices and also has a
        menuName.</li>
    </ul>
  </li>
  <li>Structure
    <ul>
      <li>Has a name.</li>
      <li>Has fields that can be any of the supported types.</li>
    </ul>
  </li>
  <li>Array - The array has elements of any of the supported types.</li>
</ul>
<hr />

<h2 style="text-align: center">PVField Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing fields within a PV
record.</p>

<h3>PVField</h3>

<p>The following is the base interface for accessing data.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requestor {
        String getRequestorName();
        void message(String message, MessageType messageType);
    }

    interface PVField extends Requestor {
        String getFullFieldName();
        Field getField();
        PVField getParent();
        PVRecord getPVRecord();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        String toString();
        String toString(int indentLevel);
    }</pre>
where
<ul>
  <li>MessageType<br />
    This is defined in org.epics.ioc.util.</li>
  <li>Requestor<br />
    Requestor is also defined in org.epics.ioc.util. For an IOC database the
    methods are implemented as follows:
    <ul>
      <li>getRequestorName<br />
        This is the full field name concatenated to the record name.</li>
      <li>message<br />

        <ul>
          <li>PVField prepends the full field name to the message and calls
            PVRecord.message. Note that this means that the PVRecord
            implementation must also implement message.</li>
          <li>PVRecord prepends the record name and passes the message to
            IOCDB.message.</li>
          <li>For now IOCDB just calls System.out. It will be extended to
            support a general purpose message handling facility.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>getFullFieldName<br />
    Get the full field name. This returns a name in the form
  ".name.name".</li>
  <li>getField<br />
    Get the reflection interface for the data.</li>
  <li>getParent<br />
    Get the interface for the parent or null if this is the PVRecord
  itself.</li>
  <li>getPVRecord<br />
    Get the interface for the record that contains this field.</li>
  <li>replacePVField<br />
    Replace this PVField. This is called by support code that wants to replace
    the default implementation of a data field with it;s own implementation.
    The new PVField must have the same Type as the oroginal field.</li>
  <li>getSupportName<br />
    Get the name of the support for this PV.</li>
  <li>setSupportName<br />
    Set the name of the support for this field. The supportName methods are
    available so that support can be changed remotely. For an IOC database
    only PVLink fields allow the support to be modified after record
    initialization.</li>
  <li>toString<br />
    Converts the field data to a string. This is mostly for debugging
    purposes.</li>
</ul>

<h3>Primitive PVField types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVField {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVField {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVField {
        short get();
        void put(short value);
    }

    interface PVInt extends PVField {
        int get();
        void put(int value);
    }

    interface PVLong extends PVField {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVField {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVField {
        double get();
        void put(double value);
    }</pre>

<h3>PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVField {
        String get();
        void put(String value);
    }</pre>

<h3>PVEnum</h3>

<p>The interface for enum is:</p>
<pre>    interface PVEnum extends PVField{
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }</pre>

<p>where</p>
<dl>
  <dt>getIndex</dt>
    <dd>Get the index of the currently selected choice.</dd>
  <dt>setIndex</dt>
    <dd>Select a choice</dd>
  <dt>setChoices</dt>
    <dd>Change the set of choices. This returns false if the choices can not
      be changed</dd>
</dl>

<h3>PVMenu</h3>

<p>The interface for a menu is:</p>
<pre>    interface PVMenu extends PVEnum {}</pre>

<p>The difference from an enum is that the reflection interface provides a
menuName and the choices can not be modified.</p>

<h3>PVLink</h3>

<p>The interface for a link is:</p>
<pre>    interface PVLink extends PVField {
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }</pre>

<p>Packages db and process allow custom support code for any field of any
record instance of an IOC database. A PVLink field can also have an
associated structure that contains configuration information.. A Channel
Access client can change the support for a PVLink field as follows. This
assumes that the client has permission to change the support:</p>
<ul>
  <li>Call setSupportName</li>
  <li>Call getSupportName. If the new name is what the client specified then
    the client knows that it has successfully changed the support for the
    field.</li>
  <li>Call getConfigurationStructure. If a null is returned it means that the
    support does not require any configuration. If access to a configuration
    structure is returned the client can use it to provide the configuration
    information.</li>
  <li>Call setConfigurationStructure to set the new configuration.</li>
</ul>

<h3>PVStructure</h3>

<p>The interface for structure is:</p>
<pre>    interface PVStructure extends PVField {
        PVField[] getFieldPVFields();
        boolean replaceStructureField(String fieldName,String structureName)
        void beginPut();
        void endPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getFieldPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>replaceStructureField</dt>
    <dd>Replace a subfield. The implementation must know how to find a
      reflection interface for structureName and how to create a PVStructure
      for the subfield. In addition it must create a new Structure reflection
      interface for itself.</dd>
  <dt>beginPut endPut</dt>
    <dd>Code that puts to multiple fields of a structure should call beginPut
      before the first put and endPut after the last put.</dd>
</dl>

<h3>PVRecord</h3>

<p>Each PVField is a field within a PVRecord:</p>
<pre>    interface PVRecord extends PVStructure
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequestor(Requestor requestor);
        void removeRequestor(Requestor requestor);
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This will be called any code that has access to the record instance.
      The implementation should prepend the record name to the message and
      then call a more generic message handler. For example package
      org.epics.ioc.db calls iocdb.message.</dd>
  <dt>addRequestor</dt>
    <dd>Add a requestor to receive messages.</dd>
  <dt>removeRequestor</dt>
    <dd>Remove a message requestor</dd>
</dl>

<h3>PVArray</h3>

<p>PROBLEM: If the capacity is mutable then there is no maximum capacity. A
channel access client could disable an ioc by sending very large arrays.
Perhaps PVArray should have two additional methods: setMaxCapacity and
getMaxCapacity. setMaxCapacity can have tight access security.</p>

<p>The interfaces for array are:</p>
<pre>    interface PVArray extends PVField {
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
    }

    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
    }

    public class EnumArrayData {
        public PVEnum[] data;
        public int offset;
    }
    interface PVEnumArray extends PVArray {
        int get(int offset, int len, EnumArrayData data);
        int put(int offset, int len, PVEnum[]from, int fromOffset);
    }

    public class MenuArrayData {
        public PVMenu[] data;
        public int offset;
    }
    interface PVMenuArray extends PVArray {
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, PVMenu[]from, int fromOffset);
    }

    public class LinkArrayData {
        public PVLink[] data;
        public int offset;
    }
    interface PVLinkArray extends PVArray {
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, PVLink[]from, int fromOffset);
    }

    public class ArrayArrayData {
        public PVArray[] data;
        public int offset;
    }
    interface PVArrayArray extends PVArray {
        int get(int offset, int len, ArrayArrayData data);
        int put(int offset, int len, PVArray[]from, int fromOffset);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }
    interface PVStructureArray extends PVArray {
        int get(int offset, int len, StructureArrayData data);
        int put(int offset, int len, PVStructure[]from, int fromOffset);
    }</pre>

<p>The interface for each array type has the same form except for the type.
For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects shold not expose their internal data but is done so
that copying between arrays with identical element types can be implemented
via a call to System.arraycopy without requiring an intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt><span style="font-family: courier">offset</span></dt>
    <dd>The offset in the PV array.</dd>
  <dt><span style="font-family: courier">len</span></dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt style="font-family: courier;">data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt><span style="font-family: courier">from</span></dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt><span style="font-family: courier">fromOffset</span></dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller can always accept or put partial arrays. For example
the following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>
<hr />

<h2 style="text-align: center">Field and PVField creation</h2>
<hr />

<p>Interfaces and factories are provided to create Introspection and PVField
instances.</p>

<h3>FieldCreate</h3>

<p>This is an interface for creating introspection objects that implement the
introspection interfaces. The methods are:</p>
<pre>    public interface FieldCreate {
        public Type getType(Map&lt;String,String&gt;attributes);
        public Type getElementType(Map&lt;String,String&gt; attributes);
        public Type getType(String value);

        public static FieldAttribute createFieldAttribute();
        public static FieldAttribute createFieldAttribute(
            Map&lt;String,String&gt; attributes);

        public static Property createProperty(String name, String fieldName);

        public static Field createField(String fieldName,Type type);
        public static Field createField(String fieldName,Type type,
            Property[] property,FieldAttribute fieldAttribute);

        public static Array createArray(String fieldName,Type elementType);
        public static Array createArray(String fieldName,Type elementType,
            Property[] property,FieldAttribute fieldAttribute);

        public static Enum createEnum(String fieldName,boolean choicesMutable);
        public static Enum createEnum(String fieldName,boolean choicesMutable,
            Property[] property,FieldAttribute fieldAttribute);

        public static Menu createMenu(String fieldName,String menuName,String[] menuChoices);
        public static Menu createMenu(String fieldName,String menuName,String[] menuChoices,
            Property[]property,FieldAttribute fieldAttribute);

        public static Structure createStructure(String fieldName,
            String structureName, Field[] field);
        public static Structure createStructure(String fieldName,
            String structureName, Field[] field,
            Property[] property,FieldAttribute fieldAttribute);
    }

    public final class FieldFactory {
        public static FieldCreate getFieldCreate();
    }</pre>

<p>where</p>
<dl>
  <dt>getType(Map&lt;String,String&gt;attributes)</dt>
    <dd>Map is expected to contain a key,value pair with key = "type". If
      found getType(value) is called and returned.</dd>
  <dt>getElementType(Map&lt;String,String&gt;attributes)</dt>
    <dd>Like getType except that the key must be "elementType"</dd>
  <dt>getType(String value)</dt>
    <dd>Looks for value to be one of the following: "boolean", "byte",
      "short", "int", "long", "float", "double", "string", "enum", "menu",
      "structure", "array",or "link". If found the Type associated with the
      value is returned. If not found a null is returned.</dd>
  <dt>createFieldAttribute()</dt>
    <dd>Create a default set of field attributes. The defaults are: asl = 1,
      default = null, isDesign = true, isLink = false, isReadOnly =
    false.</dd>
  <dt>createFieldAttribute(Map&lt;String,String&gt; attributes)</dt>
    <dd>Looks for keys that have the values: "default", "asl", "design",
      "link", or "readonly". If a key is found than the value determines the
      attribute value. And attributes not found are set the the default
    value.</dd>
  <dt>createProperty</dt>
    <dd>Create a property.</dd>
  <dt>createField(String fieldName,Type type)</dt>
    <dd>create a Field with the specified type, no properties, and default
      attributes. The type must be a scalar or a link.</dd>
  <dt>createField(String fieldName,Type type,Property[]
  property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Field with the specified type, properties, and attributes.
      The type must be a scalar or a link.</dd>
  <dt>createArray(String fieldName,Type elementType)</dt>
    <dd>create an Array with the specified elementType, no properties, and
      default attributes. The elementType can be any Type but must not be
      null.</dd>
  <dt>createArray(String fieldName,Type elementType,Property[]
  property,FieldAttribute fieldAttribute)</dt>
    <dd>create an Array with the specified elementType, properties, and
      attributes. The elementType can be any Type but must not be null.</dd>
  <dt>createEnum(String fieldName,boolean choicesMutable)</dt>
    <dd>create an Enum with no properties and default attributes.</dd>
  <dt>createEnum(String fieldName,boolean choicesMutable,Property[]
  property,FieldAttribute fieldAttribute)</dt>
    <dd>create an Enum with properties and attributes.</dd>
  <dt>createMenu(String fieldName,String menuName,String[] menuChoices)</dt>
    <dd>create a Menu with no properties and default attributes.</dd>
  <dt>createMenu(String fieldName,String menuName,String[]
  menuChoices,Property[]property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Menu with properties and attributes.</dd>
  <dt>createStructure(String fieldName,String structureName, Field[]
  field)</dt>
    <dd>create a Structure with no properties and default attributes. The
      structureName must not be null. It is permissible to have a Field[]
      with length 0.</dd>
  <dt>createStructure(String fieldName,String structureName, Field[]
  field,Property[] property,FieldAttribute fieldAttribute)</dt>
    <dd>create a Structure with properties and attributes. The structureName
      must not be null. It is permissible to have a Field[] with length
    0.</dd>
</dl>

<p>The field factory gets the single implementation of FieldCreate.</p>

<h3>PVDataCreate</h3>

<p>A factory is available that implements the interfaces for record instance
fields. The methods are called by XMLToIOCDBFactory when it is reading
instance definitions.</p>
<pre>    interface PVDataCreate {
        PVField createData(PVField parent,Field field);
        PVArray createArrayData(PVField parent,Field field,
            int capacity,boolean capacityMutable);
        PVRecord createRecord(String recordName, Structure structure);
    }

    public class PVDataFactory {
        public static PVDataCreate getPVDataCreate();
    }</pre>
where
<dl>
  <dt style="font-family: courier;">createData</dt>
    <dd>Creates an instance of any type of field except array fields, or a
      record instance itself.</dd>
  <dt style="font-family: courier;">createArrayData</dt>
    <dd>Create an array field instance.</dd>
  <dt style="font-family: courier;">createRecord</dt>
    <dd>Create a record instance.</dd>
</dl>
<hr />

<h2 style="text-align: center">Base Introspection Classes</h2>
<hr />

<p>This section describes base classes for implementimg Field objects , i.e.
introspection objects. For many applications they provide a complete
introspection implementation but they could be extended if necessary.</p>
<pre>    public class BaseField implements Field {
        public BaseField(String fieldName,
            Type type,Property[] property,FieldAttribute fieldAttribute);
        public String getFieldName();
        public Property[] getPropertys();
        public Property getProperty(String propertyName);
        public FieldAttribute getFieldAttribute();
        public Type getType();
        public String getSupportName();
        public void setSupportName(String name);
        public boolean isMutable();
        public void setMutable(boolean value);
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class BaseEnum extends BaseField implements Enum{
        public BaseEnum(String fieldName,boolean choicesMutable,
            Property[] property,FieldAttribute fieldAttribute);
        public boolean isChoicesMutable();
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class BaseMenu extends BaseField implements Menu{
        public BaseMenu(String fieldName,String menuName,String[] menuChoices,
            Property[] property,FieldAttribute fieldAttribute);
        public boolean isChoicesMutable();
        public String getMenuName();
        public String[] getMenuChoices();
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class BaseStructure.java extends BaseField implements Structure {
        public BaseStructure.java(String fieldName,String structureName,Field[] field,
             Property[] property,FieldAttribute fieldAttribute);
        public Field getField(String name);
        public int getFieldIndex(String name);
        public String[] getFieldNames();
        public Field[] getFields();
        public String getStructureName();
        public String toString();
        public String toString(int indentLevel);
    }

    public class BaseArray extends BaseField implements Array {
        public BaseArray(String fieldName,Type elementType,
            Property[] property,FieldAttribute fieldAttribute);
        public Type getElementType();
        public String toString();
        public String toString(int indentLevel);      
        private String getString(int indentLevel);
    }
}</pre>

<p>These classes are used to create instances of the reflection
interfaces.</p>
<hr />

<h2 style="text-align: center">Abstract and Base Classes for
PVField</h2>
<hr />

<h3>AbstractPVField</h3>

<p>The following is an abstract base class for implementing PVField
interfaces:</p>
<pre>public abstract class AbstractPVField implements PVField{
    protected AbstractPVField(PVField parent, Field field);
    protected void replaceField(Field field);
    public void replacePVField(PVField newPVField);
    public void setRecord(PVRecord record);
    public String getRequestorName();
    public void message(String message, MessageType messageType);
    public String getFullFieldName();
    public Field getField();
    public PVField getParent();
    public PVRecord getPVRecord();
    public String getSupportName();
    public String setSupportName(String name);
    public String toString(int indentLevel);
}</pre>

<p>where</p>
<dl>
  <dt>AbstractPVField</dt>
    <dd>The constructor which must be called by any derived class.</dd>
  <dt>replaceField</dt>
    <dd>This is called by a derived PVStructure implementation when it wants
      to change the introspection interface for one of it's fields. This is
      necessary because an IOC database allows the definition of a structure
      field to be defined during record initialization.</dd>
  <dt>setRecord</dt>
    <dd>This is called a derived PVStructure implementation to specify the
      record containing the field.</dd>
  <dt>getFullFieldName,...,getPVRecord</dt>
    <dd>The implementation should be sufficient for all derived classes.</dd>
  <dt>getSupportName and setSupportName</dt>
    <dd>With the exception of PVLink the implementation should be sufficient
      for all derived classes.</dd>
  <dt>toString</dt>
    <dd>Should be called by derived classes to add the supportName.</dd>
</dl>

<h3>AbstractPVArray</h3>

<p>The following is a abstract class for creating array fields.</p>
<pre>public abstract class AbstractPVArray extends AbstractPVField implements PVArray{
    public AbstractPVArray(PVField parent,Array array,int capacity,boolean capacityMutable);
    public boolean isCapacityMutable();
    public int getCapacity();
    public int getLength();
    abstract public void setCapacity(int capacity);
    public void setLength(int len);
    public String toString();
}</pre>

<h3>BasePVEnum</h3>
<pre>public class BasePVEnum extends AbstractPVField implements PVEnum {
    public BasePVEnum(PVField parent,Enum enumField);
    public String[] getChoices();
    public int getIndex();
    public boolean setChoices(String[] choice);
    public void setIndex(int index);
    public String toString();
    public String toString(int indentLevel);
}</pre>

<h3>BasePVMenu</h3>
<pre>public class BasePVMenu extends BasePVEnum implements PVMenu
    public BasePVMenu(PVField parent,Menu menu) {
    public boolean setChoices(String[] choice) {
    public String toString() { return getString(0);}
    public String toString(int indentLevel) {
}</pre>

<h3>BasePVLink</h3>
<pre>public class BasePVLink extends AbstractPVField implements PVLink {
    public BasePVLink(PVField parent,Field field);
    public PVStructure getConfigurationStructure();
    public boolean setConfigurationStructure(PVStructure pvStructure);
    public String toString();
    public String toString(int indentLevel);
}</pre>

<h3>BasePVStructure</h3>
<pre>public class BasePVStructure extends AbstractPVField implements PVStructure
    public BasePVStructure(PVField parent, Structure structure);
    public void setRecord(PVRecord record);
    public boolean replaceStructureField(String fieldName, Structure structure);
    public PVField[] getFieldPVFields();
    public String toString();
    public String toString(int indentLevel);
    protected String toString(String prefix,int indentLevel);
}</pre>

<h3>BasePVRecord</h3>
<pre>    public BasePVRecord(String recordName,Structure structure)
    public void message(String message, MessageType messageType);
    public String getRecordName();
    public String toString(int indentLevel);
    void addRequestor(Requestor requestor);
    void removeRequestor(Requestor requestor);
}</pre>
<hr />

<h2 style="text-align: center">Convert</h2>
<hr />

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays with element type that are scalar and satisfy one
    of the following.
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVField pv,String from);
        int fromStringArray(PVField pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
        // For the following the element type must be PVByte, ...., PVDouble
        int toByteArray(PVField pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVField pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVField pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVField pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVField pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVField pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVField pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVField pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVField pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVField pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVField pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVField pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }

    public final class ConvertFactory {
        public static Convert getConvert();
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>

<p>ConvertFactory gets the single implementation of Convert.</p>
<hr />

<h2 style="text-align: center">PVAccess</h2>
<hr />

<h3>Overview</h3>

<p>PVAccess is an interface that makes it easier to locate data fields of a
record. It also works with field properties to support "device" oriented
records, e.g. a "powerSupply" record.</p>

<p>The key method of PVAccess is:</p>
<pre>    findField(String name)</pre>

<p>name is a string that has an arbitray number of field names separated by
".". Simple examples are:</p>
<pre>    value
    value.status
    value.timeStamp</pre>

<p>If a powerSupply record type is properly defined then the following are
valid names.</p>
<pre>    current
    current.status
    current.rawValue
    voltage
    voltage.rawValue</pre>

<p>In addition PVAccess provides access to structure arrays. For example if a
record type implements an array of power supplies then the following are
valid names.</p>
<pre>    powerSupply[0].power
    powerSupply[0].current
    powerSupply[0].current.status</pre>

<p>The javaIOC unnamed package provides more complete examples.</p>

<h3>Definition</h3>

<p>The definition of PVAccess is:</p>
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    interface PVAccess {
        PVRecord getPVRecord();
        AccessSetResult findField(String name);
        String getOtherRecord();
        String getOtherField();
        void setPVField(PVField pvData);
        PVField getField();
    }

    public class PVAccessFactory {
        public static PVAccess createPVAccess(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>AccessSetResult</dt>
    <dd>The result of calling PVAccess.findField.
      <dl>
        <dt>otherRecord</dt>
          <dd>The requested field is located in another record instance.
            getOtherRecord and getOtherField can be called to get the record
            and field that has the data. A new PVAccess must be created to
            access the other record.</dd>
        <dt>thisRecord</dt>
          <dd>The requested record is located in this record. getField can be
            called to get the interface for accessing the data.</dd>
        <dt>notFound</dt>
          <dd>The requested field could not be found.</dd>
      </dl>
    </dd>
  <dt>PVAccess</dt>
    <dd>The interface for locating data fields within a record instance.
      <dl>
        <dt>getPVRecord</dt>
          <dd>Get the record instance interface this PVAccess accesses.</dd>
        <dt>findField</dt>
          <dd>Look for a data field. See below for the semantics for the
            name. See AccessSetResult for the results. The search starts at
            the current internal location, which initially is the record
            itself. A null or empty name sets the internal location to the
            record instance itself.</dd>
        <dt>getOtherRecord</dt>
          <dd>Get the name of the record instance is findField returned
            AccessSetResult.otherRecord.</dd>
        <dt>getOtherField</dt>
          <dd>Get the name of the field in the other record instance is
            findField returned AccessSetResult.otherRecord. This is the name
            that can be given to setField in a new PVAccess for the other
            record.</dd>
        <dt>setPVField</dt>
          <dd>Set the internal location in PVAccess so that the next request
            to findField is relative to this field. The argument must either
            be null or a value returned by getField. A null value sets the
            internal location to the record itself.</dd>
        <dt>getField</dt>
          <dd>Get the interface for the data field located by findField when
            it returns AccessSetResult.thisRecord.</dd>
      </dl>
    </dd>
  <dt>PVAccessFactory</dt>
    <dd>A factory for creating PVAccess</dd>
</dl>

<h3>findField Examples</h3>

<p>The semantics allow searching down a structure hierarchy and for searching
via properties. At a particular level the search is first made for subfields
and if the search fails than for properties.</p>

<p>Lets first consider some examples of locating fields within a record
instance. As the first example assume that a PVAccess has just been created,
which means it is connected to a record. The following will locate the
interfaces for a field named "value" and all properties of this field.</p>
<pre>     // Assume pvRecord has been located
     PVAccess pvAccess = PVAccessFactory.createPVAccess(pvRecord);
     AccessSetResult setResult;
     setResult = pvAccess.findField("value");
     if(setResult!=AccessSetResult.thisRecord) { /*take some action*/}
     PVField value = pvAccess.getField();
     Property[] properties = value.getField.getPropertys();
     while(Property property: properties) {
         pvAccess.setField(value);
         setResult = pvAccess.findField(property.getPropertyName());
         if(setResult!=AccessSetResult.thisRecord) { /*take some action*/}
         PVField propData = pvAccess.getField();
         // do something with propData
    }</pre>

<p>Assume that a powerSupply array instance record defines an array of
structures which each access a powerSupply:</p>
<pre>    //Locate the current for the first powerSupply
    setResult = pvAccess.findField("powerSupply[0].current");
    if(setResult==AccessSetResult.thisRecord) {
       // it is local
    } else if(setResult==AccessSetResult.otherRecord) {
       // it is remote. Must create a new PVAccess for it.
    }
    //Locate the rawValue for the current for the third power supply
    pvAccess.findField(null); // set internal location to the record itself
    setResult = pvAccess.findField("powerSupply[2].current.rawValue");
    ...</pre>
</body>
</html>
