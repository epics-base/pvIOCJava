<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: pv</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: pv<br />
package: org.epics.ioc.pv<br />
2007.11.28</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a>
    <ul>
      <li><a href="#Process">Process Variable</a></li>
      <li><a href="#Process1">Process Variable Data Types</a></li>
      <li><a href="#Process2">Process Variable Reflection</a></li>
    </ul>
  </li>
  <li><a href="#Type">Type</a></li>
  <li><a href="#Reflection">Reflection</a></li>
  <li><a href="#PVField">PVField Interfaces</a>
    <ul>
      <li><a href="#AsynAccess">AsynAccessListener</a></li>
      <li><a href="#PVField1">PVField</a></li>
      <li><a href="#Primitive">Primitive PVField types</a></li>
      <li><a href="#PVString">PVString</a></li>
      <li><a href="#PVStructur">PVStructure</a></li>
      <li><a href="#PVEnumerat">PVEnumerated</a></li>
      <li><a href="#PVRecord">PVRecord</a></li>
      <li><a href="#PVArray">PVArray</a></li>
    </ul>
  </li>
  <li><a href="#Field">Field and PVField creation</a>
    <ul>
      <li><a href="#FieldCreat">FieldCreate</a></li>
      <li><a href="#PVDataCrea">PVDataCreate</a></li>
    </ul>
  </li>
  <li><a href="#Base">Base Introspection Classes</a></li>
  <li><a href="#Abstract">Abstract and Base Classes for PVField</a>
    <ul>
      <li><a href="#AbstractPV">AbstractPVField</a></li>
      <li><a href="#AbstractPV1">AbstractPVArray</a></li>
      <li><a href="#BasePVStru">BasePVStructure</a></li>
      <li><a href="#BasePVReco">BasePVRecord</a></li>
    </ul>
  </li>
  <li><a href="#Convert">Convert</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>A Process Variable (PV) Database is a "smart" database because it has
records together with support code:</p>
<ul>
  <li>Each record has a unique record name.</li>
  <li>A record is a data structure, i.e. a set of fields holding data.</li>
  <li>Each record has associated record support.</li>
  <li>Each field can optionally have associated support.</li>
</ul>

<p>PVField, which is an interface for accessing the data residing in a field
of a database record, has one of the following types:</p>
<dl>
  <dt>primitive</dt>
    <dd>All Java primitive types except char, i.e. boolean, byte, short, int,
      float, and double.</dd>
  <dt>string</dt>
    <dd>A Java String. Primitive and string types are considered scalar
    types.</dd>
  <dt>structure</dt>
    <dd>A structure has a name and contains an array of fields of any
      supported type.</dd>
  <dt>array</dt>
    <dd>A one dimensional array. The element type is any of the supported
      types.</dd>
</dl>

<p>In addition to the Java IOC, PV data is intended for use by 1) Channel
Access client, 2) interface from client to network, 3) interface from network
to Channel Access server, 4) interface from server to IOC database. Since it
is the interface to data, it could also be used by other systems, e.g. TANGO,
TINI, DOOCS, etc.</p>

<p>This package provides the following:</p>
<dl>
  <dt>Type</dt>
    <dd>An enum that describes the valid types.</dd>
  <dt>Reflection Interfaces</dt>
    <dd>Interfaces that describe a PV. Characteristics of a PV can be
      discovered without requiring access to the data associated with it.</dd>
  <dt>Data Interfaces</dt>
    <dd>Interfaces for accessing the data associated with a PV.</dd>
  <dt>Conversion Facility</dt>
    <dd>Conversion of the data from any PV to a string is provided.</dd>
    <dd>Conversion from a string to a scalar or array of srings to an array
      of scaler types is supported.</dd>
    <dd>Conversion between a PV and numeric primitive types is supported. The
      PV must contain scalar numeric type.</dd>
    <dd>Conversion between a PV and an array of numeric primitive types is
      supported. The PV must contain an array of a numeric type.</dd>
    <dd>Copy, with conversion if the types differ, between compatible scalar
      PVs.</dd>
    <dd>Copy, with conversion if the element types differ, between compatible
      arrays of PVs.</dd>
    <dd>Copy between compatable structures.</dd>
  <dt>Field and PVField Factories</dt>
    <dd>An object factory that creates objects implementing the reflection
      interfaces and an object factory for implementing PVField
    interfaces.</dd>
  <dt>Base Field Classes</dt>
    <dd>Base classes for implementing Field objects.</dd>
  <dt>Abstract and Base Classes for creating PVField objects.</dt>
    <dd>An abstract base class for creating PVField implementations.</dd>
  <dt>Convert Factory</dt>
    <dd>An object factory that provides an implementation of the conversion
      facility.</dd>
</dl>

<h3 id="Process">Process Variable</h3>

<p>Definitions:</p>
<dl>
  <dt>Processs Variable (PV)</dt>
    <dd>The name used to specify the data this package supports.</dd>
  <dt>Field</dt>
    <dd>A Field has a name and a type that is any of the supported types. It
      has attributes and can also have properties.</dd>
  <dt>Attribute</dt>
    <dd>Each field can have a attributes, where an attribute is a key,value
      pair. Both the key and value are a string.</dd>
</dl>

<h3 id="Process1">Process Variable Data Types</h3>

<p>The following types are supported:</p>
<dl>
  <dt>primitive</dt>
    <dd><dl>
        <dt>byte</dt>
          <dd>An 8 bit signed byte</dd>
        <dt>boolean</dt>
          <dd>true or false</dd>
        <dt>short</dt>
          <dd>16 bit signed integer</dd>
        <dt>int</dt>
          <dd>32 bit signed integer</dd>
        <dt>long</dt>
          <dd>64 bit signed integer</dd>
        <dt>float</dt>
          <dd>32 bit IEEE float</dd>
        <dt>double</dt>
          <dd>64 bit IEEE float</dd>
      </dl>
    </dd>
  <dt>string</dt>
    <dd>A Java String</dd>
  <dt>structure</dt>
    <dd>A struture with fields of type primitive, string, structure, or
    array</dd>
  <dt>array</dt>
    <dd>a one dimensional array of type primitive, string, structure, or
    array</dd>
</dl>

<h3 id="Process2">Process Variable Reflection</h3>

<p>Given a pvname, which consists of a record name and field name, it is
possible to introspect the field. The reflection interface does not provide
access to data. The PVField and derived PV interfaces provide access to the
data. The reflection and data interfaces are separate because the data may
not be available. For example when a client connects to a PV, the client
library can obtain the reflection information without obtaining any data.
Only when a client issues an I/O request will data be available. This
separation is especially important for arrays and structures.</p>
<hr />

<h2 style="text-align: center" id="Type">Type</h2>
<hr />

<p>The types are defined by:</p>
<pre>    enum Type {
        pvBoolean,
        pvByte, pvShort, pvInt, pvLong,
        pvFloat,pvDouble,
        pvString,
        pvStructure,
        pvArray;

        //Convenience methods
        boolean isNumeric();    // pvByte,...pvDouble
        boolean isPrimitive();  // pvBoolean,...pvDouble
        boolean isScalar();     //pvBoolean,...pvString
    }</pre>

<p>Note that a string is a scalar.</p>
<hr />

<h2 style="text-align: center" id="Reflection">Reflection</h2>
<hr />

<p>This section defines the complete set of Java PV reflection interfaces.</p>
<pre>    public interface FieldAttribute {
        void setAttributes(Map&lt;String,String&gt; attributes,String[] exclude);
        String setAttribute(String key,String value);
        Map&lt;String,String&gt; getAttributes();
        String getAttribute(String key);
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Type getType();
        String getCreateName();
        void setCreateName(String name);
        String getSupportName();
        void setSupportName(String name);
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    } 

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<p>The above definitions support the following:</p>
<ul>
  <li>FieldAttribute<br />
    Each field can have have an arbitrary numbert of attributes. An attribute
    is a key,value pair where bot key and value are a string.</li>
  <li>Field 
    <ul>
      <li>A field has a name.</li>
      <li>A field has a Type.</li>
      <li>A field can optionally have associated creation code identified via
        a name.</li>
      <li>A field can optionally have support identified via a name.</li>
      <li>A field has attributes.</li>
      <li>A field can be converted to a string.</li>
    </ul>
  </li>
  <li>Structure 
    <ul>
      <li>Has a name.</li>
      <li>Has fields that can be any of the supported types.</li>
    </ul>
  </li>
  <li>Array - The array has elements of any of the supported types.</li>
</ul>
<hr />

<h2 style="text-align: center" id="PVField">PVField Interfaces</h2>
<hr />

<p>This section defines the Java Interfaces for accessing fields within a PV
record.</p>

<h3 id="AsynAccess">AsynAccessListener</h3>

<p>This is provided for asynchronous support. For example support that inputs
an array may have to get the array in chunks while blocking between chunks.
While a chunk is being changed the record must be locked to prevent other
code from accessing the field. The support code can implement the following
interface so that it can lock and unlock the record while the field is being
modified.</p>
<pre>    public interface AsynAccessListener {
        void beginSyncAccess();
        void endSyncAccess();
    }</pre>

<p>where </p>
<ul>
  <li>beginSyncAccess<br />
    Begin synchronous access of field. </li>
  <li>endSyncAccess<br />
    End synchronous access of the field. </li>
</ul>

<h3 id="PVField1">PVField</h3>

<p>The following is the base interface for accessing data.</p>
<pre>    enum MessageType {info,warning,error,fatalError}

    interface Requester {
        String getRequesterName();
        void message(String message, MessageType messageType);
    }

    interface PVField extends Requester {
        boolean isMutable();
        void setMutable(boolean value);
        String getFullFieldName();
        String getFullName();
        Field getField();
        PVField getParent();
        PVRecord getPVRecord();
        PVField findProperty(String propertyName);
        PVField findPropertyViaParent(String propertyName);
        String[] getPropertyNames();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        void asynAccessCallListener(boolean begin);
        boolean asynAccessStart(AsynAccessListener asynAccessListener);
        void asynAccessEnd(AsynAccessListener asynAccessListener);
        boolean isAsynAccessActive();
        String toString();
        String toString(int indentLevel);
    }</pre>
where 
<ul>
  <li>MessageType<br />
    This is defined in org.epics.ioc.util.</li>
  <li>Requester<br />
    Requester is also defined in org.epics.ioc.util. For an IOC database the
    methods are implemented as follows: 
    <ul>
      <li>getRequesterName<br />
        This is the full field name concatenated to the record name.</li>
      <li>message<br />

        <ul>
          <li>PVField prepends the full field name to the message and calls
            PVRecord.message. Note that this means that the PVRecord
            implementation must also implement message.</li>
          <li>PVRecord prepends the record name and passes the message to
            IOCDB.message.</li>
          <li>For now IOCDB just calls System.out. It will be extended to
            support a general purpose message handling facility.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>isMutable<br />
    Can the field be changed.</li>
  <li>setMutable<br />
    Specify if the field be changed.</li>
  <li>getFullFieldName<br />
    Get the full field name. This returns a name in the form "name.name
  ...".</li>
  <li>getFullName<br />
    Get the full name. This returns a name in the form "recordName.name
  ...".</li>
  <li>getField<br />
    Get the reflection interface for the data.</li>
  <li>getParent<br />
    Get the interface for the parent or null if this is the PVRecord
  itself.</li>
  <li>getPVRecord<br />
    Get the interface for the record that contains this field.</li>
  <li>findProperty<br />
    Find a field that is a subfield or property of this PVField. The
    fieldName is of the form item.item... where item is name or name[index].
    The algorithm implemented by findProperty is: 
    <ul>
      <li>Start with the leftmost item and find it.</li>
      <li>find the next leftmost item and find it.</li>
      <li>Continue until all items have been found or a search fails.</li>
      <li>Return the interface for the last item or null if a search
      fails.</li>
    </ul>
    An item is found as follows: 
    <ul>
      <li>Find the name part of item. If no [index] is present then fail.</li>
      <li>If [index] is present than field must be a structure with
        elementType structure or array. If so then make sure the index
        element is found. If so it is the field.</li>
      <li>fail</li>
    </ul>
    A name is found as follows: 
    <ol>
      <li>If the Field for the current PVField is named "value" back up one
        level in parent tree.</li>
      <li>The current PV must be a structure. If not fail.</li>
      <li>If the current PVField is type structure with a fieldName=name then
        use it.</li>
      <li>If the fieldName is not timeStamp than fail.</li>
      <li>If the parent tree is null then fail.</li>
      <li>Back up one level in the parent tree and go to 2).</li>
    </ol>
  </li>
  <li>findPropertyViaParent<br />
    Find a property by searching up the parent tree. The property nameis
    expected to match the name of a field. The return value is the interface
    to the first field found that is not a null structure or null if not
    found. </li>
  <li>getPropertyNames<br />
    Get a String array that holds the names of the properties for this field.
    A property name is the field name. If this PVfield is a structure then
    every field except null structures is a property. If this PVField is the
    value field the parent is the starting point and the properties will not
    include the value field itself. In addition a search up the parent tree
    is made for the timeStamp.</li>
  <li>replacePVField<br />
    Replace this PVField. This is called by support code that wants to
    replace the default implementation of a data field with it;s own
    implementation. The new PVField must have the same Type as the oroginal
    field.</li>
  <li>getSupportName<br />
    Get the name of the support for this PV.</li>
  <li>setSupportName<br />
    Set the name of the support for this field. The supportName methods are
    available so that support can be changed remotely. For an IOC database
    only PVLink fields allow the support to be modified after record
    initialization.</li>
  <li>asynAccessCallListener<br />
    Call the listeners. Each time a synchronous modification is made this is
    called before any modification and after all modifications are complete.
    The caller must not block between the two calls i.e. the modification
    must be synchronous. </li>
  <li>asynAccessStart<br />
    Register to be the asynchronous accessor of the field. The return value
    is false if another accessor has already registered. </li>
  <li>asynAccessEnd<br />
    End asynchronous accessor of the field. </li>
  <li>isAsynAccessActive<br />
    Is an asynchronous accessor registered? </li>
  <li>toString<br />
    Converts the field data to a string. This is mostly for debugging
    purposes.</li>
</ul>

<h3 id="Primitive">Primitive PVField types</h3>

<p>The interfaces for primitive data types are:</p>
<pre>    interface PVBoolean extends PVField {
        boolean get();
        void put(boolean value);
    }

    interface PVByte extends PVField {
        byte get();
        void put(byte value);
    }

    interface PVShort extends PVField {
        short get();
        void put(short value);
    }

    interface PVInt extends PVField {
        int get();
        void put(int value);
    }

    interface PVLong extends PVField {
        long get();
        void put(long value);
    }

    interface PVFloat extends PVField {
        float get();
        void put(float value);
    }

    interface PVDouble extends PVField {
        double get();
        void put(double value);
    }</pre>

<h3 id="PVString">PVString</h3>

<p>The interface for string is:</p>
<pre>    interface PVString extends PVField {
        String get();
        void put(String value);
    }</pre>

<h3 id="PVStructur">PVStructure</h3>

<p>The interface for structure is:</p>
<pre>    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getPVFields();
        boolean replaceStructureField(String fieldName,String structureName)
        PVBoolean getBooleanField(String fieldName);
        PVByte getByteField(String fieldName);
        PVShort getShortField(String fieldName);
        PVInt getIntField(String fieldName);
        PVLong getLongField(String fieldName);
        PVFloat getFloatField(String fieldName);
        PVDouble getDoubleField(String fieldName);
        PVString getStringField(String fieldName);
        PVStructure getStructureField(String fieldName,String structureName);
        PVArray getArrayField(String fieldName,Type elementType);
    }</pre>

<p>where</p>
<dl>
  <dt>getStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
  <dt>getPVFields</dt>
    <dd>Returns the array of subfields. The set of subfields must all have
      different field names.</dd>
  <dt>replaceStructureField</dt>
    <dd>Replace a subfield. The implementation must know how to find a
      reflection interface for structureName and how to create a PVStructure
      for the subfield. In addition it must create a new Structure reflection
      interface for itself.</dd>
  <dt>getBooleanField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getByteField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getShortField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getIntField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getLongField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getFloatField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getDoubleField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStringField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getStructureField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
  <dt>getArrayField</dt>
    <dd>Look for fieldName. If found and it has the correct type return the
      interface.</dd>
</dl>

<h3 id="PVEnumerat">PVEnumerated</h3>

<p>This is a convenience interface for a structure that happens to be an
enumerated structure, which is a stricture that has fields index, choice, and
choices. Field index is an integer, choice is a string, and choices is an
array of strings. Both index and choice select one of the choices.</p>
<pre>    public interface PVEnumerated {
        PVInt getIndexField();
        PVString getChoiceField();
        PVStringArray getChoicesField();
    }</pre>

<p>where</p>
<dl>
  <dt>getIndexField</dt>
    <dd>Returns the interface for field index.</dd>
  <dt>getChoiceField</dt>
    <dd>Returns the interface for field choice.</dd>
  <dt>getChoicesField</dt>
    <dd>Returns the interface for field choices.</dd>
</dl>

<h3 id="PVRecord">PVRecord</h3>

<p>Each PVField is a field within a PVRecord:</p>
<pre>    interface PVRecord extends PVStructure
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This will be called any code that has access to the record instance.
      The implementation should prepend the record name to the message and
      then call a more generic message handler. For example package
      org.epics.ioc.db calls iocdb.message.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
</dl>

<h3 id="PVArray">PVArray</h3>

<p>The interfaces for array are:</p>
<pre>    interface PVArray extends PVField {
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
        boolean isCapacityMutable();
        void setCapacityMutable(boolean isMutable);
    }

    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray {
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }

    public class ByteArrayData {
        public byte[] data;
        public int offset;
    }
    interface PVByteArray extends PVArray {
        int get(int offset, int len, ByteArrayData data);
        int put(int offset, int len, byte[]from, int fromOffset);
    }

    public class ShortArrayData {
        public short[] data;
        public int offset;
    }
    interface PVShortArray extends PVArray {
        int get(int offset, int len, ShortArrayData data);
        int put(int offset, int len, short[]from, int fromOffset);
    }

    public class IntArrayData {
        public int[] data;
        public int offset;
    }
    interface PVIntArray extends PVArray {
        int get(int offset, int len, IntArrayData data);
        int put(int offset, int len, int[]from, int fromOffset);
    }

    public class LongArrayData {
        public long[] data;
        public int offset;
    }
    interface PVLongArray extends PVArray {
        int get(int offset, int len, LongArrayData data);
        int put(int offset, int len, long[]from, int fromOffset);
    }

    public class FloatArrayData {
        public float[] data;
        public int offset;
    }
    interface PVFloatArray extends PVArray {
        int get(int offset, int len, FloatArrayData data);
        int put(int offset, int len, float[]from, int fromOffset);
    }

    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }

    public class StringArrayData {
        public String[] data;
        public int offset;
    }
    interface PVStringArray extends PVArray {
        int get(int offset, int len, StringArrayData data);
        int put(int offset, int len, String[]from, int fromOffset);
    }

    public class ArrayArrayData {
        public PVArray[] data;
        public int offset;
    }
    interface PVArrayArray extends PVArray {
        int get(int offset, int len, ArrayArrayData data);
        int put(int offset, int len, PVArray[]from, int fromOffset);
    }

    public class StructureArrayData {
        public PVStructure[] data;
        public int offset;
    }
    interface PVStructureArray extends PVArray {
        int get(int offset, int len, StructureArrayData data);
        int put(int offset, int len, PVStructure[]from, int fromOffset);
    }</pre>

<p>The interface for each array type has the same form except for the type.
For example PVDoubleArray is:</p>
<pre>    public class DoubleArrayData {
        public double[] data;
        public int offset;
    }
    interface PVDoubleArray extends PVArray {
        int get(int offset, int len, DoubleArrayData data);
        int put(int offset, int len, double[]from, int fromOffset);
    }</pre>

<p>Get "exposes" it's internal array by setting data.data and data.offset.
The caller is responsible for copying the array elements. This violates the
principle that objects shold not expose their internal data but is done so
that copying between arrays with identical element types can be implemented
via a call to System.arraycopy without requiring an intermediate array.</p>

<p>Both get and put return the number of elements actually transfered. The
arguments are:</p>
<dl>
  <dt><span style="font-family: courier">offset</span></dt>
    <dd>The offset in the PV array.</dd>
  <dt><span style="font-family: courier">len</span></dt>
    <dd>The maximum number of elements to transfer. The number actually
      transfered will be less than or equal to this value.</dd>
  <dt style="font-family: courier;">data</dt>
    <dd>Get sets data.data to it's internal array and data.offset to the
      offset into the array. The caller is responsible for the actual data
      transfer.</dd>
  <dt><span style="font-family: courier">from</span></dt>
    <dd>The array from which the data is taken. This array is supplied by the
      caller</dd>
  <dt><span style="font-family: courier">fromOffset</span></dt>
    <dd>The offset in <span style="font-family: courier;">from</span></dd>
</dl>

<p>The caller must be prepared to make multiple calls to retrieve or put an
entire array. A caller can always accept or put partial arrays. For example
the following reads an entire array:</p>
<pre>    double[] getArray(PVDoubleArray pv)
    {
        int len = pv.getLength();
        double[] storage = new double[len];
        DoubleArrayData data = new DoubleArrayData();
        int offset = 0;
        while(offset &lt; len) {
            int num = pv.get(offset,(len-offset),data);
            System.arraycopy(data.data,data.offset,storage,offset,num);
            offset += num;
        }
        return storage;
    } </pre>
<hr />

<h2 style="text-align: center" id="Field">Field and PVField creation</h2>
<hr />

<p>Interfaces and factories are provided to create Introspection and PVField
instances.</p>

<h3 id="FieldCreat">FieldCreate</h3>

<p>This is an interface for creating introspection objects that implement the
introspection interfaces. The methods are:</p>
<pre>    public interface FieldCreate {
        public Type getType(Map&lt;String,String&gt;attributes);
        public Type getElementType(Map&lt;String,String&gt; attributes);
        public Type getType(String value);

        public static FieldAttribute createFieldAttribute();

        public static Field createField(String fieldName,Type type);
        public static Field createField(String fieldName,Type type,
            FieldAttribute fieldAttribute);

        public static Array createArray(String fieldName,Type elementType);
        public static Array createArray(String fieldName,Type elementType,
            FieldAttribute fieldAttribute);

        public static Structure createStructure(String fieldName,
            String structureName, Field[] field);
        public static Structure createStructure(String fieldName,
            String structureName, Field[] field,
            FieldAttribute fieldAttribute);
    }

    public final class FieldFactory {
        public static FieldCreate getFieldCreate();
    }</pre>

<p>where</p>
<dl>
  <dt>getType(Map&lt;String,String&gt;attributes)</dt>
    <dd>Map is expected to contain a key,value pair with key = "type". If
      found getType(value) is called and returned.</dd>
  <dt>getElementType(Map&lt;String,String&gt;attributes)</dt>
    <dd>Like getType except that the key must be "elementType"</dd>
  <dt>getType(String value)</dt>
    <dd>Looks for value to be one of the following: "boolean", "byte",
      "short", "int", "long", "float", "double", "string", "enum", "menu",
      "structure", "array",or "link". If found the Type associated with the
      value is returned. If not found a null is returned.</dd>
  <dt>createFieldAttribute()</dt>
    <dd>Create a fieldAttrbute.</dd>
  <dt>createField(String fieldName,Type type)</dt>
    <dd>create a Field with the specified type, no properties, and default
      attributes. The type must be a scalar or a link.</dd>
  <dt>createField(String fieldName,Type type,FieldAttribute
  fieldAttribute)</dt>
    <dd>create a Field with the specified type, properties, and attributes.
      The type must be a scalar or a link.</dd>
  <dt>createArray(String fieldName,Type elementType)</dt>
    <dd>create an Array with the specified elementType, no properties, and
      default attributes. The elementType can be any Type but must not be
      null.</dd>
  <dt>createArray(String fieldName,Type elementType,FieldAttribute
  fieldAttribute)</dt>
    <dd>create an Array with the specified elementType, properties, and
      attributes. The elementType can be any Type but must not be null.</dd>
  <dt>createStructure(String fieldName,String structureName, Field[]
  field)</dt>
    <dd>create a Structure with no properties and default attributes. The
      structureName must not be null. It is permissible to have a Field[]
      with length 0.</dd>
  <dt>createStructure(String fieldName,String structureName, Field[]
  field,FieldAttribute fieldAttribute)</dt>
    <dd>create a Structure with properties and attributes. The structureName
      must not be null. It is permissible to have a Field[] with length
    0.</dd>
</dl>

<p>The field factory gets the single implementation of FieldCreate.</p>

<h3 id="PVDataCrea">PVDataCreate</h3>

<p>A factory is available that implements the interfaces for record instance
fields. The methods are called by XMLToIOCDBFactory when it is reading
instance definitions.</p>
<pre>    interface PVDataCreate {
        PVField createPVField(PVField parent,Field field);
        PVArray createPVArray(PVField parent,Field field,
            int capacity,boolean capacityMutable);
        PVRecord createPVRecord(String recordName, Structure structure);
    }

    public class PVDataFactory {
        public static PVDataCreate getPVDataCreate();
    }</pre>
where 
<dl>
  <dt style="font-family: courier;">createPVField</dt>
    <dd>Creates an instance of any type of field except array fields, or a
      record instance itself.</dd>
  <dt style="font-family: courier;">createPVArray</dt>
    <dd>Create an array field instance.</dd>
  <dt style="font-family: courier;">createPVRecord</dt>
    <dd>Create a record instance.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Base">Base Introspection Classes</h2>
<hr />

<p>This section describes base classes for implementimg Field objects , i.e.
introspection objects. For many applications they provide a complete
introspection implementation but they could be extended if necessary.</p>
<pre>    public class BaseField implements Field {
        public BaseField(String fieldName, Type type,FieldAttribute fieldAttribute);
        public String getFieldName();
        public FieldAttribute getFieldAttribute();
        public Type getType();
        public String getCreateName();
        public void setCreateName(String name);
        public String getSupportName();
        public void setSupportName(String name);
        public String toString();
        public String toString(int indentLevel);
    }
    
    public class BaseStructure.java extends BaseField implements Structure {
        public BaseStructure.java(String fieldName,String structureName,Field[] field,
             FieldAttribute fieldAttribute);
        public Field getField(String name);
        public int getFieldIndex(String name);
        public String[] getFieldNames();
        public Field[] getFields();
        public String getStructureName();
        public String toString();
        public String toString(int indentLevel);
    }

    public class BaseArray extends BaseField implements Array {
        public BaseArray(String fieldName,Type elementType,FieldAttribute fieldAttribute);
        public Type getElementType();
        public String toString();
        public String toString(int indentLevel);      
        private String getString(int indentLevel);
    }
}</pre>

<p>These classes are used to create instances of the reflection
interfaces.</p>
<hr />

<h2 style="text-align: center" id="Abstract">Abstract and Base Classes for
PVField</h2>
<hr />

<h3 id="AbstractPV">AbstractPVField</h3>

<p>The following is an abstract base class for implementing PVField
interfaces:</p>
<pre>public abstract class AbstractPVField implements PVField{
    protected AbstractPVField(PVField parent, Field field);
    protected void replaceField(Field field);
    protected void setRecord(PVRecord record);
    public String getRequesterName();
    public void message(String message, MessageType messageType);
    public boolean isMutable();
    public void setMutable(boolean value);
    public String getFullFieldName();
    public String getFullName();
    public Field getField();
    public PVField getParent();
    public PVRecord getPVRecord();
    public void replacePVField(PVField newPVField);
    public PVField findProperty(String fieldName);
    PVField findPropertyViaParent(String propertyName);
    public String[] getPropertyNames();
    public String getSupportName();
    public String setSupportName(String name);
    public void asynAccessCallListener(boolean begin);
    public boolean asynAccessStart(AsynAccessListener asynAccessListener);
    public void asynAccessEnd(AsynAccessListener asynAccessListener);
    public boolean isAsynAccessActive();
    public String toString();
    public String toString(int indentLevel);
}</pre>

<p>where</p>
<dl>
  <dt>AbstractPVField</dt>
    <dd>The constructor which must be called by any derived class.</dd>
  <dt>replaceField</dt>
    <dd>This is called by a derived PVStructure implementation when it wants
      to change the introspection interface for one of it's fields. This is
      necessary because an IOC database allows the definition of a structure
      field to be defined during record initialization.</dd>
  <dt>setRecord</dt>
    <dd>This is called a derived PVStructure implementation to specify the
      record containing the field.</dd>
  <dt>getRequestorName,...,getPropertyNames,
  asynAccessCallListener,...,isAsynAccessActive</dt>
    <dd>The implementation should be sufficient for all derived classes.</dd>
  <dt>getSupportName and setSupportName</dt>
    <dd>With the exception of PVLink the implementation should be sufficient
      for all derived classes.</dd>
  <dt>toString</dt>
    <dd>Should be called by derived classes to add the supportName.</dd>
</dl>

<h3 id="AbstractPV1">AbstractPVArray</h3>

<p>The following is a abstract class for creating array fields.</p>
<pre>public abstract class AbstractPVArray extends AbstractPVField implements PVArray{
    protected AbstractPVArray(PVField parent,Array array,
        int capacity,boolean capacityMutable);
    public Array getArray();
    public int getLength();
    public void setLength(int len);
    public int getCapacity();
    abstract public void setCapacity(int capacity);
    public boolean isCapacityMutable();
    public void setCapacityMutable(boolean isMutable);
    public String toString();
}</pre>

<h3 id="BasePVStru">BasePVStructure</h3>
<pre>public class BasePVStructure extends AbstractPVField implements PVStructure
    public BasePVStructure(PVField parent, Structure structure);
    public Structure getStructure();
    public void setRecord(PVRecord record);
    public boolean replaceStructureField(String fieldName, Structure structure);
    public PVField[] getPVFields();
    public PVBoolean getBooleanField(String fieldName);
    public PVByte getByteField(String fieldName);
    public PVShort getShortField(String fieldName);
    public PVInt getIntField(String fieldName);
    public PVLong getLongField(String fieldName);
    public PVFloat getFloatField(String fieldName);
    public PVDouble getDoubleField(String fieldName);
    public PVString getStringField(String fieldName);
    public PVStructure getStructureField(String fieldName,String structureName);
    public PVArray getArrayField(String fieldName,Type elementType);
    public String toString();
    public String toString(int indentLevel);
    protected String toString(String prefix,int indentLevel);
}</pre>

<h3 id="BasePVReco">BasePVRecord</h3>
<pre>    public BasePVRecord(String recordName,Structure structure)
    public void message(String message, MessageType messageType);
    public String getRecordName();
    public String toString(int indentLevel);
    void addRequester(Requester requester);
    void removeRequester(Requester requester);
}</pre>
<hr />

<h2 style="text-align: center" id="Convert">Convert</h2>
<hr />

<p>This section describes the supported conversions between data types.</p>
<ul>
  <li>All supported types can be converted to a string. If you ask for a 100
    megabyte array to be converted to a string expect a lot of output.</li>
  <li>Conversion from a string to a scalar type.</li>
  <li>Conversion from an array of strings to an array of scalar types.</li>
  <li>Copy between the following types of scalar PVs 
    <ul>
      <li>Numeric type to another numeric type</li>
      <li>Both have the same type.</li>
      <li>Either is a string</li>
    </ul>
  </li>
  <li>Copy between PVArrays with element type that are scalar and satisfy one
    of the following. 
    <ul>
      <li>Numeric to numeric</li>
      <li>Both have the same type.</li>
      <li>Either is a string.</li>
    </ul>
  </li>
  <li>Conversions between numeric scalar types.</li>
  <li>Conversions between arrays of numeric type.</li>
  <li>Conversion between compatible structures.</li>
</ul>
<pre>    interface Convert {
        String getString(PVField pv, int indentLevel);
        String getString(PVField pv);
        void fromString(PVField pv,String from);
        int fromStringArray(PVField pv,
             int offset, int len, String[]from, int fromOffset);
        int toStringArray(PVArray pv,
             int offset, int len, String[]to, int toOffset);
        boolean isCopyScalarCompatible(Field from, Field to);
        void copyScalar(PVField from, PVField to);
        boolean isCopyArrayCompatible(Array from, Array to);
        int copyArray(PVArray from, int offset, int len, PVArray to, int toOffset);
        boolean isCopyStructureCompatible(Structure from, Structure to);
        void copyStructure(PVStructure from, PVStructure to);
        // For the following the pv Type must be PVByte, ...., PVDouble
        byte toByte(PVField pv);
        short toShort(PVField pv);
        int   toInt(PVField pv);
        long  toLong(PVField pv);
        float toFloat(PVField pv);
        double toDouble(PVField pv);
        void fromByte(PVField pv, byte from);
        void  fromShort(PVField pv, short from);
        void  fromInt(PVField pv, int from);
        void  fromLong(PVField pv, long from);
        void  fromFloat(PVField pv, float from);
        void  fromDouble(PVField pv, double from);
        // For the following the element type must be PVByte, ...., PVDouble
        int toByteArray(PVField pv,
            int offset, int len, byte[]to, int toOffset);
        int toShortArray(PVField pv,
            int offset, int len, short[]to, int toOffset);
        int toIntArray(PVField pv,
            int offset, int len, int[]to, int toOffset);
        int toLongArray(PVField pv,
            int offset, int len, long[]to, int toOffset);
        int toFloatArray(PVField pv,
            int offset, int len, float[]to, int toOffset);
        int toDoubleArray(PVField pv,
            int offset, int len, double[]to, int toOffset);
        int fromByteArray(PVField pv,
            int offset, int len, byte[]from, fromOffset);
        int fromShortArray(PVField pv,
            int offset, int len, short[]from, fromOffset);
        int fromIntArray(PVField pv,
            int offset, int len, int[]from, fromOffset);
        int fromLongArray(PVField pv,
            int offset, int len, long[]from, fromOffset);
        int fromFloatArray(PVField pv,
            int offset, int len, float[]from, fromOffset);
        int fromDoubleArray(PVField pv,
            int offset, int len, double[]from, fromOffset);
        void newLine(StringBuilder builder, int indentLevel);
    }

    public final class ConvertFactory {
        public static Convert getConvert();
    }</pre>

<p>The array methods all return the number of elements copied or converted.
This can be less than <span style="font-family: courier;">len</span> if the
PVField array contains less than len elements.</p>

<p><span style="font-family: courier;">newLine</span> is a convenience method
for code that implements <span style="font-family: courier;">toString</span>
It generates a newline and inserts blanks at the beginning of the newline.</p>

<p>ConvertFactory gets the single implementation of Convert.</p>
</body>
</html>
