<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC:database</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: database<br />
package: org.epics.pvData.pv<br />
2011.04.14</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#RecordFiel">RecordField Interfaces</a> 
    <ul>
      <li><a href="#PVRecordFi">PVRecordField</a></li>
      <li><a href="#PVRecordSt">PVRecordStructure</a></li>
    </ul>
  </li>
  <li><a href="#Record">Record Interfaces</a> 
    <ul>
      <li><a href="#PVListener">PVListener</a></li>
      <li><a href="#PVRecordCl">PVRecordClient</a></li>
      <li><a href="#PVRecord">PVRecord</a> 
        <ul>
          <li><a href="#Record1">Record Locking</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#PVRecord1">PVRecord Definition and Creation</a> 
    <ul>
      <li><a href="#PVRecord2">PVRecord</a></li>
      <li><a href="#PVRecordCr">PVRecordCreate</a></li>
      <li><a href="#PVReplaceF">PVReplaceFactory</a></li>
    </ul>
  </li>
  <li><a href="#PVDatabase">PVDatabase</a> 
    <ul>
      <li><a href="#PVDatabase1">PVDatabaseFactory</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides everything required to create and access a PVDatabase.
</p>

<p>A PVDatabase consists of :</p>
<ol>
  <li>A set of structures. Each has a unique name and is implemented as a top
    level PVStructure. The primary use of these structures is as "templates"
    for creating structure fields within a PVRecord.</li>
  <li>A set of record instances. Each has a unique name and is implemented as a
    PVRecord.</li>
</ol>

<p>Each PVRecord has a unique record name and has top level PVStructure, which
is a structured set of PVFields. A PVRecord can be:</p>
<dl>
  <dt>processed</dt>
    <dd>A record can be processed. In addition each field of a record can
      optionally have attached support. The database does not implement
      processing but allows other code to attach support to fields and
      recordProcess to a record.</dd>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. The JavaIOC requires
      that a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is modified.
      PVField provides a method postPut, which must be called by the code that
      calls the put method of the PVField. Note the caller must call postPut
      because for array fields the array might be written in chunks. Only the
      caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever a
      message is generated.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="RecordFiel">RecordField Interfaces</h2>
<hr />

<p>Each field of a record has an associated PVRecordField and each structure
field a PVRecordStructure.</p>

<h3 id="PVRecordFi">PVRecordField</h3>
<pre>    interface PVRecordField extends Requester{
        Support getSupport();
        void setSupport(Support support);
        PVRecordStructure getParent();
        PVField getPVField();
        void replacePVField(PVField newPvField);
        String getFullFieldName();
        String getFullName();
        PVRecord getPVRecord();
        void renameField(String newName);
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getSupport</dt>
    <dd>Get the attached support. This is null if no support has been
    attached.</dd>
  <dt>setSupport</dt>
    <dd>Set support for the field.</dd>
  <dt>getParent</dt>
    <dd>Get the parent PVRecordStructure for this field.</dd>
  <dt>getPVField</dt>
    <dd>Get the PVField associated with this PVRecordField.</dd>
  <dt>replacePVField</dt>
    <dd>If the associated PVField is being replaced it must be replaced by
      calling this instead if directly replacing the PVfield.</dd>
  <dt>getFullName</dt>
    <dd>This gets recordname plus the full name of the field, i.e.
      recordName.field,field,..</dd>
  <dt>getFullFieldName</dt>
    <dd>This gets the full name of the field, i.e. field,field,..</dd>
  <dt>getPVRecord</dt>
    <dd>Returns the PVRecord to which this field belongs.</dd>
  <dt>renameField</dt>
    <dd>Renames the field name. This must be called rather than directly
      calling PVField.renameField.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield if
      this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>This is called by the code that implements the data interface. It is
      called whenever the put method is called.</dd>
</dl>

<h3 id="PVRecordSt">PVRecordStructure</h3>

<p>Each structure field has the following interface: Note that it extends
PVRecordField</p>
<pre>    public interface PVRecordStructure extends PVRecordField {
        PVRecordField[] getPVRecordFields();
        PVStructure getPVStructure();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVRecordFields</dt>
    <dd>Get the PVRecordField array.</dd>
  <dt>getPVStructure</dt>
    <dd>Get the PVStructure this field accesses.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Record">Record Interfaces</h2>
<hr />

<h3 id="PVListener">PVListener</h3>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is modified.
If the field is a structure then the PVListener is notified whenever that field
or any subfield is modified. Please note that PVStructureScalar and
PVStructureArray fields are treated as leaf fields so that the underlying
fields can not have attached listeners.</p>
<pre>    public interface PVListener {
        void dataPut(PVRecordField pvRecordField);
        void dataPut(PVRecordStructure requested,PVRecordField pvRecordField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. This is called if the listener has called
      PVRecordField.addListener for pvRecordField.</dd>
  <dt>dataPut(PVRecordStructure requested,PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener. This is called if the listener
      has called PVRecordField.addListener for requested.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when the
      record is being destroyed or when the record structure (not the data
      values) is being changed.</dd>
</dl>

<h3 id="PVRecordCl">PVRecordClient</h3>

<p>Any client that accesses a PVRecord must call registerClient so that the
client can be notified when the record is being removed from the master
database. The client must imnplement the following interface:</p>
<pre>    public interface PVRecordClient {
        void detach(PVRecord pvRecord);
    }</pre>

<h3 id="PVRecord">PVRecord</h3>

<p>A PVRecord has a top level PVStructure that provides the following
methods:</p>
<pre>    interface PVRecord extends Requester {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        PVRecordField findPVRecordField(PVField pvField);
        PVRecordStructure getPVRecordStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
        void registerClient(PVRecordClient pvRecordClient);
        void unregisterClient(PVRecordClient pvRecordClient);
        void detachClients();
        int getNumberClients();
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordProcess</dt>
    <dd>Get the record process for the record.</dd>
  <dt>setRecordProcess</dt>
    <dd>Set the record process for the record.</dd>
  <dt>findPVRecordField</dt>
    <dd>Given a PVField find the PVRecordField.</dd>
  <dt>getPVRecordStructure</dt>
    <dd>Get the top level PVRecordStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This is called by AbstractPVField if it has a RecordField. It can be
      called by other code but most code will not need it.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If the
      other record is already locked than this record may be temporily unlocked
      and then relocked. The caller must call the unlock merthod of the other
      record when done with it. The implementation prevents deadlocks BUT code
      must not try to lock more than two records at the same time or deadlocks
      can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvRecordField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
  <dt>registerClient</dt>
    <dd>Every client that accesses the record must call this so that the client
      can be notified when the record is deleted.</dd>
  <dt>unregisterClient</dt>
    <dd>Client is no longer accessing the record.</dd>
  <dt>detachClients</dt>
    <dd>All client are asked to detach from the record.</dd>
  <dt>getNumberClients</dt>
    <dd>Get the number of registered clients.</dd>
</dl>

<h4 id="Record1">Record Locking</h4>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example the JavaIOC, it may be required
that the thread does not block between lock and unlock.</p>
<hr />

<h2 style="text-align: center" id="PVRecord1">PVRecord Definition and
Creation</h2>
<hr />

<h3 id="PVRecord2">PVDatabase</h3>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        String[] getStructureNames();
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database. If the record already exists it is not
      modified and false is returned.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database. If the record was not in the
      database false is returned.</dd>
  <dt>getRecordNames</dt>
    <dd>Get an array of the record names.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database. If it already exists false is
    returned.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database. If it did not exist false is
      returned.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the structure names.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are sent
      to System.out (info) or System.err (all other message types). If at least
      one requester is present then the messages are given to the requesters
      without writing to System.out or System.err. If the database is the
      master, the message is put of a queue that is emptied by another thread.
      This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
    expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
    expression.</dd>
</dl>

<h3 id="PVRecordCr">PVRecordCreate</h3>

<p>Interface and factory for creating PVrecords and PVStructures.</p>
<pre>    interface PVRecordCreate {
        PVRecord createPVRecord(String recordName,PVStructure pvStructure);
    }

    class PVRecordCreateFactory{
        PVRecordCreate getPVRecordCreate();
    }</pre>

<p>where</p>
<dl>
  <dt>createPVRecord</dt>
    <dd>Create a PVRecord with pvStructure as the top level structure.</dd>
</dl>

<h3 id="PVReplaceF">PVReplaceFactory</h3>

<p>Factory that looks for and calls factories that replace the default
implementation of a field.</p>
<pre>    class PVReplaceFactory {
        public static void replace(PVDatabase pvDatabase);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordStructure pvRecordStructure);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordField pvRecordField);</pre>

<p>where</p>
<dl>
  <dt>replace(PVDatabase pvDatabase)</dt>
    <dd>Look at every field of every record in the database and see if field
      implementation should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordStructure
  pvRecordStructure)</dt>
    <dd>Look at every field of pvStructure and see if the field implementation
      should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordField
  pvRecordField)</dt>
    <dd><p>Look at the field and see if the field implementation should be
      replaced. If it is a structure field also look at the subfields.</p>
    </dd>
</dl>
<hr />

<h2 style="text-align: center" id="PVDatabase">PVDatabase</h2>
<hr />

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances or other structures. When a structure field of a record is defined as
follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" extends = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The Interface definition is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String recordName);
        boolean addRecord(PVRecord record);
        boolean removeRecord(PVRecord record);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String structureName);
        boolean addStructure(PVStructure structure);
        boolean removeStructure(PVStructure structure);
        String[] getStructureNames();
        PVStructure[] getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database that is
    processed,</dd>
  <dt>getName</dt>
    <dd>Get the name of this database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into master. The database must be named
      "beingInstalled". After this returns another beingInstalled database can
      be created.</dd>
  <dt>findRecord</dt>
    <dd>Find a PVRecord. If not found null is returned.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database.</dd>
  <dt>gerRecordNames</dt>
    <dd>Get an array of the names of the current records in the database.</dd>
  <dt>getRecords</dt>
    <dd>Get an array of the current records in the database.</dd>
  <dt>findStructure</dt>
    <dd>Find a PVStructure. If not found null is returned.</dd>
  <dt>addStructure</dt>
    <dd>Add a PVStructure to the database.</dd>
  <dt>removeStructure</dt>
    <dd>Removed a PVStructure from the database.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the names of the current structures in the
    database.</dd>
  <dt>getStructures</dt>
    <dd>Get an array of the current structuress in the database.</dd>
  <dt>message</dt>
    <dd>Called by a PVDatabase to report messages. This gives a way for a
      client to get all messages from all records in a database.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get an array of record names that satisfy a regular expression.</dd>
  <dt>structureList</dt>
    <dd>Get an array of structure names that satisfy a regular expression.</dd>
  <dt>recordToString</dt>
    <dd>Dumps all records with record names that satisfy a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Dumps all structures with structure names that satisfy a regular
      expression.</dd>
</dl>

<h3 id="PVDatabase1">PVDatabaseFactory</h3>

<p>This is a factort that creates a PVDatabase.</p>
<pre>    class PVDatabaseFactory {
        public static PVDatabase create(String name);
        public static PVDatabase getMaster();
        public static PVDatabase getBeingInstalled();
    }</pre>
<dl>
  <dt>create</dt>
    <dd>Create a PVDatabase. If this is a database that is intended to merge
      into master it MUST be named "beingInstalled". If a beingInstalled
      database already exists than an IllegalStateException is thrown.</dd>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database than can be
      processed and the only database pvAccess uses.</dd>
  <dt>getBeingInstalled</dt>
    <dd>Get the beingInstalled database. In not present null is returned.</dd>
</dl>
</body>
</html>
