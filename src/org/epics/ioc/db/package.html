<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2007.03.05</h1>
CONTENTS

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Instance Syntax</a>
    <ul>
      <li><a href="#General">General Statements</a>
        <ul>
          <li><a href="#namespace">namespace</a></li>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro">Macro Substitution</a></li>
          <li><a href="#Example">Example Include and Macro
          Substitution</a></li>
        </ul>
      </li>
      <li><a href="#record">record</a></li>
      <li><a href="#configure">configure</a></li>
      <li><a href="#Primitive">Primitive Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#array">array</a></li>
      <li><a href="#menu">menu</a></li>
      <li><a href="#enumerated">enumerated</a></li>
      <li><a href="#link">link</a></li>
    </ul>
  </li>
  <li><a href="#Database">XML to Database Converter</a></li>
  <li><a href="#Database1">Database Access</a>
    <ul>
      <li><a href="#Listener">Listener Interface</a>
        <ul>
          <li><a href="#DBListener">DBListener</a></li>
          <li><a href="#RecordList">RecordListener</a></li>
        </ul>
      </li>
      <li><a href="#DBField">DBField</a></li>
      <li><a href="#DBEnum">DBEnum</a></li>
      <li><a href="#DBMenu">DBMenu</a></li>
      <li><a href="#DBLink">DBLink</a></li>
      <li><a href="#DBStructur">DBStructure</a></li>
      <li><a href="#DBNonScala">DBNonScalarArray</a></li>
      <li><a href="#DBRecord">DBRecord</a></li>
      <li><a href="#DBREcordFa">DBREcordFactory</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB">IOCDB: IOC Database</a></li>
  <li><a href="#Listener1">Listener Support</a></li>
  <li><a href="#Thread">Thread Safety</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax<br />
    The XML syntax for defining record instances.</li>
  <li>An XML to database converter.<br />
    Parses xml record instance files, creates record instances, and puts them
    in an IOC database.</li>
  <li>Record Instance Access<br />
    Interfaces for accessing data in record instances.</li>
  <li>Data Factory<br />
    A factory for creating support for database fields. It can create support
    for all types of fields.</li>
  <li>Base Classes<br />
    A set of base classes for implementing DBField interfaces.</li>
  <li>IOC Database<br />
    Interface and factory for a database containing the record instances</li>
  <li>Listen Support<br />
    A description of the support for monitoring changes to the data in
    database instances fields.</li>
</ol>
<hr />

<h2 style="text-align: center" id="Record">Record Instance Syntax</h2>
<hr />
A Record Instance file must be an XML file with a root tag of IOCDatabase:
<pre>    &lt;?xml version="1.0" ?&gt;
    &lt;IOCDatabase&gt;
      &lt;?-- valid Record Instance Definitions --&gt;
    &lt;/IOCDatabase&gt;</pre>

<h3 id="General">General Statements</h3>

<h4 id="namespace">namespace</h4>
At this time namespaces are not used.

<h4 id="Include">Include</h4>
The XML file can include other files also containing Record Instance
Definitions. An included file must also be a valid XML Record Instance
Definitions. Included files can also include other files. The syntax is:
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4 id="Macro">Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4 id="Example">Example Include and Macro Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "aiRecord"&gt;
    &lt;aiInput structureName = "aiLinear" &gt;
        &lt;aiRaw&gt;
            &lt;input supportName = "inputLink"&gt;
                &lt;configure structureName = "inputLink"&gt;
                    &lt;pvname&gt;${pvname}&lt;/pvname&gt;
                    &lt;wait&gt;true&lt;/wait&gt;
                &lt;/configure&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiInput&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h3 id="record">record</h3>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span> is a string with a
combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p>supportName is the name of support. If not given the supportName specified
in the record type definition is used. In either case a support definition
with the supportName must exist. Package org.epics.ioc.dbProcess provides
support that creates support for each record instance. See that package for
details. If the same record instance appears multiple times then then last
supportName is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be a name
definied in the record type definition.</p>

<p>Any field can optionally have associated support. If a supportName is
given with a field instance then it overides any support defined in the
record type field definition. Thus support is only used if the record support
for the record instance calls the support methods. If a field is initialized
multiple times than the last supportName definition determines the
support.</p>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3 id="configure">configure</h3>

<p>If a supportName is defined for a record instance of for a field on a
record instance and the support definition specifies a configuration
structure then a configure XML element can be used to initialize the fields
of the configuration structure. This configure element MUST appear
immediately after the record instance or field instance definition.</p>

<p>For example assume the following Database Definitions:</p>
<pre>    &lt;structure name = "dummy"&gt;
        &lt;field name = "xxx" type = "string" /&gt;
        &lt;field name = "yyy" type = "int" /&gt;
    &lt;/structure&gt;
    
    
    &lt;support name = "exampleSupport" configurationStructureName = "dummy"
        factoryName = "org.epics.ioc.support.Dummy" /&gt;</pre>

<p>Then an instance of field <span style="font-family: courier;">link</span>
can be initialized as follows:</p>
<pre> &lt;value supportName = "exampleSupport"&gt;
        &lt;configure structureName = "dummy"&gt;
            &lt;xxx&gt;xxxxxx&lt;/xxx&gt;
            &lt;yyy&gt;5&lt;/yyy&gt;
        &lt;/configure&gt;
        This is a string value
    &lt;/value&gt;</pre>

<p>This example was for a field that has type string but similar definitions
can be given for any field that has associated support.</p>

<p>If the support is for a structure field then the configuration must be
given before any fields of the structure. If the support is for a record
type, the configuration must be given before any fields of the record
instance.</p>

<h3 id="Primitive">Primitive Types</h3>

<p>For primitive types the initializer has the same format as the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value supportName = "supportName" &gt;.98&lt;/value&gt;</pre>
Notes:
<ul>
  <li>supportName is optional</li>
  <li>Byte.decode, Short.decode, Integer.decide, and Long.decode are used to
    convert a string to an integer data type. Thus hex values are allowed but
    the sign bit MUST not be set. This for byte data 0xff is not allowed but
    -0x01 is allowed. Note for example that the byte value -128 can not be
    specified in hex.</li>
</ul>

<h3 id="string">string</h3>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h3 id="structure">structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure and recordType definitions:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "ai"&gt;
   ...
       &lt;field name = "displayLimit&gt;
            &lt;structure name = "displayLimit" /&gt;
       &lt;field/&gt;
   ...</pre>

<p>displayLimit is initilized as follows:.</p>
<pre>    &lt;displayLimit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;</pre>

<p>Note that supportName can optionally be defined</p>

<p>It is permissible to define a field to be a structure without providing a
structure name. In this case the structureName must be provided when the
field is being created. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" &gt;</pre>

<h3 id="array">array</h3>
The syntax for an array initializer is:
<pre>    &lt;fieldName capacity = "capacity" supportName = "supportName" &gt;
        &lt;value offset = "offset"&gt;value&lt;/value&gt;
        &lt;value offset = "offset"&gt;valueList&lt;/value&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>assigns a value to the array. If the array is an array of structures
      then the value is actually a set of field definitions. If the array is
      an array of array the value is another array initialization.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
</dl>

<p>Assume the following are part of a recordType definition:</p>
<pre>    &lt;field name = "intArray"&gt;
        &lt;array&gt;
            &lt;type&gt;&lt;int /&gt;&lt;/type&gt;
        &lt;/array&gt;
    &lt;/field&gt;
    &lt;field name = "structArray"&gt;
        &lt;type&gt;
            &lt;array&gt;
                &lt;structure name = "DisplayLimit /&gt;
            &lt;/array&gt;
        &lt;/type&gt;
    &lt;/field&gt;</pre>

<p>Then the following all perform the same initialization:</p>
<pre>    &lt;intArray capacity = "3" &gt;
        &lt;value&gt;0.0, 1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray capacity = "3" offset = "1"&gt;
        &lt;value&gt;1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray&gt;
        &lt;value&gt;0.0&lt;/value&gt;
        &lt;value&gt;1.0&lt;/value&gt;
        &lt;value&gt;2.0&lt;/value&gt;
    &lt;/intArray&gt;
         </pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray capacity = "2"&gt;
        &lt;value&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
        &lt;value&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
    &lt;/structArray&gt;</pre>

<h3 id="menu">menu</h3>

<p>A menu field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;stringValue&lt;/fieldName&gt;</pre>
where stringValue is one of the allowed values for the menu.

<p>For example:</p>
<pre>    &lt;scan&gt;periodic&lt;/scan&gt;</pre>

<p>Again supportName is optional.</p>

<h3 id="enumerated">enumerated</h3>

<p>An enumerated field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;choice&gt;choice&lt;/choice&gt;
        stringValue
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support</dd>
  <dt style="font-family: courier;">choice</dt>
    <dd>A choice string. One of these must be specified for each choice.</dd>
  <dt style="font-family: courier;">stringValue</dt>
    <dd>one of the allowed values for the enum.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;enumExample&gt;
         &lt;choice&gt;zeroState&lt;/choice&gt;
         &lt;choics&gt;oneState&lt;/choice&gt;
         oneState
    &lt;/enumExample&gt;</pre>

<h3 id="link">link</h3>
A link field is initialized as follows:
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;configure structureName = "supportStructureName"&gt;
            &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
            ...
        &lt;/configure&gt;
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of one of the <span
      style="font-family: courier;">support</span> definitions</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of the support structure given with the support
    definition</dd>
  <dt style="font-family: courier;">fieldValue</dt>
    <dd>The value for the structure field.<br />
    </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Database">XML to Database Converter</h2>
<hr />

<p><span style="font-weight:bold;">NOTE</span> : To create definitions for an
IOC, use org.epics.ioc.util.IOCFactory.initDatabase instead of directly
calling XMLToIOCDBFactory. initDatabase calls XMLToIOCDBFactory and also
initializes all support. Database instances should not be added to the master
IOCDB unless all support initializes and starts correctly.</p>

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbd, IOCDB iocdb, String fileName,
            Requester requester);
        public static IOCDB convert(String iocdbName,String fileName,
            Requester requester);
    }
  </pre>
<dl>
  <dt style="font-family: courier;">convert(DBD dbd, IOCDB iocdb, String
  fileName, Requester requester)</dt>
    <dd>Parse an xml file conaining record instance definitions and put the
      resulting record instances into an IOC database.</dd>
  <dt style="font-family: courier;">convert(String iocdbName,String fileName,
  Requester requester)</dt>
    <dd>Create an IOC Database (IOCDB) with name iocdbName and populate it
      with definitions from an XML file. The definitions are not added to the
      master IOCDB but the caller can call IOCDB.mergeIntoMaster to add them
      to master. The DBD database is named master. Attempting to add
      definitions for a record instance that is already in master is an
    error.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">iocdb</dt>
    <dd>The database that holds the record instances.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">requester</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">iocdbName</dt>
    <dd>The name of the IOCDB into which definitions are created.</dd>
</dl>

<p>For an IOC convert should be used to create record instances. This can be
done during IOC initialization or after an IOC is running, i.e. on-line add
of new record instances is supported. Only one user at a time is allowed to
call convert or convert. If XMLToIOCDBFactory is busy when another call is
made an error is generated and nothing is done. Both methods are thread
safe.</p>
<hr />

<h2 style="text-align: center" id="Database1">Database Access</h2>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc.</p>

<p>Each DBField interface provides access to a corrseponding PVField
interface and in addition provide access to support and implement monitoring,
i.e.DBField provides the following features:</p>
<ul>
  <li>Access to support.<br />
    PVField provides the name of support code. DBdata provides access to the
    support itself.</li>
  <li>Monitoring.<br />
    This is implemented via the DBListener interface.</li>
  <li>Access to the associated PVField interface.</li>
</ul>

<p>In addition DBRecord provides the following features:</p>
<ul>
  <li>Record locking.<br />
    Whenever code accesses any part of a record instance it must be locked.
    DBRecord provides the lock.</li>
  <li>Access to RecordProcess.<br />
    During ioc initialization an instance of RecordProcess created for each
    record instance.</li>
  <li>Monitoring.<br />
    DBField and DBRecord are both involved with monitoring.</li>
  <li>Location of the IOCDB and DBD to which this record instance
  belongs.</li>
</ul>

<h3 id="Listener">Listener Interface</h3>

<h4 id="DBListener">DBListener</h4>

<p>DBListener is an interface that must be implemented by code that calls
DBdata.addListener, which is a request to be notified whenever a field
changes value. A request can be made for any field including structure fields
or even a record instance. If the request is made for a structure field then
the requester will be notified whenever any field of the structure changes
value.</p>

<p>DBListener has the definition:</p>
<pre>    public interface DBListener {
        void dataPut(DBField dbField);
        void enumIndexPut(DBEnum dbEnum);
        void enumChoicesPut(DBEnum dbEnum);
        void supportNamePut(DBField dbField);
        void configurationStructurePut(DBLink dbLink);
        void beginPut(DBStructure dbStructure);
        void endPut(DBStructure dbStructure);
        void dataPut(DBField requested,DBField dbField);
        void enumIndexPut(DBField requested,DBEnum dbEnum);
        void enumChoicesPut(DBField requested,DBEnum dbEnum);
        void supportNamePut(DBField requested,DBField dbField);
        void configurationStructurePut(DBField requested,DBLink dbLink);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }</pre>
where
<dl>
  <dt style="font-family: courier;">dataPut</dt>
    <dd>A data put has occured. This will not be called for enum, menu, or
      link fields.</dd>
  <dt style="font-family: courier;">enumIndexPut</dt>
    <dd>A put to the index field of an enum or menu has occured.</dd>
  <dt style="font-family: courier;">enumChoicesPut</dt>
    <dd>The put to the choices of an enum has occured.</dd>
  <dt style="font-family: courier;">supportNamePut</dt>
    <dd>The support name has been changed.</dd>
  <dt style="font-family: courier;">configurationStructurePut</dt>
    <dd>The configuration structure of a link field has been changed.</dd>
  <dt style="font-family: courier;">beginPut</dt>
    <dd>A series of puts to a structure is starting.</dd>
  <dt style="font-family: courier;">endPut</dt>
    <dd>A series of puts to a structure has completed.</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>The record is starting processing.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>The record has completed processing.</dd>
  <dt style="font-family: courier;">unlisten</dt>
    <dd>The data source is undergoing destruction or major structural
      changes. The DBField.addListener call is no longer valid and the user
      should null the object reference returned by addListener.</dd>
</dl>

<p>For dataPut,...,configurationStructurePut two versions are provided. The
first is called if the listener attaches directly the the field that is being
modified. The second version is called if the caller attaches to a structure
that has the field located somewhere in it. The PVStructure argument is the
structure to which the listener attached. Not in particular that the listener
can listen to all changes in a record instance by attaching to the record
instance itself, because it is also a PVStructure.</p>

<p>Assume that a field named value has properties status and severity. Then
when the record is processed and field value is written then the following
calls might occur:</p>
<ul>
  <li>beginProcess</li>
  <li>dataPut for value</li>
  <li>dataPut for status</li>
  <li>enumIndexPut for severity</li>
  <li>endProcess</li>
</ul>

<h4 id="RecordList">RecordListener</h4>

<p>RecordListener is an interface that is implemented by the code that
implements DBRecord. This is normally class DBRecordBase. DBRecord provides a
method to create a RecordListener. See class FieldDataFactory and
DBRecordBase for details. The definition of RecordListener is:</p>
<pre>    public interface RecordListener {
        DBListener getDBListener();
    }</pre>

<p>At the end of this document is a example implementation of DBListener.</p>

<h3 id="DBField">DBField</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        void addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        List&lt;RecordListener&gt; getRecordListenerList();
        String toString();
        String toString(int indentLevel);
    }

    public class BaseDBField implements DBField{ ... }</pre>

<p>where</p>
<dl>
  <dt>getDBRecord</dt>
    <dd>Return the DBRecord interface for the record instance.</dd>
  <dt>getParent</dt>
    <dd>Return the DBField interface of the parent.</dd>
  <dt>getPVField</dt>
    <dd>Get the PVField interface that hold the data for the field.</dd>
  <dt>replacePVField</dt>
    <dd>Replace the PVField.</dd>
  <dt>getSupportName</dt>
    <dd>Just gets the associated PVField bsupportName.</dd>
  <dt>setSupportName</dt>
    <dd>This connects the field to associated support and also handles
      support initialization.</dd>
  <dt>getSupport</dt>
    <dd>Get the support for this field. This returns null if no support
      exists.</dd>
  <dt>setSupport</dt>
    <dd>Set the support for the field. It can be null.</dd>
  <dt>postPut</dt>
    <dd>This is called by code that puts to the PVField associated with the
      field. It implements monitoring.</dd>
  <dt>addListener</dt>
    <dd>Add a monitor listener. The RecordListener interface must be created
      by calling DBRecord.createRecordListener. If the DBField is a structure
      field the listener will be called when any field in the structure is
      modified.</dd>
  <dt>removeListener</dt>
    <dd>Remove a listener.</dd>
  <dt>getRecordListenerList</dt>
    <dd>Get a list of all the record listeners.</dd>
</dl>

<h3 id="DBEnum">DBEnum</h3>
<pre>    public interface DBEnum extends DBField {
        PVEnum getPVEnum();
        void replacePVEnum();
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }

    public class BaseDBEnum extends BaseDBField implements DBEnum {...}</pre>

<p>where</p>
<dl>
  <dt>getPVEnum</dt>
    <dd>Get the PVEnum interface that hold the data.</dd>
  <dt>replacePVEnum</dt>
    <dd>Replace the PVEnum interface.</dd>
  <dt>getIndex</dt>
    <dd>Get the current index. This method calls the associated PVField
      method.</dd>
  <dt>setIndex</dt>
    <dd>This method calls the associated PVField method AND also calls
      dbListener.enumIndexPut for all registered listeners.</dd>
  <dt>setChoices</dt>
    <dd>Get the current choices. This method just calls the associated
      PVField method.</dd>
  <dt>setIndex</dt>
    <dd>This method calls the associated PVField method AND also calls
      dbListener.enumChoicesPut for all registered listeners.</dd>
  <dt>getPVEnum</dt>
    <dd>Get the associated PVEnum interface</dd>
</dl>

<h3 id="DBMenu">DBMenu</h3>
<pre>    public interface DBMenu extends DBEnum {
        PVMenu getPVMenu();
        void replacePVMenu();
    }

    public class BaseDBMenu extends BaseDBEnum implements DBMenu{ ... }</pre>

<p>This is like PVEnum except that it will not allow the choices to be
modified.</p>

<h3 id="DBLink">DBLink</h3>

<p>A link is a field with no data but can have an associated configuration
structure.</p>
<pre>    public interface DBLink extends DBField{
        PVLink getPVLink();
        void replacePVLink();
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }

    public class BaseDBLink extends BaseDBField implements DBLink { ... }</pre>

<p>where</p>
<dl>
  <dt>getPVLink</dt>
    <dd>Get the associated PVLink interface.</dd>
  <dt>replacePVLink</dt>
    <dd>Replace the PVLink interface.</dd>
  <dt>getConfigurationStructure</dt>
    <dd>Get the interface for the configuration structure.</dd>
  <dt>setConfigurationStructure</dt>
    <dd>In any support is already active the support is forced to state
      readyForInitialize. Then the configuration structure is modified and an
      attempt is made to put the link support in the same supportState as the
      record itself.</dd>
  <dt>newSupport</dt>
    <dd>Stop existing support and connect and start the speecified
    support.</dd>
</dl>

<h3 id="DBStructur">DBStructure</h3>
<pre>    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        void replacePVStructure();
        DBField[] getFieldDBFields();
        void beginPut();
        void endPut();
    }

    public class BaseDBStructure extends BaseDBField implements DBStructure{ ... }</pre>

<p>where</p>
<dl>
  <dt>getPVStructure</dt>
    <dd>Get the associated PVStructure interface.</dd>
  <dt>replacePVStructure</dt>
    <dd>Replace the PVStructure interface.</dd>
  <dt>getFieldDBFields</dt>
    <dd>Get the DBField array for the subfields.</dd>
  <dt>beginPut</dt>
    <dd>Begin a set of puts to subfields of the structure.</dd>
  <dt>endPut</dt>
    <dd>End a set of puts to subfields of the structure.</dd>
</dl>

<h3 id="DBNonScala">DBNonScalarArray</h3>
<pre>    public interface DBNonScalarArray extends DBField{
        void replacePVArray();
        DBField[] getElementDBFields();
    }

    public class BaseDBNonScalarArray extends BaseDBField implements DBNonScalarArray{...}</pre>

<p>where</p>
<dl>
  <dt>replacePVArray</dt>
    <dd>Replace the PVArray interface.</dd>
  <dt>getElementDBFields</dt>
    <dd>Get the DBField array for the elements.</dd>
</dl>

<h3 id="DBRecord">DBRecord</h3>
<pre>    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void removeRecordListeners();
        void addListenerSource(BaseDBField dbField);
        DBD getDBD();
        void setDBD(DBD dbd);
        IOCDB getIOCDB();
        void setIOCDB(IOCDB iocdb);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">findDBField</dt>
    <dd>Given a PVField find the DBField that references it.</dd>
  <dt style="font-family: courier;">getPVRecord</dt>
    <dd>Get the PVRecord this DBRecord references.</dd>
  <dt style="font-family: courier;">getDBStructure</dt>
    <dd>Get the DBStructure for this DBRecord.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the record. The record must be locked for record processing and
      whenever the data of any field in a record is accessed.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the record.</dd>
  <dt style="font-family: courier;">lockOtherRecord</dt>
    <dd>While holding the lock for this record lock another record. The lock
      for the cxurrent record might be unlocked while this call is active but
      upon retirn both record will be locked. The caller must unlock both
      records when the caller is done. Normally it unlocks the other record,
      via it's unlock method, first.</dd>
  <dt style="font-family: courier;">getRecordProcess</dt>
    <dd>Get the interface of the RecordProcess for this instance.</dd>
  <dt style="font-family: courier;">setRecordProcess</dt>
    <dd>Set the RecordProcess inyerface for this record instance.</dd>
  <dt style="font-family: courier;">getRecordID</dt>
    <dd>Normally only called by DBRecord.lock. Each record instance is
      assigned a unique id.</dd>
  <dt style="font-family: courier;">createRecordListener</dt>
    <dd>Create a RecordListener. The listener is called when record
      processing starts and when it completes. The record listener can also
      be used to call DBField.addListener.</dd>
  <dt style="font-family: courier;">removeRecordListener</dt>
    <dd>Remove a record listener. This will also call removeListener for all
      DBFields that have this listener attached.</dd>
  <dt style="font-family: courier;">removeRecordListeners</dt>
    <dd>Remove all listeners. This is called if a record insance is being
      removed or if it's structure is being changed.</dd>
  <dt style="font-family: courier;">addListenerSource</dt>
    <dd>Add a listener source. Used for communication between
      DBRecordBase.java and BaseDBField. BaseDBField calls this the first
      time DBField.addListener is called. It should not be called by other
      code.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the DBD that this record instance uses. See package
      org.epics.ioc.dbDefinition for an explaination of a DBD.</dd>
  <dt style="font-family: courier;">setDBD</dt>
    <dd>Set the DBD that this record instance uses.</dd>
  <dt style="font-family: courier;">getIOCDB</dt>
    <dd>Get the IOCDB that holds this record instance.</dd>
  <dt style="font-family: courier;">setIOCDB</dt>
    <dd>Set the IOCDB that holds this record instance. Note that this changes
      after record initialization.</dd>
</dl>

<h3 id="DBREcordFa">DBREcordFactory</h3>

<p>A factory is available that implements the DBField interfaces for record
instance fields.</p>
<pre>    public class DBRecordFactory {
        public static DBRecord create(PVRecord pvRecord);
    }</pre>

<p>Base classes are available for implementing the PVField interfaces for
database fields. These classes are used by DBDataFactory and can also be used
by code that wants to provide special implementations of database fields. Any
code that wants to provide its own implementation should extend
AbstractPVArray, AbstractPVField or one of the BasePVxxx classes and then
replace the PV associated with a DB.</p>
<hr />

<h2 style="text-align: center" id="IOCDB">IOCDB: IOC Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC. All methods IOCDBFactory are thread
safe. The instances of IOCDB created by IOCDBFactory are also thread safe.
ReadWrite locks are used to implement thread safety.</p>
<pre>    public interface IOCDBMergeListener {
        void merged();
    }

    public interface IOCDB {
        IOCDB getMaster();
        String getName();
        void mergeIntoMaster();
        void addIOCDBMergeListener(IOCDBMergeListener listener);
        DBRecord findRecord(String recordName);
        boolean addRecord(DBRecord record);
        boolean removeRecord(DBRecord record);
        Map&lt;String,DBRecord&gt; getRecordMap();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String recordList(String regularExpression);
        String recordToString(String regularExpression);
    }

    public class IOCDBFactory {
        public static IOCDB create(String name);
        public static IOCDB getMaster();
    }
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">merged</dt>
    <dd>A listener method that is called after the database has been merged
      into the master IOC database.</dd>
  <dt style="font-family: courier;">getName</dt>
    <dd>The IOC database Name.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the Database Definition database that this DBD uses.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge the record instances from this database into the master
      database.</dd>
  <dt style="font-family: courier;">addIOCDBMergeListener</dt>
    <dd>Add a listener to call after this database has been merged into the
      master IOC database. If this is the master than the listener is called
      immediately.</dd>
  <dt style="font-family: courier;">findRecord</dt>
    <dd>Return the interface for the record with name recordName or null if
      the record is not found. A search is made this database. If not found
      and a master database exists than it is also serched.</dd>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add a record instance. (false,true) is returned if the instance (was
      not,was) added to the database. A record is not added if it already
      exists in this database or in the master database.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove the record. (false,true) is returned if the record (was
      not,was) removed.</dd>
  <dt style="font-family: courier;">getRecordMap</dt>
    <dd>Get a shallow copy of the map of all record instances in this
      database. A copy is returned to ensure thread safety.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Report a message. If no listeners are registered the messages are
      sent to System.out. If listeners are registered they are called.</dd>
  <dt style="font-family: courier;">addMessageListener</dt>
    <dd>Add a message listener.</dd>
  <dt style="font-family: courier;">removeMessageListener</dt>
    <dd>Remove a message listener.</dd>
  <dt style="font-family: courier;">createAccess</dt>
    <dd>Create a DBAccess. See below for a description of IOC Database
    Access.</dd>
  <dt style="font-family: courier;">recordList</dt>
    <dd>Return a string that contains a list if all record names that match
      the regular expression.</dd>
  <dt style="font-family: courier;">recordToString</dt>
    <dd>Return a dump of all record instances with names that match the
      regular expression.</dd>
</dl>

<p>IOCDBFactory is a class that manages IOCDB databases.</p>

<p>The methods are:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create an IOCDB or return the master IOCDB if the name is
    "master".</dd>
  <dt style="font-family: courier;">getMaster</dt>
    <dd>Get the master IOC Database, i.e. the database with name
    "master".</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes BaseDBField and DBRecordBase provide support for implementing
database monitors, i.e. support for notifying a client whenever a field of a
database instance changes value.</p>

<p>A client must implement the interface DBListener. A client can listen to
an arbitrary number of fields in a record. It must first obtain a Listen
interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    DBListener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbField.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy.
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>public class DBListenerForTesting implements DBListener{
    private RecordListener listener;
    private String pvName = null;
    private boolean verbose;
    private String actualFieldName = null;
    private boolean isProcessing = false;
    private String fullName = null;

    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName,
        boolean monitorProperties,boolean verbose)
    {
        this.pvName = pvName;
        this.verbose = verbose;
        DBRecord dbRecord = iocdb.findRecord(recordName);
        PVRecord pvRecord = dbRecord.getPVRecord();
        if(pvRecord==null) {
            System.out.printf("record %s not found%n",recordName);
            return;
        }
        PVAccess pvAccess = PVAccessFactory.createPVAccess(pvRecord);
        PVField pvField;
        if(pvName==null || pvName.length()==0) {
            pvField = pvAccess.getPVRecord();
        } else {
            if(pvAccess.findField(pvName)!=AccessSetResult.thisRecord){
                System.out.printf("name %s not in record %s%n",pvName,recordName);
                System.out.printf("%s\n",pvAccess.getPVRecord().toString());
                return;
            }
            pvField = pvAccess.getField();
        }
        actualFieldName = pvField.getField().getFieldName();
        fullName = pvField.getPVRecord().getRecordName() + pvField.getFullFieldName();
        listener = dbRecord.createRecordListener(this);
        DBField dbField = dbRecord.findDBField(pvField);
        dbField.addListener(listener);
        if(monitorProperties) {
            if(pvField.getField().getType()!=Type.pvStructure) {
                Property[] property = pvField.getField().getPropertys();
                DBField propertyField;
                for(Property prop : property) {
                    pvAccess.setPVField(pvField);
                    if(pvAccess.findField(prop.getPropertyName())!=AccessSetResult.thisRecord){
                        System.out.printf("name %s not in record %s%n",pvName,recordName);
                        System.out.printf("%s\n",pvAccess.getPVRecord().toString());
                    } else {
                        propertyField = (DBField)dbRecord.findDBField(pvAccess.getField());
                        propertyField.addListener(listener);
                    }
                }
            }
        }
    }

    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName)
    {
        this(iocdb,recordName,pvName,true,true);
    }

    private String putCommon(String message) {
        if(!verbose) {
            return fullName + " ";
        }
        return String.format("%s %s isProcessing %b pvName %s actualFieldName %s%n",
            message,
            fullName,
            isProcessing,
            pvName,
            actualFieldName);
    }
    public void beginProcess() {
        isProcessing = true;
        putCommon("beginProcess");
    }
    public void endProcess() {
        putCommon("endProcess");
        isProcessing = false;
    }
    public void beginPut(DBStructure dbStructure) {
        PVStructure pvStructure = dbStructure.getPVStructure();
        if(!verbose) return;
        String name = pvStructure.getPVRecord().getRecordName() + pvStructure.getFullFieldName();
        System.out.println("beginPut " + name);
    }
    public void endPut(DBStructure dbStructure) {
        PVStructure pvStructure = dbStructure.getPVStructure();
        if(!verbose) return;
        String name = pvStructure.getPVRecord().getRecordName() + pvStructure.getFullFieldName();
        System.out.println("endPut " + name);
    }
    public void endPut(DBStructure dbStructure) {
        PVStructure pvStructure = dbStructure.getPVStructure();
        if(!verbose) return;
        String name = pvStructure.getPVRecord().getRecordName() + pvStructure.getFullFieldName();
        System.out.println("endPut " + name);
    }
    public void dataPut(DBField dbField) {
        PVField pvField = dbField.getPVField();
        String common = putCommon("dataPut");
        if(!verbose) {
            System.out.println(common + dbField.toString(1));
            return;
        }
        String name = pvField.getPVRecord().getRecordName() + pvField.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s%s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s = %s%n",
            common,name,dbField.toString(2));
    }
    public void enumChoicesPut(DBEnum dbEnum) {
        PVEnum pvEnum = dbEnum.getPVEnum();
        String common = putCommon("enumChoicesPut");
        if(!verbose) {
            System.out.println(common + pvEnum.toString(1));
            return;
        }
        String name = pvEnum.getPVRecord().getRecordName() + pvEnum.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s %s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s = %s%n",
            common,name,pvEnum.toString(2));
    }
    public void enumIndexPut(DBEnum dbEnum) {
        PVEnum pvEnum = dbEnum.getPVEnum();
        String common = putCommon("enumChoicesPut");
        if(!verbose) {
            System.out.println(common + pvEnum.toString(1));
            return;
        }
        String name = pvEnum.getPVRecord().getRecordName() + pvEnum.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s %s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s index = %d%n",
            common,name,pvEnum.getIndex());
    }
    public void supportNamePut(DBField dbField) {
        PVField pvField = dbField.getPVField();
        String common = putCommon("supportNamePut");
        String name = pvField.getPVRecord().getRecordName() + pvField.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s %s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s = %s%n",
            common,name,pvField.getSupportName());
    }
    public void configurationStructurePut(DBLink dbLink) {
        PVLink pvLink = dbLink.getPVLink();
        System.out.printf("configStructPut pvName %s actualField %s%s%n",
            pvName,actualFieldName,pvLink.getConfigurationStructure().toString(2));
    }
    public void dataPut(DBField requested, DBField dbField) {
        PVField pvRequested = requested.getPVField();
        PVField pvField = dbField.getPVField();
        String structureName =
            pvRequested.getPVRecord().getRecordName()
            + pvRequested.getFullFieldName();
        String common = putCommon(structureName +" dataPut to field " + pvField.getFullFieldName());
        System.out.printf("%s    = %s%n",common,pvField.toString(2));
    }
    public void enumChoicesPut(DBField requested,DBEnum dbEnum) {
        PVField pvRequested = requested.getPVField();
        PVEnum pvEnum = dbEnum.getPVEnum();
        String structureName =
            pvRequested.getPVRecord().getRecordName()
            + pvRequested.getFullFieldName();
        String common = putCommon(structureName +" enumChoicesPut to field " + pvEnum.getFullFieldName());
        System.out.printf("%s    = %s%n",common,pvEnum.toString(2));
    }
    public void enumIndexPut(DBField requested,DBEnum dbEnum) {
        PVField pvRequested = requested.getPVField();
        PVEnum pvEnum = dbEnum.getPVEnum();
        String structureName =
            pvRequested.getPVRecord().getRecordName()
            + pvRequested.getFullFieldName();
        String common = putCommon(structureName +" enumIndexPut to field " + pvEnum.getFullFieldName());
        System.out.printf("%s    index = %d%n",common,pvEnum.getIndex());
    }
    public void supportNamePut(DBField requested,DBField dbField) {
        PVField pvRequested = requested.getPVField();
        PVField pvField = dbField.getPVField();
        String structureName =
            pvRequested.getPVRecord().getRecordName()
            + pvRequested.getFullFieldName();
        String common = putCommon(structureName +" supportNamePut to field " + pvField.getFullFieldName());
        System.out.printf("%s    = %s%n",common,pvField.getSupportName());
    }
    public void configurationStructurePut(DBField requested,DBLink dbLink) {
        PVLink pvLink = dbLink.getPVLink();
        System.out.printf("configStructPut pvName %s actualField %s%s%n",
            pvName,actualFieldName,pvLink.getConfigurationStructure().toString(2));
    }
    public void unlisten(RecordListener listener) {
        // Nothing to do.
    }
</pre>

<p>In order for the listen support to work support that implements the
DBRecord interface must extend AbstractDBRecord and support that implements
any other DB field interface must extend AbstractDBdata. In addition any code
that implements a put methods must call</p>
<pre>    postPut();</pre>

<p>whenever the put method is called. It must call postPut whenever if
modifies its internal data for the field. It must call postPut even if the
new value is the same as the old value.</p>
<hr />

<h2 style="text-align: center" id="Thread">Thread Safety</h2>
<hr />
The dbAccess components are designed to be used in an IOC, which is a
multithreaded environment. The design includes:
<dl>
  <dt>XMLToIOCDBFactory</dt>
    <dd>This is thread safe because only one user at a time can be using it.
      If a call to XMLToIOCDBFactory.convert is made while it is alreadty
      busy, a fatal error message is sent to the caller and convert
    returns.</dd>
  <dt>IOCDB</dt>
    <dd>All methods are thread safe.</dd>
  <dt>Record Instance interfaces.</dt>
    <dd>While accessing fields of a record instance the instance must be
      locked. This means that DBRecord.lock must be called before accessing
      fields and DBRecord.unlock must be called after the caller is done. See
      package org.epics.ioc.dbProcess for more details about record
      processing.</dd>
</dl>
</body>
</html>
