<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.db <br />
2008.08.27</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database XML Syntax</a>
    <ul>
      <li><a href="#namespace">namespace</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#field">field</a>
        <ul>
          <li><a href="#Primitive">Primitive Types</a></li>
          <li><a href="#string">string</a></li>
          <li><a href="#structure1">structure</a></li>
          <li><a href="#array">array</a></li>
        </ul>
      </li>
      <li><a href="#field1">field attribute</a></li>
      <li><a href="#create">create</a></li>
      <li><a href="#support">support</a></li>
      <li><a href="#record">record</a></li>
      <li><a href="#field2">field definition</a></li>
      <li><a href="#field3">field creation</a></li>
      <li><a href="#field4">field initialization</a></li>
      <li><a href="#Primitive1">Primitive Types</a></li>
      <li><a href="#string1">string</a></li>
      <li><a href="#structure2">structure</a></li>
      <li><a href="#array1">array</a></li>
      <li><a href="#Macro">Macro Substitution and Include</a>
        <ul>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro1">Macro Substitution</a></li>
          <li><a href="#Example">Example Include and Macro
          Substitution</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Database1">XML to Database Converter</a></li>
  <li><a href="#Introspect">Introspection of Database Definitions</a>
    <ul>
      <li><a href="#DBDStructu">DBDStructure</a></li>
      <li><a href="#DBDCreate">DBDCreate</a></li>
      <li><a href="#DBDSupport">DBDSupport</a></li>
    </ul>
  </li>
  <li><a href="#Accessing">Accessing Database Definitions</a>
    <ul>
      <li><a href="#DBD">DBD</a></li>
    </ul>
  </li>
  <li><a href="#Creating">Creating Database Definitions</a>
    <ul>
      <li><a href="#DBDFactory">DBDFactory</a></li>
      <li><a href="#Creating1">Creating Database Definitions</a></li>
    </ul>
  </li>
  <li><a href="#Database2">Database Access</a>
    <ul>
      <li><a href="#Listener">Listener Interfaces</a>
        <ul>
          <li><a href="#DBListener">DBListener</a></li>
          <li><a href="#RecordList">RecordListener</a></li>
        </ul>
      </li>
      <li><a href="#DBField">DBField</a></li>
      <li><a href="#DBStructur">DBStructure</a></li>
      <li><a href="#DBArray">DBArray</a></li>
      <li><a href="#DBStructur1">DBStructureArray</a></li>
      <li><a href="#DBArrayArr">DBArrayArray</a></li>
      <li><a href="#DBRecord">DBRecord</a></li>
      <li><a href="#DBRecordFa">DBRecordFactory</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB">IOCDB: IOC Database</a>
    <ul>
      <li><a href="#Master">Master IOCDB</a></li>
      <li><a href="#IOCDB1">IOCDB</a></li>
    </ul>
  </li>
  <li><a href="#Rules">Rules for modifying PV data</a>
    <ul>
      <li><a href="#Modifying">Modifying Data Only</a></li>
      <li><a href="#Modifying1">Modifying Structure</a></li>
    </ul>
  </li>
  <li><a href="#Listener1">Listener Support</a></li>
  <li><a href="#Thread">Thread Safety</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. In addition to record instances the database holds a
set of Database Definitions (DBD) for the following: structure, create, and
support.</p>

<p>The following is discussed:</p>
<ol>
  <li>Database Definition Syntax.<br />
    The XML syntax for defining a structure, create, support, or record
    instance. In addition macro substitution and include are available.</li>
  <li>An XML to database converter.<br />
    Parses xml files containing database definitions puts them in an IOC
    database.<br />
  </li>
  <li>Creating and using structure, create, and support Database
  Definitions.</li>
  <li>Database Access.<br />
    Interfaces for record instances..</li>
  <li>Rules for modifying PV Data.</li>
  <li>Listen Support.<br />
    A description of the support for monitoring changes to the data in
    database instances fields.<br />
  </li>
</ol>
<hr />

<h2 style="text-align: center" id="Database">Database XML Syntax</h2>
<hr />
An JavaIOV database file must be an XML file with a root tag of IOCDatabase: 
<pre>    &lt;?xml version="1.0" ?&gt;
    &lt;IOCDatabase&gt;
      &lt;?-- valid structure, create, support, and record Definitions --&gt;
    &lt;/IOCDatabase&gt;</pre>

<h3 style="text-align:center;" id="namespace">namespace</h3>
At this time namespaces are not used. 

<h3 style="text-align:center;" id="structure">structure</h3>

<p>Structure defines a data structure containing fields. A record instance is
a structure. A field of a structure can also be a structure.</p>

<p>A structure is defined as follows:</p>
<pre>&lt;structure name = "structureName" createName = "createName" supportName = "supportName" &gt;
     &lt;field name = "fieldName" createName = "createName"
         supportName = "supportName" type = "fieldType" ... /&gt;
     ...
&lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>The structure name.</dd>
  <dt style="font-family: courier;">createName</dt>
    <dd>The name of create for the structure or field. A create definition,
      described below, defines the create. When record instances are defined,
      the createName can be overridden.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the structure or field. A support definition,
      described below, defines the support. When record instances are
      defined, the default can be overridden.</dd>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>Should have the same syntax as a Java identifier, unique within the
      context of this particular structure.</dd>
  <dt><span style="font-family: courier">fieldType</span></dt>
    <dd>See fieldType below.</dd>
  <dt>...</dt>
    <dd>See field attribute below</dd>
</dl>

<h3 id="field">field</h3>
The syntax for <span style="font-family: courier">fieldType</span> depends on
the field type. 

<h4 id="Primitive">Primitive Types</h4>
Primitive types are the same as the Java primitive types, i.e. <span
style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>. For example 
<pre>     
    &lt;field name = "value", type = "double" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;</pre>

<h4 id="string">string</h4>
A <span style="font-family: courier">string</span> is a Java <span
style="font-family: courier;">String</span>. A <span
style="font-family: courier;">string</span> field type is just defined as
<span style="font-family: courier;">string</span>. For example: 
<pre>     &lt;field name = "description" type = "string" /&gt;</pre>

<h4 id="structure1">structure</h4>
A structure field is declared as 
<pre>    &lt;field name = "value" type = "structure" structureName = "name" /&gt;</pre>
<span style="font-family: courier;">structureName</span> is the name of a
structure which must have been previously defined. Example: 
<pre>   &lt;structure name = "point"&gt;
       &lt;field name = "x" type = "double" /&gt;
       &lt;field name = "y"&gt; type = "double" /&gt;
   &lt;/structure&gt;
   ...
   &lt;structure name = "haspoint"&gt;
       ...
       &lt;field name = "point" type = "structure" structureName = "point" /&gt;
       ...</pre>

<p>NOTE: The structureName does not have to be given. In this case the field
instance must define the structureName.</p>

<h4 id="array">array</h4>

<p>NOTE: One dimensional arrays are a supported type. Multidimensional arrays
can be supported via a <span style="font-family: courier;">structure</span>
definition with fields describing the number of dimensions and the attributes
of each dimension.</p>
An array is defined as follows: 
<pre>    &lt;field name = "value" type = "array" elementType = "type" capacity = "capacity" /&gt;</pre>
where 
<dl>
  <dt style="font-family: courier;">elementType</dt>
    <dd>The type must be a valid type, i.e. boolean, byte, short, int, long,
      float, double, string,enum, structure, array or link. This must be
      specified. If the elementType is structure than each element can be a
      different type of structure.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The number of array elements. If not specified the capacity is
      determined at record initialization</dd>
</dl>
Examples: 
<pre>     &lt;field name = "doubleArray" type = "array" elementType = "double" capacity = "3" /&gt;
     &lt;field name = "value" type = "array"  elementType = "double" /&gt;
     &lt;field name = "rectangle" type = "array" elementType = "structure" capacity = "2" /&gt;</pre>

<h3 id="field1">field attribute</h3>

<p>A field can have additional attributes which are specified via xml
attributes. Any xml key,value attribute that is not handled by the
XMLToDBDFactory becomes a field attribute. Two attributes that are recognized
by the javaIOC database are: </p>
<pre>     default = "stringValue"
     readonly = "booleanValue"
 </pre>

<p>The attribute parameter values have the following meanings:</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the fields is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
</dl>
The following examples show how attributes are defined: 
<pre>    &lt;structure name = "example"&gt;
        ...
        &lt;field name = "status" type = "string" readonly = "true" /&gt;
        &lt;field name = "displayLimit" structureName = "displayLimit" readonly = "true" /&gt;
        ...
        &lt;field name = "value" type = "double" default = "1.0" /&gt;
       ...
    &lt;/structure&gt;</pre>
<br />


<h3 style="text-align:center;" id="create">create</h3>

<p>Create can be associated with any field of a record instance when it is
created. See package org.epics.ioc.db for details. The syntax for a Create
definition is:</p>
<pre>    &lt;create name = "createName" factoryName = "factoryName" /&gt;</pre>
where 
<dl>
  <dt><span style="font-family: courier">create</span></dt>
    <dd>The tag.</dd>
  <dt><span style="font-family: courier">createName</span></dt>
    <dd>string that describes the create</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates create instances. See
      package org.epics.ioc.db for details,</dd>
</dl>

<h3 style="text-align:center;" id="support">support</h3>

<p>Support can be associated with any field of a record instance when it is
created. See package org.epics.ioc.db for details. Record types and
structures can have default support as shown above. The syntax for a support
definition is:</p>
<pre>    &lt;support name = "supportName" factoryName = "factoryName" /&gt;</pre>
where 
<dl>
  <dt><span style="font-family: courier">support</span></dt>
    <dd>The tag.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.process for details,</dd>
</dl>

<h3 style="text-align:center;" id="record">record</h3>

<p>The syntax for a record instance is:</p>
<pre>&lt;record name = "recordName" structureName = "structureName"  supportName = "supportName"&gt;
   &lt;!== field definition described below --&gt;
    ...
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span>, which must be
specified,is a string with a combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p><span style="font-family: courier">structureName</span>, which is
optional, is the name of a structure Database Definition (DBD). If not given
then the structureName is "generic" which is a structure with no fields and
generic support. Most record instances do not specify the structureName.
Instead they add the fields desired to the generic structure.</p>

<p><span style="font-family: courier">supportName</span>, which is optional,
is the name of support. If not given the supportName is either the
supportName specified in the structure definition or else generic. A support
definition with the supportName must be defined in a support DBD. If the same
record instance appears multiple times then then last supportName is used.</p>

<h3 id="field2">field definition</h3>

<p>A field is defined as follows:</p>
<pre> 
    &lt;fieldName supportName = "supportName" createName = "createName" ... &gt;
        &lt;!-- field initialization described below --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be specified. If
the structure within which this field is specified does not already have a
field with this name then a new field is created and appended to the end of
the structure. The details are descibed in the next section.</p>

<p><span style="font-family: courier;">supportName</span> and <span
style="font-family: courier;">createName</span> are both optional. If
specified then this definition overrides any value specified in the DBD
structure. If a field is defined multiple times than the last </p>

<p><span style="font-family: courier;">supportName</span> or <span
style="font-family: courier;">createName</span> definition determines the
final value.</p>

<p>For array fields additional XML attributes can appear, which are described
below.</p>

<h3 id="field3">field creation</h3>

<p>If <span style="font-family: courier;">fieldName</span> does not exist
then a new field can be created and appended to the end of the current
structure. In order to create a new field some combination of <span
style="font-family: courier">type</span>, <span
style="font-family: courier">structureName</span>, and <span
style="font-family: courier">elementType</span> must be specified. In this
case a new field will be appended to the end of the structure in which this
field appears. <span style="font-family: courier">type</span> can be any of
the supported types, i.e. <span style="font-family: courier">boolean</span>,
<span style="font-family: courier">byte</span>, ..., <span
style="font-family: courier">double</span>, <span
style="font-family: courier">structure</span>, <span
style="font-family: courier">array</span>. If <span
style="font-family: courier">type</span> is <span
style="font-family: courier">structure</span> then <span
style="font-family: courier">structureName</span> must be specified and must
be defined in the master DBD database. If the type is <span
style="font-family: courier">array</span> then <span
style="font-family: courier">elementType</span> must be defined and can be
any of the supported types.</p>

<p>For example:</p>
<pre>&lt;record name = "simple" &gt;
  &lt;value type = "double" /&gt;
&lt;/record&gt;</pre>

<p>Because the record definition does not specify a structureName, it starts
with the generic structure, which has no fields and generic support. Field
<span style="font-family: courier">value</span> does not exist so it is
created and appended to the structure. i.e. the record will have a single
field of type double and named "value".</p>

<p>Consider a more complex example:</p>
<pre>&lt;record name = "counter"&gt;
    &lt;value type = "double" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;input structureName = "calculation" &gt;
      &lt;calcArgArray&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double" &gt;0.0&lt;/value&gt;
            &lt;name&gt;min&lt;/name&gt;
        &lt;/element&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double" &gt;10.0&lt;/value&gt;
            &lt;name&gt;max&lt;/name&gt;
        &lt;/element&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double"&gt;0.5&lt;/value&gt;
            &lt;name&gt;inc&lt;/name&gt;
        &lt;/element&gt;
      &lt;/calcArgArray&gt;
      &lt;calculator&gt;
        &lt;expression&gt;(value+inc)&amp;lt;=max ? value+inc : min&lt;/expression&gt;
      &lt;/calculator&gt;
    &lt;/input&gt;
    &lt;scan structureName = "scan"&gt;
        &lt;type&gt;&lt;choice&gt;periodic&lt;/choice&gt;&lt;/type&gt;
        &lt;rate&gt;1.0&lt;/rate&gt;
    &lt;/scan&gt;
&lt;/record&gt;</pre>

<p>This record has the following fields:</p>
<dl>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>A value field with type double.</dd>
  <dt><span style="font-family: courier">timeStamp</span></dt>
    <dd>A structure that holds a time stamp.</dd>
  <dt><span style="font-family: courier">alarm</span></dt>
    <dd>An alarm structure which also has alarm support.</dd>
  <dt><span style="font-family: courier">input</span></dt>
    <dd>A structure for performing calculations. It contains a field
      calcArgArray which is a array of structures , where each structure
      defines an argument for the expression. The field calculator is a
      structure that has expressionCalculator support and a single field that
      is the expression to calculate.</dd>
  <dt><span style="font-family: courier">scan</span></dt>
    <dd>A structure with support that makes the record process
    periodicallly.</dd>
</dl>

<h3 id="field4">field initialization</h3>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3 id="Primitive1">Primitive Types</h3>

<p>For primitive types the initializer has the same format as the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value&gt;.98&lt;/value&gt;</pre>

<p>Note: For integer data types <span
style="font-family: courier">Long.decode</span> is used to convert a string
to a long, which is then converted to the final integer data type . Thus hex
values are allowed. Java does not allow the sign bit to be set. By converting
first to a long all interger types except long can have the sign bit set. For
example the byte value 0xff is allowed even though Java would raise an
exception if Byte.decode was used. The sign problem does exist for long
values.</p>

<h3 id="string1">string</h3>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h3 id="structure2">structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure definitions:</p>
<pre>    &lt;structure name = "doubleLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;

   &lt;structure name = "control"&gt;
     &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
     &lt;field name = "minStep" type = "double" /&gt;
   &lt;/structure&gt;</pre>

<p>limit is initilized as follows:.</p>
<pre>    &lt;control structureName = "control"&gt;
      &lt;limit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
      &lt;/limit&gt;
   &lt;/control&gt;</pre>

<p>It is permissible, in a database definition, to define a field to be a
structure without providing a structure name. In this case the default is
"generic" which is a structure with no fields and generic support.</p>

<p>The default structure and/or support can be overridden when a field
instance is defined. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" supportName = "supportName" &gt;</pre>

<h3 id="array1">array</h3>
The syntax for an array initializer is: 
<pre>    &lt;fieldName capacity = "capacity" capacityMutable = "trueFalse" length = "length" &gt;
        &lt;element offset = "offset"&gt;value&lt;/element&gt;
        &lt;element offset = "offset"&gt;valueList&lt;/element&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized. If
      the capacity is given a value &gt; 0 and capacityMutable is not
      specified then capacityMutable is set to true. </dd>
  <dt style="font-family: courier;">capacityMutable</dt>
    <dd>Can the capacity be changed?</dd>
  <dt style="font-family: courier;">length</dt>
    <dd>The initial length for the array.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">element</dt>
    <dd>assigns a value to an element of the array. If the array is an array
      of structures then the element definition allows the same attributes as
      the field definition for a structure. If the array is an array of
      arrays the element definition allows the same attributes as the field
      definition for an array.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
  <dt></dt>
</dl>

<p>The following all perform the same initialization:</p>
<pre>    &lt;intArray elementType = "double" capacity = "3" &gt;
        &lt;element&gt;0.0, 1.0, 2.0&lt;/element&gt;
    &lt;/intArray&gt;
    &lt;intArray elementType = "double" capacity = "3" offset = "1"&gt;
        &lt;element&gt;1.0, 2.0&lt;/element&gt;
    &lt;/intArray&gt;
    &lt;intArray elementType = "double"&gt;
        &lt;element&gt;0.0&lt;/element&gt;
        &lt;element&gt;1.0&lt;/element&gt;
        &lt;element&gt;2.0&lt;/element&gt;
    &lt;/intArray&gt;</pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray elementType = "structure" capacity = "2"&gt;
        &lt;element structureName = "doubleLimit" &gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/element&gt;
        &lt;element  structureName = "doubleLimit"&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/element&gt;
    &lt;/structArray&gt;</pre>

<h3 style="text-align:center;" id="Macro">Macro Substitution and Include</h3>

<h4 id="Include">Include</h4>
The XML file can include other files also containing Record Instance
Definitions. Included files can also include other files. The syntax is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4 id="Macro1">Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4 id="Example">Example Include and Macro Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record"&gt;
    &lt;value type = "double"/&gt;
    &lt;timeStamp structureName = "timeStamp"&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;input structureName = "linearConvertInput" &gt;
        &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;${pvname}&lt;/pvname&gt;
            &lt;wait&gt;true&lt;/wait&gt;
        &lt;/input&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/input&gt;
    &lt;display structureName = "display" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/display&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>
<hr />

<h2 style="text-align: center" id="Database1">XML to Database Converter</h2>
<hr />

<p><span style="font-weight:bold;">NOTE</span> : To create definitions for an
IOC, use org.epics.ioc.util.IOCFactory.initDatabase instead of directly
calling XMLToIOCDBFactory. initDatabase calls XMLToIOCDBFactory and also
initializes all support. Record instances should not be added to the master
IOCDB unless all support initializes and starts correctly.</p>

<p>The following reads an xml file and puts the result into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbd, IOCDB iocdb, String fileName,
            Requester requester);
        public static IOCDB convert(String iocdbName,String fileName,
            Requester requester);
    }</pre>
<dl>
  <dt style="font-family: courier;">convert(DBD dbd, IOCDB iocdb, String
  fileName, Requester requester)</dt>
    <dd>Parse an xml file conaining record instance definitions and put the
      resulting record instances into an IOC database.</dd>
  <dt style="font-family: courier;">convert(String iocdbName,String fileName,
  Requester requester)</dt>
    <dd>Create an IOC Database (IOCDB) with name iocdbName and populate it
      with definitions from an XML file. The definitions are not added to the
      master IOCDB but the caller can call IOCDB.mergeIntoMaster to add them
      to master. The DBD database is named master. Attempting to add
      definitions for a record instance that is already in master is an
    error.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">iocdb</dt>
    <dd>The database that holds the record instances.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">requester</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">iocdbName</dt>
    <dd>The name of the IOCDB into which definitions are created.</dd>
</dl>

<p>For an IOC convert should be used to create record instances. This can be
done during IOC initialization or after an IOC is running, i.e. on-line add
of new record instances is supported. Only one user at a time is allowed to
call convert or convert. If XMLToIOCDBFactory is busy when another call is
made an error is generated and nothing is done. Both methods are thread
safe.</p>
<hr />

<h2 style="text-align: center" id="Introspect">Introspection of Database
Definitions</h2>
<hr />

<p>This section describes support for code that accessses Database
Definitions: structure, create , and support.</p>

<p>The interfaces support reflection for Database Definitions. The interfaces
can be used by tools such as VDCT or on a running IOC database. The
interfaces are also used by record support, link support, and the database
itself.</p>

<h3 id="DBDStructu">DBDStructure</h3>

<p>The interface for introspecting an XML structure definition is:</p>
<pre>    interface DBDStructure extends Structure{}</pre>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(DBDStructure structure) {
        Field[] fields = structure.getFields();
        System.out.printf("structure %s {\n",structure.getStructureName();
        for(Field field : fields) {
            Type type = field.getType();
            System.out.printf("field %s type %s",
                field.getName(),type.toString());
        }
    }</pre>

<p>A shorter way is:</p>
<pre>    void dumpStructure(DBDStructure structure) {System.out.println(structure.toString);}</pre>

<h3 id="DBDCreate">DBDCreate</h3>

<p>The interface for introspecting an XML create definition is:</p>
<pre>    interface DBDCreate {
        String getCreateName();
        String getFactoryName();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getCreateName</dt>
    <dd>Get the create name.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.create for details about create and create factories.</dd>
</dl>

<h3 id="DBDSupport">DBDSupport</h3>

<p>The interface for introspecting an XML support definition is:</p>
<pre>    interface DBDSupport {
        String getSupportName();
        String getFactoryName();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.dbProcess for details about support and support
    factories.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Accessing">Accessing Database
Definitions</h2>
<hr />

<h3 id="DBD">DBD</h3>

<p>DBD is an interface for accessing a Database containing Database
Definitions. Methods are provided for accessing and inserting components. In
addition a number of "convenience" methods are provided.</p>
<pre>public interface DBD {
    String getName();
    DBD getMasterDBD();
    void mergeIntoMaster();
    DBDStructure createStructure(String name,
        Field[] field,FieldAttribute fieldAttribute);
    DBDCreate createCreate(String createName,String factoryName);
    DBDSupport createSupport(String supportName,String factoryName);
    DBDStructure getStructure(String structureName);
    boolean addStructure(DBDStructure structure);
    DBDStructure[] getDBDStructures();
    DBDCreate getCreate(String createName);
    boolean addCreate(DBDCreate create);
    DBDCreate[] getDBDCreates()
    DBDSupport getSupport(String supportName);
    boolean addSupport(DBDSupport support);
    DBDSupport[] getDBDSupports();
    String[] structureList(String regularExpression);
    String structureToString(String regularExpression);
    String[] createList(String regularExpression);
    String createToString(String regularExpression);
    String[] supportList(String regularExpression);
    String supportToString(String regularExpression);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The name of this DBD database.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Get the master DBD or null if no master was passed to
      DBDFactory.create. Normally this means that this is the master.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge this DBD into the master DBD. After merging into master the
      compoments are removed from this database.</dd>
  <dt style="font-family: courier;">createStructure</dt>
    <dd>Create a DBDStructure.</dd>
  <dt style="font-family: courier;">createCreate</dt>
    <dd>Create a DBDCreate.</dd>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create a DBDSupport.</dd>
  <dt style="font-family: courier;">getStructure</dt>
    <dd>Get the DBDStructure that describes the structureName</dd>
  <dt style="font-family: courier;">addStructure</dt>
    <dd>Add a structure definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getStructures</dt>
    <dd>Get an array of all the structure definitions. </dd>
  <dt style="font-family: courier;">getCreate</dt>
    <dd>Get the DBDCreate that describes createName.</dd>
  <dt style="font-family: courier;">addCreate</dt>
    <dd>Add a create definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getCreates</dt>
    <dd>Get an array of all the create definitions. </dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the DBDSupport that describes supportName.</dd>
  <dt style="font-family: courier;">addSupport</dt>
    <dd>Add a support definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getSupports</dt>
    <dd>Get an artray of all the support definitions.</dd>
</dl>
The remaining methods are convenience methods. Each convenience method
produces a string that lists or dumps all components with names that match a
regular expression. The java.util.regex facility is used. Consult it for a
definition of regular expressions. 
<dl>
  <dt style="font-family: courier;">structureList</dt>
    <dd>Return an array of strings that is the list of structure names that
      match a regular expression</dd>
  <dt style="font-family: courier;">structureToString</dt>
    <dd>Get a dump of all the DBDStructure definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">createList</dt>
    <dd>Return an array of strings that is the list of create names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">createToString</dt>
    <dd>Get a dump of all the DBDCreate definitions with names that match a
      regular expression.</dd>
  <dt style="font-family: courier;">supportList</dt>
    <dd>Return an array of strings that is the list of support names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">supportToString</dt>
    <dd>Get a dump of all the DBDSupport definitions with names that match a
      regular expression.</dd>
</dl>
An example of using a convience method is: 
<pre>    String[] list = master.menuList(".*[S].*");</pre>
Produces a list of all menu definitions that have an 'S" somewhere in the
menu name. 
<hr />

<h2 style="text-align: center" id="Creating">Creating Database
Definitions</h2>
<hr />
Two classes are provided for creation of DBD Databases: 
<ul>
  <li>DBDFactory<br />
    A factory to create and manage DBD databases.</li>
  <li>XMLToDBDFactory<br />
    A factory that reads xml Database Definitions and puts them into a DBD
    Database.</li>
</ul>

<h3 id="DBDFactory">DBDFactory</h3>

<p>DBDFactory is a class that creates DBD Databases. It provides the
following methods:</p>
<pre>public class DBDFactory {
    public static DBD create(String name);
    public static DBD getMasterDBD();
}
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a new DBD with the specified name. If the name is "master"
      than the master DBD is returned.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Return the master DBD. This is created automatically by
    DBDFactory</dd>
  <dt></dt>
  <dt>All methods of DBDFactory and of the DBD instances it creates are
  thread safe.</dt>
  <dt></dt>
</dl>

<h3 id="Creating1">Creating Database Definitions</h3>

<p>Before record instances can be created all structure, create, and support
definitions used by record instances must be created.</p>

<p>A running IOC always uses a DBD Database named "master" and an IOCDB also
named "master". The prefered way to create definitions by calling:</p>
<pre>    maxMessageType = IOCMessageType.info;
    DBD add = XMLToDBDFactory.create("add",fileName,this);
    if(maxMessageType!=IOCMessageType.info) // failure take appropriate action</pre>

<p>addToMaster will not add any definitions to master if any errors are
detected. It can be called during IOC initialization and also while an IOC is
running. For an IOC this is the only method required for generating Database
Definitions. Other code may decide to use DBDFactory.create instead.</p>

<p>All DBD methods are thread safe. In order to prevent race conditions:</p>
<ul>
  <li>DBD has a private readWrite lock that manages all access to its
  methods.</li>
  <li>Database components can be added but not removed from a DBD.</li>
  <li>All getXXXMap methods return shallow copies of the internal map.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Database2">Database Access</h2>
<hr />

<p>This section describes interfaces for accessing fields of record
instances. These interfaces are of interest to the database, support, Channel
Access, etc.</p>

<p>Each field has an interface DBField which provides the following
features:</p>
<ul>
  <li>Access to the associated PVField interface.</li>
  <li>Access to support and create.<br />
    PVField provides the name of support and/or create. DBField provides
    access to the support and/or create itself.</li>
  <li>Monitoring.<br />
    This is implemented via the DBListener interface.</li>
</ul>

<p>Each record instance has an interface DBRecord which provides the
following features:</p>
<ul>
  <li>Record locking.<br />
    Whenever code accesses any part of a record instance it must be locked.
    DBRecord provides the lock.</li>
  <li>Access to RecordProcess.<br />
    During ioc initialization an instance of RecordProcess created for each
    record instance.</li>
  <li>Monitoring.<br />
    DBField and DBRecord are both involved with monitoring.</li>
  <li>Location of the IOCDB and DBD to which this record instance
  belongs.</li>
</ul>

<h3 style="text-align:center;" id="Listener">Listener Interfaces</h3>

<h4 id="DBListener">DBListener</h4>

<p>DBListener is an interface that must be implemented by code that calls
DBField.addListener, which is a request to be notified whenever a field
changes value. A request can be made for any field including a structure
field. If the request is made for a structure field then the requester will
be notified whenever any field of the structure changes value. Since a record
instance is a structure it is possible to monitor all changes to a record
instance.</p>

<p>DBListener has the definition:</p>
<pre>    public interface DBListener {
        void dataPut(DBField dbField);
        void dataPut(DBField requested,DBField dbField);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }

    public abstract class AbstractDBListener implements DBListener{...}</pre>
where 
<dl>
  <dt style="font-family: courier;">dataPut</dt>
    <dd>A data put has occured.</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>The record is starting processing.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>The record has completed processing.</dd>
  <dt style="font-family: courier;">unlisten</dt>
    <dd>The data source is undergoing destruction or major structural
      changes. The DBField.addListener call is no longer valid and the user
      should null the object reference returned by addListener.</dd>
  <dt style="font-family: courier;">AbstractDBListener</dt>
    <dd>Implements each method by doing nothing. This is useful for code that
      listens to a field that is primitive ot an array of primitive types. In
      this case only the single argument dataPut needs to be implemented.</dd>
</dl>

<p>For dataPut two versions are provided. The first is called if the listener
attaches directly the the field that is being modified. The second version is
called if the caller attaches to a structure that has the field located
somewhere in it. The first argument is the structure or array to which the
listener attached. Not in particular that the listener can listen to all
changes in a record instance by attaching to the record instance itself.</p>

<p>Assume that a field named value has property alarm. Then when the record
is processed and field value is written then the following calls might
occur:</p>
<ul>
  <li>beginProcess</li>
  <li>dataPut for value</li>
  <li>dataPut for alarm</li>
  <li>endProcess</li>
</ul>

<h4 id="RecordList">RecordListener</h4>

<p>RecordListener is an interface that is implemented by the code that
implements DBRecord. This is normally class DBRecordBase. DBRecord provides a
method to create a RecordListener. See class FieldDataFactory and
DBRecordBase for details. The definition of RecordListener is:</p>
<pre>    public interface RecordListener {
        DBListener getDBListener();
    }</pre>

<p>At the end of this document is a example implementation of DBListener.</p>

<h3 style="text-align:center;" id="DBField">DBField</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Create getCreate();
        void setCreate(Create create);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        boolean addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDBRecord</dt>
    <dd>Return the DBRecord interface for the record instance.</dd>
  <dt style="font-family: courier;">getParent</dt>
    <dd>Return the DBField interface of the parent.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Get the PVField interface that hold the data for the field.</dd>
  <dt style="font-family: courier;">replacePVField</dt>
    <dd>Replace the PVField.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Just gets the associated PVField bsupportName.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>This connects the field to associated support and also handles
      support initialization.</dd>
  <dt style="font-family: courier;">getCreate</dt>
    <dd>Get the create for this field. This returns null if no create
    exists.</dd>
  <dt style="font-family: courier;">setCreate</dt>
    <dd>Set the create for the field. It can be null.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the support for this field. This returns null if no support
      exists.</dd>
  <dt style="font-family: courier;">setSupport</dt>
    <dd>Set the support for the field. It can be null.</dd>
  <dt style="font-family: courier;">postPut</dt>
    <dd>This is called by code that puts to the PVField associated with the
      field. It implements monitoring.</dd>
  <dt style="font-family: courier;">addListener</dt>
    <dd>Add a monitor listener. The RecordListener interface must be created
      by calling DBRecord.createRecordListener. If the DBField is a structure
      field the listener will be called when any field in the structure is
      modified.</dd>
  <dt style="font-family: courier;">removeListener</dt>
    <dd>Remove a listener.</dd>
</dl>

<h3 style="text-align:center;" id="DBStructur">DBStructure</h3>
<pre>    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        DBField[] getDBFields();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVStructure</dt>
    <dd>Get the associated PVStructure interface.</dd>
  <dt style="font-family: courier;">getDBFields</dt>
    <dd>Get the DBField array for the subfields.</dd>
</dl>

<h3 style="text-align:center;" id="DBArray">DBArray</h3>
<pre>    public interface DBArray extends DBField{
        PVArray getPVArray();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVArray</dt>
    <dd>Get the PVArray associated with this DBArray.</dd>
</dl>

<h3 id="DBStructur1">DBStructureArray</h3>
<pre>    public interface DBStructureArray extends DBArray {
        PVStructureArray getPVStructureArray();
        DBStructure[] getElementDBStructures();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVStructureArray</dt>
    <dd>Gert the PVStructureArray associated with the DBStructureArray.</dd>
  <dt style="font-family: courier;">getElementDBStructures</dt>
    <dd>Get the DBStructure array for the elements.</dd>
</dl>

<h3 id="DBArrayArr">DBArrayArray</h3>
<pre>    public interface DBArrayArray extends DBArray {
        PVArrayArray getPVArrayArray();
        DBArray[] getElementDBArrays();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVArrayArray</dt>
    <dd>Gert the PVArrayArray associated with the DBArrayArray.</dd>
  <dt style="font-family: courier;">getElementDBArrays</dt>
    <dd>Get the DBArray array for the elements.</dd>
</dl>

<h3 style="text-align:center;" id="DBRecord">DBRecord</h3>
<pre>    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void addListenerSource(BaseDBField dbField);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">findDBField</dt>
    <dd>Given a PVField find the DBField that references it.</dd>
  <dt style="font-family: courier;">getPVRecord</dt>
    <dd>Get the PVRecord this DBRecord references.</dd>
  <dt style="font-family: courier;">getDBStructure</dt>
    <dd>Get the DBStructure for this DBRecord.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the record. The record must be locked for record processing and
      whenever the data of any field in a record is accessed. While a record
      is locked the caller must perform operations that can block, i. e. file
      I/O.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the record.</dd>
  <dt style="font-family: courier;">lockOtherRecord</dt>
    <dd>While holding the lock for this record lock another record. The lock
      for the cxurrent record might be unlocked while this call is active but
      upon retirn both record will be locked. The caller must unlock both
      records when the caller is done. Normally it unlocks the other record,
      via it's unlock method, first.</dd>
  <dt style="font-family: courier;">getRecordProcess</dt>
    <dd>Get the interface of the RecordProcess for this instance.</dd>
  <dt style="font-family: courier;">setRecordProcess</dt>
    <dd>Set the RecordProcess inyerface for this record instance.</dd>
  <dt style="font-family: courier;">createRecordListener</dt>
    <dd>Create a RecordListener. The listener is called when record
      processing starts and when it completes. The record listener can also
      be used to call DBField.addListener.</dd>
  <dt style="font-family: courier;">removeRecordListener</dt>
    <dd>Remove a record listener. This will also call removeListener for all
      DBFields that have this listener attached.</dd>
  <dt style="font-family: courier;">addListenerSource</dt>
    <dd>Add a listener source. Used for communication between
      DBRecordBase.java and BaseDBField. BaseDBField calls this the first
      time DBField.addListener is called. It should not be called by other
      code.</dd>
</dl>

<h3 style="text-align:center;" id="DBRecordFa">DBRecordFactory</h3>

<p>A factory is available that implements the DBField interfaces for record
instance fields.</p>
<pre>    public class DBRecordFactory {
        public static DBRecord create(PVRecord pvRecord,IOCDB iocdb,DBD dbd);
    }</pre>

<p>Base classes are available for implementing the PVField interfaces for
database fields. These classes are used by DBDataFactory and can also be used
by code that wants to provide special implementations of database fields. Any
code that wants to provide its own implementation should extend
AbstractPVArray, AbstractPVField or one of the BasePVxxx classes and then
replace the PV associated with a DB.</p>

<p>Package org.epics.ioc.db has a number of classes (ImplDBArray , ... ,
ImplDBStructureArray) with package visibility that implement the DBRecord
instances. These classes provide a complete implementation and are not
designed to be extended.</p>
<hr />

<h2 style="text-align: center" id="IOCDB">IOCDB: IOC Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC. All methods IOCDBFactory are thread
safe. The instances of IOCDB created by IOCDBFactory are also thread safe.
ReadWrite locks are used to implement thread safety.</p>

<p>A javaIOC has a master IOCDB. In addition temporary IOCDBs can be created.
For example new records are added to a running IOC via the following
method:</p>
<ol>
  <li>Create an IOCDB called temp.</li>
  <li>Create record instances and put them into temp.</li>
  <li>Initialize and start the records in temp.</li>
  <li>If all records start successfully merge temp into the master IOCDB.</li>
</ol>

<p>The next section describes some special features provided by the master
IOCDB. The section after that describes the methods provided by an IOCDB.</p>

<h3 id="Master">Master IOCDB</h3>

<p>In addition to providing access to it's record instances the master IOCDB
provides access to the messages sent to it or to any of it's record
instances. When recods are merged into master, it calls pvRecord.addRequester
as each record is added. Thus whenever a message is sent to a record , via a
call to pvRecord.message(), the IOCDB.message is called. Any code can request
that it be called whenever IOCDB.message is called by calling
IOCDB.addRequester. If no requesters are registered than the master just
prtints the messages on System.out (MessageType.info) or to System.err (All
other message types.).</p>

<p>When the message method of the master is called it does not immediately
call the requesters of print the message. Instead to keeps a circular buffer
containing the messages. A separate thread takes the messages from the
circular buffer and calls the requesters or prints the messages. Thus calls
to iocdb.message do not block.</p>

<p></p>

<h3 id="IOCDB1">IOCDB</h3>

<p>The following is the definition of interface IOCDB:</p>
<pre>    public interface IOCDB {
        IOCDB getMaster();
        String getName();
        void mergeIntoMaster();
        DBRecord findRecord(String recordName);
        boolean addRecord(DBRecord record);
        boolean removeRecord(DBRecord record);
        DBRecord[] getDBRecords();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String recordToString(String regularExpression);
    }

    public class IOCDBFactory {
        public static IOCDB create(String name);
        public static IOCDB getMaster();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getMaster</dt>
    <dd>Get the master IOCDB. After records have been initialized they are
      put into the master IOCDB.</dd>
  <dt style="font-family: courier;">getName</dt>
    <dd>The IOC database Name.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the Database Definition database that this DBD uses.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge the record instances from this database into the master
      database.</dd>
  <dt style="font-family: courier;">findRecord</dt>
    <dd>Return the interface for the record with name recordName or null if
      the record is not found. A search is made this database. If not found
      and a master database exists than it is also serched.</dd>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add a record instance. (false,true) is returned if the instance (was
      not,was) added to the database. A record is not added if it already
      exists in this database or in the master database.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove the record. (false,true) is returned if the record (was
      not,was) removed.</dd>
  <dt style="font-family: courier;">getRecords</dt>
    <dd>Get an array of all record instances in this database. </dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Report a message. If no requesters are registered the messages are
      sent to System.out or System.err. If requesters are registered they are
      called. A separate thread calls the requesters or prints the messages.
      Thus this method does not block.</dd>
  <dt style="font-family: courier;">addRequester</dt>
    <dd>Add a requester for messages. Requester is defined in package
      org.epics.ioc.util. The </dd>
  <dt style="font-family: courier;">removeRequester</dt>
    <dd>Remove a message requester.</dd>
  <dt style="font-family: courier;">recordList</dt>
    <dd>Return a string that contains a list if all record names that match
      the regular expression.</dd>
  <dt style="font-family: courier;">recordToString</dt>
    <dd>Return a dump of all record instances with names that match the
      regular expression.</dd>
</dl>

<p>IOCDBFactory is a class that creates IOCDB databases.</p>

<p>The methods are:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create an IOCDB or return the master IOCDB if the name is
    "master".</dd>
  <dt style="font-family: courier;">getMaster</dt>
    <dd>Get the master IOC Database, i.e. the database with name
    "master".</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Rules">Rules for modifying PV data</h2>
<hr />

<h3 id="Modifying">Modifying Data Only</h3>

<p>If a put to a field only modifies data then the code issuing the post must
call dbField.postPut() after the put completes: Puts to the following types
of field only modify data:</p>
<ul>
  <li>scalar<br />
    This means types boolean, all numeric types, and string. </li>
  <li>array of scalar</li>
  <li>structures<br />
    If a field is an array the element type MUST be scalar. Note that this
    definition is recursive; If a field is a structure than that structure
    must follow the same rules.</li>
</ul>

<p>postPut notifys all record listeners attached to the field, to subfields
of the field, or to parents of the field.</p>

<h3 id="Modifying1">Modifying Structure</h3>
Some examples are: 
<ul>
  <li>changing the type of structure for a structure field.</li>
  <li>changing an element of an array of structures.</li>
  <li>changing an element of an array of arrays.</li>
</ul>

<p>Such changes modify the structure of a record not just the data contained
within the record. In this case the code making the change must create the
new PV data and then call dbField.replacePVField(newPVField)</p>

<p>dbField will update it's internal fields and also call the unlisten method
of every DBListener that is attached to the record. The DBListener can just
reconnect.</p>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes BaseDBField and DBRecordBase provide support for implementing
database monitors, i.e. support for notifying a client whenever a field of a
database instance changes value.</p>

<p>A client must implement the interface DBListener. A client can listen to
an arbitrary number of fields in a record. It must first obtain a Listen
interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    DBListener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbField.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy. 
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
  <li>An abstract base class (AbstractDBListener) is provided. It provides
    default methods that do nothing. This is useful for listening to
    primitive fields since only dataPut(DBField dbField) needs to do
  anything.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>public class DBListenerForTesting implements DBListener{ 
    private String recordName = null;
    private String pvName = null;
    private boolean monitorProperties = false;
    private boolean verbose;
    private DBRecord dbRecord = null;
    
    private RecordListener listener;
    private String actualFieldName = null;
    private boolean isProcessing = false;
    private String fullName = null;
    
    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName,
        boolean monitorProperties,boolean verbose)
    {
        this.pvName = pvName;
        this.verbose = verbose;
        this.recordName = recordName;
        this.monitorProperties = monitorProperties;
        dbRecord = iocdb.findRecord(recordName);
        if(dbRecord==null) {
            System.out.printf("record %s not found%n",recordName);
            return;
        }
        connect();
    }
    
    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName)
    {
        this(iocdb,recordName,pvName,true,true);
    }
    
    private String putCommon(String message) {
        if(!verbose) {
            return fullName + " ";
        }
        return String.format("%s %s isProcessing %b pvName %s actualFieldName %s%n",
            message,
            fullName,
            isProcessing,
            pvName,
            actualFieldName);
    }
    
    public void beginProcess() {
        isProcessing = true;
        putCommon("beginProcess");
    }
    
    public void endProcess() {
        putCommon("endProcess");
        isProcessing = false;
    }
   
    public void dataPut(DBField dbField) {
        PVField pvField = dbField.getPVField();
        String common = putCommon("dataPut");
        if(!verbose) {
            System.out.println(common + dbField.toString(1));
            return;
        }
        String name = pvField.getPVRecord().getRecordName() + "." + pvField.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s%s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s = %s%n",
            common,name,dbField.toString(2));
    }
    
    public void dataPut(DBField requested, DBField dbField) {
        PVField pvRequested = requested.getPVField();
        PVField pvField = dbField.getPVField();
        String structureName = pvRequested.getFullName();
        String common = putCommon(structureName +" dataPut to field " + pvField.getFullFieldName());
        System.out.printf("%s    = %s%n",common,pvField.toString(2));
    }       
    
    public void unlisten(RecordListener listener) {
        connect();
    }
    
    private void connect() {
        PVRecord pvRecord = dbRecord.getPVRecord();
        if(pvRecord==null) {
            System.out.printf("record %s not found%n",recordName);
            return;
        }
        PVField pvField;
        if(pvName==null || pvName.length()==0) {
            pvField = pvRecord;
        } else {
            pvField = pvRecord.findProperty(pvName);
            if(pvField==null){
                System.out.printf("name %s not in record %s%n",pvName,recordName);
                System.out.printf("%s\n",pvRecord.toString());
                return;
            }
        }
        actualFieldName = pvField.getField().getFieldName();
        fullName = pvField.getFullName();
        listener = dbRecord.createRecordListener(this);
        DBField dbField = dbRecord.findDBField(pvField);
        dbField.addListener(listener);
        if(monitorProperties) {
            String[] propertyNames = pvField.getPropertyNames();
            if(propertyNames!=null) {
                for(String propertyName : propertyNames) {
                    PVField pvf = pvField.findProperty(propertyName);
                    DBField dbf = dbRecord.findDBField(pvf);
                    dbf.addListener(listener);
                }
            }
        }
    }
}</pre>
<hr />

<h2 style="text-align: center" id="Thread">Thread Safety</h2>
<hr />
The dbAccess components are designed to be used in an IOC, which is a
multithreaded environment. The design includes: 
<dl>
  <dt>XMLToIOCDBFactory</dt>
    <dd>This is thread safe because only one user at a time can be using it.
      If a call to XMLToIOCDBFactory.convert is made while it is alreadty
      busy, a fatal error message is sent to the caller and convert
    returns.</dd>
  <dt>IOCDB</dt>
    <dd>All methods are thread safe.</dd>
  <dt>Record Instance interfaces.</dt>
    <dd>While accessing fields of a record instance the instance must be
      locked. This means that DBRecord.lock must be called before accessing
      fields and DBRecord.unlock must be called after the caller is done. See
      package org.epics.ioc.dbProcess for more details about record
      processing.</dd>
</dl>
</body>
</html>
