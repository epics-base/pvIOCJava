<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2008.08.25</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Instance Syntax</a>
    <ul>
      <li><a href="#General">General Statements</a>
        <ul>
          <li><a href="#namespace">namespace</a></li>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro">Macro Substitution</a></li>
          <li><a href="#Example">Example Include and Macro
          Substitution</a></li>
        </ul>
      </li>
      <li><a href="#record">record</a></li>
      <li><a href="#field">field definition</a></li>
      <li><a href="#field1">field creation</a></li>
      <li><a href="#field2">field initialization</a></li>
      <li><a href="#Primitive">Primitive Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#array">array</a></li>
    </ul>
  </li>
  <li><a href="#Database">XML to Database Converter</a></li>
  <li><a href="#Database1">Database Access</a>
    <ul>
      <li><a href="#Listener">Listener Interface</a>
        <ul>
          <li><a href="#DBListener">DBListener</a></li>
          <li><a href="#RecordList">RecordListener</a></li>
        </ul>
      </li>
      <li><a href="#DBField">DBField</a></li>
      <li><a href="#DBStructur">DBStructure</a></li>
      <li><a href="#DBArray">DBArray</a></li>
      <li><a href="#DBStructur1">DBStructureArray</a></li>
      <li><a href="#DBArrayArr">DBArrayArray</a></li>
      <li><a href="#DBRecord">DBRecord</a></li>
      <li><a href="#DBRecordFa">DBRecordFactory</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB">IOCDB: IOC Database</a>
    <ul>
      <li><a href="#Master">Master IOCDB</a></li>
      <li><a href="#IOCDB1">IOCDB</a></li>
    </ul>
  </li>
  <li><a href="#Rules">Rules for modifying PV data</a>
    <ul>
      <li><a href="#Modifying">Modifying Data Only</a></li>
      <li><a href="#Modifying1">Modifying Structure</a></li>
    </ul>
  </li>
  <li><a href="#Listener1">Listener Support</a></li>
  <li><a href="#Thread">Thread Safety</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax<br />
    The XML syntax for defining record instances.</li>
  <li>An XML to database converter.<br />
    Parses xml record instance files, creates record instances, and puts them
    in an IOC database.</li>
  <li>Database Access<br />
    Interfaces for accessing database records and support.<br />
  </li>
  <li>IOC Database<br />
    Interface and factory for a database containing the record instances</li>
  <li>Rules for modifying PV Data.</li>
  <li>Listen Support<br />
    A description of the support for monitoring changes to the data in
    database instances fields.</li>
</ol>
<hr />

<h2 style="text-align: center" id="Record">Record Instance Syntax</h2>
<hr />
A Record Instance file must be an XML file with a root tag of IOCDatabase: 
<pre>    &lt;?xml version="1.0" ?&gt;
    &lt;IOCDatabase&gt;
      &lt;?-- valid Record Instance Definitions --&gt;
    &lt;/IOCDatabase&gt;</pre>

<h3 id="General">General Statements</h3>

<h4 id="namespace">namespace</h4>
At this time namespaces are not used. 

<h4 id="Include">Include</h4>
The XML file can include other files also containing Record Instance
Definitions. Included files can also include other files. The syntax is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4 id="Macro">Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4 id="Example">Example Include and Macro Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record"&gt;
    &lt;value type = "double"/&gt;
    &lt;timeStamp structureName = "timeStamp"&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;input structureName = "linearConvertInput" &gt;
        &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;${pvname}&lt;/pvname&gt;
            &lt;wait&gt;true&lt;/wait&gt;
        &lt;/input&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/input&gt;
    &lt;display structureName = "display" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/display&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h3 id="record">record</h3>

<p>The syntax for a record instance is:</p>
<pre>&lt;record name = "recordName" structureName = "structureName"  supportName = "supportName"&gt;
   &lt;!== field definition described below --&gt;
    ...
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span>, which must be
specified,is a string with a combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p><span style="font-family: courier">structureName</span>, which is
optional, is the name of a structure Database Definition (DBD). If not given
then the structureName is "generic" which is a structure with no fields and
generic support. Most record instances do not specify the structureName.
Instead they add the fields desired to the generic structure.</p>

<p><span style="font-family: courier">supportName</span>, which is optional,
is the name of support. If not given the supportName is either the
supportName specified in the structure definition or else generic. A support
definition with the supportName must be defined in a support DBD. If the same
record instance appears multiple times then then last supportName is used.</p>

<h3 id="field">field definition</h3>

<p>A field is defined as follows:</p>
<pre> 
    &lt;fieldName supportName = "supportName" createName = "createName" ... &gt;
        &lt;!-- field initialization described below --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be specified. If
the structure within which this field is specified does not already have a
field with this name then a new field is created and appended to the end of
the structure. The details are descibed in the next section.</p>

<p><span style="font-family: courier;">supportName</span> and <span
style="font-family: courier;">createName</span> are both optional. If
specified then this definition overrides any value specified in the DBD
structure. If a field is definedd multiple times than the last </p>

<p><span style="font-family: courier;">supportName</span> or <span
style="font-family: courier;">createName</span> definition determines the
final value.</p>

<p>For array fields additional XML attributes can appear, which are described
below.</p>

<h3 id="field1">field creation</h3>

<p>If <span style="font-family: courier;">fieldName</span> does not exist
then a new field can be created and appended to the end of the current
structure. In order to create a new field some combination of <span
style="font-family: courier">type</span>, <span
style="font-family: courier">structureName</span>, and <span
style="font-family: courier">elementType</span> must be specified. In this
case a new field will be appended to the end of the structure in which this
field appears. <span style="font-family: courier">type</span> can be any of
the supported types, i.e. <span style="font-family: courier">boolean</span>,
<span style="font-family: courier">byte</span>, ..., <span
style="font-family: courier">double</span>, <span
style="font-family: courier">structure</span>, <span
style="font-family: courier">array</span>. If <span
style="font-family: courier">type</span> is <span
style="font-family: courier">structure</span> then <span
style="font-family: courier">structureName</span> must be specified and must
be defined in the master DBD database. If the type is <span
style="font-family: courier">array</span> then <span
style="font-family: courier">elementType</span> must be defined and can be
any of the supported types.</p>

<p>For example:</p>
<pre>&lt;record name = "simple" &gt;
  &lt;value type = "double" /&gt;
&lt;/record&gt;</pre>

<p>Because the record definition does not specify a structureName, it starts
with the generic structure, which has no fields and generic support. Field
<span style="font-family: courier">value</span> does not exist so it is
created and appended to the structure. i.e. the record will have a single
field of type double and named "value".</p>

<p>Consider a more complex example:</p>
<pre>&lt;record name = "counter"&gt;
    &lt;value type = "double" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;input structureName = "calculation" &gt;
      &lt;calcArgArray&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double" &gt;0.0&lt;/value&gt;
            &lt;name&gt;min&lt;/name&gt;
        &lt;/element&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double" &gt;10.0&lt;/value&gt;
            &lt;name&gt;max&lt;/name&gt;
        &lt;/element&gt;
        &lt;element structureName = "calcArg"&gt;
            &lt;value type = "double"&gt;0.5&lt;/value&gt;
            &lt;name&gt;inc&lt;/name&gt;
        &lt;/element&gt;
      &lt;/calcArgArray&gt;
      &lt;calculator&gt;
        &lt;expression&gt;(value+inc)&amp;lt;=max ? value+inc : min&lt;/expression&gt;
      &lt;/calculator&gt;
    &lt;/input&gt;
    &lt;scan structureName = "scan"&gt;
        &lt;type&gt;&lt;choice&gt;periodic&lt;/choice&gt;&lt;/type&gt;
        &lt;rate&gt;1.0&lt;/rate&gt;
    &lt;/scan&gt;
&lt;/record&gt;</pre>

<p>This record has the following fields:</p>
<dl>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>A value field with type double.</dd>
  <dt><span style="font-family: courier">timeStamp</span></dt>
    <dd>A structure that holds a time stamp.</dd>
  <dt><span style="font-family: courier">alarm</span></dt>
    <dd>An alarm structure which also has alarm support.</dd>
  <dt><span style="font-family: courier">input</span></dt>
    <dd>A structure for performing calculations. It contains a field
      calcArgArray which is a array of structures , where each structure
      defines an argument for the expression. The field calculator is a
      structure that has expressionCalculator support and a single field that
      is the expression to calculate.</dd>
  <dt><span style="font-family: courier">scan</span></dt>
    <dd>A structure with support that makes the record process
    periodicallly.</dd>
</dl>

<h3 id="field2">field initialization</h3>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3 id="Primitive">Primitive Types</h3>

<p>For primitive types the initializer has the same format as the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value&gt;.98&lt;/value&gt;</pre>

<p>Note: For integer data types <span
style="font-family: courier">Long.decode</span> is used to convert a string
to a long, which is then converted to the final integer data type . Thus hex
values are allowed. Java does not allow the sign bit to be set. By converting
first to a long all interger types except long can have the sign bit set. For
example the byte value 0xff is allowed even though Java would raise an
exception if Byte.decode was used. The sign problem does exist for long
values.</p>

<h3 id="string">string</h3>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h3 id="structure">structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure definitions:</p>
<pre>    &lt;structure name = "doubleLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;

   &lt;structure name = "control"&gt;
     &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
     &lt;field name = "minStep" type = "double" /&gt;
   &lt;/structure&gt;</pre>

<p>limit is initilized as follows:.</p>
<pre>    &lt;control structureName = "control"&gt;
      &lt;limit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
      &lt;/limit&gt;
   &lt;/control&gt;</pre>

<p>It is permissible, in a database definition, to define a field to be a
structure without providing a structure name. In this case the default is
"generic" which is a structure with no fields and generic support.</p>

<p>The default structure and/or support can be overridden when a field
instance is defined. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" supportName = "supportName" &gt;</pre>

<h3 id="array">array</h3>
The syntax for an array initializer is: 
<pre>    &lt;fieldName capacity = "capacity" capacityMutable = "trueFalse" length = "length" &gt;
        &lt;element offset = "offset"&gt;value&lt;/element&gt;
        &lt;element offset = "offset"&gt;valueList&lt;/element&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized. If
      the capacity is given a value &gt; 0 and capacityMutable is not
      specified then capacityMutable is set to true. </dd>
  <dt style="font-family: courier;">capacityMutable</dt>
    <dd>Can the capacity be changed?</dd>
  <dt style="font-family: courier;">length</dt>
    <dd>The initial length for the array.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">element</dt>
    <dd>assigns a value to an element of the array. If the array is an array
      of structures then the element definition allows the same attributes as
      the field definition for a structure. If the array is an array of
      arrays the element definition allows the same attributes as the field
      definition for an array.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
  <dt></dt>
</dl>

<p>The following all perform the same initialization:</p>
<pre>    &lt;intArray elementType = "double" capacity = "3" &gt;
        &lt;element&gt;0.0, 1.0, 2.0&lt;/element&gt;
    &lt;/intArray&gt;
    &lt;intArray elementType = "double" capacity = "3" offset = "1"&gt;
        &lt;element&gt;1.0, 2.0&lt;/element&gt;
    &lt;/intArray&gt;
    &lt;intArray elementType = "double"&gt;
        &lt;element&gt;0.0&lt;/element&gt;
        &lt;element&gt;1.0&lt;/element&gt;
        &lt;element&gt;2.0&lt;/element&gt;
    &lt;/intArray&gt;</pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray elementType = "structure" capacity = "2"&gt;
        &lt;element structureName = "doubleLimit" &gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/element&gt;
        &lt;element  structureName = "doubleLimit"&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/element&gt;
    &lt;/structArray&gt;</pre>
<hr />

<h2 style="text-align: center" id="Database">XML to Database Converter</h2>
<hr />

<p><span style="font-weight:bold;">NOTE</span> : To create definitions for an
IOC, use org.epics.ioc.util.IOCFactory.initDatabase instead of directly
calling XMLToIOCDBFactory. initDatabase calls XMLToIOCDBFactory and also
initializes all support. Database instances should not be added to the master
IOCDB unless all support initializes and starts correctly.</p>

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbd, IOCDB iocdb, String fileName,
            Requester requester);
        public static IOCDB convert(String iocdbName,String fileName,
            Requester requester);
    }</pre>
<dl>
  <dt style="font-family: courier;">convert(DBD dbd, IOCDB iocdb, String
  fileName, Requester requester)</dt>
    <dd>Parse an xml file conaining record instance definitions and put the
      resulting record instances into an IOC database.</dd>
  <dt style="font-family: courier;">convert(String iocdbName,String fileName,
  Requester requester)</dt>
    <dd>Create an IOC Database (IOCDB) with name iocdbName and populate it
      with definitions from an XML file. The definitions are not added to the
      master IOCDB but the caller can call IOCDB.mergeIntoMaster to add them
      to master. The DBD database is named master. Attempting to add
      definitions for a record instance that is already in master is an
    error.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">iocdb</dt>
    <dd>The database that holds the record instances.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">requester</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">iocdbName</dt>
    <dd>The name of the IOCDB into which definitions are created.</dd>
</dl>

<p>For an IOC convert should be used to create record instances. This can be
done during IOC initialization or after an IOC is running, i.e. on-line add
of new record instances is supported. Only one user at a time is allowed to
call convert or convert. If XMLToIOCDBFactory is busy when another call is
made an error is generated and nothing is done. Both methods are thread
safe.</p>
<hr />

<h2 style="text-align: center" id="Database1">Database Access</h2>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, support, Channel Access,
etc.</p>

<p>Each DBField interface provides access to a corrseponding PVField
interface and in addition provide access to support and implement monitoring,
i.e.DBField provides the following features:</p>
<ul>
  <li>Access to support.<br />
    PVField provides the name of support code. DBdata provides access to the
    support itself.</li>
  <li>Monitoring.<br />
    This is implemented via the DBListener interface.</li>
  <li>Access to the associated PVField interface.</li>
</ul>

<p>In addition DBRecord provides the following features:</p>
<ul>
  <li>Record locking.<br />
    Whenever code accesses any part of a record instance it must be locked.
    DBRecord provides the lock.</li>
  <li>Access to RecordProcess.<br />
    During ioc initialization an instance of RecordProcess created for each
    record instance.</li>
  <li>Monitoring.<br />
    DBField and DBRecord are both involved with monitoring.</li>
  <li>Location of the IOCDB and DBD to which this record instance
  belongs.</li>
</ul>

<h3 id="Listener">Listener Interface</h3>

<h4 id="DBListener">DBListener</h4>

<p>DBListener is an interface that must be implemented by code that calls
DBdata.addListener, which is a request to be notified whenever a field
changes value. A request can be made for any field including structure fields
or even a record instance. If the request is made for a structure field then
the requester will be notified whenever any field of the structure changes
value.</p>

<p>DBListener has the definition:</p>
<pre>    public interface DBListener {
        void dataPut(DBField dbField);
        void dataPut(DBField requested,DBField dbField);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }

    public abstract class AbstractDBListener implements DBListener{...}</pre>
where 
<dl>
  <dt style="font-family: courier;">dataPut</dt>
    <dd>A data put has occured.</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>The record is starting processing.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>The record has completed processing.</dd>
  <dt style="font-family: courier;">unlisten</dt>
    <dd>The data source is undergoing destruction or major structural
      changes. The DBField.addListener call is no longer valid and the user
      should null the object reference returned by addListener.</dd>
  <dt style="font-family: courier;">AbstractDBListener</dt>
    <dd>Implements each method by doing nothing. This is useful for code that
      listens to a field that is primitive ot an array of primitive types. In
      this case only the single argument dataPut needs to be implemented.</dd>
</dl>

<p>For dataPut two versions are provided. The first is called if the listener
attaches directly the the field that is being modified. The second version is
called if the caller attaches to a structure that has the field located
somewhere in it. The first argument is the structure or array to which the
listener attached. Not in particular that the listener can listen to all
changes in a record instance by attaching to the record instance itself.</p>

<p>Assume that a field named value has property alarm. Then when the record
is processed and field value is written then the following calls might
occur:</p>
<ul>
  <li>beginProcess</li>
  <li>dataPut for value</li>
  <li>dataPut for alarm</li>
  <li>endProcess</li>
</ul>

<h4 id="RecordList">RecordListener</h4>

<p>RecordListener is an interface that is implemented by the code that
implements DBRecord. This is normally class DBRecordBase. DBRecord provides a
method to create a RecordListener. See class FieldDataFactory and
DBRecordBase for details. The definition of RecordListener is:</p>
<pre>    public interface RecordListener {
        DBListener getDBListener();
    }</pre>

<p>At the end of this document is a example implementation of DBListener.</p>

<h3 id="DBField">DBField</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Create getCreate();
        void setCreate(Create create);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        boolean addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDBRecord</dt>
    <dd>Return the DBRecord interface for the record instance.</dd>
  <dt style="font-family: courier;">getParent</dt>
    <dd>Return the DBField interface of the parent.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Get the PVField interface that hold the data for the field.</dd>
  <dt style="font-family: courier;">replacePVField</dt>
    <dd>Replace the PVField.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Just gets the associated PVField bsupportName.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>This connects the field to associated support and also handles
      support initialization.</dd>
  <dt style="font-family: courier;">getCreate</dt>
    <dd>Get the create for this field. This returns null if no create
    exists.</dd>
  <dt style="font-family: courier;">setCreate</dt>
    <dd>Set the create for the field. It can be null.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the support for this field. This returns null if no support
      exists.</dd>
  <dt style="font-family: courier;">setSupport</dt>
    <dd>Set the support for the field. It can be null.</dd>
  <dt style="font-family: courier;">postPut</dt>
    <dd>This is called by code that puts to the PVField associated with the
      field. It implements monitoring.</dd>
  <dt style="font-family: courier;">addListener</dt>
    <dd>Add a monitor listener. The RecordListener interface must be created
      by calling DBRecord.createRecordListener. If the DBField is a structure
      field the listener will be called when any field in the structure is
      modified.</dd>
  <dt style="font-family: courier;">removeListener</dt>
    <dd>Remove a listener.</dd>
</dl>

<h3 id="DBStructur">DBStructure</h3>
<pre>    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        DBField[] getDBFields();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVStructure</dt>
    <dd>Get the associated PVStructure interface.</dd>
  <dt style="font-family: courier;">getDBFields</dt>
    <dd>Get the DBField array for the subfields.</dd>
</dl>

<h3 id="DBArray">DBArray</h3>
<pre>    public interface DBArray extends DBField{
        PVArray getPVArray();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVArray</dt>
    <dd>Get the PVArray associated with this DBArray.</dd>
</dl>

<h3 id="DBStructur1">DBStructureArray</h3>
<pre>    public interface DBStructureArray extends DBArray {
        PVStructureArray getPVStructureArray();
        DBStructure[] getElementDBStructures();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVStructureArray</dt>
    <dd>Gert the PVStructureArray associated with the DBStructureArray.</dd>
  <dt style="font-family: courier;">getElementDBStructures</dt>
    <dd>Get the DBStructure array for the elements.</dd>
</dl>

<h3 id="DBArrayArr">DBArrayArray</h3>
<pre>    public interface DBArrayArray extends DBArray {
        PVArrayArray getPVArrayArray();
        DBArray[] getElementDBArrays();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVArrayArray</dt>
    <dd>Gert the PVArrayArray associated with the DBArrayArray.</dd>
  <dt style="font-family: courier;">getElementDBArrays</dt>
    <dd>Get the DBArray array for the elements.</dd>
</dl>

<h3 id="DBRecord">DBRecord</h3>
<pre>    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void addListenerSource(BaseDBField dbField);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">findDBField</dt>
    <dd>Given a PVField find the DBField that references it.</dd>
  <dt style="font-family: courier;">getPVRecord</dt>
    <dd>Get the PVRecord this DBRecord references.</dd>
  <dt style="font-family: courier;">getDBStructure</dt>
    <dd>Get the DBStructure for this DBRecord.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the record. The record must be locked for record processing and
      whenever the data of any field in a record is accessed. While a record
      is locked the caller must perform operations that can block, i. e. file
      I/O.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the record.</dd>
  <dt style="font-family: courier;">lockOtherRecord</dt>
    <dd>While holding the lock for this record lock another record. The lock
      for the cxurrent record might be unlocked while this call is active but
      upon retirn both record will be locked. The caller must unlock both
      records when the caller is done. Normally it unlocks the other record,
      via it's unlock method, first.</dd>
  <dt style="font-family: courier;">getRecordProcess</dt>
    <dd>Get the interface of the RecordProcess for this instance.</dd>
  <dt style="font-family: courier;">setRecordProcess</dt>
    <dd>Set the RecordProcess inyerface for this record instance.</dd>
  <dt style="font-family: courier;">createRecordListener</dt>
    <dd>Create a RecordListener. The listener is called when record
      processing starts and when it completes. The record listener can also
      be used to call DBField.addListener.</dd>
  <dt style="font-family: courier;">removeRecordListener</dt>
    <dd>Remove a record listener. This will also call removeListener for all
      DBFields that have this listener attached.</dd>
  <dt style="font-family: courier;">addListenerSource</dt>
    <dd>Add a listener source. Used for communication between
      DBRecordBase.java and BaseDBField. BaseDBField calls this the first
      time DBField.addListener is called. It should not be called by other
      code.</dd>
</dl>

<h3 id="DBRecordFa">DBRecordFactory</h3>

<p>A factory is available that implements the DBField interfaces for record
instance fields.</p>
<pre>    public class DBRecordFactory {
        public static DBRecord create(PVRecord pvRecord,IOCDB iocdb,DBD dbd);
    }</pre>

<p>Base classes are available for implementing the PVField interfaces for
database fields. These classes are used by DBDataFactory and can also be used
by code that wants to provide special implementations of database fields. Any
code that wants to provide its own implementation should extend
AbstractPVArray, AbstractPVField or one of the BasePVxxx classes and then
replace the PV associated with a DB.</p>

<p>Package org.epics.ioc.db has a number of classes (ImplDBArray , ... ,
ImplDBStructureArray) with package visibility that implement the DBRecord
instances. These classes provide a complete implementation and are not
designed to be extended.</p>
<hr />

<h2 style="text-align: center" id="IOCDB">IOCDB: IOC Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC. All methods IOCDBFactory are thread
safe. The instances of IOCDB created by IOCDBFactory are also thread safe.
ReadWrite locks are used to implement thread safety.</p>

<p>A javaIOC has a master IOCDB. In addition temporary IOCDBs can be created.
For example new records are added to a running IOC via the following
method:</p>
<ol>
  <li>Create an IOCDB called temp.</li>
  <li>Create record instances and put them into temp.</li>
  <li>Initialize and start the records in temp.</li>
  <li>If all records start successfully merge temp into the master IOCDB.</li>
</ol>

<p>The next section describes some special features provided by the master
IOCDB. The section after that describes the methods provided by an IOCDB.</p>

<h3 id="Master">Master IOCDB</h3>

<p>In addition to providing access to it's record instances the master IOCDB
provides access to the messages sent to it or to any of it's record
instances. When recods are merged into master, it calls pvRecord.addRequester
as each record is added. Thus whenever a message is sent to a record , via a
call to pvRecord.message(), the IOCDB.message is called. Any code can request
that it be called whenever IOCDB.message is called by calling
IOCDB.addRequester. If no requesters are registered than the master just
prtints the messages on System.out (MessageType.info) or to System.err (All
other message types.).</p>

<p>When the message method of the master is called it does not immediately
call the requesters of print the message. Instead to keeps a circular buffer
containing the messages. A separate thread takes the messages from the
circular buffer and calls the requesters or prints the messages. Thus calls
to iocdb.message do not block.</p>

<p></p>

<h3 id="IOCDB1">IOCDB</h3>

<p>The following is the definition of interface IOCDB:</p>
<pre>    public interface IOCDB {
        IOCDB getMaster();
        String getName();
        void mergeIntoMaster();
        DBRecord findRecord(String recordName);
        boolean addRecord(DBRecord record);
        boolean removeRecord(DBRecord record);
        DBRecord[] getDBRecords();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String recordToString(String regularExpression);
    }

    public class IOCDBFactory {
        public static IOCDB create(String name);
        public static IOCDB getMaster();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getMaster</dt>
    <dd>Get the master IOCDB. After records have been initialized they are
      put into the master IOCDB.</dd>
  <dt style="font-family: courier;">getName</dt>
    <dd>The IOC database Name.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the Database Definition database that this DBD uses.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge the record instances from this database into the master
      database.</dd>
  <dt style="font-family: courier;">findRecord</dt>
    <dd>Return the interface for the record with name recordName or null if
      the record is not found. A search is made this database. If not found
      and a master database exists than it is also serched.</dd>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add a record instance. (false,true) is returned if the instance (was
      not,was) added to the database. A record is not added if it already
      exists in this database or in the master database.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove the record. (false,true) is returned if the record (was
      not,was) removed.</dd>
  <dt style="font-family: courier;">getRecords</dt>
    <dd>Get an array of all record instances in this database. </dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Report a message. If no requesters are registered the messages are
      sent to System.out or System.err. If requesters are registered they are
      called. A separate thread calls the requesters or prints the messages.
      Thus this method does not block.</dd>
  <dt style="font-family: courier;">addRequester</dt>
    <dd>Add a requester for messages. Requester is defined in package
      org.epics.ioc.util. The </dd>
  <dt style="font-family: courier;">removeRequester</dt>
    <dd>Remove a message requester.</dd>
  <dt style="font-family: courier;">recordList</dt>
    <dd>Return a string that contains a list if all record names that match
      the regular expression.</dd>
  <dt style="font-family: courier;">recordToString</dt>
    <dd>Return a dump of all record instances with names that match the
      regular expression.</dd>
</dl>

<p>IOCDBFactory is a class that creates IOCDB databases.</p>

<p>The methods are:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create an IOCDB or return the master IOCDB if the name is
    "master".</dd>
  <dt style="font-family: courier;">getMaster</dt>
    <dd>Get the master IOC Database, i.e. the database with name
    "master".</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Rules">Rules for modifying PV data</h2>
<hr />

<h3 id="Modifying">Modifying Data Only</h3>

<p>If a put to a field only modifies data then the code issuing the post must
call dbField.postPut() after the put completes: Puts to the following types
of field only modify data:</p>
<ul>
  <li>scalar<br />
    This means types boolean, all numeric types, and string. </li>
  <li>array of scalar</li>
  <li>structures<br />
    If a field is an array the element type MUST be scalar. Note that this
    definition is recursive; If a field is a structure than that structure
    must follow the same rules.</li>
</ul>

<p>postPut notifys all record listeners attached to the field, to subfields
of the field, or to parents of the field.</p>

<h3 id="Modifying1">Modifying Structure</h3>
Some examples are: 
<ul>
  <li>changing the type of structure for a structure field.</li>
  <li>changing an element of an array of structures.</li>
  <li>changing an element of an array of arrays.</li>
</ul>

<p>Such changes modify the structure of a record not just the data contained
within the record. In this case the code making the change must create the
new PV data and then call dbField.replacePVField(newPVField)</p>

<p>dbField will update it's internal fields and also call the unlisten method
of every DBListener that is attached to the record. The DBListener can just
reconnect.</p>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes BaseDBField and DBRecordBase provide support for implementing
database monitors, i.e. support for notifying a client whenever a field of a
database instance changes value.</p>

<p>A client must implement the interface DBListener. A client can listen to
an arbitrary number of fields in a record. It must first obtain a Listen
interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    DBListener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbField.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy. 
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
  <li>An abstract base class (AbstractDBListener) is provided. It provides
    default methods that do nothing. This is useful for listening to
    primitive fields since only dataPut(DBField dbField) needs to do
  anything.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>public class DBListenerForTesting implements DBListener{ 
    private String recordName = null;
    private String pvName = null;
    private boolean monitorProperties = false;
    private boolean verbose;
    private DBRecord dbRecord = null;
    
    private RecordListener listener;
    private String actualFieldName = null;
    private boolean isProcessing = false;
    private String fullName = null;
    
    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName,
        boolean monitorProperties,boolean verbose)
    {
        this.pvName = pvName;
        this.verbose = verbose;
        this.recordName = recordName;
        this.monitorProperties = monitorProperties;
        dbRecord = iocdb.findRecord(recordName);
        if(dbRecord==null) {
            System.out.printf("record %s not found%n",recordName);
            return;
        }
        connect();
    }
    
    public DBListenerForTesting(IOCDB iocdb,String recordName,String pvName)
    {
        this(iocdb,recordName,pvName,true,true);
    }
    
    private String putCommon(String message) {
        if(!verbose) {
            return fullName + " ";
        }
        return String.format("%s %s isProcessing %b pvName %s actualFieldName %s%n",
            message,
            fullName,
            isProcessing,
            pvName,
            actualFieldName);
    }
    
    public void beginProcess() {
        isProcessing = true;
        putCommon("beginProcess");
    }
    
    public void endProcess() {
        putCommon("endProcess");
        isProcessing = false;
    }
   
    public void dataPut(DBField dbField) {
        PVField pvField = dbField.getPVField();
        String common = putCommon("dataPut");
        if(!verbose) {
            System.out.println(common + dbField.toString(1));
            return;
        }
        String name = pvField.getPVRecord().getRecordName() + "." + pvField.getFullFieldName();
        if(!name.equals(fullName)) {
            System.out.printf("%s%s NOT_EQUAL %s%n",common,name,fullName);
        }
        System.out.printf("%s    %s = %s%n",
            common,name,dbField.toString(2));
    }
    
    public void dataPut(DBField requested, DBField dbField) {
        PVField pvRequested = requested.getPVField();
        PVField pvField = dbField.getPVField();
        String structureName = pvRequested.getFullName();
        String common = putCommon(structureName +" dataPut to field " + pvField.getFullFieldName());
        System.out.printf("%s    = %s%n",common,pvField.toString(2));
    }       
    
    public void unlisten(RecordListener listener) {
        connect();
    }
    
    private void connect() {
        PVRecord pvRecord = dbRecord.getPVRecord();
        if(pvRecord==null) {
            System.out.printf("record %s not found%n",recordName);
            return;
        }
        PVField pvField;
        if(pvName==null || pvName.length()==0) {
            pvField = pvRecord;
        } else {
            pvField = pvRecord.findProperty(pvName);
            if(pvField==null){
                System.out.printf("name %s not in record %s%n",pvName,recordName);
                System.out.printf("%s\n",pvRecord.toString());
                return;
            }
        }
        actualFieldName = pvField.getField().getFieldName();
        fullName = pvField.getFullName();
        listener = dbRecord.createRecordListener(this);
        DBField dbField = dbRecord.findDBField(pvField);
        dbField.addListener(listener);
        if(monitorProperties) {
            String[] propertyNames = pvField.getPropertyNames();
            if(propertyNames!=null) {
                for(String propertyName : propertyNames) {
                    PVField pvf = pvField.findProperty(propertyName);
                    DBField dbf = dbRecord.findDBField(pvf);
                    dbf.addListener(listener);
                }
            }
        }
    }
}</pre>
<hr />

<h2 style="text-align: center" id="Thread">Thread Safety</h2>
<hr />
The dbAccess components are designed to be used in an IOC, which is a
multithreaded environment. The design includes: 
<dl>
  <dt>XMLToIOCDBFactory</dt>
    <dd>This is thread safe because only one user at a time can be using it.
      If a call to XMLToIOCDBFactory.convert is made while it is alreadty
      busy, a fatal error message is sent to the caller and convert
    returns.</dd>
  <dt>IOCDB</dt>
    <dd>All methods are thread safe.</dd>
  <dt>Record Instance interfaces.</dt>
    <dd>While accessing fields of a record instance the instance must be
      locked. This means that DBRecord.lock must be called before accessing
      fields and DBRecord.unlock must be called after the caller is done. See
      package org.epics.ioc.dbProcess for more details about record
      processing.</dd>
</dl>
</body>
</html>
