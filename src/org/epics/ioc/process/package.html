<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: process</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: process<br />
package: org.epics.ioc.process<br />
2007.08.30</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Processing: Theory of Operation</a> 
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Requester">Requester Examples</a></li>
      <li><a href="#Overview1">Overview</a></li>
      <li><a href="#Local">Local Channel Access Example</a></li>
      <li><a href="#Link">Link Support Example</a></li>
      <li><a href="#Support">Support State</a></li>
      <li><a href="#Locking">Locking</a></li>
    </ul>
  </li>
  <li><a href="#Record1">Record Process</a> 
    <ul>
      <li><a href="#Definition1">Definitions</a></li>
      <li><a href="#RecordProc">RecordProcess - General Purpose
      Methods</a></li>
      <li><a href="#RecordProc1">RecordProcess - Record Lifetime
      Methods.</a></li>
      <li><a href="#RecordProc2">RecordProcess - Record Process Requester
        Methods</a></li>
      <li><a href="#RecordProc3">RecordProcess - Support Processing
        methods.</a></li>
      <li><a href="#RecordProc4">RecordProcessRequester</a></li>
      <li><a href="#ProcessCal">ProcessCallbackRequester</a></li>
      <li><a href="#ProcessCon">ProcessContinueRequester</a></li>
      <li><a href="#SupportPro">SupportProcessRequester</a></li>
      <li><a href="#RecordProc5">RecordProcessFactory</a></li>
    </ul>
  </li>
  <li><a href="#Support1">Support Creation</a> 
    <ul>
      <li><a href="#Definition2">Definitions:</a></li>
      <li><a href="#Support2">Support Creation</a></li>
      <li><a href="#Factory">Factory</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides support for processing IOC database records. It
defines the following interfaces:</p>
<dl>
  <dt>RecordProcess</dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt>SupportCreation</dt>
    <dd>An interface for creating and initializing all support for a set of
      record instances.</dd>
</dl>

<p>It also has a number of interfaces implement by code that requests to be
notified about process or support events:</p>
<dl>
  <dt>RecordProcessRequester.</dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt>SupportProcessRequester</dt>
    <dd>Implemented by code that calls support.process.</dd>
  <dt>ProcessCallbackRequester</dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt>ProcessContinueRequester</dt>
    <dd>Implemented by code that call recordProcess.processContinue.</dd>
</dl>

<p>The following enum defines the support state:</p>
<dl>
  <dt>SupportState</dt>
    <dd>Specifies the current status of the support. For example is it ready
      for processing.</dd>
</dl>

<p>In addition the following classes are provided:</p>
<dl>
  <dt>RecordProcessFactory</dt>
    <dd>Implements RecordProcess.</dd>
  <dt>SupportCreationFactory</dt>
    <dd>Creates a process Database.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Record">Record Processing: Theory of
Operation</h2>

<h3 id="Definition">Definitions</h3>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete. It is permissible to take locks that that are
      shared by other synchronous code.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke
      other support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance.</dd>
  <dt>recordProcess</dt>
    <dd>Every record instance has an implementation of an object that
      coordinates record processing. RecordProcess is the name of the
      interface implemented by record processing.</dd>
  <dt>process requester</dt>
    <dd>Code that asks recordProcess to process a record. Code must register
      to be the requester and only one requester is allow to request
      processing. Thus a registration request fails if a requester is already
      attached to a record. If code that is not the requester attempts to
      process a record an exception is thrown.</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h3 id="Requester">Requester Examples</h3>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests: 
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status,
            severity, and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be
      done with as few lock/unlock cycles and context switches as possible.
      In particular the only asynchronous support should cause a context
      switch. <br />
      Typical requests are: 
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or
          severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>

<h3 id="Overview1">Overview</h3>

<p>A record is processed via a call to RecordProcess.process. It in turn
calls the record support process method. Record support optionally calls the
process methods of field support modules. Each support module can optionally
call the process method of support code for subfields. Record support is just
like field support except that it is attached to the record rather than to a
subfield of the record.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support 
    <p>Synchronous support is suport that can implemented without blocking,
    i.e. waiting. Asynchronous support is support that must wait. For example
    network requests must block. Asynchronous support does not cause record
    processing to block. Instead the support code returns without completing
    and arranges some other way to perform it's function. When it is done it
    again interacts with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active
    and other requests to process the record will not succeed.</p>
  </li>
  <li>record locking 
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
  <li>RecordProcsssRequester 
    <p>A record can have only a single process requester. A requester must
    register before it can request processing.</p>
  </li>
  <li>RecordProcess 
    <p>Each record has an instance of RecordProcess. It manages all process
    related activities.</p>
  </li>
</ul>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess 
    <ul>
      <li>setActive 
        <p>Set the record active but do not call the record support process
        method.</p>
      </li>
      <li>process 
        <p>If the record has not been made active via a call to setActive it
        is set active. recordSupport.process is called. The results of
        processing are sent to the requester via the RecordProcessRequester
        methods. The requester can request the record be left active when
        processing completes.</p>
      </li>
      <li>setInactive 
        <p>Must be called if the requester asked that the record be left
        active when processing completes.</p>
      </li>
      <li>processContinue 
        <p>Called by asynchronous support when it is ready to continue
        processing. The record is locked and
        processContinueRequester.processContinue is called..</p>
      </li>
      <li>requestProcessCallback 
        <p>Any support code called directly or indirectly by process or
        processContinue can call this method.
        processRequestRequester.processCallback is called with the record
        unlocked. Support code that processes other records must only issue
        the process requests via this method or deadlocks can occur.</p>
      </li>
    </ul>
  </li>
  <li>Support 
    <ul>
      <li>process(SupportProcessRequester supportProcessRequester) 
        <p>This is a method that must be implemented by all support modules.
        When the support is done it calls the supportProcessRequester to
        report completion.</p>
      </li>
    </ul>
  </li>
  <li>RecordProcessRequester 
    <ul>
      <li>recordProcessResult(RequestResult requestResult) 
        <p>Called with the record locked and all processing is complete.</p>
      </li>
      <li>recordProcessComplete() 
        <p>Called with the record inlocked and processing complete.</p>
      </li>
    </ul>
  </li>
  <li>SupportProcessRequester 
    <ul>
      <li>supportProcessDone(RequestResult requestResult) 
        <p>called by whoever calls support.process. In particular
        recordSupport also implements this interface.</p>
      </li>
    </ul>
  </li>
  <li>ProcessCallbackRequester 
    <ul>
      <li>processCallback() 
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
  <li>ProcessContinueRequester 
    <ul>
      <li>processContinue() 
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="Local">Local Channel Access Example</h3>

<p>As an example assume that a channel access server does the following to a
record:</p>
<ul>
  <li>Puts data into the record.</li>
  <li>Processes the record.</li>
  <li>Reads a large array from the record. The array is too big to fit in a
    single network buffer.</li>
</ul>

<p>This can be implemented as follows:</p>
<ul>
  <li>server calls recordSupport.setActive</li>
  <li>server locks the record, puts data, unlocks the record.</li>
  <li>server calls recordSupport.process and specifies that the record be
    left active.</li>
  <li>When processing is complete recordSupport calls
    server.recordProcessResult and server.recordProcessDone.</li>
  <li>The server gets the array. It may have to access the array multiple
    times because of the network buffer restrictions. It must lock the record
    as it reads each segment.</li>
  <li>The server calls recordSupport.setInactive.</li>
</ul>

<h3 id="Link">Link Support Example</h3>

<p>As an example assume that a record type double has the following
fields:</p>
<dl>
  <dt>value</dt>
    <dd>A DBDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A DBlink field for input.</dd>
  <dt>output</dt>
    <dd>A DBLinkArray field.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>doubleRecord</dt>
    <dd>The record support module. It's process method calls two other
      support modules: The first must be support for a link that can input a
      double value. The second must support an array of links. The support
      must be able to call link support for each element of the array. Each
      element support can either require no input or a single value that is a
      double.</dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e.
      a link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links,
      i.e. a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e.
      a link that can put data to another record.</dd>
  <dt>linkArray</dt>
    <dd>A support module for an array on links. For each array element it
      knows how to use the associated link support module.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "doubleRecord"&gt;
    &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;recordForInput&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
    &lt;/input&gt;

    &lt;supportArray&gt;
        &lt;value structureName = "supportArrayElement"&gt;
            &lt;wait&gt;false&lt;/wait&gt;
            &lt;link  supportName = "processSupport" structureName = "processSupport"&gt;
                &lt;pvname&gt;processRecord&lt;/pvname&gt;
            &lt;/link&gt;
        &lt;/value&gt;
        &lt;value structureName = "supportArrayElement"&gt;
            &lt;wait&gt;false&lt;/wait&gt;
            &lt;link  supportName = "outputSupport" structureName = "outputSupport"&gt;
                &lt;pvname&gt;outputRecord&lt;/pvname&gt;
                &lt;process&gt;true&lt;/process&gt;
            &lt;/link&gt;
        &lt;/value&gt;
    &lt;/supportArray&gt;

&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess locks the record, prepares it for processing and sets it
    active. The record will remain active until the record is completely
    processed.</li>
  <li>recordProcess calls doubleRecord.process</li>
  <li>doubleRecord calls inputSupport.process.</li>
  <li>Assuming the recordForInput is local and since process is false, the
    input support just: 
    <ul>
      <li>locks the linked record</li>
      <li>transfers data from the linked record to the double record.</li>
      <li>unlocks the linked record.</li>
      <li>notifys doubleRecord that it has completed.</li>
    </ul>
  </li>
  <li>doubleRecord calls supportArray.process.</li>
  <li>supportArray calls recordProcess.requestProcessCallback.</li>
  <li>doubleRecord returns.</li>
  <li>recordProcess unlocks the record and calls
    supportArray.processCallback. supportArray performs whatever action is
    required to process the processRecord and to put data into and process
    record outputRecord.</li>
  <li>supportArray, when done, calls recordSupport.processContinue.</li>
  <li>recordSupport calls supportArray.processContinue</li>
  <li>supportArray calls doubleRecord.supportProcessDone.</li>
  <li>doubleRecord calls recordProcess.supportProcessDone</li>
  <li>recordProcess completes record processing 
    <ul>
      <li>calls recordProcessRequester.recordProcessResult</li>
      <li>unlocks the record and sets the record inactive.</li>
      <li>calls recordProcessRequester.recordProcessComplete.</li>
    </ul>
  </li>
</ul>

<h3 id="Support">Support State</h3>

<p>Before support is ready for processing it must be ready. In addition
on-line add and delete is supported. Thus it is possible to dynamically
redefine link fields, array fields, etc. Unless a support module is in the
ready state it's process method should not be called and if it is it should
just report failure.</p>
<pre>    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }</pre>

<p>NOTE: zombie is for support that is being removed and can never again
process.</p>

<p>Every Support module must implement the methods initialize, start, stop,
and uninitialize. Initialize performs initialization related to the record
instance being supported but can not access anything outside the record.
Start completes all initialization including linking to the outside, e.g. to
other records. Stop must remove all access to the outside. Uninitialize must
remove all access to the record instance being supported.</p>

<h3 id="Locking">Locking</h3>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when and field is being accessed.</li>
  <li>A record must be locked while processing. 
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support
        interacts with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks take.</li>
  <li>Locks should always be taken with code that has the form: 
    <pre>record.lock();
try {
     ...

} finally {
    record.unlock();
}
    </pre>
  </li>
  <li>Code must not block while a record is locked.</li>
  <li>Two record can be locked simultaneously via: 
    <pre>record.lockOtherRecord(otherRecord);
try {
     ...

} finally {
    otherRecord.unlock();
}
    </pre>
    While a record is locked another record should never be locked by calling
    it's record.lock directly. Doing so can lead to deadlocks. It is NOT
    permissible to lock more than two records at a time.</li>
</ul>

<p></p>
<hr />

<h2 style="text-align: center;" id="Record1">Record Process</h2>
<hr />

<h3 id="Definition1">Definitions</h3>

<p>The following are the interfaces for record processing:</p>
<pre>    public interface RecordProcess {
        // general purpose methods
        boolean isEnabled();
        boolean setEnabled(boolean value);
        boolean isActive();
        DBRecord getRecord();
        boolean isTrace();
        boolean setTrace(boolean value);
        SupportState getSupportState();
        // support lifecycle methods
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void allSupportStarted();
        // record process requester methods
        boolean setRecordProcessRequester(
            RecordProcessRequester recordProcessRequester);
        boolean releaseRecordProcessRequester(
            RecordProcessRequester recordProcessRequester);
        void releaseRecordProcessRequester();
        String getRecordProcessRequesterName();
        boolean canProcessSelf();
        boolean processSelfRequest(RecordProcessRequester recordProcessRequester);
        void processSelfSetActive(RecordProcessRequester recordProcessRequester);
        void processSelfProcess(RecordProcessRequester recordProcessRequester,
            boolean leaveActive);
        void processSelfSetInactive(RecordProcessRequester recordProcessRequester);
        boolean setActive(RecordProcessRequester recordProcessRequester);
        boolean process(RecordProcessRequester recordProcessRequester,
            boolean leaveActive, TimeStamp timeStamp);
        void setInactive(RecordProcessRequester recordProcessRequester);
        // support processing methods
        void processContinue(
            ProcessContinueRequester processContinueRequester);
        void requestProcessCallback(
            ProcessCallbackRequester processCallbackRequester);
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
    }

    public interface RecordProcessRequester extends Requester{
        void recordProcessResult(RequestResult requestResult);
        void recordProcessComplete();
    }
    
    public interface ProcessCallbackRequester extends Requester{
        void processCallback();
    }

    public interface ProcessContinueRequester {
        void processContinue();
    }
    
    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>An instance of RecordProcess is created for each IOCrecord. Each method
falls into one of the following classes:</p>
<ol>
  <li>General Purpose. These are methods that can be called by any code. If
    necessary a method locks the record while performing its action and
    unlocks before returning.</li>
  <li>Record Support Lifetime. Initialize,start,stop,ininitialize.</li>
  <li>Record Process Requester: These are methods for code that requests
    record processing.</li>
  <li>Support Processing. These are methods for use by support code, i.e.
    code that implements record processing.</li>
</ol>

<h3 id="RecordProc">RecordProcess - General Purpose Methods</h3>
<dl>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>Is the record enabled?</dd>
  <dt style="font-family: courier;">setEnabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when a record is disabled the current process
      is allowed to complete.</dd>
  <dt style="font-family: courier;">isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt style="font-family: courier;">isTrace</dt>
    <dd>Is trace active for this record?</dd>
  <dt style="font-family: courier;">setTrace</dt>
    <dd>Set tracing on or off. When true info messages are sent to
      dbRecord.message whenever any processing related method is called.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the current support state.</dd>
</dl>

<h3 id="RecordProc1">RecordProcess - Record Lifetime Methods.</h3>

<p><span style="font-family: courier;">RecordProcess</span> looks for the
fields <span style="font-family: courier;">timeStamp</span>, <span
style="font-family: courier;">processAfterStart</span> , and <span
style="font-family: courier;">scan</span>. It handled these fields itself.
The record support code must ignore these fields.</p>
<dl>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Initialize record support. record support, in turn, initializes
      support that it invokes. Initialize should perform any initialiation
      not requiring access aanything outside the record. For example it is
      not permissible to connect to other records. If initialize is
      successful record support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span></dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start record support. Again record support calls start for any
      support it invokes. If successful, the support enters state <span
      style="font-family: courier;">SupportState.ready</span>. Until record
      support is in the ready state and attempt to process a record will
    fail.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop record support. Record support calls stop for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span>.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Unitialize record support. It calls unitialize for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForInitialize.</span></dd>
  <dt style="font-family: courier;">allSupportStarted</dt>
    <dd>This is called after all records currently being loaded have
      successfully started.</dd>
</dl>

<h3 id="RecordProc2">RecordProcess - Record Process Requester Methods</h3>

<p>These are methods called by code that wants a record processed.</p>
<dl>
  <dt style="font-family: courier;">canProcessSelf</dt>
    <dd>Can the record process itself? This is true if scan.processSelf is
      true. In this case scanSupport, itself, is the recordProcessRequester
      and processes the record when method (processSelfRequest) is
    called.</dd>
  <dt style="font-family: courier;">setRecordProcessRequester</dt>
    <dd>Request to be the record processor. Each record instance can have
      only one record process requester. If a requester is already registered
      a message is sent to the requester and false is returned.</dd>
  <dt style="font-family: courier;">releaseRecordProcessRequester</dt>
    <dd>Release the requester. Normally a requester passes itself to this
      method when it no longer wishes to be the requester. the method without
      an argument is for use if a requester crashes without calling
    release.</dd>
  <dt style="font-family: courier;">getRecordProcessRequesterName</dt>
    <dd>Get the name of the recordProcessRequester.</dd>
  <dt style="font-family: courier;">setActive</dt>
    <dd>Prepare the record for processing but do not call record support. The
      caller must be the registered requester. If the request fails a message
      is sent to the requester and false is returned. If the request is
      successful than the caller can access the record and when ready call
      process. If successful the record is set active and another request to
      setActive will fail.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Request that the record be processed. If the caller has not called
      setActive the record is prepared for processing. In either case if the
      record is ready record support process is called. If true is returned
      the methods implemented by the recordProcessRequester are called to
      show the results of the process request. If <span
      style="font-family: courier;">leaveActive</span> is true than when the
      record completes processing it is left active until setInActive is
      called. Until the record becomes inactive another request to process
      the record will fail. Record support is called with the record
      locked.<br />
      If false is returned the request has failed and
      recordProcessRequester.message is called to provide the reason. If
      recordProcessRequester is null an IllegalStateException is thrown. </dd>
  <dt style="font-family: courier;">setInActive</dt>
    <dd>Call by the record process requester when it is done with processing.
      Calling process with <span
      style="font-family: courier;">leaveActive</span> true and then calling
      setInactive allows the requester to communicated with other code after
      the record is unlocked but before it becomes inactive.</dd>
  <dt style="font-family: courier;">processSelfRequest</dt>
    <dd>Ask that the record process itself. This request will succeed only if
      scan.processSelf is true and the record is not active. The caller must
      be prepared for a false return, which means the following methods can
      not be called.</dd>
  <dt style="font-family: courier;">processSelfSetActive</dt>
    <dd>Set the record active.</dd>
  <dt style="font-family: courier;">processSelfProcess</dt>
    <dd>Process the record.</dd>
  <dt style="font-family: courier;">processSelfSetInactive</dt>
    <dd>Set the record inactive.</dd>
</dl>

<h3 id="RecordProc3">RecordProcess - Support Processing methods.</h3>

<p>Methods called by support code which may be record support or support
called directly or indirectly by record support. Except for <span
style="font-family: courier;">processContinue</span> these methods throw an
exception unless <span style="font-family: courier;">process</span> or <span
style="font-family: courier;">processContinue</span> is running.</p>
<dl>
  <dt style="font-family: courier;">requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but
      before RecordProcess.process returns. The callback is made with the
      record unlocked. Thus the callback can request that other records be
      processed. This is the way support code can process other records. If
      support code directly request processing of linked records deadlocks
      can occur.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only
      way asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt style="font-family: courier;">setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a
      record is being processed, then RecordProcess will set the time stamp
      if the record has a timeStamp field.</dd>
  <dt style="font-family: courier;">getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <span
      style="font-family: courier;">setTimeStamp</span></dd>
</dl>

<h3 id="RecordProc4">RecordProcessRequester</h3>

<p>Methods implemented by code that requests that a record be processed.</p>
<dl>
  <dt style="font-family: courier;">recordProcessResult</dt>
    <dd>The results of record processing. This is called with the record
      locked so that the process requester can access data from the
    record.</dd>
  <dt style="font-family: courier;">recordProcessComplete</dt>
    <dd>Processing is complete. This is called with the record unlocked. If
      the process requester called process with <span
      style="font-family: courier;">leaveActive</span> <span
      style="font-family: courier;">true</span> then the requester must call
      <span style="font-family: courier;">setInactive.</span></dd>
</dl>

<h3 id="ProcessCal">ProcessCallbackRequester</h3>

<p>The method implemented by code that calls requestProcessCallback.</p>
<dl>
  <dt style="font-family: courier;">processCallback</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface. The callback is called with the record
      unlocked.</dd>
</dl>

<h3 id="ProcessCon">ProcessContinueRequester</h3>

<p>The method implemented by code that calls processContinue.</p>
<dl>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>A request to call support with the record locked. This is the only
      way asynchronous support should continue processing.</dd>
</dl>

<h3 id="SupportPro">SupportProcessRequester</h3>

<p>The method implemented by code that calls the process method of any
support code.</p>
<dl>
  <dt style="font-family: courier;">supportProcessDone</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface. This MUST be called with either process or
      processContinue running.</dd>
</dl>

<h3 id="RecordProc5">RecordProcessFactory</h3>

<p>A factory is provided to create an instance of RecordProcess for a record
instance. It has the method:</p>
<pre>public class RecordProcessFactory {
    static public RecordProcess createRecordProcess(DBRecord dbRecord);
}</pre>
<hr />

<h2 style="text-align: center;" id="Support1">Support Creation</h2>
<hr />

<p>This is called to create all support for all fields of all records in the
IOC database passed to createSupportCreation.</p>

<h3 id="Definition2">Definitions:</h3>
<pre>    public interface SupportCreation {
        boolean createSupport();
        boolean initializeSupport();
        boolean  startSupport();
        void uninitializeSupport();
        void stopSupport();
    }

    public class SupportCreationFactory
        static public SupportCreation createSupportCreation(
            IOCDB iocdb,Requester requester);
        static public boolean createSupport(DBField dbField);
    }</pre>

<h3 id="Support2">Support Creation</h3>

<p>SupportCreation has the methods:</p>
<dl>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create the support. The return value is true only if no errors are
      reported.</dd>
  <dt style="font-family: courier;">initializeSupport</dt>
    <dd>Initialize the support. The return value is true only if all record
      instances enter the state readyForStart.</dd>
  <dt style="font-family: courier;">startSupport</dt>
    <dd>Start the support. The return value is true only if all record
      instances enter the state ready.</dd>
  <dt style="font-family: courier;">uninitializeSupport</dt>
    <dd>Uninitialize the support.</dd>
  <dt style="font-family: courier;">stopSupport</dt>
    <dd>Stop the support.</dd>
</dl>

<h3 id="Factory">Factory</h3>

<p>SupportCreationFactory has the method:</p>
<dl>
  <dt>createSupportCreation</dt>
    <dd>Create a SupportCreation database.</dd>
</dl>
</body>
</html>
