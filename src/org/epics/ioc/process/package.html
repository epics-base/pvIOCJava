<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: process</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: process<br />
package: org.epics.ioc.process<br />
2007.01.09</h1>
CONTENTS

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Processing: Theory of Operation</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Requestor">Requestor Examples</a></li>
      <li><a href="#Overview1">Overview</a></li>
      <li><a href="#Local">Local Channel Access Example</a></li>
      <li><a href="#Link">Link Support Example</a></li>
      <li><a href="#Support">Support State</a></li>
      <li><a href="#Locking">Locking</a></li>
    </ul>
  </li>
  <li><a href="#Record1">Record Process</a>
    <ul>
      <li><a href="#Definition1">Definitions</a></li>
      <li><a href="#RecordProc">RecordProcess - General Purpose
      Methods</a></li>
      <li><a href="#RecordProc1">RecordProcess - Record Lifetime
      Methods.</a></li>
      <li><a href="#RecordProc2">RecordProcess - Record Process Requestor
        Methods</a></li>
      <li><a href="#RecordProc3">RecordProcess - Support Processing
        methods.</a></li>
      <li><a href="#RecordProc4">RecordProcessRequestor</a></li>
      <li><a href="#ProcessCal">ProcessCallbackRequestor</a></li>
      <li><a href="#ProcessCon">ProcessContinueRequestor</a></li>
      <li><a href="#SupportPro">SupportProcessRequestor</a></li>
      <li><a href="#RecordProc5">RecordProcessFactory</a></li>
    </ul>
  </li>
  <li><a href="#Support1">Support</a>
    <ul>
      <li><a href="#Definition2">Definitions</a></li>
      <li><a href="#Support2">Support</a></li>
      <li><a href="#SupportSta">SupportState</a></li>
      <li><a href="#LinkSuppor">LinkSupport</a></li>
      <li><a href="#AbstractSu">AbstractSupport</a></li>
    </ul>
  </li>
  <li><a href="#Support3">Support Creation</a>
    <ul>
      <li><a href="#Definition3">Definitions:</a></li>
      <li><a href="#Support4">Support Creation</a></li>
      <li><a href="#Factory">Factory</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides support for processing IOC database records. It has
the following interfaces:</p>
<dl>
  <dt>RecordProcess</dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt>Support</dt>
    <dd>Methods implemented by support code. A record instance can have one
      or more support modules. Each instance must have a record support
      modules and each field can optionally have a field support module. All
      support modules must implement interface Support. Most will extend
      AbstractSupport</dd>
  <dt>LinkSupport</dt>
    <dd>An extension of Support for link fields.</dd>
  <dt>SupportCreation</dt>
    <dd>An interface for creating and initializing all support for a set of
      record instances.</dd>
</dl>

<p>It also has a number of interfaces implement by code that requests to be
notified about process or support events:</p>
<dl>
  <dt>RecordProcessRequestor.</dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt>SupportProcessRequestor</dt>
    <dd>Implemented by code that calls support.process.</dd>
  <dt>ProcessCallbackRequestor</dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt>ProcessContinueRequestor</dt>
    <dd>Implemented by code that call recordProcess.processContinue.</dd>
</dl>

<p>The following enum defines the support state:</p>
<dl>
  <dt>SupportState</dt>
    <dd>Specifies the current status of the support. For example is it ready
      for processing.</dd>
</dl>

<p>In addition the following classes are provided:</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>A base class that can be extended by most support code. It implements
      a number of the Support methods.</dd>
  <dt>RecordProcessFactory</dt>
    <dd>Implements RecordProcess.</dd>
  <dt>SupportCreationFactory</dt>
    <dd>Creates a process Database.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Record">Record Processing: Theory of
Operation</h2>

<h3 id="Definition">Definitions</h3>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete. It is permissible to take locks that that are
      shared by other synchronous code.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke
      other support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance.</dd>
  <dt>recordProcess</dt>
    <dd>Every record instance has an implementation of an object that
      coordinates record processing. RecordProcess is the name of the
      interface implemented by record processing.</dd>
  <dt>process requestor</dt>
    <dd>Code that asks recordProcess to process a record. Code must register
      to be the requestor and only one requestor is allow to request
      processing. Thus a registration request fails if a requestor is already
      attached to a record. If code that is not the requestor attempts to
      process a record an exception is thrown.</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h3 id="Requestor">Requestor Examples</h3>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests:
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status,
            severity, and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be
      done with as few lock/unlock cycles and context switches as possible.
      In particular the only asynchronous support should cause a context
      switch. <br />
      Typical requests are:
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or
          severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>

<h3 id="Overview1">Overview</h3>

<p>A record is processed via a call to RecordProcess.process. It in turn
calls the record support process method. Record support optionally calls the
process methods of field support modules. Each support module can optionally
call the process method of support code for subfields. Record support is just
like field support except that it is attached to the record rather than to a
subfield of the record.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support
    <p>Synchronous support is suport that can implemented without blocking,
    i.e. waiting. Asynchronous support is support that must wait. For example
    network requests must block. Asynchronous support does not cause record
    processing to block. Instead the support code returns without completing
    and arranges some other way to perform it's function. When it is done it
    again interacts with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active
    and other requests to process the record will not succeed.</p>
  </li>
  <li>record locking
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
  <li>RecordProcsssRequestor
    <p>A record can have only a single process requestor. A requestor must
    register before it can request processing.</p>
  </li>
  <li>RecordProcess
    <p>Each record has an instance of RecordProcess. It manages all process
    related activities.</p>
  </li>
</ul>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess
    <ul>
      <li>setActive
        <p>Set the record active but do not call the record support process
        method.</p>
      </li>
      <li>process
        <p>If the record has not been made active via a call to setActive it
        is set active. recordSupport.process is called. The results of
        processing are sent to the requestor via the RecordProcessRequestor
        methods. The requestor can request the record be left active when
        processing completes.</p>
      </li>
      <li>setInactive
        <p>Must be called if the requestor asked that the record be left
        active when processing completes.</p>
      </li>
      <li>processContinue
        <p>Called by asynchronous support when it is ready to continue
        processing. The record is locked and
        processContinueRequestor.processContinue is called..</p>
      </li>
      <li>requestProcessCallback
        <p>Any support code called directly or indirectly by process or
        processContinue can call this method.
        processRequestRequestor.processCallback is called with the record
        unlocked. Support code that processes other records must only issue
        the process requests via this method or deadlocks can occur.</p>
      </li>
    </ul>
  </li>
  <li>Support
    <ul>
      <li>process(SupportProcessRequestor supportProcessRequestor)
        <p>This is a method that must be implemented by all support modules.
        When the support is done it calls the supportProcessRequestor to
        report completion.</p>
      </li>
    </ul>
  </li>
  <li>RecordProcessRequestor
    <ul>
      <li>recordProcessResult(RequestResult requestResult)
        <p>Called with the record locked and all processing is complete.</p>
      </li>
      <li>recordProcessComplete()
        <p>Called with the record inlocked and processing complete.</p>
      </li>
    </ul>
  </li>
  <li>SupportProcessRequestor
    <ul>
      <li>supportProcessDone(RequestResult requestResult)
        <p>called by whoever calls support.process. In particular
        recordSupport also implements this interface.</p>
      </li>
    </ul>
  </li>
  <li>ProcessCallbackRequestor
    <ul>
      <li>processCallback()
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
  <li>ProcessContinueRequestor
    <ul>
      <li>processContinue()
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="Local">Local Channel Access Example</h3>

<p>As an example assume that a channel access server does the following to a
record:</p>
<ul>
  <li>Puts data into the record.</li>
  <li>Processes the record.</li>
  <li>Reads a large array from the record. The array is too big to fit in a
    single network buffer.</li>
</ul>

<p>This can be implemented as follows:</p>
<ul>
  <li>server calls recordSupport.setActive</li>
  <li>server locks the record, puts data, unlocks the record.</li>
  <li>server calls recordSupport.process and specifies that the record be
    left active.</li>
  <li>When processing is complete recordSupport calls
    server.recordProcessResult and server.recordProcessDone.</li>
  <li>The server gets the array. It may have to access the array multiple
    times because of the network buffer restrictions. It must lock the record
    as it reads each segment.</li>
  <li>The server calls recordSupport.setInactive.</li>
</ul>

<h3 id="Link">Link Support Example</h3>

<p>As an example assume that a record type double has the following
fields:</p>
<dl>
  <dt>value</dt>
    <dd>A DBDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A DBlink field for input.</dd>
  <dt>output</dt>
    <dd>A DBLinkArray field.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>doubleRecord</dt>
    <dd>The record support module. It's process method calls two other
      support modules: The first must be support for a link that can input a
      double value. The second must support an array of links. The support
      must be able to call link support for each element of the array. Each
      element support can either require no input or a single value that is a
      double.</dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e.
      a link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links,
      i.e. a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e.
      a link that can put data to another record.</dd>
  <dt>linkArray</dt>
    <dd>A support module for an array on links. For each array element it
      knows how to use the associated link support module.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "doubleRecord"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;recordForInput&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;

    &lt;linkArray&gt;
        &lt;value structureName = "linkArrayElement"&gt;
            &lt;wait&gt;false&lt;/wait&gt;
            &lt;link  supportName = "processLink" &gt;
                &lt;configure structureName = "processLink"&gt;
                    &lt;pvname&gt;processRecord&lt;/pvname&gt;
                &lt;/configure&gt;
            &lt;/link&gt;
        &lt;/value&gt;
        &lt;value structureName = "linkArrayElement"&gt;
            &lt;wait&gt;false&lt;/wait&gt;
            &lt;link  supportName = "outputLink" &gt;
                &lt;configure structureName = "outputLink"&gt;
                    &lt;pvname&gt;outputRecord&lt;/pvname&gt;
                    &lt;process&gt;true&lt;/process&gt;
                &lt;/configure&gt;
            &lt;/link&gt;
        &lt;/value&gt;
    &lt;/linkArray&gt;

&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess locks the record, prepares it for processing and sets it
    active. The record will remain active until the record is completely
    processed.</li>
  <li>recordProcess calls doubleRecord.process</li>
  <li>doubleRecord calls the inputLink.process</li>
  <li>Assuming the recordForInput is local and since process is false, the
    inputLink support just:
    <ul>
      <li>locks the linked record</li>
      <li>transfers data from the linked record to the double record.</li>
      <li>unlocks the linked record.</li>
      <li>notifys doubleRecord that it has completed.</li>
    </ul>
  </li>
  <li>doubleRecord call linkArray.process.</li>
  <li>linkArray calls recordProcess.requestProcessCallback.</li>
  <li>doubleRecord returns.</li>
  <li>recordProcess unlocks the record and calls linkArray.processCallback.
    linkArray performs whatever action is required to process the
    recordToProcess and to put data into and process record
    recordToPutAndProcess.</li>
  <li>linkArray, when done, calls recordSupport.processContinue.</li>
  <li>recordSupport calls linkArray.processContinue</li>
  <li>linkArray call doubleRecord.supportProcessDone.</li>
  <li>doubleRecord calls recordProcess.supportProcessDone</li>
  <li>recordProcess completes record processing
    <ul>
      <li>calls recordProcessRequestor.recordProcessResult</li>
      <li>unlocks the record and sets the record inactive.</li>
      <li>calls recordProcessRequestor.recordProcessComplete.</li>
    </ul>
  </li>
</ul>

<h3 id="Support">Support State</h3>

<p>Before support is ready for processing it must be ready. In addition
on-line add and delete is supported. Thus it is possible to dynamically
redefine link fields, array fields, etc. Unless a support module is in the
ready state it's process method should not be called and if it is it should
just report failure.</p>

<p>An enum SupportState defines the following states: readyForInitialize,
readyForStart, ready, and zombie. Zombie is for support that is being removed
and can never again process.</p>

<p>Every Support module must implement the methods initialize, start, stop,
and uninitialize. Initialize performs initialization related to the record
instance being supported but can not access anything outside the record.
Start completes all initialization including linking to the outside, e.g. to
other records. Stop must remove all access to the outside. Uninitialize must
remove all access to the record instance being supported.</p>

<h3 id="Locking">Locking</h3>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when and field is being accessed.</li>
  <li>A record must be locked while processing.
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support
        interacts with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks take.</li>
  <li>Locks should always be taken with code that has the form:
    <pre>record.lock();
try {
     ...

} finally {
    record.unlock();
}
    </pre>
  </li>
  <li>Code must not block while a record is locked.</li>
  <li>Two record can be locked simultaneously via:
    <pre>record.lockOtherRecord(otherRecord);
try {
     ...

} finally {
    otherRecord.unlock();
}
    </pre>
    While a record is locked another record should never be locked by calling
    it's record.lock directly. Doing so can lead to deadlocks. It is NOT
    permissible to lock more than two records at a time.</li>
</ul>

<p></p>
<hr />

<h2 style="text-align: center;" id="Record1">Record Process</h2>
<hr />

<h3 id="Definition1">Definitions</h3>

<p>The following are the interfaces for record processing:</p>
<pre>    public interface RecordProcess {
        // general purpose methods
        boolean isDisabled();
        boolean setDisabled(boolean value);
        boolean isActive();
        DBRecord getRecord();
        boolean setTrace(boolean value);
        // support lifecycle methods
        void initialize();
        void start();
        void stop();
        void uninitialize();
        // record process requestor methods
        boolean setRecordProcessRequestor(
            RecordProcessRequestor recordProcessRequestor);
        boolean releaseRecordProcessRequestor(
            RecordProcessRequestor recordProcessRequestor);
        void releaseRecordProcessRequestor();
        String getRecordProcessRequestorName();
        boolean setActive(RecordProcessRequestor recordProcessRequestor);
        boolean process(RecordProcessRequestor recordProcessRequestor,
            boolean leaveActive, TimeStamp timeStamp);
        void setInactive(RecordProcessRequestor recordProcessRequestor);
        // support processing methods
        void processContinue(
            ProcessContinueRequestor processContinueRequestor);
        void requestProcessCallback(
            ProcessCallbackRequestor processCallbackRequestor);
        boolean setStatusSeverity(String status, AlarmSeverity alarmSeverity);
        boolean setStatus(String status);
        String getStatus();
        AlarmSeverity getAlarmSeverity();
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
    }

    public interface RecordProcessRequestor extends Requestor{
        void recordProcessResult(RequestResult requestResult);
        void recordProcessComplete();
    }
    
    public interface ProcessCallbackRequestor extends Requestor{
        void processCallback();
    }

    public interface ProcessContinueRequestor {
        void processContinue();
    }
    
    public interface SupportProcessRequestor {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>An instance of RecordProcess is created for each IOCrecord. Each method
falls into one of the following classes:</p>
<ol>
  <li>General Purpose. These are methods that can be called by any code. If
    necessary a method locks the record while performing its action and
    unlocks before returning.</li>
  <li>Record Support Lifetime. Initialize,start,stop,ininitialize.</li>
  <li>Record Process Requestor: These are methods for code that requests
    record processing.</li>
  <li>Support Processing. These are methods for use by support code, i.e.
    code that implements record processing.</li>
</ol>

<h3 id="RecordProc">RecordProcess - General Purpose Methods</h3>
<dl>
  <dt style="font-family: courier;">isDisabled</dt>
    <dd>Is the record disabled?</dd>
  <dt style="font-family: courier;">setDisabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when setDisable is issued the current process
      is allowed to complete.</dd>
  <dt style="font-family: courier;">isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt style="font-family: courier;">setTrace</dt>
    <dd>Set tracing on or off. When true info messages are sent to
      dbRecord.message whenever any processing related method is called.</dd>
</dl>

<h3 id="RecordProc1">RecordProcess - Record Lifetime Methods.</h3>
<dl>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Initialize record support. record support, in turn, initializes
      support that it invokes. Initialize should perform any initialiation
      not requiring access aanything outside the record. For example it is
      not permissible to connect to other records. If initialize is
      successful record support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span></dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start record support. Again record support calls start for any
      support it invokes. If successful, the support enters state <span
      style="font-family: courier;">SupportState.ready</span>. Until record
      support is in the ready state and attempt to process a record will
    fail.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop record support. Record support calls stop for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span>.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Unitialize record support. It calls unitialize for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForInitialize.</span></dd>
</dl>

<h3 id="RecordProc2">RecordProcess - Record Process Requestor Methods</h3>

<p>These are methods called by code that wants a record processed.</p>
<dl>
  <dt style="font-family: courier;">setRecordProcessRequestor</dt>
    <dd>Request to be the record processor. Each record instance can have
      only one record process requestor. If a requester is already registered
      a message is sent to the requestor and false is returned.</dd>
  <dt style="font-family: courier;">releaseRecordProcessRequestor</dt>
    <dd>Release the requestor. Normally a requestor passes itself to this
      method when it no longer wishes to be the requestor. the method without
      an argument is for use if a requestor crashes without calling
    release.</dd>
  <dt style="font-family: courier;">setActive</dt>
    <dd>Prepare the record for processing but do not call record support. The
      caller must be the registered requestor. If the request fails a message
      is sent to the requestor and false is returned. If the request is
      successful than the caller can access the record and when ready call
      process. If successful the record is set active and another request to
      setActive will fail.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Request that the record be processed. If the caller has not called
      setActive the record is prepared for processing. In either case if the
      record is ready record support process is called. If true is returned
      the methods implemented by the recordProcessRequestor are called to
      show the results of the process request. If <span
      style="font-family: courier;">leaveActive</span> is true than when the
      record completes processing it is left active until setInActive is
      called. Until the record becomes inactive another request to process
      the record will fail. Record support is called with the record
      locked.<br />
      The request will fail for the following reasons:
      <ul>
        <li>The record is already active. Unless the caller passed a null
          value for listener it will be added to a list of listeners to call
          when the record completes processing. The return value will be
          alreadyActive.</li>
        <li>The caller is not the registered process requestor. If this case
          an exception is thrown.</li>
        <li>The record state is not RecordState.constructed. The return value
          is failure. This can happen if the changes are being made to the
          the definitions of any of the fields in the record instance, i.e.
          on-line add/delete is in process for the record.</li>
        <li>The record is disabled. The return value is failure.</li>
        <li>The support state is not SupportState.ready. This can happen if
          online add/delete is in process or if support has failed to start
          successfully. The return value is failure.</li>
      </ul>
    </dd>
  <dt style="font-family: courier;">setInActive</dt>
    <dd>Call by the record process requestor when it is done with processing.
      Calling process with <span
      style="font-family: courier;">leaveActive</span> true and then calling
      setInactive allows the requestor to communicated with other code after
      the record is unlocked but before it becomes inactive.</dd>
</dl>

<h3 id="RecordProc3">RecordProcess - Support Processing methods.</h3>

<p>Methods called by support code which may be record support or support
called directly or indirectly by record support. Except for <span
style="font-family: courier;">processContinue</span> these methods throw an
exception unless <span style="font-family: courier;">process</span> or <span
style="font-family: courier;">processContinue</span> is running.</p>
<dl>
  <dt style="font-family: courier;">requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but
      before RecordProcess.process returns. The callback is made with the
      record unlocked. Thus the callback can request that other records be
      processed. This is the way support code can process other records. If
      support code directly request processing of linked records deadlocks
      can occur.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only
      way asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt style="font-family: courier;">setStatusSeverity</dt>
    <dd>Called by support code to set the status and severity of the record.
      support code should never directly access the status and severity
      fields of a record.</dd>
  <dt style="font-family: courier;">getStatus</dt>
    <dd>Get the latest status set by calls to <span
      style="font-family: courier;">setStateSeverity.</span></dd>
  <dt style="font-family: courier;">getAlarmSeverity</dt>
    <dd>Get the latest severity set by calls to <span
      style="font-family: courier;">setStateSeverity.</span></dd>
  <dt style="font-family: courier;">setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a
      record is being processed, then RecordProcess will set the time stamp
      if the record has a timeStamp field.</dd>
  <dt style="font-family: courier;">getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <span
      style="font-family: courier;">setTimeStamp</span></dd>
</dl>

<h3 id="RecordProc4">RecordProcessRequestor</h3>

<p>Methods implemented by code that requests that a record be processed.</p>
<dl>
  <dt style="font-family: courier;">recordProcessResult</dt>
    <dd>The results of record processing. This is called with the record
      locked so that the process requestor can access data from the
    record.</dd>
  <dt style="font-family: courier;">recordProcessComplete</dt>
    <dd>Processing is complete. This is called with the record unlocked. If
      the process requestor called process with <span
      style="font-family: courier;">leaveActive</span> <span
      style="font-family: courier;">true</span> then the requestor must call
      <span style="font-family: courier;">setInactive.</span></dd>
</dl>

<h3 id="ProcessCal">ProcessCallbackRequestor</h3>

<p>The method implemented by code that calls requestProcessCallback.</p>
<dl>
  <dt style="font-family: courier;">processCallback</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface. The callback is called with the record
      unlocked.</dd>
</dl>

<h3 id="ProcessCon">ProcessContinueRequestor</h3>

<p>The method implemented by code that calls processContinue.</p>
<dl>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>A request to call support with the record locked. This is the only
      way asynchronous support should continue processing.</dd>
</dl>

<h3 id="SupportPro">SupportProcessRequestor</h3>

<p>The method implemented by code that calls the process method of any
support code.</p>
<dl>
  <dt style="font-family: courier;">supportProcessDone</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface. This MUST be called with either process or
      processContinue running.</dd>
</dl>

<h3 id="RecordProc5">RecordProcessFactory</h3>

<p>A factory is provided to create an instance of RecordProcess for a record
instance. It has the method:</p>
<pre>public class RecordProcessFactory {
    static public RecordProcess createRecordProcess(DBRecord dbRecord);
}</pre>
<hr />

<h2 style="text-align: center;" id="Support1">Support</h2>
<hr />

<h3 id="Definition2">Definitions</h3>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>   public interface Support extends Requestor{
        SupportState getSupportState();
        DBField getDBField();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void process(SupportProcessRequestor supportProcessRequestor);
    }

    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public interface LinkSupport extends Support {
        void setField(DBField dbField);
    }

    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,DBField dbField);
        // methods from Requestor
        public String getRequestorName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public DBField getDBField();
        // following normally overridden
        public void initialize();
        public void start();
        public void stop();
        public void uninitialize();
        public void process(SupportProcessRequestor supportProcessRequestor);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following are for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
        protected DBStructure getConfigStructure(String structureName);
        protected static PVBoolean getBoolean(
            DBStructure configStructure,String fieldName)
        protected static PVByte getByte(
            DBStructure configStructure,String fieldName)
        protected static PVInt getInt(
            DBStructure configStructure,String fieldName)
        protected static PVLong getLong(
            DBStructure configStructure,String fieldName)
        protected static PVFloat getFloat(
            DBStructure configStructure,String fieldName)
        protected static PVDouble getDouble(
            DBStructure configStructure,String fieldName)
        protected static PVString getString(
            DBStructure configStructure,String fieldName)
    }</pre>

<h3 id="Support2">Support</h3>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">getRequestorName</dt>
    <dd>A requestor method to get the name of the support.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>A Requestor method. This is called to pass messages to the
    support.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Get the <span style="font-family: courier;">DBField</span> interface
      for the field that is being supported. For record support this will be
      the record itself. <span style="font-family: courier;"></span></dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
</dl>

<h3 id="SupportSta">SupportState</h3>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting
      to other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is going away.</dd>
</dl>

<h3 id="LinkSuppor">LinkSupport</h3>

<p><span style="font-family: courier;">LinkSupport</span> extends <span
style="font-family: courier;">Support</span> with the method:</p>
<dl>
  <dt style="font-family: courier;">setField</dt>
    <dd>This specifies the field in the record to/from the support will
      put/get data.</dd>
</dl>

<h3 id="AbstractSu">AbstractSupport</h3>

<p>All support code should extend AbstractSupport.</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
      constructor.</dd>
  <dt style="font-family: courier;">getRequestorName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Calls dbField.message.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Returns dbField.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Normally overridden. The default version sends a message to dbField
      and calls supportProcessRequestor with a failure result.</dd>
  <dt style="font-family: courier;">setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt style="font-family: courier;">checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
  <dt style="font-family: courier;">getConfigStructure</dt>
    <dd>Get the configuration structure for the field. <span
      style="font-family: courier;">null</span> is returned if no
      configuration structure exists.</dd>
  <dt style="font-family: courier;">getBoolean</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">boolean</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getByte</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">byte</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getInt</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">integer</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getLong</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">long</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getFloat</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">float</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getDouble</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">double</span> field of the configuration
      structure.</dd>
  <dt style="font-family: courier;">getString</dt>
    <dd>Get the interface for a <span
      style="font-family: courier;">string</span> field of the configuration
      structure.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Support3">Support Creation</h2>
<hr />

<p>This is called to create all support for all fields of all records in the
IOC database passed to createSupportCreation.</p>

<h3 id="Definition3">Definitions:</h3>
<pre>    public interface SupportCreation {
        boolean createSupport();
        boolean initializeSupport();
        boolean  startSupport();
        void uninitializeSupport();
        void stopSupport();
    }

    public class SupportCreationFactory
        static public SupportCreation createSupportCreation(
            IOCDB iocdb,Requestor requestor);
        static public boolean createSupport(DBField dbField);
    }</pre>

<h3 id="Support4">Support Creation</h3>

<p>SupportCreation has the methods:</p>
<dl>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create the support. The return value is true only if no errors are
      reported.</dd>
  <dt style="font-family: courier;">initializeSupport</dt>
    <dd>Initialize the support. The return value is true only if all record
      instances enter the state readyForStart.</dd>
  <dt style="font-family: courier;">startSupport</dt>
    <dd>Start the support. The return value is true only if all record
      instances enter the state ready.</dd>
  <dt style="font-family: courier;">uninitializeSupport</dt>
    <dd>Uninitialize the support.</dd>
  <dt style="font-family: courier;">stopSupport</dt>
    <dd>Stop the support.</dd>
</dl>

<h3 id="Factory">Factory</h3>

<p>SupportCreationFactory has the method:</p>
<dl>
  <dt>createSupportCreation</dt>
    <dd>Create a SupportCreation database.</dd>
</dl>
</body>
</html>
