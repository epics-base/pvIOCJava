<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: dbProcess</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: dbProcess<br />
package: org.epics.ioc.dbProcess<br />
2006.09.22</h1>
<hr />

<h2 style="text-align: center">Overview</h2>
<hr />

<p>This package provides support for processing IOC database records. It has
the following interfaces:</p>
<dl>
  <dt>RecordProcess</dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt>recordProcessSupport</dt>
    <dd>An instance is created for each IOC record. It has methods called by
      support code.</dd>
  <dt>Support</dt>
    <dd>Methods implemented by support code. A record instance can have one
      or more support modules. Each instance must have a record support
      modules and each field can optionally have a field support module. All
      support modules must implement interface Support. Most will extend
      AbstractSupport</dd>
  <dt>LinkSupport</dt>
    <dd>An extension of Support for link fields.</dd>
  <dt>ChannelLink</dt>
    <dd>An extension of interface Channel, which is described in package
      org.epics.ioc.channelAccess. It is used by code that implements channel
      access links, i.e. links to other IOC records.</dd>
  <dt>SupportCreation</dt>
    <dd>An interface for creating and initializing all support for a set of
      record instances.</dd>
</dl>

<p>It also has a number of listener interfaces implement by code that
requests to be notified about process or support events:
SupportStateListener, ProcessCompleteListener, and
ProcessCallbackListener.</p>

<p>In addition the following classes are provided:</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>A base class that can be extended by most support code. It implements
      a number of the Support methods.</dd>
  <dt>RecordProcessFactory</dt>
    <dd>Implements RecordProcess and RecordProcessSupport.</dd>
  <dt>SupportCreationFactory</dt>
    <dd>Creates a process Database.</dd>
  <dt>ChannelAccessLocalFactory</dt>
    <dd>Implements the Channel Access client for accessing a local IOC
      database. This is used by Link Support code and can also by used by any
      other code that resides in the same process as the IOC database.</dd>
</dl>
<hr />

<h2 style="text-align: center">Record Processing Theory of Operation</h2>

<h3>Definitions</h3>

<p>Record Processing uses the following definitions:</p>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete. It is permissible to take locks that that are
      shared by other synchronous code.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>Short for record instance.</dd>
  <dt>process</dt>
    <dd>Short for processing a record instance.</dd>
  <dt>support</dt>
    <dd>Short for code that is involved with implementing record processing.
      This code can be either synchronous or asynchronous. Support code can
      also invoke other support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance.</dd>
  <dt>recordProcess</dt>
    <dd>Every record instance has an implementation of an object that
      coordinates record processing. RecordProcess is the name of the
      interface implemented by record processing.</dd>
  <dt>process requestor</dt>
    <dd>Code that asks recordProcess to process a record. Code must register
      to be the requestor and only one requestor is allow to request
      processing. Thus a registration request fails if a requestor is already
      attached to a record. If code that is not the requestor attempt to
      process a record an exception is thrown.</dd>
  <dt>active</dt>
    <dd>A record instance is active while processing is active. Issuing a new
      process request while a record is already active will cause an
      exception.</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is not way to detect if code violates this rule
      so code must be implemented carefully.</dd>
</dl>

<h3>Requestor Examples</h3>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests it makes:
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance. It must lock the
            record while accessing but does not interact with recordProcess.
            For arrays it may have to lock and unlock the record multiple
            times. For example a channel access server might not be able to
            allocate a network buffer that hold the entire array.</dd>
        <dt>process and get</dt>
          <dd>A typical example is to process a record and get some data as
            well as the status, severity, and timeStamp. In this case the
            requestor wants the following:
            <ul>
              <li>set record active and process but leave record active</li>
              <li>get data <br />
                Note that the record must be unlocked before the requestor
                starts getting data. The requestor is responsible for locking
                and unlocking while accessing the record.</li>
              <li>make record inactive</li>
            </ul>
          </dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get the status, severity, and timeStamp. The
            requestor wants the following:
            <ul>
              <li>set record active</li>
              <li>put data <br />
                Note that the record must be unlocked before the requestor
                starts putting data. The requestor is responsible for locking
                and unlocking while accessing the record.</li>
              <li>process the record but leave it active</li>
              <li>get data <br />
                Note that the record must be unlocked before the requestor
                starts getting data. The requestor is responsible for locking
                and unlocking while accessing the record.</li>
              <li>make record inactive</li>
            </ul>
          </dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be
      done with as few lock/unlock cycles and context switches as possible.
      In particular the only asynchronous support should cause a context
      switch. <br />
      Typical requests are:
      <dl>
        <dt>process and get</dt>
          <dd>Just cause a record to process and after the record processes
            get data and/or severity. The requestor wants the following:
            <ul>
              <li>make the record active</li>
              <li>process the record</li>
              <li>get the data and/or severity.<br />
                This is done with both records locked since data will be
                transfered between the two records.</li>
              <li>make the record inactive</li>
            </ul>
          </dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, make it process, and then get
            the severity. The requestor wants the following:
            <ul>
              <li>make the record active</li>
              <li>put data the record<br />
                This is done with both records locked since data will be
                transfered between the two records.</li>
              <li>process the record</li>
              <li>get the severity.<br />
                This is done with both records locked.</li>
              <li>make the record inactive</li>
            </ul>
          </dd>
      </dl>
    </dd>
</dl>

<h3>Overview</h3>

<p>A record is processed via a call to RecordProcess.process. It in turn
calls record support Support.process. Record support optionally calls the
process methods of field support modules. Each support module can optionally
call the process method of support code for subfields.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support
    <p>Synchronous support is suport that can implemented without blocking,
    i.e. waiting. Asynchronous support is support that must wait. For example
    network requests must block. Asynchronous support does not cause record
    processing to block. Instead the support code returns active and arranges
    some other way to perform it's function. When it is done it again
    interacts with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active
    and other requests to process the record will not succeed.</p>
  </li>
  <li>record locking
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
</ul>

<p>In the following recordProcess will mean a combination of RecordProcess
and RecordProcessSupport methods.</p>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess
    <ul>
      <li>ProcessReturn process(ProcessCompleteListener listener);
        <p>This is the request to process a record. If the record is already
        active, i.e. being processed the rerturn value is alreadyActive. If
        the record is not active it is set active, the record is locked, and
        record support is called. If record support returns active the record
        stays in the active state until listener is called. When record
        support returns the record is unlocked.</p>
      </li>
      <li>void requestProcessCallback(ProcessCallbackListener
        processCallbackListener);
        <p>Any support code called as a result of process being called can
        call this method. When record support returns to recordProcess all
        the callback are called with the record unlocked. Support code that
        wants to process other records must only issue the process requests
        via this method or deadlocks can occur.</p>
      </li>
      <li>void processContinue(Support support);
        <p>When asynchronous support code is again ready to access records
        and/or interact with other support code it must first call
        processContinue which will lock the record.</p>
      </li>
    </ul>
  </li>
  <li>Support
    <ul>
      <li>ProcessReturn process(ProcessCompleteListener listener);
        <p>This is a method that must be implemented by all support
        modules.</p>
      </li>
    </ul>
  </li>
</ul>

<h3>Example</h3>

<p>As an example assume that a record type double has the following
fields:</p>
<dl>
  <dt>value</dt>
    <dd>A DBDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A DBlink field for input.</dd>
  <dt>output</dt>
    <dd>A DBLinkArray field.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>doubleRecord</dt>
    <dd>The record support module. When it's process method is called it
      calls two other support modules: The first must be support for a link
      that can input a double value. The second must support an array of
      links. The support must be able to call link support for each element
      of the array. Each element support can either require no input or a
      single value that is a double.</dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e.
      a link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links,
      i.e. a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e.
      a link that can put data to another record.</dd>
  <dt>linkArray</dt>
    <dd>A support module for an array on links. For each array element it
      knows how to use the associated link support module.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "doubleRecord"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;recordForInput&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
            &lt;wait&gt;false&lt;/wait&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
    &lt;process supportName = "linkArray" &gt;
        &lt;value  supportName = "processLink" &gt;
            &lt;configure structureName = "processLink"&gt;
                &lt;pvname&gt;recordToProcess&lt;/pvname&gt;
                &lt;wait&gt;true&lt;/wait&gt;
            &lt;/configure&gt;
        &lt;/value&gt;
        &lt;value supportName = "outputLink" &gt;
            &lt;configure structureName = "outputLink"&gt;
                &lt;pvname&gt;recordToPutAndProcess&lt;/pvname&gt;
                &lt;process&gt;true&lt;/process&gt;
                &lt;wait&gt;true&lt;/wait&gt;
            &lt;/configure&gt;
        &lt;/value&gt;
    &lt;/process&gt;
&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess sets the record active. The record will remain active
    until the record is completely processed.</li>
  <li>recordProcess locks the record.</li>
  <li>recordProcess calls doubleRecord.</li>
  <li>doubleRecord calls the inputLink support.</li>
  <li>inputLink calls recordProcess.requestProcessCallback and returns
  active.</li>
  <li>doubleRecord returns active.</li>
  <li>recordProcess unlocks the record and calls inputLink.callback.
    inputLink performs whatever action is required to get the data. For
    example if the link is a local link, the linked record and the record
    containing the link are both locked and the data is copied between the
    records. When inputLink is done it calls the processComplete method of
    the listener passed to linkSupport by doubleRecord.</li>
  <li>doubleRecord calls recordProcess.processContinue.</li>
  <li>recordProcess locks the record and calls
  doubleRecord.processContinue.</li>
  <li>doubleRecord call linkArray.</li>
  <li>linkArray calls recordProcess.requestProcessCallback and returns
  active.</li>
  <li>doubleRecord returns active.</li>
  <li>recordProcess unlocks the record and calls linkArray.callback.
    linkArray performs whatever action is required to process the
    recordToProcess and to put data into and process record
    recordToPutAndProcess. When linkArray is done it calls the
    processComplete method of the listener passed to linkArray by
    doubleRecord.</li>
  <li>doubleRecord is now done and calls the processComplete method of the
    listener passed to it by recordProcess.</li>
  <li>recordProcess sets the record inactive.</li>
</ul>

<h3>Support State</h3>

<p>Before support is ready for processing it must be ready. In addition
on-line add and delete is supported. Thus it is possible to dynamically
redefine link fields, array fields, etc. Unless a support module is in the
ready state it's process method should not be called and if it is it should
just return failure.</p>

<p>An enum SupportState defines the following states: readyForInitialize,
readyForStart, ready, and zombie. Zombie is for support that is being removed
and can never again process.</p>

<p>Every Support module must implement the methods initialize, start, stop,
and uninitialize. Initialize performs initialization related to the record
instance being supported but can not access anything outside the record.
Start completes all initialization including linking to the outside, e.g. to
other records. Stop must remove all access to the outside. Uninitialize must
remove all access to the record instance being supported.</p>

<h3>Locking</h3>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when and field is being accessed.</li>
  <li>A record must be locked while processing.
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support
        interacts with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks take.</li>
  <li>Locks should always be taken with code that has the form:
    <pre>lock();
try {
     ...

} finally {
    unlock();
}
    </pre>
  </li>
</ul>

<p></p>
<hr />

<h2 style="text-align: center;">Record Process</h2>
<hr />

<p>The following are the interfaces for record processing:</p>
<pre>    public enum ProcessReturn {
        zombie,
        noop,
        success,
        failure,
        active,
        alreadyActive
    }

    public enum ProcessResult {
        success,
        failure
    }

    public interface RecordProcess {
        boolean isDisabled();
        boolean setDisabled(boolean value);
        boolean isActive();
        DBRecord getRecord();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        ProcessReturn process(ProcessCompleteListener listener);
        void update();
        void removeCompletionListener(ProcessCompleteListener listener);
        RecordProcessSupport getRecordProcessSupport();
        boolean setTrace(boolean value);
    }

    public interface RecordProcessSupport {
        void requestProcessCallback(
            ProcessCallbackListener processCallbackListener);
        void processContinue(Support support);
        boolean setStatusSeverity(String status, AlarmSeverity alarmSeverity);
        String getStatus();
        AlarmSeverity getAlarmSeverity();
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
        void errorMessage(String message);
    }

    public interface ProcessCompleteListener {
        void processComplete(Support support,ProcessResult result);
    }

    public interface ProcessCallbackListener {
        void callback();
    }</pre>

<p>An instance of RecordProcess and RecordProcessSupport are created for each
IOCrecord. RecordProcessSupport methods are called by support code, i.e.
recordSupport, linkSupport, etc. RecordProcess methods are called to request
record processing and or find out the process state of a record.</p>

<p><span style="font-family: courier;">RecordProcess</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">isDisabled</dt>
    <dd>Is the record disabled?</dd>
  <dt style="font-family: courier;">setDisabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when setDisable is issued the current process
      is allowed to complete.</dd>
  <dt style="font-family: courier;">isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt style="font-family: courier;">initialize</dt>
  <dt style="font-family: courier;">start</dt>
  <dt style="font-family: courier;">stop</dt>
  <dt style="font-family: courier;">uninitialize</dt>
  <dt style="font-family: courier;">process</dt>
    <dd>Request that the record be processed. If successful the record is set
      active and the record support process method is called. In this case
      the return value from record support is returned. If record support
      returns active then it must call listener provided by RecordProcess
      when it completes processing. <br />
      The request will fail for the following reasons:
      <ul>
        <li>The record is already active. Unless the caller passed a null
          value for listener it will be added to a list of listeners to call
          when the record completes processing. The return value will be
          alreadyActive.</li>
        <li>The record state is not RecordState.constructed. The return value
          is failure. This can happen if the changes are being made to the
          the definitions of any of the fields in the record instance, i.e.
          on-line add/delete is in process for the record.</li>
        <li>The record is disabled. The return value is failure.</li>
        <li>The support state is not SupportState.ready. This can happen if
          online add/delete is in process or if support has failed to start
          successfully. The return value is failure.</li>
      </ul>
    </dd>
  <dt style="font-family: courier;">update</dt>
    <dd>Request that an active record update. The result is record support
      dependent. Most support does nothing. Some support, e.g. motor record
      support updates it's internal state.</dd>
  <dt style="font-family: courier;">removeCompletionListener</dt>
    <dd>Remove a record completion listener from the list of listeners to
      call.</dd>
  <dt style="font-family: courier;">getRecordProcessSupport</dt>
    <dd>Get the RecordProcessSupport interface.</dd>
  <dt>setTrace</dt>
    <dd>If true a message will displayed whenever process,
      requestProcessCallback, or processContinue are called.</dd>
</dl>

<p><span style="font-family: courier;">RecordProcessSupport</span>, which
should only be called by support code, has the methods:</p>
<dl>
  <dt style="font-family: courier;">requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but
      before RecordProcess.process returns. The callback will be made with
      the record unlocked. Thus the callback can request that other records
      be processed. This is the way support code can process other records.
      If support code directly request processing of linked records deadlocks
      can occur.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only
      way asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt style="font-family: courier;">setStatusSeverity</dt>
    <dd>Called by support code to set the status and severity of the record.
      support code should never directly access the status and severity
      fields of a record.</dd>
  <dt style="font-family: courier;">getStatus</dt>
    <dd>Get the latest status set by calls to <span
      style="font-family: courier;">setStateSeverity.</span></dd>
  <dt style="font-family: courier;">getAlarmSeverity</dt>
    <dd>Get the latest severity set by calls to <span
      style="font-family: courier;">setStateSeverity.</span></dd>
  <dt style="font-family: courier;">setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a
      record is being processed, then RecordProcess will set the time stamp
      if the record has a timeStamp field.</dd>
  <dt style="font-family: courier;">getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <span
      style="font-family: courier;">setTimeStamp</span></dd>
</dl>

<p><span style="font-family: courier;">ProcessCompleteListener</span> has the
single method:</p>
<dl>
  <dt style="font-family: courier;">processComplete</dt>
    <dd>Processing is complete. Either failure or success can be returned.
      Note that this same interface is used by RecordProcess and by most
      support code.</dd>
</dl>

<p><span style="font-family: courier;">ProcessCallbackListener</span> has the
single method:</p>
<dl>
  <dt style="font-family: courier;">callback</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface.</dd>
</dl>
<hr />

<h2 style="text-align: center;">Support</h2>
<hr />

<p>The following interfaces are used by support code, i.e. record, link, and
any other support code that is involved with record processing:</p>
<pre>   public interface Support {
        String getName();
        SupportState getSupportState();
        DBData getDBData();
        boolean addSupportStateListener(SupportStateListener listener);
        boolean removeSupportStateListener(SupportStateListener listener);
        void errorMessage(String message);
        void initialize();
        void start();
        void stop();
        void uninitialize();
        ProcessReturn process(ProcessCompleteListener listener);
        void processContinue();
        void update();
    }

    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public interface SupportStateListener {
        void newState(Support support,SupportState state);
    }

    public interface LinkSupport extends Support {
        void setField(PVData field);
    }</pre>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>Get the support name. Implemented by <span
      style="font-family: courier;">AbstractSupport.</span></dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state. Implemented by <span
      style="font-family: courier;">AbstractSupport</span>. Note that <span
      style="font-family: courier;">AbstractSupport</span> provides a
      protected method <span
      style="font-family: courier;">setSupportState</span> which must be
      called by support code whenever it changes support state.</dd>
  <dt style="font-family: courier;">getDBData</dt>
    <dd>Get the <span style="font-family: courier;">DBData</span> interface
      for the field that bis being supported. For record support this will be
      the <span style="font-family: courier;">DBRecord</span> itself.
      Implemented by <span
      style="font-family: courier;">AbstractSupport.</span></dd>
  <dt style="font-family: courier;">addSupportStateListener</dt>
    <dd>Add listener to be called when the support state changes. Implemented
      by <span style="font-family: courier;">AbstractSupport.</span></dd>
  <dt style="font-family: courier;">removeSupportStateListener</dt>
    <dd>Remove a support state listener. Implemented by <span
      style="font-family: courier;">AbstractSupport.</span></dd>
  <dt style="font-family: courier;">errorMessage</dt>
    <dd>Generate an error message. Implemented by <span
      style="font-family: courier;">AbstractSupport</span>. It adds to the
      message the record instance name ands the hierarchical field name.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Continue processing. Note that this must be called as a result of a
      call to RecorrProcessSupport.processContinue.</dd>
  <dt style="font-family: courier;">update</dt>
    <dd>Optional method. <span
      style="font-family: courier;">AbstractSupport</span> implements this by
      doing nothing.</dd>
</dl>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting
      to other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is going away.</dd>
</dl>

<p><span style="font-family: courier;">SupportStateListener</span> has the
single method:</p>
<dl>
  <dt style="font-family: courier;">newState</dt>
    <dd>The new state.</dd>
</dl>

<p><span style="font-family: courier;">LinkSupport</span> extends <span
style="font-family: courier;">Support</span> with the method:</p>
<dl>
  <dt style="font-family: courier;">setField</dt>
    <dd>This specifies the field in the record to/from the support will
      put/get data.</dd>
</dl>

<p>All support code should extend AbstractSupport, which declares the
following methods abstract: initialize, start, stop, uninitialize, and
process. Support code may also chose to override update. AbstractSupport also
implements the protected methods:</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport(String name,DBData
  dbData)</dt>
    <dd>The constructor which must be called by the support constructor.</dd>
  <dt style="font-family: courier;">setSupportState(SupportState state)</dt>
    <dd>This must be called by support whenever it changes state.</dd>
</dl>
<hr />

<h2 style="text-align: center;">SupportCreation</h2>
<hr />

<p>This is MARTY SAY SOMETHING</p>
<pre>    public interface SupportCreation {
        boolean createSupport();
        boolean initializeSupport();
        boolean  startSupport();
        void uninitializeSupport();
        void stopSupport();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create the support. The return value is true only if no errors are
      reported.</dd>
  <dt style="font-family: courier;">initializeSupport</dt>
    <dd>Initialize the support. The return value is true only if all record
      instances enter the state readyForStart.</dd>
  <dt style="font-family: courier;">startSupport</dt>
    <dd>Start the support. The return value is true only if all record
      instances enter the state ready.</dd>
  <dt style="font-family: courier;">uninitializeSupport</dt>
    <dd>Uninitialize the support.</dd>
  <dt style="font-family: courier;">stopSupport</dt>
    <dd>Stop the support.</dd>
</dl>
<hr />

<h2 style="text-align: center;">Record Process</h2>
<hr />

<p>RecordProcess is an interface implemented for every record instance.</p>
<pre>    public interface RecordProcess {
        boolean isDisabled();
        boolean setDisabled(boolean value);
        boolean isActive();
        ProcessDB getProcessDB();
        DBRecord getRecord();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        ProcessReturn process(ProcessCompleteListener listener);
        void update();
        void removeCompletionListener(ProcessCompleteListener listener);
        RecordProcessSupport getRecordProcessSupport();
        boolean setTrace(boolean value);
    }
    
    public interface RecordProcessSupport {
        void requestProcessCallback(ProcessCallbackListener processCallbackListener);
        void processContinue(Support support);
        boolean setStatusSeverity(String status, AlarmSeverity alarmSeverity);
        String getStatus();
        AlarmSeverity getAlarmSeverity();
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
        void errorMessage(String message);
    }
    
    public class RecordProcessFactory {
        static public RecordProcess createRecordProcess(DBRecord dbRecord) {
    }</pre>
<hr />

<h2 style="text-align: center;">Support Creation Factory</h2>
<hr />
<hr />
<pre>    public class SupportCreationFactory
        static public SupportCreation createSupportCreation(IOCDB iocdb)
    }</pre>

<p>where</p>
<dl>
  <dt>createSupportCreation</dt>
    <dd>Create a SupportCreation database.</dd>
</dl>

<h2 style="text-align: center;">Local Channel Access</h2>
<hr />

<p>An implementation of a channel access client for accessing records in the
IOC database is provided:</p>
<pre>    public interface ChannelLink extends Channel {
        void setLinkRecord(DBRecord record);
        DBRecord getLinkRecord();
    }

    public class ChannelAccessLocalFactory  {
        static public boolean create(IOCDB iocdb);
    }</pre>

<p>The factory creates a single instance of an implementation of a channel
access client for accessing local records. This is used by link support.</p>
</body>
</html>
