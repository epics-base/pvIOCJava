<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIOC: Database Definition</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Definition <br />
package: org.epics.ioc.dbDefinition<br />
2006.09.22</h1>
<hr />

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database Definition Syntax</a>
    <ul>
      <li><a href="#General">General Statements</a>
        <ul>
          <li><a href="#namespace">namespace</a></li>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro">Macro Substitution</a></li>
        </ul>
      </li>
      <li><a href="#Menu">Menu</a></li>
      <li><a href="#Structure">Structure and Record Type</a></li>
      <li><a href="#field">field</a>
        <ul>
          <li><a href="#Primitive">Primitive Types</a></li>
          <li><a href="#string">string</a></li>
          <li><a href="#enumerated">enumerated</a></li>
          <li><a href="#structure">structure</a></li>
          <li><a href="#array">array</a></li>
          <li><a href="#menu">menu</a></li>
          <li><a href="#link">link</a></li>
        </ul>
      </li>
      <li><a href="#field1">field attribute</a></li>
      <li><a href="#property">property</a></li>
      <li><a href="#Support">Support</a></li>
    </ul>
  </li>
  <li><a href="#Overview1">Overview of Java Support For Database
    Definition</a></li>
  <li><a href="#Database1">Database Types</a></li>
  <li><a href="#Introspect">Introspection of Database Definitions</a>
    <ul>
      <li><a href="#Menu1">Menu</a></li>
      <li><a href="#Structure1">Structure and RecordType</a></li>
      <li><a href="#Support1">Support</a></li>
    </ul>
  </li>
  <li><a href="#Reflection">Reflection for Database Fields</a>
    <ul>
      <li><a href="#Field">Field Introspection</a></li>
    </ul>
  </li>
  <li><a href="#Accessing">Accessing Database Definitions</a>
    <ul>
      <li><a href="#DBD">DBD</a></li>
    </ul>
  </li>
  <li><a href="#Creating">Creating Database Definitions</a>
    <ul>
      <li><a href="#DBDFactory">DBDFactory</a></li>
      <li><a href="#XMLToDBDFa">XMLToDBDFactory</a></li>
      <li><a href="#Creating1">Creating Database Definitions</a></li>
    </ul>
  </li>
  <li><a href="#Implementa">Implementation Specific Definitions</a>
    <ul>
      <li><a href="#DBDCreateF">DBDCreateFactory</a></li>
      <li><a href="#AbstractDB">AbstractDBDField</a></li>
      <li><a href="#DBDAttribu">DBDAttribute ETC</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type.</p>

<p>This package describes support for Database Definitions, i.e. support for
the following database components: menu, structure, recordType, and support.
Included are factories for creating multiple DBD (Database Definition)
instances. A DBD provides reflection interfaces for all database components
it contains. dbAccess, which implements a javaIOC database, uses a DBD to
implement database reflection.</p>

<p>The following is discussed:</p>
<ol>
  <li>Database Definition Syntax<br />
    The XML syntax for defining menus, structures, record types, and
    support.<br />
  </li>
  <li>Java Support for Database Definitions</li>
  <li>Factory support for Database Definitions</li>
  <li>parser support<br />
    This reads an xml file containing menu, structure, record types, and link
    support and adds them to a database definition file.</li>
  <li>Creating and using Database Definitions.<br />
  </li>
</ol>
<hr />

<h2 style="text-align: center" id="Database">Database Definition Syntax</h2>
<hr />
A Database Definition file must be an XML file with a root tag of
DBDDefinition:
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;?-- valid Database Definition elements --&gt;
&lt;/DBDefinition&gt;</pre>

<h3 id="General">General Statements</h3>

<h4 id="namespace">namespace</h4>
At this time namespaces are not used.

<h4 id="Include">Include</h4>
An XML file containing Database Definitions can include other files also
containing Database Definitions. An included file must also be a valid XML
Database Definition. Included files can also include other files. The syntax
is:
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Database Definition file, is processed. If any addPaths
      have been defined the last one specified is prefixed to the
    filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>See {@link org.epics.ioc.util} for details.</p>

<h4 id="Macro">Macro Substitution</h4>

<p>Macro substitution is not very usefull for Database Definition but it is
support just like for Database Instance files. See package
org.epics.ioc.dbAccess for details about how macro substitution works.</p>

<h3 id="Menu">Menu</h3>
A menu is an enumerated type, defined below, where the choice strings are
defined once for each IOC. The syntax is:
<pre>    
&lt;menu name = "name"&gt;
    &lt;choice&gt;choice&lt;/choice&gt;
    ...
&lt;/menu&gt;</pre>
Example:
<pre>    
&lt;menu name = "scan"&gt;
     &lt;choice&gt;passive&lt;/choice&gt;
     &lt;choice&gt;event&lt;/choice&gt;
     &lt;choice&gt;interrupt&lt;/choice&gt;
     &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;</pre>

<h3 id="Structure">Structure and Record Type</h3>

<p>Structure and recordType both define a data structure containing fields.
The main difference is that a structure can't be instanciated except as a
field of a record.</p>

<p>A structure is defined as follows:</p>
<pre>&lt;structure name = "structureName" supportName = "supportName" &gt;
     &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
     ...
     &lt;field name = "fieldName" supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...

    &lt;/field&gt;
     ...
&lt;/structure&gt;</pre>

<p>A record type is defined as follows:</p>
<pre>&lt;recordType name = "recordtypeName" supportName = "supportName" &gt;
    &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
    ...
     &lt;field name = "fieldName"  supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...
     &lt;/field&gt;
     ...
&lt;/recordType&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
  <dt><span style="font-family: courier">recordtypeName</span></dt>
    <dd>The structure or record type name.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the structure, record type, or field. A
      support definition, described below, defines the support. When record
      instances are defined, the default can be overridden.</dd>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>Should also have the same syntax as a Java identifier, unique within
      the context of this particular structure.</dd>
  <dt><span style="font-family: courier">fieldType</span></dt>
    <dd>See fieldType below.</dd>
  <dt>...</dt>
    <dd>See field attribute below</dd>
  <dt><span style="font-family: courier">propertyName and
  associatedField</span></dt>
    <dd>See property below.</dd>
</dl>

<h3 id="field">field</h3>
The syntax for <span style="font-family: courier">fieldType</span> depends on
the field type.

<h4 id="Primitive">Primitive Types</h4>
Primitive types are the same as the Java primitive types, i.e. <span
style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>. Primitive field types are just
defined as <span style="font-family: courier;">&lt;type /&gt;</span> For
example
<pre>     
    &lt;field name = "value", type = "double" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;</pre>

<h4 id="string">string</h4>
A <span style="font-family: courier">string</span> is a Java <span
style="font-family: courier;">String</span>. A <span
style="font-family: courier;">string</span> field type is just defined as
<span style="font-family: courier;">string</span>. For example:
<pre>     &lt;field name = "description" type = "string" /&gt;</pre>

<h4 id="enumerated">enumerated</h4>

<p>An enumerated field type specified as enum For example:</p>
<pre>    &lt;field name = "value" type = "enum" /&gt;</pre>

<h4 id="structure">structure</h4>
A structure field is declared as
<pre>    &lt;field name = "value" type = "structure" structureName = "name" /&gt;</pre>
<span style="font-family: courier;">structureName</span> is the name of a
structure which must have been previously defined. Example:
<pre>   &lt;structure name = "point"&gt;
       &lt;field name = "x" type = "double" /&gt;
       &lt;field name = "y"&gt; type = "double" /&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "haspoint"&gt;
       ...
       &lt;field name = "point" type = "structure" structureName = "point" /&gt;
       ...</pre>

<p>NOTE: The structureName does not have to be given. In this case the field
instance must define the structureName.</p>

<h4 id="array">array</h4>

<p>NOTE: One dimensional arrays are a supported type. Multidimensional arrays
can be supported via a <span style="font-family: courier;">structure</span>
definition with fields describing the number of dimensions and the attributes
of each dimension.</p>
An array is defined as follows:
<pre>    &lt;field name = "value" type = "array" elementType = "type" capacity = "capacity" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">elementType</dt>
    <dd>The type must be a valid type, i.e. boolean, byte, short, int, long,
      float, double, string,enum, structure, array or link. This must be
      specified. If the elementType is structure than each element can be a
      different type of structure.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The number of array elements. If not specified the capacity is
      determined at record initialization</dd>
</dl>
Examples:
<pre>     &lt;field name = "doubleArray" type = "array" elementType = "double" capacity = "3" /&gt;
     &lt;field name = "value" type = "array"  elementType = "double" /&gt;
     &lt;field name = "rectangle" type = "array" elementType = "structure" capacity = "2" /&gt;</pre>

<h4 id="menu">menu</h4>
A menu field is defined as:
<pre>     &lt;field name = "name" type = "menu" nameName = "menuName" /&gt;</pre>
where <span style="font-family: courierfont-family: courier;">menuName</span>
is the name of the menu. <br />
Example:
<pre>    &lt;field name = "scan" type = "menu" menuName = "menuScan" /&gt;</pre>

<p>To the database, a menu field is presented just like an enumerated field
with constant choices. The choices are taken from the menu definition.</p>

<h4 id="link">link</h4>
This field type can get/put data from/to a location outside the record. When
a record instance is created, the link choices come from <span
style="font-family: courier;">support</span> definitions which are defined
below. A <span style="font-family: courier;">link</span> can be a link to
another database record, to hardware device support, or something else. The
syntax is:
<pre>     &lt;field name = "name" type = "link" /&gt;</pre>
Examples:
<pre>     &lt;field name = "disableLink" type = "link" /&gt;
     &lt;field name = "input" type = "link" /&gt;</pre>

<h3 id="field1">field attribute</h3>

<p>A field can have additional attributes which are specified via xml
attributes. The additional attributes are:</p>
<pre>     default = "stringValue"
     readonly = "booleanValue"
     design = "booleanValue"
     link = "booleanValue"
     asl = "intValue"</pre>

<p>The attribute parameter values have the following meanings:</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the fields is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>
The following examples show how attributes are defined:
<pre>    &lt;recordType name = "example"&gt;
        ...
        &lt;field name = "status" type = "string" readonly "true" /&gt;
        &lt;field name = "displayLimit" type = "structure"
                structureName = "displayLimit" readonly = "true" /&gt;
        ...
        &lt;field name = "value" type = "double" asl value = "0" /&gt;
       ...
    &lt;/recordType&gt;</pre>
<br />


<h3 id="property">property</h3>
A structure, recordType, and field can have properties. A property is defined
as:
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>The name of the property</dd>
  <dt style="font-family: courier;">associatedField</dt>
    <dd>The name of a field that has the value for the property. It can have
      one of the following forms:
      <dl>
        <dt>..</dt>
          <dd>A search is made up the structure hierarchy for a field name
            that is the same as the property name. If the property is
            attached to a field then the search starts with the parent of the
            structure containing the structure. If the property is attached
            to a structure, the search starts with the parent of the
            structure itself. This is not valid for a property attached to a
            recordType.</dd>
        <dt>name</dt>
          <dd>If attached to a structure or recordType the associated field
            must be a field in that structure or recordType. If attached to a
            field it must be a field or a property in the structure that
            holds the field.</dd>
        <dt>name1.name2</dt>
          <dd>Only valid for a property attached to a structure or
            recordType. name1 must be the name of a structure field in the
            structure to which the property is attached. name2 must be a
            property of field in the structure field.</dd>
      </dl>
    </dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>

<h3 id="Support">Support</h3>

<p>Support can be associated with any field of a record instance when it is
created. See package org.epics.ioc.dbAccess for details. Record types and
structures can have default support as shown above.</p>

<p>Each support can optionally have an associated structure for configuration
information. In addition a support definition must be defined. The syntax
is:</p>
<pre>    &lt;structure name = "configurationStructureName"&gt;
        ...
    &lt;/structure&gt;
    ...
    &lt;support name = "supportName"
         configurationStructureName = "configurationStructureName"
         factoryName = "factoryName" /&gt;</pre>
where
<dl>
  <dt><span style="font-family: courier">support</span></dt>
    <dd>Support for a link field of a record.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span
  style="font-family: courier">configurationStructureName</span></dt>
    <dd>The name of a structure containing configuration information for the
      support. Database configuration tools prompt the user to assign values
      to the structure. This is optional.</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.dbProcess for details,</dd>
</dl>

<p>When a record instance is created the supportName selects the support to
attach to a record link field.</p>
<br />
Examples of support:
<pre>     &lt;structure name = "processLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "wait" type = "boolean" /&gt;
         &lt;field name = "timeout" type = "double" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;structure name = "monitorLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "process" type = "boolean"&gt;
             &lt;!-- process this record when monitor occurs --&gt;
         &lt;/field&gt;
         &lt;field name = "monitorOnly" type = "boolean"&gt;
             &lt;!-- monitor only or data also --&gt;
         &lt;/field&gt;
         &lt;field name = "inheritSeverity" type = "boolean" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;support name = "processLink" configurationStructureName = "processLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;
     &lt;support name = "monitorLink" configurationStructureName = "monitorLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;</pre>
<hr />

<h2 style="text-align: center" id="Overview1">Overview of Java Support For
Database Definition</h2>
<hr />

<p>This following sections describes support for code that accessses Database
Definitions: menu, structure, recordType and, support..</p>

<p>The interfaces support reflection for everything created from Database
Definitions. The interfaces can be used by tools such as VDCT or on a running
IOC database. The interfaces are also used by record support, link support,
and the database itself.</p>

<p>The definitions extend the support provided by pvAccess, which defines the
following types: boolean, byte, short, int, long, float, double, string,
enum, structure, and array.</p>

<p>DBType defines the database types, which extend the types defined by
pvAccess. The new types are:</p>
<dl>
  <dt>dbMenu</dt>
    <dd>Like Type.pvEnum except that the choices are readonly. This is to
      support the XML menu definitions.</dd>
  <dt>dbStructure</dt>
    <dd>Like Type.pvStructure except that fields can be a DBType.</dd>
  <dt>dbArray</dt>
    <dd>Like Type.pvArray except that nthe array elements can ba a
    DBType.</dd>
  <dt>dbLink</dt>
    <dd>This has type Type.pvUnknown, i.e. there is no data associated with
      the field but it does have configuration information.</dd>
</dl>

<p>Reflection interfaces are available for the following XML definitions</p>
<dl>
  <dt>DBDMenu</dt>
    <dd>This is for introspecting the XML menu definitions</dd>
  <dt>DBDStructure</dt>
    <dd>This is for introspecting the XML structure definitions.</dd>
  <dt>DBDRecordType</dt>
    <dd>This is for introspecting the XML recordType definitions.</dd>
  <dt>DBDSupport</dt>
    <dd>This is for introspecting the XML support definitions.</dd>
</dl>

<p>Reflection interfaces for structure and recordType fields extent the
reflection interfaces provided by org.epics.ioc.pvAccess:</p>
<dl>
  <dt>DBDField</dt>
    <dd>Extends Field</dd>
  <dt>DBDEnumField</dt>
    <dd>Extends Enum</dd>
  <dt>DBDMenuField</dt>
    <dd>Extends Enum</dd>
  <dt>DBDArrayField</dt>
    <dd>Extends Array</dd>
  <dt>DBDStructureField</dt>
    <dd>Extends Structure</dd>
  <dt></dt>
</dl>
<hr />

<h2 style="text-align: center" id="Database1">Database Types</h2>
<hr />

<p>The types, which extends the types defined by pvAccess, are:</p>
<pre>    enum DBType {
        dbPVType, // It is a plain PVType
        dbMenu,
        dbStructure,
        dbArray,
        dbLink;
    }</pre>

<p>where:</p>
<dl>
  <dt style="font-family: courier;">dbMenu</dt>
    <dd>A pvEnum with choices that are read only.</dd>
  <dt>dbStructure</dt>
    <dd>A dbStructure contains fields that can be have any DBType. This is an
      extension of pvStructure.</dd>
  <dt>dbArray</dt>
    <dd>An array element type can be any DBType. This is an extension of
      pvArray.</dd>
  <dt style="font-family: courier;">dbLink</dt>
    <dd>A link appears as a pvUnknown field that has associated support.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Introspect">Introspection of Database
Definitions</h2>
<hr />

<p>This section describes interfaces for accessing menu, structure,
recordType, and support, i.e. everything defined in Database Definition files
except record instances. Reflection for fields of a structure or recordType
is discussed in the next section.</p>

<h3 id="Menu1">Menu</h3>

<p>The interface is:</p>
<pre>    interface DBDMenu{
        String getName();
        String[] getChoices();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The menu name.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>The array of choices for the menu.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>Dumps the menu definition.</dd>
</dl>

<p>For example the following dumps a menu</p>
<pre>    void dumpMenu(DBDMenu menu) {
        String[] choices = menu.getChoices();
        System.out.printf("menu %s {\n",menu.getName();
        for(choice: choices) System.out.printf("    %s\n",choice);
        System.out.printf("}\n");
    }</pre>

<p>Note that a shorter way is:</p>
<pre>    void dumpMenu(DBDMenu menu) {System.out.println(menu.toString());}</pre>

<h3 id="Structure1">Structure and RecordType</h3>

<p>The interfaces are:</p>
<pre>    interface DBDStructure extends DBDField, Structure{
        DBDField[] getDBDFields(String fieldName);
        int getDBDFieldIndex(String fieldName);
    }

    interface DBDRecordType extends DBDStructure {}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDBDFields</dt>
    <dd>Get the introspection interfaces for the fields of the structure.
      DBDField is descrtibed in the next section.</dd>
  <dt style="font-family: courier;">getDBDFieldIndex</dt>
    <dd>Given a field name find the index for the field in the DBDField[]. If
      the field is not found -1 is returned.</dd>
</dl>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(DBDStructure structure) {
        DBDField[] fields = structure.getDBDFields();
        System.out.printf("structure %s {\n",structure.getStructureName();
        for(DBDField field : fields) {
            DBType type = field.getDBType();
            Type pvtype = field.getType();
            System.out.printf("field %s dbtype %s pvtype %s",
                field.getName(),type.toString(),pvtype.toString());
        }
    }</pre>

<p>Again a shorter way is:</p>
<pre>    void dumpStructure(DBDStructure structure) {System.out.println(structure.toString);}</pre>

<h3 id="Support1">Support</h3>

<p>The following interface is provided for accessing support.</p>
<pre>    interface DBDSupport {
        String getSupportName();
        String getConfigurationStructureName();
        String getFactoryName();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getConfigurationStructureName</dt>
    <dd>Get the configuration structire name. A null is returned if none was
      defined in the support definition. This means the support does not
      require configuration information.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.dbProcess for details about support and support
    factories.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Reflection">Reflection for Database
Fields</h2>
<hr />

<p>This section describes reflection for a field of a structure or
recordType.</p>

<h3 id="Field">Field Introspection</h3>

<p>Every field has the following set of attributes.</p>
<pre>   interface DBDFieldAttribute {
       String getDefault();
       boolean isReadOnly();
       boolean isDesign();
       boolean isLink();
       int getAsl();
       String toString(int indentLevel);
   }</pre>

<p>where</p>
<dl>
  <dt>getDefault</dt>
    <dd>A default value for the field or null if no default was defined.</dd>
  <dt>isReadonly</dt>
    <dd>(false,true) if the data for the field is (immutable, mutable)</dd>
  <dt>isDesign</dt>
    <dd>This is for use by Database Configuration tools. It is (false,true)
      if the DCT should allow values to be assigned to the field.</dd>
  <dt>isLink</dt>
    <dd>This is for use by Database Configuration tools. It is (false,true)
      if the field is the name of linked process variable.</dd>
  <dt>getAsl</dt>
    <dd>Get the Access Security Level.</dd>
</dl>

<p>The interfaces for introspecting a field are:</p>
<pre>   interface DBDField extends Field {
        DBType getDBType();
        DBDFieldAttribute getFieldAttribute();
    }

    interface DBDEnumField extends DBDField, Enum {}
    interface DBDMenuField extends DBDField, Enum {
        DBDMenu getMenu();
    }
    interface DBDStructureField extends DBDField,Structure {
         DBDField[] getDBDFields();
         DBDStructure getDBDStructure();
    }
    interface DBDArrayField extends DBDField, Array {
        DBType getElementDBType();
    }    
    </pre>

<p>Since DBDField extends Field it has the following methods:</p>
<pre>    String getName();
    Property[] getPropertys();
    Property getProperty(String propertyName);
    Type getType()
    String getSupportName();
    void setSupportName(String name);
    boolean isMutable();
    void setMutable(boolean value);
    String toString();
    String toString(int indent Level);</pre>

<p>Thus DBDField has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>Get the field name.</dd>
  <dt style="font-family: courier;">getPropertys</dt>
    <dd>Get the properties for the field. See org.epics.ioc.pvAccess for a
      description of properties.</dd>
  <dt style="font-family: courier;">getProperty</dt>
    <dd>Given a name get the Property with that name of null if no such
      property exists.</dd>
  <dt style="font-family: courier;">getType</dt>
    <dd>Get the PV Type.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the name of the support for this field or null if no support is
      defined.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>Set the name of the support for this field.</dd>
  <dt style="font-family: courier;">isMutable</dt>
    <dd>Can the value on the field be changed?</dd>
  <dt style="font-family: courier;">setMutable</dt>
    <dd>Set the mutable status for the field. This should NOT be called by
      user code.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>Dump a description of the DBDField into a string. This is for
      debugging not for normal use.</dd>
  <dt style="font-family: courier;">getDBType</dt>
    <dd>Get the DBType for the field.</dd>
  <dt style="font-family: courier;">getFieldAttribute</dt>
    <dd>Get the DBFieldAttribute interface for the field.</dd>
</dl>

<p>DBDEnumField adds the method:</p>
<pre>        boolean isChoicesMutable();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">isChoicesMutable</dt>
    <dd>The value true is returned.</dd>
</dl>

<p>DBDMenuField adds the methods:</p>
<pre>        boolean isChoicesMutable();
        DBDMenu getMenu();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">isChoicesMutable</dt>
    <dd>The value false is returned.</dd>
  <dt style="font-family: courier;">getMenu</dt>
    <dd>Get the introspection interface for the menu</dd>
</dl>

<p>DBDStructureField adds the methods:</p>
<pre>         String getStructureName();
         String[] getFieldNames();
         Field getField(String fieldName);
         int getFieldIndex(String fieldName);
         Field[] getFields();
         DBDField[] getDBDFields();
         DBDStructure getDBDStructure();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getStructureName</dt>
    <dd>Get the name of the structure.</dd>
  <dt style="font-family: courier;">getFieldNames</dt>
    <dd>Get an array containing the field name.</dd>
  <dt style="font-family: courier;">getField</dt>
    <dd>Get the introspection interface for the specified field.</dd>
  <dt style="font-family: courier;">getFieldIndex</dt>
    <dd>Get the index into Field[] or DBDField[] of the specified fieldName.
      In the fieldName is not in the structure -1 is returned.</dd>
  <dt style="font-family: courier;">getFields</dt>
    <dd>Get the array of introspection interfaces for the fields.</dd>
  <dt style="font-family: courier;">getDBDFields</dt>
    <dd>Get the array of introspection interfaces for the fields.</dd>
  <dt style="font-family: courier;">getDBDStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
</dl>

<p>DBDArray adds the methods:</p>
<pre>        Type getElementType();
        DBType getElementDBType();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getElementType</dt>
    <dd>Get the Type for the array elements</dd>
  <dt style="font-family: courier;">getElementDBType</dt>
    <dd>Get the DBType for the array elements.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Accessing">Accessing Database
Definitions</h2>
<hr />

<h3 id="DBD">DBD</h3>

<p>DBD is an interface for accessing a Database containing Database
Definitions. Methods are provided for accessing and inserting components. In
addition a number of "convenience" methods are provided.</p>
<pre>public interface DBD {
    String getName();
    DBD getMasterDBD();
    void mergeIntoMaster();
    DBDMenu getMenu(String menuName);
    boolean addMenu(DBDMenu menu);
    Map&lt;String,DBDMenu&gt; getMenuMap();
    DBDStructure getStructure(String structureName);
    boolean addStructure(DBDStructure structure);
    Map&lt;String,DBDStructure&gt; getStructureMap();
    DBDRecordType getRecordType(String recordTypeName);
    boolean addRecordType(DBDRecordType recordType);
    Map&lt;String,DBDRecordType&gt; getRecordTypeMap();
    DBDSupport getSupport(String supportName);
    boolean addSupport(DBDSupport support);
    Map&lt;String,DBDSupport&gt; getSupportMap();
    String menuList(String regularExpression);
    String menuToString(String regularExpression);
    String structureList(String regularExpression);
    String structureToString(String regularExpression);
    String recordTypeList(String regularExpression);
    String recordTypeToString(String regularExpression);
    String supportList(String regularExpression);
    String supportToString(String regularExpression);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The name of this DBD database.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Get the master DBD or null if no master was passed to
      DBDFactory.create. Normally this means that this is the master.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge this DBD into the master DBD. After merging into master the
      compoments are removed from this database.</dd>
  <dt style="font-family: courier;">getMenu</dt>
    <dd>Get the DBDMenu that describes menuName.</dd>
  <dt style="font-family: courier;">addMenu</dt>
    <dd>Add a menu definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getMenuMap</dt>
    <dd>Get a map of all the menu definitions. A shallow copy of the map is
      returned.</dd>
  <dt style="font-family: courier;">getStructure</dt>
    <dd>Get the DBDStructure that describes the structureName</dd>
  <dt style="font-family: courier;">addStructure</dt>
    <dd>Add a structure definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getStructureMap</dt>
    <dd>Get a map of all the structure definitions. A shallow copy of the map
      is returned.</dd>
  <dt style="font-family: courier;">getRecordType</dt>
    <dd>Get the DBDRecordType that describes recordTypeName.</dd>
  <dt style="font-family: courier;">addRecordType</dt>
    <dd>Add a recordType definition and return true. If the definition
      already exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getRecordTypeMap</dt>
    <dd>Get a map of all the recordType definitions. A shallow copy of the
      map is returned.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the DBDSupport that describes supportName.</dd>
  <dt style="font-family: courier;">addSupport</dt>
    <dd>Add a support definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getSupportMap</dt>
    <dd>Get a map of all the support definitions. A shallow copy of the map
      is returned.</dd>
</dl>
The remaining methods are convenience methods. Each convenience method
produces a string that lists or dumps all components with names that match a
regular expression. The java.util.regex facility is used. Consult it for a
definition of regular expressions.
<dl>
  <dt style="font-family: courier;">menuList</dt>
    <dd>Get a list of menu names that match a regular expression</dd>
  <dt style="font-family: courier;">menuToString</dt>
    <dd>Get a dump of all the DBDMenu definitions with names that match a
      regular expression.</dd>
  <dt style="font-family: courier;">structureList</dt>
    <dd>Get a list of structure names that match a regular expression</dd>
  <dt style="font-family: courier;">structureToString</dt>
    <dd>Get a dump of all the DBDStructure definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">recordTypeList</dt>
    <dd>Get a list of recordType names that match a regular expression</dd>
  <dt style="font-family: courier;">recordTypeToString</dt>
    <dd>Get a dump of all the DBDRecordType definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">supportList</dt>
    <dd>Get a list of support names that match a regular expression.</dd>
  <dt style="font-family: courier;">supportToString</dt>
    <dd>Get a dump of all the DBDSupport definitions with names that match a
      regular expression.</dd>
</dl>
An example of using a convience method is:
<pre>    String list = master.menuList(".*[S].*");</pre>
Produces a list of all menu definitions that have an 'S" somewhere in the
menu name.
<hr />

<h2 style="text-align: center" id="Creating">Creating Database
Definitions</h2>
<hr />
Two classes are provided for creation of DBD Databases:
<ul>
  <li>DBDFactory<br />
    A factory to create and manage DBD databases.</li>
  <li>XMLToDBDFactory<br />
    A factory that reads xml Database Definitions and puts them into a DBD
    Database.</li>
</ul>

<h3 id="DBDFactory">DBDFactory</h3>

<p>DBDFactory is a class that creates DBD Databases. It provides the
following methods:</p>
<pre>public class DBDFactory {
    public static DBD create(String name,DBD masterDBD);
    public static void remove(DBD dbd);
    public static DBD find(String name);
    public static Map&lt;String,DBD&gt; getDBDMap();
    public static String list(String regularExpression);
}
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a new DBD with the name "name". If the master DBD is being
      created then masterDBD is null.</dd>
  <dt style="font-family: courier;">remove</dt>
    <dd>Remove the dbd from the DBD database.</dd>
  <dt style="font-family: courier;">find</dt>
    <dd>Find a DBD.</dd>
  <dt style="font-family: courier;">getDBDMap</dt>
    <dd>Get a Map of all the DBDs. A shallow copy of the internal map is
      returned.</dd>
  <dt style="font-family: courier;">list</dt>
    <dd>Get a string containing a list of all the DBDs with names that match
      the regular expression.</dd>
  <dt>All methods of DBDFactory and of the DBD instances it creates are
  thread safe.</dt>
</dl>

<h3 id="XMLToDBDFa">XMLToDBDFactory</h3>

<p>The following reads an xml file containing menu, structure, record type,
and link support definitions and adds the definitions to a database
definition database.</p>
<pre>    public class XMLToDBDFactory {
        public static void convert(DBD dbd, String fileName,
            IOCMessageListener messageListener);
        public static DBD addToMaster(String fileName,
            IOCMessageListener messageListener,IOCMessageType okToAddType);
    }</pre>
<dl>
  <dt style="font-family: courier;">convert</dt>
    <dd>Convert the xml DBD definitions in file fileName and put the
      definitions into dbd. When generating definitions for an IOC use
      addToMaster instead of this.</dd>
  <dt style="font-family: courier;">addToMaster</dt>
    <dd>Add definitions defined in fileName to a DBD named "master". This can
      be called either during IOC initialization or while an IOC is running,
      i.e. on-line add of new definitions is supported. If master does not
      exist it is created. Definitions will not be created if they already
      appear in master or if they are defined more than once. If any errors
      occur then no definitions are added to master and null is returned. A
      DBD named "add" holds the definitions from fileName. If all definitions
      are read successfully than the definitions are merged into master and
      DVD add is returned. After addToMaster returns DBD add will not appear
      in the map returned by getDBDMap.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">messageListener</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">okToAddType</dt>
    <dd>The definitions will only be added if all messages types are of type
      less than or equal to this type.</dd>
</dl>

<h3 id="Creating1">Creating Database Definitions</h3>

<p>Before record instances can be created all menu, structure, recordType,
and support definitions used by record instances must be created.</p>

<p>A running IOC always uses a DBD Database named "master" and an IOCDB also
named "master". The prefered way to create definitions by calling:</p>
<pre>    DBD add = XMLToDBDFactory.addToMaster(fileName);
    if(add==null) // failure take appropriate action</pre>

<p>addToMaster will not add any definitions to master if any errors are
detected. It can be called during IOC initialization and also while an IOC is
running. For an IOC this is the only method required for generating Database
Definitions. Other code may decide to use DBDFactory.create instead.</p>

<p>All DBDFactory and DBD methods are thread safe. In order to prevent race
conditions:</p>
<ul>
  <li>DBDFactory has a private readWrite lock that manages all access to its
    methods.</li>
  <li>DBD has a private readWrite lock that manages all access to its
  methods.</li>
  <li>Database components can be added but not removed from a DBD.</li>
  <li>All getXXXMap methods return shallow copies of the internal map.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Implementa">Implementation Specific
Definitions</h2>
<hr />

<p>This section describes interfaces and classes used by the Database
Definition implementation. Other than the possible exception of
DBDCreateFactory, the definition are probably not of interest to other
code.</p>

<h3 id="DBDCreateF">DBDCreateFactory</h3>

<p>The following class provides methods to create components for a Database
Definition.</p>
<pre>public final class  DBDCreateFactory {
    public static DBDMenu createMenu(String menuName, String[] choices);  
    public static DBDStructure createStructure(String name,
        DBDField[] dbdField,Property[] property);
    public static DBDRecordType createRecordType(String name,
        DBDField[] dbdField,Property[] property);
    public static DBDSupport createSupport(String supportName,
        String configurationStructName,String factoryName);
    public static DBDField createField(DBDAttribute attribute, Property[]property);
}</pre>

<h3 id="AbstractDB">AbstractDBDField</h3>

<p>An abstract class is available for creating implementations of the field
reflection interfaces. This class is used by DBDCreateFactory and is probably
not needed by other code.</p>

<h3 id="DBDAttribu">DBDAttribute ETC</h3>

<p>Interfaces DBDAttribute and DBDAttribute and class DBDAttributeFactory are
used by the XML parsers and are not of use after database creation. Thus,
other than showing the interfaces they are not discussed in this package
overview.</p>
<pre>    interface DBDAttribute {
        String getName();      // If possible use the version from DBDField
        DBType getDBType();    // If possible use the version from DBDField
        Type getType();        // If possible use the version from DBDField
        String getDefault();
        boolean isReadonly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        DBDMenu getMenu();
        DBDStructure getStructure();
        DBType getElementDBType();
        Type getElementType();
        String getSupportName();
    }

    interface DBDAttributeValues {
        int getLength();
        String getValue(String name);
        Set&lt;String&gt; keySet();
    }

    public class DBDAttributeFactory {
        static public DBDAttribute create(DBD dbd, DBDAttributeValues attributes);
    }</pre>
</body>
</html>
