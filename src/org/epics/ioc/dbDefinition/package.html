<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIOC: Database Definition</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Definition <br />
package: org.epics.ioc.dbDefinition<br />
2006.09.01</h1>
<hr />
PUT TOC HERE
<hr />

<h2 style="text-align: center">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type.</p>

<p>This package describes support for Database Definitions, i.e. support for
the following database components: menu, structure, recordType, and support.
Included are factories for creating multiple DBD (Database Definition)
instances. A DBD provides reflection interfaces for all database components
it contains. dbAccess, which implements a javaIOC database, uses a DBD to
implement database reflection.</p>

<p>The following is discussed:</p>
<ol>
  <li>Database Definition Syntax<br />
    The XML syntax for defining menus, structures, record types, and
    support.<br />
  </li>
  <li>Java Support for Database Definitions</li>
  <li>Factory support for Database Definitions</li>
  <li>parser support<br />
    This reads an xml file containing menu, structure, record types, and link
    support and adds them to a database definition file.</li>
  <li>Creating and using Database Definitions.<br />
  </li>
</ol>
<hr />

<h2 style="text-align: center">Database Definition Syntax</h2>
<hr />
A Database Definition file must be an XML file with a root tag of
DBDDefinition:
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;?-- valid Database Definition elements --&gt;
&lt;/DBDefinition&gt;</pre>

<h3>General Statements</h3>

<h4>namespace</h4>
At this time namespaces are not used.

<h4>Include</h4>
An XML file containing Database Definitions can include other files also
containing Database Definitions. An included file must also be a valid XML
Database Definition. Included files can also include other files. The syntax
is:
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Database Definition file, is processed. If any addPaths
      have been defined the last one specified is prefixed to the
    filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>NOTE: Path needs more work. But what to do???</p>

<h4>Macro Substitution</h4>

<p>Macro substitution is not very usefull for Database Definition but it is
support just like for Database Instance files. See package
org.epics.ioc.dbAccess for details about how macro substitution works.</p>

<h3>Menu</h3>
A menu is an enumerated type, defined below, where the choice strings are
defined once for each IOC. The syntax is:
<pre>    
&lt;menu name = "name"&gt;
    &lt;choice&gt;choice&lt;/choice&gt;
    ...
&lt;/menu&gt;</pre>
Example:
<pre>    
&lt;menu name = "scan"&gt;
     &lt;choice&gt;passive&lt;/choice&gt;
     &lt;choice&gt;event&lt;/choice&gt;
     &lt;choice&gt;interrupt&lt;/choice&gt;
     &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;</pre>

<h3>Structure and Record Type</h3>

<p>Structure and recordType both define a data structure containing fields.
The main difference is that a structure can't be instanciated except as a
field of a record.</p>

<p>A structure is defined as follows:</p>
<pre>&lt;structure name = "structureName" supportName = "supportName" &gt;
     &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
     ...
     &lt;field name = "fieldName" supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...

    &lt;/field&gt;
     ...
&lt;/structure&gt;</pre>

<p>A record type is defined as follows:</p>
<pre>&lt;recordType name = "recordtypeName" supportName = "supportName" &gt;
    &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
    ...
     &lt;field name = "fieldName"  supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...
     &lt;/field&gt;
     ...
&lt;/recordType&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
  <dt><span style="font-family: courier">recordtypeName</span></dt>
    <dd>The structure or record type name.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the structure, record type, or field. A
      support definition, described below, defines the support. When record
      instances are defined, the default can be overridden.</dd>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>Should also have the same syntax as a Java identifier, unique within
      the context of this particular structure.</dd>
  <dt><span style="font-family: courier">fieldType</span></dt>
    <dd>See fieldType below.</dd>
  <dt>...</dt>
    <dd>See field attribute below</dd>
  <dt><span style="font-family: courier">propertyName and
  associatedField</span></dt>
    <dd>See property below.</dd>
</dl>

<h3>field</h3>
The syntax for <span style="font-family: courier">fieldType</span> depends on
the field type.

<h4>Primitive Types</h4>
Primitive types are the same as the Java primitive types, i.e. <span
style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>. Primitive field types are just
defined as <span style="font-family: courier;">&lt;type /&gt;</span> For
example
<pre>     
    &lt;field name = "value", type = "double" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;</pre>

<h4>string</h4>
A <span style="font-family: courier">string</span> is a Java <span
style="font-family: courier;">String</span>. A <span
style="font-family: courier;">string</span> field type is just defined as
<span style="font-family: courier;">string</span>. For example:
<pre>     &lt;field name = "description" type = "string" /&gt;</pre>

<h4>enumerated</h4>

<p>An enumerated field type specified as enum For example:</p>
<pre>    &lt;field name = "value" type = "enum" /&gt;</pre>

<h4>structure</h4>
A structure field is declared as
<pre>    &lt;field name = "value" type = "structure" structureName = "name" /&gt;</pre>
<span style="font-family: courier;">structureName</span> is the name of a
structure which must have been previously defined. Example:
<pre>   &lt;structure name = "point"&gt;
       &lt;field name = "x" type = "double" /&gt;
       &lt;field name = "y"&gt; type = "double" /&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "haspoint"&gt;
       ...
       &lt;field name = "point" type = "structure" structureName = "point" /&gt;
       ...</pre>

<p>NOTE: The structureName does not have to be given. In this case the field
instance must define the structureName.</p>

<h4>array</h4>

<p>NOTE: One dimensional arrays are a supported type. Multidimensional arrays
can be supported via a <span style="font-family: courier;">structure</span>
definition with fields describing the number of dimensions and the attributes
of each dimension.</p>
An array is defined as follows:
<pre>    &lt;field name = "value" type = "array" elementType = "type" capacity = "capacity" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">elementType</dt>
    <dd>The type must be a valid type, i.e. boolean, byte, short, int, long,
      float, double, string,enum, structure, array or link. This must be
      specified. If the elementType is structure than each element can be a
      different type of structure.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The number of array elements. If not specified the capacity is
      determined at record initialization</dd>
</dl>
Examples:
<pre>     &lt;field name = "doubleArray" type = "array" elementType = "double" capacity = "3" /&gt;
     &lt;field name = "value" type = "array"  elementType = "double" /&gt;
     &lt;field name = "rectangle" type = "array" elementType = "structure" capacity = "2" /&gt;</pre>

<h4>menu</h4>
A menu field is defined as:
<pre>     &lt;field name = "name" type = "menu" nameName = "menuName" /&gt;</pre>
where <span style="font-family: courierfont-family: courier;">menuName</span>
is the name of the menu. <br />
Example:
<pre>    &lt;field name = "scan" type = "menu" menuName = "menuScan" /&gt;</pre>

<p>To the database, a menu field is presented just like an enumerated field
with constant choices. The choices are taken from the menu definition.</p>

<h4>link</h4>
This field type can get/put data from/to a location outside the record. When
a record instance is created, the link choices come from <span
style="font-family: courier;">support</span> definitions which are defined
below. A <span style="font-family: courier;">link</span> can be a link to
another database record, to hardware device support, or something else. The
syntax is:
<pre>     &lt;field name = "name" type = "link" /&gt;</pre>
Examples:
<pre>     &lt;field name = "disableLink" type = "link" /&gt;
     &lt;field name = "input" type = "link" /&gt;</pre>

<h3>field attribute</h3>

<p>A field can have additional attributes which are specified via xml
attributes. The additional attributes are:</p>
<pre>     default = "stringValue"
     readonly = "booleanValue"
     design = "booleanValue"
     link = "booleanValue"
     asl = "intValue"</pre>

<p>The attribute parameter values have the following meanings:</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the fields is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>
The following examples show how attributes are defined:
<pre>    &lt;recordType name = "example"&gt;
        ...
        &lt;field name = "status" type = "string" readonly "true" /&gt;
        &lt;field name = "displayLimit" type = "structure"
                structureName = "displayLimit" readonly = "true" /&gt;
        ...
        &lt;field name = "value" type = "double" asl value = "0" /&gt;
       ...
    &lt;/recordType&gt;</pre>
<br />


<h3>property</h3>
A structure, recordType, and field can have properties. A property is defined
as:
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>The name of the property</dd>
  <dt style="font-family: courier;">associatedField</dt>
    <dd>The name of a field that has the value for the property. It can have
      one of the following forms:
      <dl>
        <dt>..</dt>
          <dd>A search is made up the structure hierarchy for a field name
            that is the same as the property name. If the property is
            attached to a field then the search starts with the parent of the
            structure containing the structure. If the property is attached
            to a structure, the search starts with the parent of the
            structure itself. This is not valid for a property attached to a
            recordType.</dd>
        <dt>name</dt>
          <dd>If attached to a structure or recordType the associated field
            must be a field in that structure or recordType. If attached to a
            field it must be a field or a property in the structure that
            holds the field.</dd>
        <dt>name1.name2</dt>
          <dd>Only valid for a property attached to a structure or
            recordType. name1 must be the name of a structure field in the
            structure to which the property is attached. name2 must be a
            property of field in the structure field.</dd>
      </dl>
    </dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>

<h3>Support</h3>

<p>Support can be associated with any field of a record instance when it is
created. See package org.epics.ioc.dbAccess for details. Record types and
structures can have default support as shown above.</p>

<p>Each support can optionally have an associated structure for configuration
information. In addition a support definition must be defined. The syntax
is:</p>
<pre>    &lt;structure name = "configurationStructureName"&gt;
        ...
    &lt;/structure&gt;
    ...
    &lt;support name = "supportName"
         configurationStructureName = "configurationStructureName"
         factoryName = "factoryName" /&gt;</pre>
where
<dl>
  <dt><span style="font-family: courier">support</span></dt>
    <dd>Support for a link field of a record.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span
  style="font-family: courier">configurationStructureName</span></dt>
    <dd>The name of a structure containing configuration information for the
      support. Database configuration tools prompt the user to assign values
      to the structure. This is optional.</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.dbProcess for details,</dd>
</dl>

<p>When a record instance is created the supportName selects the support to
attach to a record link field.</p>
<br />
Examples of support:
<pre>     &lt;structure name = "processLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "wait" type = "boolean" /&gt;
         &lt;field name = "timeout" type = "double" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;structure name = "monitorLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "process" type = "boolean"&gt;
             &lt;!-- process this record when monitor occurs --&gt;
         &lt;/field&gt;
         &lt;field name = "monitorOnly" type = "boolean"&gt;
             &lt;!-- monitor only or data also --&gt;
         &lt;/field&gt;
         &lt;field name = "inheritSeverity" type = "boolean" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;support name = "processLink" configurationStructureName = "processLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;
     &lt;support name = "monitorLink" configurationStructureName = "monitorLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;</pre>
<hr />

<h2 style="text-align: center">Overview of Java Support For Database
Definition</h2>
<hr />

<p>This following sections describes support for code that accessses Database
Definitions: menu, structure, recordType and, support..</p>

<p>The interfaces support reflection for everything created from Database
Definitions. The interfaces can be used by tools such as VDCT or on a running
IOC database. The interfaces are also used by record support, link support,
and the database itself.</p>

<p>The definitions extend the support provided by pvAccess, which defines the
following types: boolean, byte, short, int, long, float, double, string,
enum, structure, and array.</p>

<p>DBType defines the database types, which extend the types defined by
pvAccess. The new types are:</p>
<dl>
  <dt>dbMenu</dt>
    <dd>Like Type.pvEnum except that the choices are readonly. This is to
      support the XML menu definitions.</dd>
  <dt>dbStructure</dt>
    <dd>Like Type.pvStructure except that fields can be a DBType.</dd>
  <dt>dbArray</dt>
    <dd>Like Type.pvArray except that nthe array elements can ba a
    DBType.</dd>
  <dt>dbLink</dt>
    <dd>This has type Type.pvUnknown, i.e. there is no data associated with
      the field but it does have configuration information.</dd>
</dl>

<p>Reflection interfaces are available for the following XML definitions</p>
<dl>
  <dt>DBDMenu</dt>
    <dd>This is for introspecting the XML menu definitions</dd>
  <dt>DBDStructure</dt>
    <dd>This is for introspecting the XML structure definitions.</dd>
  <dt>DBDRecordType</dt>
    <dd>This is for introspecting the XML recordType definitions.</dd>
  <dt>DBDSupport</dt>
    <dd>This is for introspecting the XML support definitions.</dd>
</dl>

<p>Reflection interfaces for structure and recordType fields extent the
reflection interfaces provided by org.epics.ioc.pvAccess:</p>
<dl>
  <dt>DBDField</dt>
    <dd>Extends Field</dd>
  <dt>DBDEnumField</dt>
    <dd>Extends Enum</dd>
  <dt>DBDMenuField</dt>
    <dd>Extends Enum</dd>
  <dt>DBDArrayField</dt>
    <dd>Extends Array</dd>
  <dt>DBDStructureField</dt>
    <dd>Extends Structure</dd>
  <dt></dt>
</dl>
<hr />

<h2 style="text-align: center">Database Types</h2>
<hr />

<p>The types, which extends the types defined by pvAccess, are:</p>
<pre>    enum DBType {
        dbPVType, // It is a plain PVType
        dbMenu,
        dbStructure,
        dbArray,
        dbLink;
    }</pre>

<p>where:</p>
<dl>
  <dt style="font-family: courier;">dbMenu</dt>
    <dd>A pvEnum with choices that are read only.</dd>
  <dt>dbStructure</dt>
    <dd>A dbStructure contains fields that can be have any DBType. This is an
      extension of pvStructure.</dd>
  <dt>dbArray</dt>
    <dd>An array element type can be any DBType. This is an extension of
      pvArray.</dd>
  <dt style="font-family: courier;">dbLink</dt>
    <dd>A link appears as a pvUnknown field that has associated support.</dd>
</dl>
<hr />

<h2 style="text-align: center">Introspection of Database Definitions</h2>
<hr />

<p>This section describes interfaces for accessing menu, structure,
recordType, and support, i.e. everything defined in Database Definition files
except record instances. Reflection for fields of a structure or recordType
is discussed in the next section.</p>

<h3>Menu</h3>

<p>The interface is:</p>
<pre>    interface DBDMenu{
        String getName();
        String[] getChoices();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The menu name.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>The array of choices for the menu.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>Dumps the menu definition.</dd>
</dl>

<p>For example the following dumps a menu</p>
<pre>    void dumpMenu(DBDMenu menu) {
        String[] choices = menu.getChoices();
        System.out.printf("menu %s {\n",menu.getName();
        for(choice: choices) System.out.printf("    %s\n",choice);
        System.out.printf("}\n");
    }</pre>

<p>Note that a shorter way is:</p>
<pre>    void dumpMenu(DBDMenu menu) {System.out.println(menu.toString());}</pre>

<h3>Structure and RecordType</h3>

<p>The interfaces are:</p>
<pre>    interface DBDStructure extends DBDField, Structure{
        DBDField[] getDBDFields(String fieldName);
        int getDBDFieldIndex(String fieldName);
    }

    interface DBDRecordType extends DBDStructure {}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDBDFields</dt>
    <dd>Get the introspection interfaces for the fields of the structure.
      DBDField is descrtibed in the next section.</dd>
  <dt style="font-family: courier;">getDBDFieldIndex</dt>
    <dd>Given a field name find the index for the field in the DBDField[]. If
      the field is not found -1 is returned.</dd>
</dl>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(DBDStructure structure) {
        DBDField[] fields = structure.getDBDFields();
        System.out.printf("structure %s {\n",structure.getStructureName();
        for(DBDField field : fields) {
            DBType type = field.getDBType();
            Type pvtype = field.getType();
            System.out.printf("field %s dbtype %s pvtype %s",
                field.getName(),type.toString(),pvtype.toString());
        }
    }</pre>

<p>Again a shorter way is:</p>
<pre>    void dumpStructure(DBDStructure structure) {System.out.println(structure.toString);}</pre>

<h3>Support</h3>

<p>The following interface is provided for accessing support.</p>
<pre>    interface DBDSupport {
        String getSupportName();
        String getConfigurationStructureName();
        String getFactoryName();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getConfigurationStructureName</dt>
    <dd>Get the configuration structire name. A null is returned if none was
      defined in the support definition. This means the support does not
      require configuration information.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.dbProcess for details about support and support
    factories.</dd>
</dl>
<hr />

<h2 style="text-align: center">Reflection for Database Fields</h2>
<hr />

<p>This section describes reflection for a field of a structure or
recordType.</p>

<h3>Field Introspection</h3>

<p>Every field has the following set of attributes.</p>
<pre>   interface DBDFieldAttribute {
       String getDefault();
       boolean isReadOnly();
       boolean isDesign();
       boolean isLink();
       int getAsl();
       String toString(int indentLevel);
   }</pre>

<p>where</p>
<dl>
  <dt>getDefault</dt>
    <dd>A default value for the field or null if no default was defined.</dd>
  <dt>isReadonly</dt>
    <dd>(false,true) if the data for the field is (immutable, mutable)</dd>
  <dt>isDesign</dt>
    <dd>This is for use by Database Configuration tools. It is (false,true)
      if the DCT should allow values to be assigned to the field.</dd>
  <dt>isLink</dt>
    <dd>This is for use by Database Configuration tools. It is (false,true)
      if the field is the name of linked process variable.</dd>
  <dt>getAsl</dt>
    <dd>Get the Access Security Level.</dd>
</dl>

<p>The interfaces for introspecting a field are:</p>
<pre>   interface DBDField extends Field {
        DBType getDBType();
        DBDFieldAttribute getFieldAttribute();
    }

    interface DBDEnumField extends DBDField, Enum {}
    interface DBDMenuField extends DBDField, Enum {
        DBDMenu getMenu();
    }
    interface DBDStructureField extends DBDField,Structure {
         DBDField[] getDBDFields();
         DBDStructure getDBDStructure();
    }
    interface DBDArrayField extends DBDField, Array {
        DBType getElementDBType();
    }    
    </pre>

<p>Since DBDField extends Field it has the following methods:</p>
<pre>    String getName();
    Property[] getPropertys();
    Property getProperty(String propertyName);
    Type getType()
    String getSupportName();
    void setSupportName(String name);
    boolean isMutable();
    void setMutable(boolean value);
    String toString();
    String toString(int indent Level);</pre>

<p>Thus DBDField has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>Get the field name.</dd>
  <dt style="font-family: courier;">getPropertys</dt>
    <dd>Get the properties for the field. See org.epics.ioc.pvAccess for a
      description of properties.</dd>
  <dt style="font-family: courier;">getProperty</dt>
    <dd>Given a name get the Property with that name of null if no such
      property exists.</dd>
  <dt style="font-family: courier;">getType</dt>
    <dd>Get the PV Type.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the name of the support for this field or null if no support is
      defined.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>Set the name of the support for this field.</dd>
  <dt style="font-family: courier;">isMutable</dt>
    <dd>Can the value on the field be changed?</dd>
  <dt style="font-family: courier;">setMutable</dt>
    <dd>Set the mutable status for the field. This should NOT be called by
      user code.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>Dump a description of the DBDField into a string. This is for
      debugging not for normal use.</dd>
  <dt style="font-family: courier;">getDBType</dt>
    <dd>Get the DBType for the field.</dd>
  <dt style="font-family: courier;">getFieldAttribute</dt>
    <dd>Get the DBFieldAttribute interface for the field.</dd>
</dl>

<p>DBDEnumField adds the method:</p>
<pre>        boolean isChoicesMutable();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">isChoicesMutable</dt>
    <dd>The value true is returned.</dd>
</dl>

<p>DBDMenuField adds the methods:</p>
<pre>        boolean isChoicesMutable();
        DBDMenu getMenu();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">isChoicesMutable</dt>
    <dd>The value false is returned.</dd>
  <dt style="font-family: courier;">getMenu</dt>
    <dd>Get the introspection interface for the menu</dd>
</dl>

<p>DBDStructureField adds the methods:</p>
<pre>         String getStructureName();
         String[] getFieldNames();
         Field getField(String fieldName);
         int getFieldIndex(String fieldName);
         Field[] getFields();
         DBDField[] getDBDFields();
         DBDStructure getDBDStructure();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getStructureName</dt>
    <dd>Get the name of the structure.</dd>
  <dt style="font-family: courier;">getFieldNames</dt>
    <dd>Get an array containing the field name.</dd>
  <dt style="font-family: courier;">getField</dt>
    <dd>Get the introspection interface for the specified field.</dd>
  <dt style="font-family: courier;">getFieldIndex</dt>
    <dd>Get the index into Field[] or DBDField[] of the specified fieldName.
      In the fieldName is not in the structure -1 is returned.</dd>
  <dt style="font-family: courier;">getFields</dt>
    <dd>Get the array of introspection interfaces for the fields.</dd>
  <dt style="font-family: courier;">getDBDFields</dt>
    <dd>Get the array of introspection interfaces for the fields.</dd>
  <dt style="font-family: courier;">getDBDStructure</dt>
    <dd>Get the introspection interface for the structure.</dd>
</dl>

<p>DBDArray adds the methods:</p>
<pre>        Type getElementType();
        DBType getElementDBType();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getElementType</dt>
    <dd>Get the Type for the array elements</dd>
  <dt style="font-family: courier;">getElementDBType</dt>
    <dd>Get the DBType for the array elements.</dd>
</dl>

<h3>AbstractDBDField</h3>

<p>An abstract class is available for creating implementations of the field
reflection interfaces. This class is used by DBDCreateFactory and is probably
not needed by other code.</p>

<h3>DBDAttribute ETC..</h3>

<p>Interfaces DBDAttribute and DBDAttribute and class DBDAttributeFactory are
used by the XML parsers and are not of use after database creation. Thus,
other than showing the interfaces they will not be discussed.</p>
<pre>    interface DBDAttribute {
        String getName();      // If possible use the version from DBDField
        DBType getDBType();    // If possible use the version from DBDField
        Type getType();        // If possible use the version from DBDField
        String getDefault();
        boolean isReadonly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        DBDMenu getMenu();
        DBDStructure getStructure();
        DBType getElementDBType();
        Type getElementType();
        String getSupportName();
    }

    interface DBDAttributeValues {
        int getLength();
        String getValue(String name);
        Set&lt;String&gt; keySet();
    }

    public class DBDAttributeFactory {
        static public DBDAttribute create(DBD dbd, DBDAttributeValues attributes);
    }</pre>
<hr />

<h2 style="text-align: center">Creation of Database Definition Components</h2>
<hr />

<p>The following class provides methods to create components for a Database
Definition.</p>
<pre>public final class  DBDCreateFactory {
    public static DBDMenu createMenu(String menuName, String[] choices);  
    public static DBDStructure createStructure(String name,
        DBDField[] dbdField,Property[] property);
    public static DBDRecordType createRecordType(String name,
        DBDField[] dbdField,Property[] property);
    public static DBDSupport createSupport(String supportName,
        String configurationStructName,String factoryName);
    public static DBDField createField(DBDAttribute attribute, Property[]property);
}</pre>
<hr />

<h2 style="text-align: center">Accessing Database Definitions</h2>
<hr />

<p>The following interface provides methods to access Database Defininition
Components. It also provides methods to insert components.</p>
<pre>public interface DBD {
    String getName();
    DBD getMasterDBD();
    void mergeIntoMaster();
    DBDMenu getMenu(String menuName);
    boolean addMenu(DBDMenu menu);
    Map&lt;String,DBDMenu&gt; getMenuMap();
    DBDStructure getStructure(String structureName);
    boolean addStructure(DBDStructure structure);
    Map&lt;String,DBDStructure&gt; getStructureMap();
    DBDStructure getRecordType(String recordTypeName);
    boolean addRecordType(DBDStructure recordType);
    Map&lt;String,DBDRecordType&gt; getRecordTypeMap();
    DBDSupport getSupport(String supportName);
    boolean addSupport(DBDSupport support);
    Map&lt;String,DBDSupport&gt; getSupportMap();
    String menuList(String regularExpression);
    String menuToString(String regularExpression);
    String structureList(String regularExpression);
    String structureToString(String regularExpression);
    String recordTypeList(String regularExpression);
    String recordTypeToString(String regularExpression);
    String supportList(String regularExpression);
    String supportToString(String regularExpression);
}</pre>

<p>The following class is a factory to create DBDs</p>
<pre>public class DBDFactory {
    public static DBD create(String name,DBD masterDBD);
    public static DBD find(String name);
    public static Collection&lt;DBD&gt; getDBDList();
    public static void remove(DBD dbd);
    public static Map&lt;String,DBD&gt; getDBDList();
    public static String list(String regularExpression);
}</pre>
<hr />

<h2 style="text-align: center">XML to DBD Converter</h2>
<hr />

<p>The following reads an xml file containing menu, structure, record type,
and link support definitions and adds the definitions to a database
definition database.</p>
<pre>    public class XMLToDBDFactory {
        public static void convert(DBD dbd, String fileName);
    }</pre>
<hr />

<h2 style="text-align: center">Creating and Using Database Definitions</h2>
<hr />

<p>This section explains how Database Definitions are used in an IOC.
Database Definitions are created during IOC initialization but new
definitions can also be added to a running IOC. Thus on-line add is
supported. It is not, however, possible to remove definitions after they have
been created.</p>

<p>Before record instances can be created all menu, structure, recordType,
and support definitions used by record instances must be created. The
definitions are created by calling XMLToDBDFactory.convert, which has two
arguments:</p>
<ul>
  <li>DBD dbd<br />
    A database into which to store new definitions.</li>
  <li>String fileName<br />
    A file containing xml definitions for the new definitions.</li>
</ul>

<p>Thus a DBD must first be created. A DBD is created via a call to
DBDFactory.create, which also has two arguments:</p>
<ul>
  <li>String name<br />
    The name of the DBD being created.</li>
  <li>DBD masterDBD<br />
    A master DBD or null</li>
</ul>

<p>During IOC initialization name is given the value "master" and masterDBD
is given the value null. This this is the masterDBD.</p>

<p>In order to add new definitions to a running IOC the following is done:</p>
<pre>    DBD masterDBD = DBDFactory.find("master");
    DBD addDBD = DBDFactory.create("add",masterDBD);
    boolean success = true;
    try {
        XMLToDBDFactory.convert(addDBD,fileName);
    } catch (IllegalStateException e) {
        System.out.println("IllegalStateException: " + e);
        success = false;
    }
    if(success) {
        addDBD.mergeIntoMaster();
    }</pre>

<p>This the new definitions are created in a separate DBD and if successfull
then the new definitions are merged into the master DBD.</p>

<p>DBDFactory implements DBD so that all methods arte thread safe. It does
this by:</p>
<ul>
  <li>Using readWrite locks.</li>
  <li>Returns a shallow copy for all getXXXMap methods.</li>
</ul>
</body>
</html>
