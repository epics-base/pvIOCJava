<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2006.09.14</h1>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Instance Syntax</a>
    <ul>
      <li><a href="#GeneralStatements">General Statements</a>
        <ul>
          <li><a href="#SyntaxNamespace">namespace</a></li>
          <li><a href="#SyntaxInclude">Include</a></li>
          <li><a href="#SyntaxMacroSubstitution">Macro Substitution</a></li>
          <li><a href="#ExampleIncludeMacro">Example Include and Macro
            Substitution</a></li>
        </ul>
      </li>
      <li><a href="#RecordInstance">record</a></li>
      <li><a href="#Configure">configure</a></li>
      <li><a href="#Primitive">Primitive Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#array">array</a></li>
      <li><a href="#menu">menu</a></li>
      <li><a href="#enumerated">enumerated</a></li>
      <li><a href="#link">link</a></li>
    </ul>
  </li>
  <li><a href="#Database">XML to Database Converter</a></li>
  <li><a href="#Record1">Record Instance Access</a>
    <ul>
      <li><a href="#Listener">Listener Interface</a></li>
      <li><a href="#Base">Base Interface for accessing data</a></li>
      <li><a href="#Scalar">Scalar and String Data</a></li>
      <li><a href="#Enumerated">Enumerated Data</a></li>
      <li><a href="#Menu">Menu Data</a></li>
      <li><a href="#Structure">Structure Data</a></li>
      <li><a href="#RecordData1">RecordData</a></li>
      <li><a href="#Link">Link Data</a></li>
      <li><a href="#Array">Array Data</a></li>
    </ul>
  </li>
  <li><a href="#Factory">Factory for creating Data Fields</a></li>
  <li><a href="#Abstract">Abstract Classes</a>
    <ul>
      <li><a href="#AbstractDB">AbstractDBData</a></li>
      <li><a href="#AbstractDB1">AbstractDBEnum</a></li>
      <li><a href="#AbstractDB2">AbstractDBMenu</a></li>
      <li><a href="#AbstractDB3">AbstractDBStructure</a></li>
      <li><a href="#AbstractDB4">AbstractDBRecord</a></li>
      <li><a href="#AbstractDB5">AbstractDBArray</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB1">IOCDB: IOC Database</a></li>
  <li><a href="#Database1">IOC Database Access</a></li>
  <li><a href="#Listener1">Listener Support</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax<br />
    The XML syntax for defining record instances.</li>
  <li>An XML to database converter.<br />
    Parses xml record instance files, creates record instances, and puts them
    in an IOC database.</li>
  <li>Record Instance Access<br />
    Interfaces for accessing data in record instances.</li>
  <li>Data Factory<br />
    A factory for creating support for database fields. It can create support
    for all types of fields.</li>
  <li>Abstract Classes<br />
    A set of abstract classes for implementing ths support for database
    fields.</li>
  <li>IOC Database<br />
    Interface and factory for a database containing the record instances.</li>
  <li>Database Access<br />
    An interface for locating fields of a record instance.</li>
  <li>Listen Support<br />
    A description of the support for monitoring changes to the data in
    database instances fields.</li>
</ol>
<hr />

<h2 style="text-align: center" id="Record"><a id="Instance"></a>Record
Instance Syntax</h2>
<hr />
A Record Instance file must be an XML file with a root tag of IOCDatabase:
<pre>    &lt;?xml version="1.0" ?&gt;
    &lt;IOCDatabase&gt;
      &lt;?-- valid Record Instance Definitions --&gt;
    &lt;/IOCDatabase&gt;</pre>

<h3><a id="GeneralStatements"></a>General Statements</h3>

<h4><a id="SyntaxNamespace"></a> namespace</h4>
At this time namespaces are not used.

<h4><a id="SyntaxInclude"></a> Include</h4>
The XML file can include other files also containing Record Instance
Definitions. An included file must also be a valid XML Record Instance
Definitions. Included files can also include other files. The syntax is:
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4><a id="SyntaxMacroSubstitution"></a> Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4><a id="ExampleIncludeMacro"></a> Example Include and Macro
Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "aiRecord"&gt;
    &lt;aiInput structureName = "aiLinear" &gt;
        &lt;aiRaw&gt;
            &lt;input supportName = "inputLink"&gt;
                &lt;configure structureName = "inputLink"&gt;
                    &lt;pvname&gt;${pvname}&lt;/pvname&gt;
                    &lt;wait&gt;true&lt;/wait&gt;
                &lt;/configure&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiInput&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h3><a id="RecordInstance"></a>record</h3>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span> is a string with a
combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p>supportName is the name of support. If not given the supportName specified
in the record type definition is used. In either case a support definition
with the supportName must exist. Package org.epics.ioc.dbProcess provides
support that creates support for each record instance. See that package for
details. If the same record instance appears multiple times then then last
supportName is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be a name
definied in the record type definition.</p>

<p>Any field can optionally have associated support. If a supportName is
given with a field instance then it overides any support defined in the
record type field definition. Thus support is only used if the record support
for the record instance calls the support methods. If a field is initialized
multiple times than the last supportName definition determines the
support.</p>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3 id="Configure"><a id="configure" name="configure"></a>configure</h3>

<p>If a supportName is defined for a record instance of for a field on a
record instance and the support definition specifies a configuration
structure then a configure XML element can be used to initialize the fields
of the configuration structure. This configure element MUST appear
immediately after the record instance or field instance definition.</p>

<p>For example assume the following Database Definitions:</p>
<pre>    &lt;structure name = "dummy"&gt;
        &lt;field name = "xxx" type = "string" /&gt;
        &lt;field name = "yyy" type = "int" /&gt;
    &lt;/structure&gt;
    
    
    &lt;support name = "exampleSupport" configurationStructureName = "dummy"
        factoryName = "org.epics.ioc.support.Dummy" /&gt;</pre>

<p>Then an instance of field <span style="font-family: courier;">link</span>
can be initialized as follows:</p>
<pre> &lt;value supportName = "exampleSupport"&gt;
        &lt;configure structureName = "dummy"&gt;
            &lt;xxx&gt;xxxxxx&lt;/xxx&gt;
            &lt;yyy&gt;5&lt;/yyy&gt;
        &lt;/configure&gt;
        This is a string value
    &lt;/value&gt;</pre>

<p>This example was for a field that has type string but similar definitions
can be given for any field that has associated support.</p>

<p>If the support is for a structure field then the configuration must be
given before any fields of the structure. If the support is for a record
type, the configuration must be given before any fields of the record
instance.</p>

<h3 id="Primitive"><a id="FieldPrimitive"></a>Primitive Types</h3>

<p>For primitive types the initializer has the same format as the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value supportName = "supportName" &gt;.98&lt;/value&gt;</pre>
Notes:
<ul>
  <li>supportName is optional</li>
  <li>Byte.decode, Short.decode, Integer.decide, and Long.decode are used to
    convert a string to an integer data type. Thus hex values are allowed but
    the sign bit MUST not be set. This for byte data 0xff is not allowed but
    -0x01 is allowed. Note for example that the byte value -128 can not be
    specified in hex.</li>
</ul>

<h3 id="string"><a id="FieldString"></a>string</h3>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h3 id="structure"><a id="FieldStructure"></a>structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure and recordType definitions:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "ai"&gt;
   ...
       &lt;field name = "displayLimit&gt;
            &lt;structure name = "displayLimit" /&gt;
       &lt;field/&gt;
   ...</pre>

<p>displayLimit is initilized as follows:.</p>
<pre>    &lt;displayLimit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;</pre>

<p>Note that supportName can optionally be defined</p>

<p>It is permissible to define a field to be a structure without providing a
structure name. In this case the structureName must be provided when the
field is being created. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" &gt;</pre>

<h3 id="array"><a id="FieldArray"></a>array</h3>
The syntax for an array initializer is:
<pre>    &lt;fieldName capacity = "capacity" supportName = "supportName" &gt;
        &lt;value offset = "offset"&gt;value&lt;/value&gt;
        &lt;value offset = "offset"&gt;valueList&lt;/value&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>assigns a value to the array. If the array is an array of structures
      then the value is actually a set of field definitions. If the array is
      an array of array the value is another array initialization.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
</dl>

<p>Assume the following are part of a recordType definition:</p>
<pre>    &lt;field name = "intArray"&gt;
        &lt;array&gt;
            &lt;type&gt;&lt;int /&gt;&lt;/type&gt;
        &lt;/array&gt;
    &lt;/field&gt;
    &lt;field name = "structArray"&gt;
        &lt;type&gt;
            &lt;array&gt;
                &lt;structure name = "DisplayLimit /&gt;
            &lt;/array&gt;
        &lt;/type&gt;
    &lt;/field&gt;</pre>

<p>Then the following all perform the same initialization:</p>
<pre>    &lt;intArray capacity = "3" &gt;
        &lt;value&gt;0.0, 1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray capacity = "3" offset = "1"&gt;
        &lt;value&gt;1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray&gt;
        &lt;value&gt;0.0&lt;/value&gt;
        &lt;value&gt;1.0&lt;/value&gt;
        &lt;value&gt;2.0&lt;/value&gt;
    &lt;/intArray&gt;
         </pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray capacity = "2"&gt;
        &lt;value&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
        &lt;value&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
    &lt;/structArray&gt;</pre>

<h3 id="menu"><a id="FieldMenu"></a>menu</h3>

<p>A menu field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;stringValue&lt;/fieldName&gt;</pre>
where stringValue is one of the allowed values for the menu.

<p>For example:</p>
<pre>    &lt;scan&gt;periodic&lt;/scan&gt;</pre>

<p>Again supportName is optional.</p>

<h3 id="enumerated"><a id="FieldEnumerated"></a>enumerated</h3>

<p>An enumerated field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;choice&gt;choice&lt;/choice&gt;
        stringValue
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support</dd>
  <dt style="font-family: courier;">choice</dt>
    <dd>A choice string. One of these must be specified for each choice.</dd>
  <dt style="font-family: courier;">stringValue</dt>
    <dd>one of the allowed values for the enum.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;enumExample&gt;
         &lt;choice&gt;zeroState&lt;/choice&gt;
         &lt;choics&gt;oneState&lt;/choice&gt;
         oneState
    &lt;/enumExample&gt;</pre>

<h3 id="link"><a id="FieldLink"></a>link</h3>
A link field is initialized as follows:
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;configure structureName = "supportStructureName"&gt;
            &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
            ...
        &lt;/configure&gt;
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of one of the <span
      style="font-family: courier;">support</span> definitions</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of the support structure given with the support
    definition</dd>
  <dt style="font-family: courier;">fieldValue</dt>
    <dd>The value for the structure field.<br />
    </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Database"><a id="XMLToDB"></a>XML to
Database Converter</h2>
<hr />

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbd, IOCDB iocdb, String fileName);
        public static IOCDB addToMaster(String fileName);
    }
  </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">convert</dt>
    <dd>parse an xml file conaining record instance definitions and put the
      resulting record instances into an IOC database.
      <ul>
        <li><span style="font-family: courier;">dbd</span> - The database
          that has the Database Definitions required by the record
        instances.</li>
        <li><span style="font-family: courier;">iocdb</span> - The database
          that hols the record instances.</li>
        <li><span style="font-family: courier;">fileName</span> - The xml
          file that has the record instance definitions.</li>
      </ul>
    </dd>
  <dt style="font-family: courier;">addToMaster</dt>
    <dd>Add definitions from fileName into an IOCDB named master. The DBD
      database and the IOCDB are both named master. If any errors are
      detected no definitions are added to master and a null is returned. If
      no errors occur, the definitions are added to master and the return
      value is an IOCDB that contains the newly created record instances.
      Attempting to add definitions for a record instance that is already in
      master is an error.</dd>
  <dt>For an IOC addToMaster should be used to create record instances. This
  can be done during IOC initialization or after an IOC is running, i.e.
  on-line add of new record instances is supported. Only one user at a time
  is allowed to call convert or addToMaster. If XMLToIOCDBFactory is busy
  when another call is made an error is generated and nothing is done. Both
  methods are thread safe.</dt>
</dl>
<hr />

<h2 style="text-align: center" id="Record1"><a
id="RecordInstanceAccess"></a>Record Instance Access</h2>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc.</p>

<h3 id="Listener">Listener Interface</h3>

<h4>DBListener</h4>

<p>DBListener is an interface that must be implemented by code that calls
DBdata.addListener, which is a request to be notified whenever a field
changes value. A request can be made for any field including structure fields
or even a record instance. If the request is made for a structure field then
the requester will be notified whenever any field of the structure changes
value.</p>

<p>DBListener has the definition:</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
        void unlisten(RecordListener listener);
    }</pre>
where
<dl>
  <dt style="font-family: courier;">newData</dt>
    <dd>The new data value. This is always an elementary field, i.e. not a
      structure.</dd>
  <dt style="font-family: courier;">beginSynchronous</dt>
    <dd>This is called before a set of synchronous data modifications. It is
      followed by an arbitrary number calls to newData and finally a call to
      endSynchronous</dd>
  <dt style="font-family: courier;">endSynchronous</dt>
    <dd>End of synchronous data</dd>
  <dt style="font-family: courier;">unlisten</dt>
    <dd>The data source is undergoing destruction or major structural
      changes. The DBData.addListener call is no longer valid and the user
      should null the object reference returned by addListener.</dd>
</dl>

<p>Assume that a field named value has properties status and severity. Then
when the record is processed and field value is written then the following
calls might occur:</p>
<ul>
  <li>beginSynchronous</li>
  <li>newData for value</li>
  <li>newData for status</li>
  <li>newData for severity</li>
  <li>endSynchronous</li>
</ul>

<h4>RecordListener</h4>

<p>RecordListener is an interface that is implemented by the code that
implements DBRecord. This is normally class AbstractDBRecord. DBRecord
provides a method to create a RecordListener. See class FieldDataFactory and
AbstractDBRecord for details. The definition of RecordListener is:</p>
<pre>    public interface RecordListener {
        void newData(DBData dbData);
    }</pre>

<h3>Example</h3>

<p>The following is sample code that implements RecordListener.</p>
<pre>    private static class TestListener implements DBListener{

        TestListener(DBData dbData) {
            RecordListener listener = dbData.getRecord().createListener(this);
            dbData.addListener(listener);
        }
        public void beginSynchronous() { }
        public void endSynchronous() { }
        public void newData(DBData dbData) {
            System.out.println("new data " + dbData.toString);
        }
        public void unlisten(RecordListener listener) { }
    }</pre>

<h3 id="Base">Base Interface for accessing data</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBData extends PVData {
        DBDField getDBDField();
        String getFullFieldName();
        DBStructure getParent();
        DBRecord getRecord();
        void addListener(RecordListener listener);
        void removeListener(RecordListener listener);
        void postPut();
        void postPut(DBData dbData);
        DBStructure getConfigurationStructure();
        Support getSupport();
        void setSupport(Support support);
    }</pre>

<p>Since it extends PVData it also has the methods:</p>
<pre>        Field getField();
        String getSupportName();
        String setSupportName(String name);
        PVStructure getConfigurationStructure();
        String toString();
        String toString(int indentLevel);</pre>

<p>AbstractDBData implements all of the DBData methods. The methods are:</p>
<dl>
  <dt style="font-family: courier;">getField</dt>
    <dd>Get the Field introspection interface.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the name of the support for the field. If no support has been
      specified null is returned.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>Set the support name. This is called by the XML parser.</dd>
  <dt style="font-family: courier;">getConfigurationStructure</dt>
    <dd>Get the configuration structure or null if no configuration exists
      for the field instance. A value is determined when setSupportName is
      called. The caller can ask for a PVStructurte or a DBStructure.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>This is for debugging. It dumps the contents of the field.
      AbstractDBData shows the supportName of it has been defined and the
      contents of the configuration structure if it exists. Any code that
      extents DBData should append super.toString(level) to any output it
      generates.</dd>
  <dt style="font-family: courier;">getDBDField</dt>
    <dd>Get the DBDField introspection interface</dd>
  <dt style="font-family: courier;">getFullFieldName</dt>
    <dd>Get the full field name, i.e. The hierarcharical name with a '.'
      separating each field.</dd>
  <dt style="font-family: courier;">getParent</dt>
    <dd>Get the interface for the parent of this field</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the interface of the record instance that has this field.</dd>
  <dt style="font-family: courier;">addListener</dt>
    <dd>Add a record listener. This is normally only called by code that
      wants to be notified of any data updates. The caller must first create
      a RecordListener by calling DBRecord.createListener.</dd>
  <dt style="font-family: courier;">removelistener</dt>
    <dd>Remove a listener.</dd>
  <dt style="font-family: courier;">postPut()</dt>
    <dd>This is called by the code that implements the put method for a
      DBData instance. It is implemented by AbstractDBData.</dd>
  <dt style="font-family: courier;">postPut(DBData dbdata)</dt>
    <dd>This is called AbstractDBData whenever the field or any subfield of a
      field changes value. It is implemented and called by
    ABStractDBData.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the support or return null if no support exists for the
    field.</dd>
  <dt style="font-family: courier;">setSupport</dt>
    <dd>Set the support for the field.</dd>
</dl>

<p>Field is the introspection interface for pvAccess Types. DBDField is the
introspection interface for DBTypes.</p>

<h3 id="Scalar"><a id="DBPVData"></a>Scalar and String Data</h3>
The following are the data interfaces for fields that have a pvAccess Type.
<pre>    public interface DBBoolean extends DBData, PVBoolean{}
    public interface DBByte extends DBData, PVByte{}
    public interface DBShort extends DBData, PVShort{}
    public interface DBInt extends DBData, PVInt{}
    public interface DBLong extends DBData, PVLong{}
    public interface DBFloat extends DBData, PVFloat{}
    public interface DBDouble extends DBData, PVDouble{}
    public interface DBString extends DBData, PVString{}</pre>
Since each interface implements a PV data interface it has get/put methods to
get and put data values.

<p>The following example shows how a double field can be read.</p>
<pre>     double getValue(DBData db) {
        Type type = db.getField().getType();
        if(type != Type.pvDouble) throw new IllegalStateException("not double");
        PVDouble data = (PVDouble)db;
        return data.get();
    }</pre>

<p>The following accomplishes the same but an exception will be thrown if the
DBData is not a PVDouble:</p>
<pre>     double getValue(DBData db) {
        PVDouble data = (PVDouble)db; // exception may be thrown
        return data.get();
    }</pre>

<h3 id="Enumerated"><a id="EnumData"></a>Enumerated Data</h3>
An enumerated field is accessed via the interface
<pre>    public interface DBEnum extends DBData, PVEnum{}</pre>

<h3 id="Menu"><a id="MenuData"></a>Menu Data</h3>
A menu field is accessed via the interface:
<pre>    public interface DBMenu extends DBData, DBEnum {
        String getMenuName();
    }</pre>

<p>The following shows how to access a menu field:</p>
<pre>    void dumpMenuField(DBMenu menu) {
        String[] choice = menu.getChoices();
        int index = menu.getIndex();
        System.out.printf("field %s is menu %s. Value is %d %s%n",
            menu.getField().getName(),menu.getMenuName(),
            menu.getIndex(),choice[index]);
    }</pre>

<h3 id="Structure"><a id="StructureData"></a>Structure Data</h3>
<pre>    public interface DBStructure extends DBData, PVStructure {
         boolean createFields(DBDStructure dbdStructure);
         DBDStructure getDBDStructure();
         DBData[] getFieldDBDatas();
         int getFieldDBDataIndex(String fieldName);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createFields</dt>
    <dd>If the database definition for the field did not specify a
      structureName than when a field is being created this must be called to
      associate a structure with the field.</dd>
  <dt style="font-family: courier;">getDBDStructure</dt>
    <dd>This returns the DBDStructure for the field, i.e. the interface that
      describes the structure.</dd>
  <dt style="font-family: courier;">getFieldDBDatas</dt>
    <dd>Get the array of interfaces for the fields of the structure
    instance.</dd>
  <dt style="font-family: courier;">getFieldDBDataIndex</dt>
    <dd>Get the index into DBData for the specified field.</dd>
</dl>

<h3 id="RecordData1"><a id="RecordData"></a>RecordData</h3>
<pre>    public interface RecordStateListener {
        void newState(DBRecord dbRecord,RecordState newState);
    }

    public interface DBRecord extends DBStructure {
        String getRecordName();
        RecordState getRecordState();
        void setRecordState(RecordState state);
        void addRecordStateListener(RecordStateListener listener);
        void removeRecordStateListener(RecordStateListener listener);
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginSynchronous();
        void endSynchronous();
        RecordListener createListener(DBListener listener);
        void removeListener(RecordListener listener);
        void removeListeners();
        void addListenerSource(AbstractDBData dbData);
        DBD getDBD();
        void setDBD(DBD dbd);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getRecordName</dt>
    <dd>Get the name of the record intsance.</dd>
  <dt style="font-family: courier;">getRecordState</dt>
    <dd>Get the state of record processing.</dd>
  <dt style="font-family: courier;">setRecordState</dt>
    <dd>Set the state of record processing. This is called by
    RecordProcess.</dd>
  <dt style="font-family: courier;">addRecordStateListener</dt>
    <dd>Add a listener to call wheneven the state of record processing
      changes.</dd>
  <dt style="font-family: courier;">removeRecordStateListener</dt>
    <dd>Remove a record state listener.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the record. The record must be locked for record processing and
      whenever the data of any field in a record is accessed.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the record.</dd>
  <dt style="font-family: courier;">lockOtherRecord</dt>
    <dd>While holding the lock for this record lock another record. The lock
      for the cxurrent record might be unlocked while this call is active but
      upon retirn both record will be locked. The caller must unlock both
      records when the caller is done. Normally it unlocks the other record,
      via it's unlock method, first.</dd>
  <dt style="font-family: courier;">getRecordProcess</dt>
    <dd>Get the interface of the RecordProcess for this instance.</dd>
  <dt style="font-family: courier;">setRecordProcess</dt>
    <dd>Set the RecordProcess inyerface for this record instance.</dd>
  <dt style="font-family: courier;">getRecordID</dt>
    <dd>Normally only called by AbstractDBRecord.lock. Each record instance
      is assigned a unique id.</dd>
  <dt style="font-family: courier;">beginSynchronous</dt>
    <dd>Called by record processing when a set of synchronous puts is
    started.</dd>
  <dt style="font-family: courier;">endSynchronous</dt>
    <dd>End of a set of synchronous puts.</dd>
  <dt style="font-family: courier;">createListener</dt>
    <dd>Create a RecordListener than can be used to call
    DBData.addListener.</dd>
  <dt style="font-family: courier;">removeListener</dt>
    <dd>Remove a listener. This also calls DBData.removeListener.</dd>
  <dt style="font-family: courier;">removeListeners</dt>
    <dd>Remove all listeners. This is called if a record insance is being
      removed or if it's structure is being changed.</dd>
  <dt style="font-family: courier;">addListenerSource</dt>
    <dd>Add a listener source. Used for communication between
      AbstractDBRecord and AbstractDBData. AbstractDBData calls this the
      first time DBData.addListener is called. It should not be called by
      other code.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the DBD that holds this record instance. See package
      org.epics.ioc.dbDefinition for an explaination of a DBD.</dd>
  <dt style="font-family: courier;">setDBD</dt>
    <dd>Set the DBD that holds this record instance.</dd>
    <dd></dd>
</dl>

<h3 id="Link1">Link Data</h3>
<pre>    public interface DBLink extends DBData {}</pre>

<p>A DBLink is a link to external support. It has no data other than
configuration data.</p>

<h3 id="Array">Array Data</h3>

<p>The base interface for array fields is:</p>
<pre>    public interface DBArray extends DBData, PVArray {}</pre>

<p>The following are the interfaces for each of the array types:</p>
<pre>    public interface DBBooleanArray extends DBArray, PVBooleanArray{}
    public interface DBByteArray extends DBArray, PVByteArray{}
    public interface DBShortArray extends DBArray, PVShortArray{}
    public interface DBIntArray extends DBArray, PVIntArray{}
    public interface DBLongArray extends DBArray, PVLongArray{}
    public interface DBFloatArray extends DBArray, PVFloatArray{}
    public interface DBDoubleArray extends DBArray, PVDoubleArray{}
    public interface DBStringArray extends DBArray, PVStringArray{}
    public interface DBEnumArray extends DBArray, PVEnumArray{}

    public class MenuArrayData {
        public DBMenu[] data;
        public int offset;
    }
    public interface DBMenuArray extends DBArray{
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, DBMenu[]from, int fromOffset);
    }
    
    public class DBStructureArrayData {
        public DBStructure[] data;
        public int offset;
    }
    public interface DBStructureArray extends DBArray{
        int get(int offset, int len, DBStructureArrayData data);
        int put(int offset, int len, DBStructure[]from, int fromOffset);
    }

    public class DBArrayArrayData {
        public DBArray[] data;
        public int offset;
    }
    public interface DBArrayArray extends DBArray{
        int get(int offset, int len, DBArrayArrayData data);
        int put(int offset, int len, DBArray[]from, int fromOffset);
    }

    public class LinkArrayData {
        public DBLink[] data;
        public int offset;
    }
    public interface DBLinkArray extends DBArray{
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, DBLink[]from, int fromOffset);
    }</pre>

<p>The array interfaces are an extension of the pvAccess array interfaces.
See pvAccess for details about how arrays are supported. The package overview
gives an example of how to read array data.</p>
<hr />

<h2 style="text-align: center" id="Factory"><a
id="FieldDataFactory"></a>Factory for creating Data Fields</h2>
<hr />

<p>A factory is available that implements the interfaces for record instance
fields. The methods are called by XMLToIOCDBFactory when it is reading
instance definitions.</p>
<pre>    public class FieldDataFactory {
        public static DBData createData(DBData parent,
            DDBDField dbdField);
        public static DBData createEnumData(DBData parent,
            DDBDField dbdField, String[] choice);
        public static DBArray createArrayData(DBData parent,
            DDBDField dbdField, int capacity,boolean capacityMutable);
        public static DBRecord createRecord(String recordName,
             DBDRecordType dbdRecordType);
    }</pre>
where
<dl>
  <dt style="font-family: courier;">createData</dt>
    <dd>Creates an instance of any type of field except enum, array fields,
      or a record instance itself.</dd>
  <dt style="font-family: courier;">createEnumData</dt>
    <dd>Create an enum field instance.</dd>
  <dt style="font-family: courier;">createArrayData</dt>
    <dd>Create an array field instance.</dd>
  <dt style="font-family: courier;">createRecord</dt>
    <dd>Create a record instance.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Abstract"><a
id="AbstractClasses"></a>Abstract Classes</h2>
<hr />

<p>This section describes abstract classes for implementing the data
interface for database fields. These classes are used by FieldDataFactory and
can also be used by code that wants to provide special implementations of
database fields.</p>

<h3 id="AbstractDB"><a id="AbstractDBData"></a>AbstractDBData</h3>

<p>Abstract base class for a scalar field. Any code that implements scalar
fields should extend this class since it implements almost all methods except
the methods to actually get ot put data.</p>
<pre>    public abstract class AbstractDBData implements DBData{
        public Field getField();
        public String getSupportName();
        public String setSupportName(String name);
        public Support getSupport();
        public void setSupport(Support support);
        public DBStructure getConfigurationStructure();
        public String toString();
        public String toString(int indentLevel);
        //PVData methods
        public Field getField();
        // DBData methods
        public DBDField getDBDField();
        public DBData getParent();
        public DBRecord getRecord();
        public Support getSupport();
        public void setSupport(Support support);
        public DBStructure getConfigurationStructure();
        public void addListener(Listener listener);
        public void removeListener(Listener listener);
        public void postPut();
        public void postPut(DBData dbData);
        // convenience method for derived classes
        protected static void newLine(StringBuilder builder, int indentLevel);
        // constructor
        protected AbstractDBData(DBData parent, DBDField dbdField);
        // must be called by derived class 
        protected void setRecord(DBRecord record);
        protected static void newLine(StringBuilder builder, int indentLevel);
        protected void removeListeners();
    }</pre>

<h3 id="AbstractDB1"><a id="AbstractDBEnum"></a>AbstractDBEnum</h3>

<p>Abstract base class for an enumerated field. Any code that implements
DBEnum should extend this class.</p>
<pre>    public abstract class AbstractDBEnum extends AbstractDBData implements DBEnum {
        protected AbstractDBEnum(DBData parent,
            DBDEnumField dbdEnumField, String[]choice);
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB2"><a id="AbstractDBMenu"></a>AbstractDBMenu</h3>

<p>Abstract base class for a menu field. Any code that implements DBMenu
should extend this class.</p>
<pre>    public abstract class AbstractDBMenu extends AbstractDBData implements DBMenu
    {
        protected AbstractDBMenu(DBData parent, DBDMenuField dbdMenuField);
        // DBMenu methods
        public String getMenuName();
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB3"><a id="AbstractDBStructure"></a>AbstractDBStructure</h3>

<p>Abstract base class for a structure field. Any code that implements
DBStructure should extend this class.</p>
<pre>    public abstract class AbstractDBStructure extends AbstractDBData
    implements DBStructure
    {
        // constructor for structure fields
        protected AbstractDBStructure(DBData parent, DBDStructureField dbdStructureField);
        // constructor for record instances
        protected AbstractDBStructure(DBDRecordType dbdRecordType));
        // called by record instance constructor
        protected void createFields(DBRecord record);
        public PVData[] getFieldPVDatas();
        public boolean createFields(DBDStructure dbdStructure);
        public DBDStructure getDBDStructure();
        public DBData[] getFieldDBDatas();
        public int getFieldDBDataIndex(String fieldName);
        public String toString();
        public String toString(int indentLevel);
        public String toString(String prefix,int indentLevel)
    }</pre>

<h3 id="AbstractDB4"><a id="AbstractDBRecord"></a>AbstractDBRecord</h3>

<p>Abstract base class for a record instance.</p>
<pre>    public class AbstractDBRecord extends AbstractDBStructure implements DBRecord {
        protected AbstractDBRecord(String recordName, DBDRecordType dbdRecordType);
        // DBRecord methods
        public String getRecordName();
        public RecordState getRecordState();
        public void setRecordState(RecordState state);
        public void addRecordStateListener(RecordStateListener listener);
        public void removeRecordStateListener(RecordStateListener listener);
        public void lock();
        public void unlock();
        public void lockOtherRecord(DBRecord otherRecord);
        public RecordProcess getRecordProcess();
        public boolean setRecordProcess(RecordProcess recordProcess);
        public RecordSupport getRecordSupport();
        public boolean setRecordSupport(RecordSupport support);
        public int getRecordID();
        public void beginSynchronous();
        public void endSynchronous();
        Listener createListener(DBListener listener);
        void removeListener(Listener listener);
        public void removeListeners();
        public void addListenerSource(AbstractDBData dbData);
        public DBD getDBD();
        public void setDBD(DBD dbd);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB5"><a id="AbstractDBArray"></a>AbstractDBArray</h3>

<p>Abstract base class for an array field.</p>
<pre>    public abstract class AbstractDBArray extends AbstractDBData implements DBArray
    {
        protected AbstractDBArray(DBData parent,DBDArrayField dbdArrayField);
        // PVArray methods
        public boolean isCapacityMutable();
        public DBType getElementDBType(); 
        public Type getElementType();
        abstract public int getCapacity();
        abstract public int getLength();
        abstract public void setCapacity(int len);
        abstract public void setLength(int len);
    }</pre>

<p>This is likely to be the class that is most often extented for special
purposes. The following is the code that provides the default implementation
for a DBDoubleArray:</p>
<pre>    private static class DoubleArray extends AbstractDBArray implements DBDoubleArray
    {
        private double[] value;
        int length = 0;
        int capacity;
        boolean capacityMutable;

        // The constructor
        DoubleArray(DBData parent,DBDArrayField dbdArrayField,
            int capacity,boolean capacityMutable)
        {
            super(parent,dbdArrayField);
            this.capacity = capacity;
            this.capacityMutable = capacityMutable;
            value = new double[capacity];
            String defaultValue = dbdArrayField.getFieldAttribute().getDefault();
            if(defaultValue!=null &amp;&amp; defaultValue.length()&gt;0) {
                String[] values = primitivePattern.split(defaultValue);
                try {
                    convert.fromStringArray(this,0,values.length,values,0);
                } catch (NumberFormatException e) {
                }
            }
        }

        public String toString() { return toString(0); }
        public String toString(int indentLevel) {
            return convert.getString(this, indentLevel)
            + super.toString(indentLevel);
        }
        public boolean isCapacityMutable() { return capacityMutable;}
        public int get(int offset, int len, DoubleArrayData data) {
            int n = len;
            if(offset+len &gt; length) n = length;
            data.data = value;
            data.offset = offset;
            return n;
        }
        public int put(int offset, int len, double[]from, int fromOffset) {
            if(offset+len &gt; length) {
                 int newlength = offset + len;
                 if(newlength&gt;capacity) setCapacity(newlength);
                 length = newlength;
            }
            System.arraycopy(from,fromOffset,value,offset,len);
            return len;
        }
        public int getCapacity() { return capacity; }
        public int getLength() { return length; }
        public void setCapacity(int len) {
            if(!capacityMutable)
                throw new IllegalStateException("capacity is immutable");
            if(length&gt;len) length = len;
            double[]newarray = new double[len];
            if(length&gt;0) System.arraycopy(value,0,newarray,0,length);
            value = newarray;
            capacity = len;
        }
        public void setLength(int len) {
            if(!super.getField().isMutable())
                throw new IllegalStateException("PVData.isMutable is false");
            if(len&gt;capacity) setCapacity(len);
            length = len;
        }
    }</pre>

<p>This implementation starts with an array capacity passed to the
constructor. If the capacity is mutable, the array grows as required.</p>
<hr />

<h2 style="text-align: center" id="IOCDB1"><a id="IOCDB"></a> IOCDB: IOC
Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC. All methods IOCDBFactory are thread
safe. The instances of IOCDB created by IOCDBFactory are also thread safe.
ReadWrite locks are used to implement thread safety.</p>
<pre>    public interface IOCDB {
        String getName();
        DBD getDBD();
        IOCDB getMasterIOCDB();
        void mergeIntoMaster();
        DBRecord findRecord(String recordName);
        boolean removeRecord(DBRecord record);
        boolean addRecord(DBRecord record);
        DBAccess createAccess(String recordName);
        Map&lt;String,DBRecord&gt; getRecordMap();
        String recordList(String regularExpression);
        String recordToString(String regularExpression);
    }
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The IOC database Name.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the Database Definition database that this DBD uses.</dd>
  <dt style="font-family: courier;">getMasterIOCDB</dt>
    <dd>Get the master DBD for this DBD. The return value is null if no
      master.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge the record instances from this database into the master
      database.</dd>
  <dt style="font-family: courier;">findRecord</dt>
    <dd>Return the interface for the record with name recordName or null if
      the record is not found. A search is made this database. If not found
      and a master database exists than it is also serched.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove the record. (false,true) is returned if the record (was
      not,was) removed.</dd>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add a record instance. (false,true) is returned if the instance (was
      not,was) added to the database. A record is not added if it already
      exists in this database or in the master database.</dd>
  <dt style="font-family: courier;">createAccess</dt>
    <dd>Create a DBAccess. See below for a description of IOC Database
    Access.</dd>
  <dt style="font-family: courier;">getRecordMap</dt>
    <dd>Get a shallow copy of the map of all record instances in this
      database. A copy is returned to ensure thread safety.</dd>
  <dt style="font-family: courier;">recordList</dt>
    <dd>Return a string that contains a list if all record names that match
      the regular expression.</dd>
  <dt style="font-family: courier;">recordToString</dt>
    <dd>Return a dump of all record instances with names that match the
      regular expression.</dd>
</dl>

<p>IOCDBFactory is a class that manages IOCDB databases.</p>
<pre>    
    public class IOCDBFactory {
        public static IOCDB create(DBD dbd, String name, IOCDB master);
        public static boolean remove(IOCDB iocdb);
        public static IOCDB find(String name);
        public static Map&lt;String,IOCDB&gt; getIOCDBMap();
        public static String list(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create an IOCDB and add it to the map of all IOCDBs. A nul is
      returned if an IOCDB with the same name already exists.
      <ul>
        <li>dbd<br />
          The Database Definition database for use with this IOCDB.</li>
        <li>name<br />
          The name for this IOCDB. It must not already exist.</li>
        <li>master<br />
          The master IOCDB or null if this is the master or no master is
          required.</li>
      </ul>
    </dd>
  <dt style="font-family: courier;">remove</dt>
    <dd>Remove the iocdb. (false,true) is returned if the iocdb (was not,
      was) removed.</dd>
  <dt style="font-family: courier;">find</dt>
    <dd>Find the IOCDB. Return null is not found.</dd>
  <dt style="font-family: courier;">getIOCDBMap</dt>
    <dd>Get a shallow copy of the map of all IOCDBs. A copy is returned to
      ensure thread safety.</dd>
  <dt style="font-family: courier;">list</dt>
    <dd>Return a string that contains a list if all IOCDBs with names that
      match the regular expression.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Database1"><a id="DatabaseAccess"></a>IOC
Database Access</h2>
<hr />
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    public interface DBAccess {
        DBRecord getDbRecord();
        AccessSetResult setField(String name);
        String getOtherRecord();
        String getOtherField();
        void setField(DBData dbData);
        DBData getField();
        DBData getPropertyField(Property property);
        DBData getPropertyField(String propertyName);
        void replaceField(DBData oldField, DBData newField);
    }</pre>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes AbstractDBData and AbstractDBRecord provide support for
implementing database monitors, i.e. support for notifying a client whenever
a field of a database instance changes value.</p>

<p>A client must implement the interface:</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
    }</pre>

<p>A client can listen to an arbitrary number of fields in a record. It must
first obtain a Listen interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    Listener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbData.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy.
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>   class TestListener implements DBListener{
        private Listener listener;
        private String recordName;
        private String field = null;
        private boolean synchronousData = false;

        TestListener(IOCDB iocdb,String recordName,String field) {
            this.recordName = recordName;
            this.field = field;
            DBAccess dbAccess = iocdb.createAccess(recordName);
            if(dbAccess==null) {
                System.out.printf("record %s not found\n",recordName);
                return;
            }
            DBData dbData;
            if(dbAccess.setField(field)!=AccessSetResult.thisRecord){
                System.out.printf("name %s not in record %s\n",field,recordName);
                return;
            }
            dbData = dbAccess.getField();
            listener = dbData.getRecord().createListener(this);
            dbData.addListener(listener);
            if(dbData.getField().getType()!=Type.pvStructure) {
                Property[] property = dbData.getField().getPropertys();
                for(Property prop : property) {
                    dbData = dbAccess.getPropertyField(prop);
                    dbData.addListener(listener);
                }
            }
        }

        public void beginSynchronous() {
            synchronousData = true;
        }

        public void endSynchronous() {
            synchronousData = false;
        }

        public void newData(DBData dbData) {
            System.out.printf(" actualField %s value %s\n",
                dbData.getField().getName(), dbData.toString());
            System.out.printf("TestListener recordName %s is Synchronous %b"
                    + " field %s",
                recordName,
                synchronousData,
                field);
            String dbDataName = dbData.getField().getName();
            DBData parent = dbData.getParent();
            while(parent!=dbData.getRecord()) {
                dbDataName = parent.getField().getName() + "." + dbDataName;
                parent = parent.getParent();
            }
            String value = dbData.toString();
            System.out.printf("    dbDataName %s value %s\n",
                dbDataName,value);
        }
    }</pre>

<p>In order for the listen support to work support that implements the
DBRecord interface must extend AbstractDBRecord and support that implements
any other DB field interface must extend AbstractDBdata. In addition any code
that implements a put methods must call</p>
<pre>    postPut();</pre>

<p>whenever the put method is called. It must call postPut whenever if
modifies its internal data for the field. It must call postPut even if the
new value is the same as the old value.</p>
</body>
</html>
