<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2006.05.25</h1>
<hr />
<a href="#Overview">Overview</a> <br />
<a href="#Instance">Record Instance Syntax</a>
<ul>
  <li><a href="#FieldAssignment">Field Assignmant</a>
    <ul>
      <li><a href="#FieldPrimitive">Primitive Types</a></li>
      <li><a href="#FieldString">string</a></li>
      <li><a href="#FieldStructure">structure</a></li>
      <li><a href="#FieldArray">array</a></li>
      <li><a href="#FieldMenu">menu</a></li>
      <li><a href="#FieldEnumerated">enumerated</a></li>
      <li><a href="#FieldLink">link</a></li>
    </ul>
  </li>
</ul>
<a href="#RecordInstanceAccess">Record Instance Access</a>
<ul>
  <li><a href="#DBListener">Listener Interface</a></li>
  <li><a href="#DBMasterListener">Master Listener Interface</a></li>
  <li><a href="#DBData">Base Interface for accesssing data</a></li>
  <li><a href="#DBPVData">Scalar and String Data</a></li>
  <li><a href="#EnumData">Enumerated Data</a></li>
  <li><a href="#MenuData">Menu Data</a></li>
  <li><a href="#StructureData">Structure Data</a></li>
  <li><a href="#RecordData">Record Data</a></li>
  <li><a href="#LinkData">Link Data</a></li>
  <li><a href="#ArrayData">Array Data</a></li>
</ul>
<a href="#FieldDataFactory">Factory for creating Data Fields</a><br />
<a href="#AbstractClasses">Abstract Classes</a>
<ul>
  <li><a href="#AbstractDBData">AbstractDBData</a></li>
  <li><a href="#AbstractDBEnum">AbstractDBEnum</a></li>
  <li><a href="#AbstractDBMenu">AbstractDBMenu</a></li>
  <li><a href="#AbstractDBStructure">AbstractDBStructure</a></li>
  <li><a href="#AbstractDBRecord">AbstractDBRecord</a></li>
  <li><a href="#AbstractDBLink">AbstractDBLink</a></li>
  <li><a href="#AbstractDBArray">AbstractDBArray</a></li>
</ul>
<a href="#IOCDB">IOCDB: IOC Database</a><br />
<a href="#XMLToDB">XML to Database Converter</a><br />
<a href="#DatabaseAccess">IOC Database Access</a><br />

<hr />

<h1 style="text-align: center"><a id="Overview"></a>Overview</h1>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax
    <p>The XML syntax for defining record instances.</p>
  </li>
  <li>An XML to database converter.
    <p>This takes as input two files: 1) Database Definitions ( menu,
    structure, recordType, linkSupport) and 2) record instance definitions.
    The files are converted from xml and the results places in an IOC
    database.</p>
    <p>In addition a comman line utility is orovided that calls the XML to
    database convertter and dumps the resulting record instance
    definitions.</p>
  </li>
  <li>A factory for creating supporty for database fields.<br />
  </li>
  <li>Java Support for accessing fields of a record instance.</li>
  <li>A set of abstract classes for implementing ths support for database
    fields.</li>
</ol>
<hr />

<h1 style="text-align: center"><a id="Instance"></a>Record Instance
Syntax</h1>
<hr />

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span> is a string with a
combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p><span style="font-family: courier;">fieldAssignment</span> is described
next.</p>

<h2 style="text-align: center">Field Assignment</h2>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be a name
definied in the record type definition.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h3><a id="FieldPrimitive"></a>Primitive Types</h3>

<p>For primitive types the initializer has the same format as the the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value&gt;.98&lt;/value&gt;
</pre>

<p>NOTE: Byte.decode, Short.decode, Integer.decide, and Long.decode are used
to convert a string to an integer data type. Thus hex values are allowed but
the sign bit MUST not be set. This for byte data 0xff is not allowed but
-0x01 is allowed. Note for example that the byte value -128 can not be
specified in hex.</p>

<h3><a id="FieldString"></a>string</h3>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h3><a id="FieldStructure"></a>structure</h3>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure and recordType definitions:</p>
<pre>    &lt;structure name = "DisplayLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "ai"&gt;
   ...
       &lt;field name = "displayLimit&gt;
            &lt;structure name = "DisplayLimit" /&gt;
       &lt;field/&gt;
   ...</pre>

<p>displayLimit is initilized as follows:.</p>
<pre>    &lt;displayLimit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;</pre>

<h3><a id="FieldArray"></a>array</h3>
The syntax for an array initializer is:
<pre>    &lt;fieldName capacity = "capacity" &gt;
        &lt;value offset = "offset"&gt;value&lt;/value&gt;
        &lt;value offset = "offset"&gt;valueList&lt;/value&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>assigns a value to the array. If the array is an array of structures
      then the value is actually a set of field definitions. If the array is
      an array of array the value is another array initialization.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
</dl>

<p>Assume the following are part of a recordType definition:</p>
<pre>    &lt;field name = "intArray"&gt;
        &lt;array&gt;
            &lt;type&gt;&lt;int /&gt;&lt;/type&gt;
        &lt;/array&gt;
    &lt;/field&gt;
    &lt;field name = "structArray"&gt;
        &lt;type&gt;
            &lt;array&gt;
                &lt;structure name = "DisplayLimit /&gt;
            &lt;/array&gt;
        &lt;/type&gt;
    &lt;/field&gt;</pre>

<p>Then the following all perform the same initialization:</p>
<pre>    &lt;intArray capacity = "3" &gt;
        &lt;value&gt;0.0, 1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray capacity = "3" offset = "1"&gt;
        &lt;value&gt;1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray&gt;
        &lt;value&gt;0.0&lt;/value&gt;
        &lt;value&gt;1.0&lt;/value&gt;
        &lt;value&gt;2.0&lt;/value&gt;
    &lt;/intArray&gt;
         </pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray capacity = "2"&gt;
        &lt;value&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
        &lt;value&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
    &lt;/structArray&gt;</pre>

<h3><a id="FieldMenu"></a>menu</h3>

<p>A menu field is initialized as follows:</p>
<pre>    &lt;fieldName&gt;stringValue&lt;/fieldName&gt;</pre>
where stringValue is one of the allowed values for the menu.

<p>For example:</p>
<pre>    &lt;scan&gt;periodic&lt;/scan&gt;</pre>

<h3><a id="FieldEnumerated"></a>enumerated</h3>

<p>An enumerated field is initialized as follows:</p>
<pre>    &lt;fieldName&gt;
        &lt;choice&gt;choice&lt;/choice&gt;
        stringValue
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">choice</dt>
    <dd>A choice string. One of these must be specified for each choice.</dd>
  <dt style="font-family: courier;">stringValue</dt>
    <dd>one of the allowed values for the enum.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;enumExample&gt;
         &lt;choice&gt;zeroState&lt;/choice&gt;
         &lt;choics&gt;oneState&lt;/choice&gt;
         oneState
    &lt;/enumExample&gt;</pre>

<h3><a id="FieldLink"></a>link</h3>
A link field is initialized as follows:
<pre>    &lt;fieldName&gt;
        &lt;support name = "supportName" /&gt;
        &lt;structure name = "supportStructureName"&gt;
            &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
            ...
        &lt;/structure&gt;
    &lt;/fieldName&gt;</pre>

<p></p>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of one of the <span
      style="font-family: courier;">linkSupport</span> definitions</dd>
  <dt style="font-family: courier;">supportStructureName</dt>
    <dd>The name of the support structure given with the support
    definition</dd>
  <dt style="font-family: courier;">fieldValue</dt>
    <dd>The value for the structure field.<br />
    </dd>
</dl>
<hr />

<h1 style="text-align: center"><a id="RecordInstanceAccess"></a>Record
Instance Access</h1>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc.</p>

<h2><a id="DBListener"></a>Listener Interface</h2>

<p>DBListener is an interface that must be implemented by code that calls
PVdata.addListener.</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void startSynchronous();
        void endSynchronous();
    }</pre>

<h2><a id="DBMasterListener"></a>Master Listener Interface</h2>

<p>DBMasterListener is an interface that must be implemented by code
that wants to perform synchronous puts. For example RecordProcess
does synchronous puts.</p>
<pre>    public interface DBMasterListener {
        void newData(DBData dbData);
    }</pre>

<h2><a id="DBData"></a>Base Interface for accessing data</h2>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBData extends PVData {
        DBDField getDBDField();
        DBStructure getParent();
        DBRecord getRecord();
        void addListener(DBListener listener);
        void postPut();
        void postPut(DBData dbData);
    }</pre>

<p>Since it extends PVData it has the methods:</p>
<pre>        Field getField();
        String toString(int indentLevel);</pre>
Field is the introspection interface for pvAccess Types. DBDField is the
introspection interface for DBTypes.

<h2><a id="DBPVData"></a>Scalar and String Data</h2>
The following are the data interfaces for fields that have a pvAccess Type.
<pre>    public interface DBBoolean extends DBData, PVBoolean{}
    public interface DBByte extends DBData, PVByte{}
    public interface DBShort extends DBData, PVShort{}
    public interface DBInt extends DBData, PVInt{}
    public interface DBLong extends DBData, PVLong{}
    public interface DBFloat extends DBData, PVFloat{}
    public interface DBDouble extends DBData, PVDouble{}
    public interface DBString extends DBData, PVString{}</pre>
Since each interface implements a PV data interface it has get/put methods to
get and put data values.

<p>The following example shows how a double field can be read.</p>
<pre>     double getValue(DBData db) {
        DBField field = db.getDBField();
        if(field.getDBType != dbPVType) throw new IllegalStateException("not double");
        if(field.getPVType() != pvDouble) throw new IllegaStateException("not double");
        PVDouble data = (PVDouble)db;
        return data.get();
    }</pre>

<p>the following accomplishes the same but an exception will be thrown if the
DBData is not a PVDouble:</p>
<pre>     double getValue(DBData db) {
        PVDouble data = (PVDouble)db; // exception may be thrown
        return data.get();
    }</pre>

<h2><a id="EnumData"></a>Enumerated Data</h2>
An enumerated field is accessed via the interface
<pre>    public interface DBEnum extends DBData, PVEnum{}</pre>

<h2><a id="MenuData"></a>Menu Data</h2>
A menu field is accessed via the interface:
<pre>    public interface DBMenu extends DBData, DBEnum {
        String getMenuName();
    }</pre>

<p>The following shows how to access a menu field:</p>
<pre>    void dumpMenuField(DBMenu menu) {
        String[] choice = menu.getChoices();
        int index = menu.getIndex();
        printf("field %s is menu %s. Value is %d %s\n",
            menu.getField().getName(),menu.getMenuName(),
            menu.getIndex(),choice[index]);
    }</pre>

<h2><a id="StructureData"></a>Structure Data</h2>
<pre>    public interface DBStructure extends DBData, PVStructure {
         DBData[] getFieldDBDatas();
         int getFieldDBDataIndex(String fieldName);
    }</pre>

<h2><a id="RecordData"></a>RecordData</h2>
<pre>    public interface DBRecord extends DBStructure {
        String getRecordName();
        void readLock();
        void readUnlock();
        void writeLock();
        void writeUnlock();
        boolean insertMasterListener(DBMasterListener listener);
        void removeMasterListener(DBMasterListener listener);
        boolean postMaster(DBData dbData);
        void startSynchronous();
        void stopSynchronous();
        void postForMaster(DBData dbData);
        void addListener(DBListenerPvt listener);
        void removeListener(DBListenerPvt listener);
    }</pre>

<h2><a id="LinkData"></a>Link Data</h2>
<pre>    public interface DBLink extends DBStructure {
        String getConfigStructureFieldName();
        void putConfigStructureFieldName(String name);
        String getLinkSupportName();
        void putLinkSupportName(String name);
        DBStructure getConfigStructure();
        void putConfigStructure(DBStructure dbStructure);
    }</pre>

<h2><a id="ArrayData"></a>Array Data</h2>

<p>The base interface for array fields is:</p>
<pre>    public interface DBArray extends DBData, PVArray {}</pre>

<p></p>

<p>The following are the interfaces for each of the array types:</p>
<pre>    public interface DBBooleanArray extends DBArray, PVBooleanArray{}
    public interface DBByteArray extends DBArray, PVByteArray{}
    public interface DBShortArray extends DBArray, PVShortArray{}
    public interface DBIntArray extends DBArray, PVIntArray{}
    public interface DBLongArray extends DBArray, PVLongArray{}
    public interface DBFloatArray extends DBArray, PVFloatArray{}
    public interface DBDoubleArray extends DBArray, PVDoubleArray{}
    public interface DBStringArray extends DBArray, PVStringArray{}
    public interface DBEnumArray extends DBArray, PVEnumArray{}
    public interface DBMenuArray extends DBArray{
        int get(int offset, int len, DBMenu[]to, int toOffset);
        int put(int offset, int len, DBMenu[]from, int fromOffset);
    }
    public interface DBStructureArray extends DBArray{
        int get(int offset, int len, DBStructure[]to, int toOffset);
        int put(int offset, int len, DBStructure[]from, int fromOffset);
    }
    public interface DBArrayArray extends DBArray{
        int get(int offset, int len, DBArray[]to, int toOffset);
        int put(int offset, int len, DBArray[]from, int fromOffset);
    }
    public interface DBLinkArray extends DBArray{
        int get(int offset, int len, DBLink[]to, int toOffset);
        int put(int offset, int len, DBLink[]from, int fromOffset);
    }</pre>
<hr />

<h1 style="text-align: center"><a id="FieldDataFactory"></a>Factory for
creating Data Fields</h1>
<hr />

<p>A factory is available that implements the interfaces for record instance
fields.</p>
<pre>    public class FieldDataFactory {
        public static DBData createData(DBStructure parent,
            DDBDField dbdField);
        public static DBData createEnumData(DBStructure parent,
            DDBDField dbdField, String[] choice);
        public static DBArray createArrayData(DBStructure parent,
            DDBDField dbdField, int capacity,boolean capacityMutable);
        public static DBRecord createRecord(String recordName,
             DBDRecordType dbdRecordType);
    }</pre>
<hr />

<h1 style="text-align: center"><a id="AbstractClasses"></a>Abstract
Classes</h1>
<hr />

<p>This section describes abstract classes for implementing the data
interface for database fields. These classes are used by FieldDataFactory and
can also be used by code that wants to provide special implementations of
database fields.</p>

<h2><a id="AbstractDBData"></a>AbstractDBData</h2>

<p>Abstract base class for a scalar field.</p>
<pre>    public abstract class AbstractDBData implements DBData{
        public static void newLine(StringBuilder builder, int indentLevel);
        protected void setRecord(DBRecord record);
        protected AbstractDBData(DBStructure parent, DBDField dbdField);
    }</pre>

<h2><a id="AbstractDBEnum"></a>AbstractDBEnum</h2>

<p>Abstract base class for an enumerated field.</p>
<pre>    public abstract class AbstractDBEnum extends AbstractDBData
    implements DBEnum {
        protected AbstractDBEnum(DBStructure parent,
            DBDEnumField dbdEnumField, String[]choice);
        protected int index;
        protected String[]choice;
    }</pre>

<h2><a id="AbstractDBMenu"></a>AbstractDBMenu</h2>

<p>Abstract base class for a menu field.</p>
<pre>    public abstract class AbstractDBMenu extends AbstractDBData
    implements DBMenu
    {
        protected AbstractDBMenu(DBStructure parent,
            DBDMenuField dbdMenuField);
        protected int index;
        protected String[]choice;
        protected String menuName;
        protected static Convert convert;
        protected static void newLine(StringBuilder builder, int indentLevel);
    }</pre>

<h2><a id="AbstractDBStructure"></a>AbstractDBStructure</h2>

<p>Abstract base class for a structure field.</p>
<pre>    public abstract class AbstractDBStructure extends AbstractDBData
    implements DBStructure
    {
        // constructor for structure fields
        protected AbstractDBStructure(DBStructure parent,
           DBDStructureField dbdStructureField);
        // constructor for record instances
        protected AbstractDBStructure(DBDRecordType dbdRecordType));
        protected void createFields(DBRecord record);
    }</pre>

<h2><a id="AbstractDBRecord"></a>AbstractDBRecord</h2>

<p>Abstract base class for a record instance.</p>
<pre>    public class AbstractDBRecord extends AbstractDBStructure
    implements DBRecord {
        protected AbstractDBRecord(String recordName,
            DBDRecordType dbdRecordType);
    }</pre>

<h2><a id="AbstractDBLink"></a>AbstractDBLink</h2>

<p>Abstract base class for a link field.</p>
<pre>    public abstract class AbstractDBLink
    extends AbstractDBStructure implements DBLink
    {
        protected AbstractDBLink(DBStructure parent,
            DBDStructureField dbdLinkField);
    }</pre>

<h2><a id="AbstractDBArray"></a>AbstractDBArray</h2>

<p>Abstract base class for an array field.</p>
<pre>    public abstract class AbstractDBArray
    extends AbstractDBData implements DBArray
    {
        abstract public int getCapacity();
        abstract public int getLength();
        abstract public void setCapacity(int len);
        abstract public void setLength(int len);
        protected AbstractDBArray(DBDArrayField dbdArrayField);
    }</pre>

<p>This is probably the most usefull abstract class.</p>
<hr />

<h1 style="text-align: center"><a id="IOCDB"></a> IOCDB: IOC Database</h1>
<hr />

<p>An IOCDB is a database for a java IOC.</p>
<pre>    public interface IOCDB {
        String getName();
        DBD getDBD();
        DBRecord findRecord(String recordName);
        DBAccess createAccess(String recordName);
        boolean createRecord(String recordName, DBDRecordType dbdRecordType);
        Map&lt;String,DBRecord&gt; getRecordMap();
    }
    
    public class IOCDBFactory {
        public static IOCDB create(DBD dbd, String name);
        public static IOCDB find(String name);
        public static Collection&lt;IOCDB&gt; getIOCDBList();
        public static void remove(IOCDB iocdb);
    }</pre>
<hr />

<h1 style="text-align: center"><a id="XMLToDB"></a>XML to Database
Converter</h1>
<hr />

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbdin, IOCDB iocdbin, String fileName);
    }</pre>

<p>A java application that reads and dumps a record instance file can be
invoked from a shell via the command:</p>
<pre>     java XMLToDB dbdFile dbInstanceFile</pre>
<hr />

<h1 style="text-align: center"><a id="DatabaseAccess"></a>IOC Database
Access</h1>
<hr />
<pre>    public interface DBAccess {
        DBRecord getDbRecord();
        boolean setField(String name);
        void setField(DBData dbData);
        DBData getField();
        DBData getPropertyField(Property property);
        DBData getPropertyField(String propertyName);
    }</pre>
</body>
</html>
