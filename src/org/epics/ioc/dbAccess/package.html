<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2006.07.11</h1>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Instance Syntax</a>
    <ul>
      <li><a href="#Primitive">Primitive Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#array">array</a></li>
      <li><a href="#menu">menu</a></li>
      <li><a href="#enumerated">enumerated</a></li>
      <li><a href="#link">link</a></li>
    </ul>
  </li>
  <li><a href="#Database">XML to Database Converter</a></li>
  <li><a href="#Record1">Record Instance Access</a>
    <ul>
      <li><a href="#Listener">Listener Interface</a></li>
      <li><a href="#Base">Base Interface for accessing data</a></li>
      <li><a href="#Scalar">Scalar and String Data</a></li>
      <li><a href="#Enumerated">Enumerated Data</a></li>
      <li><a href="#Menu">Menu Data</a></li>
      <li><a href="#Structure">Structure Data</a></li>
      <li><a href="#RecordData1">RecordData</a></li>
      <li><a href="#Link">Link Data</a></li>
      <li><a href="#Array">Array Data</a></li>
    </ul>
  </li>
  <li><a href="#Factory">Factory for creating Data Fields</a></li>
  <li><a href="#Abstract">Abstract Classes</a>
    <ul>
      <li><a href="#AbstractDB">AbstractDBData</a></li>
      <li><a href="#AbstractDB1">AbstractDBEnum</a></li>
      <li><a href="#AbstractDB2">AbstractDBMenu</a></li>
      <li><a href="#AbstractDB3">AbstractDBStructure</a></li>
      <li><a href="#AbstractDB4">AbstractDBRecord</a></li>
      <li><a href="#AbstractDB5">AbstractDBLink</a></li>
      <li><a href="#AbstractDB6">AbstractDBArray</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB1"> IOCDB: IOC Database</a></li>
  <li><a href="#Database1">IOC Database Access</a></li>
  <li><a href="#Listener1">Listener Support</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax<br />
    The XML syntax for defining record instances.</li>
  <li>An XML to database converter.<br />
    This takes as input two files: 1) Database Definitions ( menu, structure,
    recordType, linkSupport) and 2) record instance definitions. The files
    are converted from xml and the result placed in an IOC database.</li>
  <li>Record Instance Access<br />
    Interfaces for accessing data in record instances.</li>
  <li>Data Factory<br />
    A factory for creating support for database fields. It can create support
    for all types of fields.</li>
  <li>Abstract Classes<br />
    A set of abstract classes for implementing ths support for database
    fields.</li>
  <li>Listen Support<br />
    A description of the support for monitoring changes to the data in
    database instances fields.</li>
</ol>
<hr />

<h2 style="text-align: center" id="Record"><a id="Instance"></a>Record
Instance Syntax</h2>
<hr />

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" recordSupportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span> is a string with a
combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p>supportName is the name of the class that implements the support. If the
class is implemented in a package (except the default package), the package
must preceed the class name. For example
"org.epics.ioc.support.ExampleSupport".</p>

<p>When a record instance is being loaded into an ioc, an attempt is made to
create record support for each record instance. If support can not be created
a warning message is generated. The record support is created as follows: If
the record instance defines a recordSupportName this name provides the
supportName. Otherwise the recordType definition is consulted to see if it
defins support. If no support is found than an warnimng message is issued.
Record support is created via Java reflection, The supportName must be the
name of a Java Class that has an appropriate constructor which is called to
create the support. Any failure is reported via a warning message.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be a name
definied in the record type definition.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h4 id="Primitive"><a id="FieldPrimitive"></a>Primitive Types</h4>

<p>For primitive types the initializer has the same format as the the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value&gt;.98&lt;/value&gt;</pre>

<p>NOTE: Byte.decode, Short.decode, Integer.decide, and Long.decode are used
to convert a string to an integer data type. Thus hex values are allowed but
the sign bit MUST not be set. This for byte data 0xff is not allowed but
-0x01 is allowed. Note for example that the byte value -128 can not be
specified in hex.</p>

<h4 id="string"><a id="FieldString"></a>string</h4>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h4 id="structure"><a id="FieldStructure"></a>structure</h4>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure and recordType definitions:</p>
<pre>    &lt;structure name = "DisplayLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "ai"&gt;
   ...
       &lt;field name = "displayLimit&gt;
            &lt;structure name = "DisplayLimit" /&gt;
       &lt;field/&gt;
   ...</pre>

<p>displayLimit is initilized as follows:.</p>
<pre>    &lt;displayLimit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;</pre>

<p>If a structure field has associated support it can be specified as
follows:</p>
<pre>    &lt;fieldName structureSupportName = "supportName" &gt;</pre>

<p>supportName is the name of the class that implements the support. If the
class is implemented in a package (except the default package), the package
must preceed the class name. For example
"org.epics.ioc.support.ProcessSupport".</p>

<p>When a record instance is being loaded into an ioc, an attempt is made to
create structure support for each structure field instance. If no support is
found then the field has no support. The structure support is created as
follows: If the structure field instance defines a structureSupportName this
name provides the supportName, otherwise the structure definition is
consulted to see if it defines support. If no support is found than nothing
more is done. Record support for the structure field is created via Java
reflection, The supportName must be the name of a Java Class that has an
appropriate constructor which is called to create the support. Any failure is
reported via a warning message.</p>

<p>It is permissible to define a field to be a structure without providing a
structure name. In this case the structureName must be provided whe the field
is being created. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" &gt;</pre>

<h4 id="array"><a id="FieldArray"></a>array</h4>
The syntax for an array initializer is:
<pre>    &lt;fieldName capacity = "capacity" &gt;
        &lt;value offset = "offset"&gt;value&lt;/value&gt;
        &lt;value offset = "offset"&gt;valueList&lt;/value&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>assigns a value to the array. If the array is an array of structures
      then the value is actually a set of field definitions. If the array is
      an array of array the value is another array initialization.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
</dl>

<p>Assume the following are part of a recordType definition:</p>
<pre>    &lt;field name = "intArray"&gt;
        &lt;array&gt;
            &lt;type&gt;&lt;int /&gt;&lt;/type&gt;
        &lt;/array&gt;
    &lt;/field&gt;
    &lt;field name = "structArray"&gt;
        &lt;type&gt;
            &lt;array&gt;
                &lt;structure name = "DisplayLimit /&gt;
            &lt;/array&gt;
        &lt;/type&gt;
    &lt;/field&gt;</pre>

<p>Then the following all perform the same initialization:</p>
<pre>    &lt;intArray capacity = "3" &gt;
        &lt;value&gt;0.0, 1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray capacity = "3" offset = "1"&gt;
        &lt;value&gt;1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray&gt;
        &lt;value&gt;0.0&lt;/value&gt;
        &lt;value&gt;1.0&lt;/value&gt;
        &lt;value&gt;2.0&lt;/value&gt;
    &lt;/intArray&gt;
         </pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray capacity = "2"&gt;
        &lt;value&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
        &lt;value&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
    &lt;/structArray&gt;</pre>

<h4 id="menu"><a id="FieldMenu"></a>menu</h4>

<p>A menu field is initialized as follows:</p>
<pre>    &lt;fieldName&gt;stringValue&lt;/fieldName&gt;</pre>
where stringValue is one of the allowed values for the menu.

<p>For example:</p>
<pre>    &lt;scan&gt;periodic&lt;/scan&gt;</pre>

<h4 id="enumerated"><a id="FieldEnumerated"></a>enumerated</h4>

<p>An enumerated field is initialized as follows:</p>
<pre>    &lt;fieldName&gt;
        &lt;choice&gt;choice&lt;/choice&gt;
        stringValue
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">choice</dt>
    <dd>A choice string. One of these must be specified for each choice.</dd>
  <dt style="font-family: courier;">stringValue</dt>
    <dd>one of the allowed values for the enum.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;enumExample&gt;
         &lt;choice&gt;zeroState&lt;/choice&gt;
         &lt;choics&gt;oneState&lt;/choice&gt;
         oneState
    &lt;/enumExample&gt;</pre>

<h4 id="link"><a id="FieldLink"></a>link</h4>
A link field is initialized as follows:
<pre>    &lt;fieldName&gt;
        &lt;support name = "supportName" /&gt;
        &lt;structure name = "supportStructureName"&gt;
            &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
            ...
        &lt;/structure&gt;
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of one of the <span
      style="font-family: courier;">linkSupport</span> definitions</dd>
  <dt style="font-family: courier;">supportStructureName</dt>
    <dd>The name of the support structure given with the support
    definition</dd>
  <dt style="font-family: courier;">fieldValue</dt>
    <dd>The value for the structure field.<br />
    </dd>
</dl>

<p>supportName is the name of the class that implements the support. If the
class is implemented in a package (except the default package), the package
must preceed the class name. For example
"org.epics.ioc.support.ProcessSupport".</p>

<p>When a record instance is being loaded into an ioc, an attempt is made to
create link support for each link instance. If support can not be created a
warning message is generated. The link support is created via Java
reflection. The supportName must be the name of a Java Class that has an
appropriate constructor which is called to create the support. Any failure is
reported via a warning message.</p>
<hr />

<h2 style="text-align: center" id="Database"><a id="XMLToDB"></a>XML to
Database Converter</h2>
<hr />

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbdin, IOCDB iocdbin, String fileName);
    }</pre>
<hr />

<h2 style="text-align: center" id="Record1"><a
id="RecordInstanceAccess"></a>Record Instance Access</h2>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc.</p>

<h3 id="Listener"><a id="DBListener"></a>Listener Interface</h3>

<p>DBListener is an interface that must be implemented by code that calls
DBdata.addListener.</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
    }</pre>

<p>Listener is an interface that must be implemented by the code that
implements DBRecord. DBRecord provides a method to create a Listener.</p>
<pre>    public interface Listener {
        void newData(DBData dbData);
    }</pre>

<h3 id="Base"><a id="DBData"></a>Base Interface for accessing data</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBData extends PVData {
        DBDField getDBDField();
        DBStructure getParent();
        DBRecord getRecord();
        void addListener(Listener listener);
        void removeListener(Listener listener);
        void postPut();
        void postPut(DBData dbData);
    }</pre>

<p>Since it extends PVData it has the methods:</p>
<pre>        Field getField();
        String toString(int indentLevel);</pre>
Field is the introspection interface for pvAccess Types. DBDField is the
introspection interface for DBTypes.

<h3 id="Scalar"><a id="DBPVData"></a>Scalar and String Data</h3>
The following are the data interfaces for fields that have a pvAccess Type.
<pre>    public interface DBBoolean extends DBData, PVBoolean{}
    public interface DBByte extends DBData, PVByte{}
    public interface DBShort extends DBData, PVShort{}
    public interface DBInt extends DBData, PVInt{}
    public interface DBLong extends DBData, PVLong{}
    public interface DBFloat extends DBData, PVFloat{}
    public interface DBDouble extends DBData, PVDouble{}
    public interface DBString extends DBData, PVString{}</pre>
Since each interface implements a PV data interface it has get/put methods to
get and put data values.

<p>The following example shows how a double field can be read.</p>
<pre>     double getValue(DBData db) {
        Type type = db.getField().getType();
        if(type != Type.pvDouble) throw new IllegaStateException("not double");
        PVDouble data = (PVDouble)db;
        return data.get();
    }</pre>

<p>The following accomplishes the same but an exception will be thrown if the
DBData is not a PVDouble:</p>
<pre>     double getValue(DBData db) {
        PVDouble data = (PVDouble)db; // exception may be thrown
        return data.get();
    }</pre>

<h3 id="Enumerated"><a id="EnumData"></a>Enumerated Data</h3>
An enumerated field is accessed via the interface
<pre>    public interface DBEnum extends DBData, PVEnum{}</pre>

<h3 id="Menu"><a id="MenuData"></a>Menu Data</h3>
A menu field is accessed via the interface:
<pre>    public interface DBMenu extends DBData, DBEnum {
        String getMenuName();
    }</pre>

<p>The following shows how to access a menu field:</p>
<pre>    void dumpMenuField(DBMenu menu) {
        String[] choice = menu.getChoices();
        int index = menu.getIndex();
        printf("field %s is menu %s. Value is %d %s\n",
            menu.getField().getName(),menu.getMenuName(),
            menu.getIndex(),choice[index]);
    }</pre>

<h3 id="Structure"><a id="StructureData"></a>Structure Data</h3>
<pre>    public interface DBStructure extends DBData, PVStructure {
         boolean createFields(DBDStructure dbdStructure);
         DBDStructure getDBDStructure();
         DBData[] getFieldDBDatas();
         int getFieldDBDataIndex(String fieldName);
         RecordSupport getStructureSupport();
         boolean setStructureSupport(RecordSupport support);
    }</pre>

<p>where</p>
<dl>
  <dt>getDBDStructure</dt>
    <dd>This returns the DBDStructure for the field. If the database
      definition for the field did not specify a structure name then this is
      the only way to introspect the structure information.</dd>
  <dt>createFields</dt>
    <dd>If the database definition for the field did not specify a
      structureName than when a field is being created this must be called to
      associate a structure with the field.</dd>
  <dt>getFieldDBDatas</dt>
    <dd>Get the array of interfaces for the fields of the structure
    instance.</dd>
  <dt>getFieldDBDataIndex</dt>
    <dd>Get the index into DBData for the specified field.</dd>
  <dt>getStructureSupport</dt>
    <dd>Get the support for the structure.</dd>
  <dt>setStructureSupport</dt>
    <dd>Set the support for the structure.</dd>
</dl>

<h3 id="RecordData1"><a id="RecordData"></a>RecordData</h3>
<pre>    public interface DBRecord extends DBStructure {
        String getRecordName();
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        RecordSupport getRecordSupport();
        boolean setRecordSupport(RecordSupport support);
        ReentrantLock getLock();
        ReentrantLock lockOtherRecord(DBRecord otherRecord);
        int getRecordID();
        void beginSynchronous();
        void endSynchronous();
        Listener createListener(DBListener listener);
        void destroyListener(Listener listener);
    }</pre>

<h3 id="Link"><a id="LinkData"></a>Link Data</h3>
<pre>    public interface DBLink extends DBStructure {
        String getConfigStructureName();
        void putConfigStructureName(String name);
        String getLinkSupportName();
        void putLinkSupportName(String name);
        DBStructure getConfigStructure();
        void putConfigStructure(DBStructure dbStructure);
        LinkSupport getLinkSupport();
        boolean setLinkSupport(LinkSupport support);
    }</pre>

<h3 id="Array"><a id="ArrayData"></a>Array Data</h3>

<p>The base interface for array fields is:</p>
<pre>    public interface DBArray extends DBData, PVArray {}</pre>

<p></p>

<p>The following are the interfaces for each of the array types:</p>
<pre>    public interface DBBooleanArray extends DBArray, PVBooleanArray{}
    public interface DBByteArray extends DBArray, PVByteArray{}
    public interface DBShortArray extends DBArray, PVShortArray{}
    public interface DBIntArray extends DBArray, PVIntArray{}
    public interface DBLongArray extends DBArray, PVLongArray{}
    public interface DBFloatArray extends DBArray, PVFloatArray{}
    public interface DBDoubleArray extends DBArray, PVDoubleArray{}
    public interface DBStringArray extends DBArray, PVStringArray{}
    public interface DBEnumArray extends DBArray, PVEnumArray{}

    public class MenuArrayData {
        public DBMenu[] data;
        public int offset;
    }
    public interface DBMenuArray extends DBArray{
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, DBMenu[]from, int fromOffset);
    }
    
    public class DBStructureArrayData {
        public DBStructure[] data;
        public int offset;
    }
    public interface DBStructureArray extends DBArray{
        int get(int offset, int len, DBStructureArrayData data);
        int put(int offset, int len, DBStructure[]from, int fromOffset);
    }

    public class DBArrayArrayData {
        public DBArray[] data;
        public int offset;
    }
    public interface DBArrayArray extends DBArray{
        int get(int offset, int len, DBArrayArrayData data);
        int put(int offset, int len, DBArray[]from, int fromOffset);
    }

    public class LinkArrayData {
        public DBLink[] data;
        public int offset;
    }
    public interface DBLinkArray extends DBArray{
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, DBLink[]from, int fromOffset);
    }</pre>
<hr />

<h2 style="text-align: center" id="Factory"><a
id="FieldDataFactory"></a>Factory for creating Data Fields</h2>
<hr />

<p>A factory is available that implements the interfaces for record instance
fields.</p>
<pre>    public class FieldDataFactory {
        public static DBData createData(DBStructure parent,
            DDBDField dbdField);
        public static DBData createEnumData(DBStructure parent,
            DDBDField dbdField, String[] choice);
        public static DBArray createArrayData(DBStructure parent,
            DDBDField dbdField, int capacity,boolean capacityMutable);
        public static DBRecord createRecord(String recordName,
             DBDRecordType dbdRecordType);
    }</pre>
<hr />

<h2 style="text-align: center" id="Abstract"><a
id="AbstractClasses"></a>Abstract Classes</h2>
<hr />

<p>This section describes abstract classes for implementing the data
interface for database fields. These classes are used by FieldDataFactory and
can also be used by code that wants to provide special implementations of
database fields.</p>

<h3 id="AbstractDB"><a id="AbstractDBData"></a>AbstractDBData</h3>

<p>Abstract base class for a scalar field.</p>
<pre>    public abstract class AbstractDBData implements DBData{
        // PVData methods
        public Field getField();
        abstract public String toString();
        abstract public String toString(int indentLevel);
        // DBData methods
        public DBDField getDBDField();
        public DBStructure getParent();
        public DBRecord getRecord();
        public void addListener(Listener listener);
        public void removeListener(Listener listener);
        public void postPut();
        public void postPut(DBData dbData);
        // convenience method for derived classes
        protected static void newLine(StringBuilder builder, int indentLevel);
        // constructor
        protected AbstractDBData(DBStructure parent, DBDField dbdField);
        // must be called by derived class 
        protected void setRecord(DBRecord record);
    }</pre>

<h3 id="AbstractDB1"><a id="AbstractDBEnum"></a>AbstractDBEnum</h3>

<p>Abstract base class for an enumerated field.</p>
<pre>    public abstract class AbstractDBEnum extends AbstractDBData implements DBEnum {
        protected AbstractDBEnum(DBStructure parent,
            DBDEnumField dbdEnumField, String[]choice);
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB2"><a id="AbstractDBMenu"></a>AbstractDBMenu</h3>

<p>Abstract base class for a menu field.</p>
<pre>    public abstract class AbstractDBMenu extends AbstractDBData implements DBMenu
    {
        protected AbstractDBMenu(DBStructure parent, DBDMenuField dbdMenuField);
        // DBMenu methods
        public String getMenuName();
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB3"><a id="AbstractDBStructure"></a>AbstractDBStructure</h3>

<p>Abstract base class for a structure field.</p>
<pre>    public abstract class AbstractDBStructure extends AbstractDBData
    implements DBStructure
    {
        // constructor for structure fields
        protected AbstractDBStructure(DBStructure parent, DBDStructureField dbdStructureField);
        // constructor for record instances
        protected AbstractDBStructure(DBDRecordType dbdRecordType));
        // called by record instance constructor
        protected void createFields(DBRecord record);
        // PVStructure methods
        public PVData[] getFieldPVDatas();
        // DBStructure methods
        public boolean createFields(DBDStructure dbdStructure);
        public DBDStructure getDBDStructure();
        public DBData[] getFieldDBDatas();
        public int getFieldDBDataIndex(String fieldName);
        public RecordSupport getStructureSupport();
        public boolean setStructureSupport(RecordSupport support);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB4"><a id="AbstractDBRecord"></a>AbstractDBRecord</h3>

<p>Abstract base class for a record instance.</p>
<pre>    public class AbstractDBRecord extends AbstractDBStructure implements DBRecord {
        protected AbstractDBRecord(String recordName, DBDRecordType dbdRecordType);
        // DBRecord methods
        public String getRecordName();
        public RecordProcess getRecordProcess();
        public boolean setRecordProcess(RecordProcess recordProcess);
        public RecordSupport getRecordSupport();
        public boolean setRecordSupport(RecordSupport support);
        public ReentrantLock getLock();
        public ReentrantLock lockOtherRecord(DBRecord otherRecord);
        public int getRecordID();
        public void beginSynchronous();
        public void stopSynchronous();
        Listener createListener(DBListener listener);
        void destroyListener(Listener listener);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB5"><a id="AbstractDBLink"></a>AbstractDBLink</h3>

<p>Abstract base class for a link field.</p>
<pre>    public abstract class AbstractDBLink extends AbstractDBStructure implements DBLink
    {
        protected AbstractDBLink(DBStructure parent, DBDStructureField dbdLinkField);
        // DBLink methods
        public String getConfigStructureName();
        public void putConfigStructureName(String name);
        public String getLinkSupportName();
        public void putLinkSupportName(String name);
        public DBStructure getConfigStructure();
        public void putConfigStructure(DBStructure dbStructure);
        public LinkSupport getLinkSupport();
        public boolean setLinkSupport(LinkSupport support);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB6"><a id="AbstractDBArray"></a>AbstractDBArray</h3>

<p>Abstract base class for an array field.</p>
<pre>    public abstract class AbstractDBArray
    extends AbstractDBData implements DBArray
    {
        protected AbstractDBArray(DBStructure parent,DBDArrayField dbdArrayField);
        // PVArray methods
        public boolean isCapacityMutable();
        abstract public int getCapacity();
        abstract public int getLength();
        abstract public void setCapacity(int len);
        abstract public void setLength(int len);
    }</pre>

<p>This is probably the most usefull abstract class.</p>
<hr />

<h2 style="text-align: center" id="IOCDB1"><a id="IOCDB"></a> IOCDB: IOC
Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC.</p>
<pre>    public interface IOCDB {
        String getName();
        DBD getDBD();
        DBRecord findRecord(String recordName);
        DBAccess createAccess(String recordName);
        boolean createRecord(String recordName, DBDRecordType dbdRecordType);
        Map&lt;String,DBRecord&gt; getRecordMap();
    }
    
    public class IOCDBFactory {
        public static IOCDB create(DBD dbd, String name);
        public static IOCDB find(String name);
        public static Collection&lt;IOCDB&gt; getIOCDBList();
        public static void remove(IOCDB iocdb);
    }</pre>
<hr />

<h2 style="text-align: center" id="Database1"><a id="DatabaseAccess"></a>IOC
Database Access</h2>
<hr />
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    public interface DBAccess {
        DBRecord getDbRecord();
        AccessSetResult setField(String name);
        String getOtherRecord();
        String getOtherField();
        void setField(DBData dbData);
        DBData getField();
        DBData getPropertyField(Property property);
        DBData getPropertyField(String propertyName);
        void replaceField(DBData oldField, DBData newField);
    }</pre>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes AbstractDBData and AbstractDBRecord provide support for
implementing database monitors, i.e. support for notifying a client whenever
a field of a database instance changes value.</p>

<p>A client must implement the interface:</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
    }</pre>

<p>A client can listen to an arbitrary number of fields in a record. It must
first obtain a Listen interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    Listener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbData.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy.
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>   class TestListener implements DBListener{
        private Listener listener;
        private String recordName;
        private String field = null;
        private boolean synchronousData = false;

        TestListener(IOCDB iocdb,String recordName,String field) {
            this.recordName = recordName;
            this.field = field;
            DBAccess dbAccess = iocdb.createAccess(recordName);
            if(dbAccess==null) {
                System.out.printf("record %s not found\n",recordName);
                return;
            }
            DBData dbData;
            if(dbAccess.setField(field)!=AccessSetResult.thisRecord){
                System.out.printf("name %s not in record %s\n",field,recordName);
                return;
            }
            dbData = dbAccess.getField();
            listener = dbData.getRecord().createListener(this);
            dbData.addListener(listener);
            if(dbData.getField().getType()!=Type.pvStructure) {
                Property[] property = dbData.getField().getPropertys();
                for(Property prop : property) {
                    dbData = dbAccess.getPropertyField(prop);
                    dbData.addListener(listener);
                }
            }
        }

        public void beginSynchronous() {
            synchronousData = true;
        }

        public void endSynchronous() {
            synchronousData = false;
        }

        public void newData(DBData dbData) {
            System.out.printf(" actualField %s value %s\n",
                dbData.getField().getName(), dbData.toString());
            System.out.printf("TestListener recordName %s is Synchronous %b"
                    + " field %s",
                recordName,
                synchronousData,
                field);
            String dbDataName = dbData.getField().getName();
            DBData parent = dbData.getParent();
            while(parent!=dbData.getRecord()) {
                dbDataName = parent.getField().getName() + "." + dbDataName;
                parent = parent.getParent();
            }
            String value = dbData.toString();
            System.out.printf("    dbDataName %s value %s\n",
                dbDataName,value);
        }
    }
</pre>

<p>In order for the listen support to work any support that implements the
DBRecord interface must extend AbstractDBRecord and an support that
implements any other DB field interface must extend AbstractDBdata. In
addition any code that implements a put methods must call</p>
<pre>    postPut();</pre>

<p>whenever the put method is called. It must call postPut whenever if
modifies its internal data for the field. Note that it must call postPut even
if the new value is the same as the old value.</p>
</body>
</html>
