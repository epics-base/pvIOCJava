<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIoc: Database Access</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Access <br />
package: org.epics.ioc.dbAcess <br />
2006.08.07</h1>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Record">Record Instance Syntax</a>
    <ul>
      <li><a href="#Configure">configure</a></li>
      <li><a href="#Primitive">Primitive Types</a></li>
      <li><a href="#string">string</a></li>
      <li><a href="#structure">structure</a></li>
      <li><a href="#array">array</a></li>
      <li><a href="#menu">menu</a></li>
      <li><a href="#enumerated">enumerated</a></li>
      <li><a href="#link">link</a></li>
    </ul>
  </li>
  <li><a href="#Database">XML to Database Converter</a></li>
  <li><a href="#Record1">Record Instance Access</a>
    <ul>
      <li><a href="#Listener">Listener Interface</a></li>
      <li><a href="#Base">Base Interface for accessing data</a></li>
      <li><a href="#Scalar">Scalar and String Data</a></li>
      <li><a href="#Enumerated">Enumerated Data</a></li>
      <li><a href="#Menu">Menu Data</a></li>
      <li><a href="#Structure">Structure Data</a></li>
      <li><a href="#RecordData1">RecordData</a></li>
      <li><a href="#Link">Link Data</a></li>
      <li><a href="#Array">Array Data</a></li>
    </ul>
  </li>
  <li><a href="#Factory">Factory for creating Data Fields</a></li>
  <li><a href="#Abstract">Abstract Classes</a>
    <ul>
      <li><a href="#AbstractDB">AbstractDBData</a></li>
      <li><a href="#AbstractDB1">AbstractDBEnum</a></li>
      <li><a href="#AbstractDB2">AbstractDBMenu</a></li>
      <li><a href="#AbstractDB3">AbstractDBStructure</a></li>
      <li><a href="#AbstractDB4">AbstractDBRecord</a></li>
      <li><a href="#AbstractDB5">AbstractDBArray</a></li>
    </ul>
  </li>
  <li><a href="#IOCDB1">IOCDB: IOC Database</a></li>
  <li><a href="#Database1">IOC Database Access</a></li>
  <li><a href="#Listener1">Listener Support</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type. This package describes the database that holds record
instances. The following is discussed:</p>
<ol>
  <li>Record Instance Syntax<br />
    The XML syntax for defining record instances.</li>
  <li>An XML to database converter.<br />
    This takes as input two files: 1) Database Definitions ( menu, structure,
    recordType, linkSupport) and 2) record instance definitions. The files
    are converted from xml and the result placed in an IOC database.</li>
  <li>Record Instance Access<br />
    Interfaces for accessing data in record instances.</li>
  <li>Data Factory<br />
    A factory for creating support for database fields. It can create support
    for all types of fields.</li>
  <li>Abstract Classes<br />
    A set of abstract classes for implementing ths support for database
    fields.</li>
  <li>Listen Support<br />
    A description of the support for monitoring changes to the data in
    database instances fields.</li>
</ol>
<hr />

<h2 style="text-align: center" id="Record"><a id="Instance"></a>Record
Instance Syntax</h2>
<hr />

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p><span style="font-family: courier;">recordName</span> is a string with a
combination of the following characters:</p>
<ul>
  <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; &lt; &gt; [
    ]</span></li>
  <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
</ul>

<p>supportName is the name of support. If not given the supportName specified
in the record type definition is used. In either case a support definition
with the supportName must exist. Package org.epics.ioc.dbProcess provides
support that creates support for each record instance. See that package for
details. If the same record instance appears multiple times then then last
supportName is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<p><span style="font-family: courier;">fieldName</span> must be a name
definied in the record type definition.</p>

<p>Any field can optionally have associated support. If a supportName is
given with a field instance then it overides any support defined in the
record type field definition. Thus support is only used if the record support
for the record instance calls the support methods. If a field is initialized
multiple times than the last supportName definition determines the
support.</p>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h4 id="Configure"><a id="configure"></a>Primitive Types</h4>

<p>If a supportName is defined for a record instance of for a field on a
record instance and the support definition specifies a configuration
structure then a configure XML element can be used to initialize the fields
of the configuration structure. This configure element MUST appear
immediately after the record instance or field instance definition.</p>

<p>For example assume the following Database Definitions:</p>
<pre>    &lt;structure name = "dummy"&gt;
        &lt;field name = "xxx" type = "string" /&gt;
        &lt;field name = "yyy" type = "int" /&gt;
    &lt;/structure&gt;
    
    
    &lt;support name = "exampleSupport" configurationStructureName = "dummy"
        factoryName = "org.epics.ioc.support.Dummy" /&gt;</pre>

<p>Then an instance of field link can be initialized as follows:</p>
<pre> &lt;value supportName = "exampleSupport"&gt;
        &lt;configure structureName = "dummy"&gt;
            &lt;xxx&gt;xxxxxx&lt;/xxx&gt;
            &lt;yyy&gt;5&lt;/yyy&gt;
        &lt;/configure&gt;
        This is a string
    &lt;/value&gt;</pre>

<p>This example was for a field that has type string but similar definitions
can be given for any field that has associated support.</p>

<p>If the support is for a structure field then the configuration must be
given before any fields of the structure. If the support is for a record
type, the configuration must be given before any fields of the record
instance.</p>

<h4 id="Primitive"><a id="FieldPrimitive"></a>Primitive Types</h4>

<p>For primitive types the initializer has the same format as the Java
constants for the type. For example if the type for field value is double:</p>
<pre>    &lt;value supportName = "supportNAme" &gt;.98&lt;/value&gt;</pre>
Notes:
<ul>
  <li>supportName is optional</li>
  <li>Byte.decode, Short.decode, Integer.decide, and Long.decode are used to
    convert a string to an integer data type. Thus hex values are allowed but
    the sign bit MUST not be set. This for byte data 0xff is not allowed but
    -0x01 is allowed. Note for example that the byte value -128 can not be
    specified in hex.</li>
</ul>

<h4 id="string"><a id="FieldString"></a>string</h4>

<p>For string types the initializer is a valid Java string constant. For
example:</p>
<pre>    &lt;units&gt;voltage&lt;/units&gt;</pre>

<h4 id="structure"><a id="FieldStructure"></a>structure</h4>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure and recordType definitions:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low"&gt;&lt;double/&gt;&lt;/field&gt;
        &lt;field name = "high"&gt;&lt;double /&gt;&lt;/field&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "ai"&gt;
   ...
       &lt;field name = "displayLimit&gt;
            &lt;structure name = "displayLimit" /&gt;
       &lt;field/&gt;
   ...</pre>

<p>displayLimit is initilized as follows:.</p>
<pre>    &lt;displayLimit&gt;
         &lt;low&gt;0.0&lt;/low&gt;
         &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;</pre>

<p>Note that supportName can optionally be defined</p>

<p>It is permissible to define a field to be a structure without providing a
structure name. In this case the structureName must be provided when the
field is being created. The syntax is:</p>
<pre>    &lt;fieldName structureName = "structureName" &gt;</pre>

<h4 id="array"><a id="FieldArray"></a>array</h4>
The syntax for an array initializer is:
<pre>    &lt;fieldName capacity = "capacity" supportName = "supportName" &gt;
        &lt;value offset = "offset"&gt;value&lt;/value&gt;
        &lt;value offset = "offset"&gt;valueList&lt;/value&gt;
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>offset for the next value. If not specified it starts at 0 and is
      incremented by one as each new value is defined.</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>assigns a value to the array. If the array is an array of structures
      then the value is actually a set of field definitions. If the array is
      an array of array the value is another array initialization.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values. This is
      only supported for primitive and string types.</dd>
</dl>

<p>Assume the following are part of a recordType definition:</p>
<pre>    &lt;field name = "intArray"&gt;
        &lt;array&gt;
            &lt;type&gt;&lt;int /&gt;&lt;/type&gt;
        &lt;/array&gt;
    &lt;/field&gt;
    &lt;field name = "structArray"&gt;
        &lt;type&gt;
            &lt;array&gt;
                &lt;structure name = "DisplayLimit /&gt;
            &lt;/array&gt;
        &lt;/type&gt;
    &lt;/field&gt;</pre>

<p>Then the following all perform the same initialization:</p>
<pre>    &lt;intArray capacity = "3" &gt;
        &lt;value&gt;0.0, 1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray capacity = "3" offset = "1"&gt;
        &lt;value&gt;1.0, 2.0&lt;/value&gt;
    &lt;/intArray&gt;
    &lt;intArray&gt;
        &lt;value&gt;0.0&lt;/value&gt;
        &lt;value&gt;1.0&lt;/value&gt;
        &lt;value&gt;2.0&lt;/value&gt;
    &lt;/intArray&gt;
         </pre>

<p>The following initializes a <span
style="font-family: courier;">structArray</span></p>
<pre>    &lt;structArray capacity = "2"&gt;
        &lt;value&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
        &lt;value&gt;
            &lt;low&gt;-10.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/value&gt;
    &lt;/structArray&gt;</pre>

<h4 id="menu"><a id="FieldMenu"></a>menu</h4>

<p>A menu field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;stringValue&lt;/fieldName&gt;</pre>
where stringValue is one of the allowed values for the menu.

<p>For example:</p>
<pre>    &lt;scan&gt;periodic&lt;/scan&gt;</pre>

<p>Again supportName is optional.</p>

<h4 id="enumerated"><a id="FieldEnumerated"></a>enumerated</h4>

<p>An enumerated field is initialized as follows:</p>
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;choice&gt;choice&lt;/choice&gt;
        stringValue
        ...
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>Optional support</dd>
  <dt style="font-family: courier;">choice</dt>
    <dd>A choice string. One of these must be specified for each choice.</dd>
  <dt style="font-family: courier;">stringValue</dt>
    <dd>one of the allowed values for the enum.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;enumExample&gt;
         &lt;choice&gt;zeroState&lt;/choice&gt;
         &lt;choics&gt;oneState&lt;/choice&gt;
         oneState
    &lt;/enumExample&gt;</pre>

<h4 id="link"><a id="FieldLink"></a>link</h4>
A link field is initialized as follows:
<pre>    &lt;fieldName supportName = "supportName" &gt;
        &lt;configure structureName = "supportStructureName"&gt;
            &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
            ...
        &lt;/configure&gt;
    &lt;/fieldName&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of one of the <span
      style="font-family: courier;">support</span> definitions</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of the support structure given with the support
    definition</dd>
  <dt style="font-family: courier;">fieldValue</dt>
    <dd>The value for the structure field.<br />
    </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Database"><a id="XMLToDB"></a>XML to
Database Converter</h2>
<hr />

<p>The following reads an xml file containing record instance definitions and
puts them into an IOCDB.</p>
<pre>    public class XMLToIOCDBFactory {
        public static void convert(DBD dbdin, IOCDB iocdbin, String fileName);
    }</pre>
<hr />

<h2 style="text-align: center" id="Record1"><a
id="RecordInstanceAccess"></a>Record Instance Access</h2>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc.</p>

<h3 id="Listener">Listener Interface</h3>

<h4>DBListener</h4>

<p>DBListener is an interface that must be implemented by code that calls
DBdata.addListener, which is a request to be notified whenever a field
changes value. A request can be made for any field including structure fields
or even a record instance. If the request is made for a structure field then
the requester will be notified whenever any field of the structure changes
value.</p>

<p>DBListener has the definition:</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
        void unlisten(RecordListener listener);
    }</pre>
where
<dl>
  <dt style="font-family: courier;">newData</dt>
    <dd>The new data value. This is always an elementary field, i.e. not a
      structure.</dd>
  <dt style="font-family: courier;">beginSynchronous</dt>
    <dd>This is called before a set of synchronous data modifications. It is
      followed by an arbitrary number calls to newData and finally a call to
      endSynchronous</dd>
  <dt style="font-family: courier;">endSynchronous</dt>
    <dd>End of synchronous data</dd>
  <dt style="font-family: courier;">unlisten</dt>
    <dd>The data source is undergoing destruction or major structural
      changes. The DBData.addListener call is no longer valid and the user
      should null the object reference returned by addListener.</dd>
</dl>

<p>Assume that a field named value has properties status and severity. Then
when the record is processed and field value is written then the following
calls might occur:</p>
<ul>
  <li>beginSynchronous</li>
  <li>newData for value</li>
  <li>newData for status</li>
  <li>newData for severity</li>
  <li>endSynchronous</li>
</ul>

<h4>RecordListener</h4>

<p>RecordListener is an interface that is implemented by the code that
implements DBRecord. This is normally class AbstractDBRecord. DBRecord
provides a method to create a RecordListener. See class FieldDataFactory and
AbstractDBRecord for details. The definition of RecordListener is:</p>
<pre>    public interface RecordListener {
        void newData(DBData dbData);
    }</pre>

<h3 id="Base"><a id="DBData"></a>Base Interface for accessing data</h3>

<p>The following is the base interface for accessing a field of a record
instance.</p>
<pre>    public interface DBData extends PVData {
        DBDField getDBDField();
        DBStructure getParent();
        DBRecord getRecord();
        void addListener(RecordListener listener);
        void removeListener(RecordListener listener);
        void postPut();
        void postPut(DBData dbData);
        DBStructure getConfigurationStructure();
        Support getSupport();
        void setSupport(Support support);
    }</pre>

<p>Since it extends PVData it also has the methods:</p>
<pre>        Field getField();
        String getSupportName();
        String setSupportName(String name);
        PVStructure getConfigurationStructure();
        String toString();
        String toString(int indentLevel);</pre>

<p>AbstractDBData implements all of the DBData methods. The methods are:</p>
<dl>
  <dt style="font-family: courier;">getField</dt>
    <dd>Get the Field introspection interface.</dd>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the name of the support for the field. If no support has been
      specified null is returned.</dd>
  <dt style="font-family: courier;">setSupportName</dt>
    <dd>Set the support name. This is called by the XML parser.</dd>
  <dt style="font-family: courier;">getConfigurationStructure</dt>
    <dd>Get the configuration structure interface. In no configuration
      structure is associated with the field then null is returned. The
      caller can ask for either a PVStructure or a DBStructure.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>This is for debugging. It dumps the contents of the field.
      AbstractDBData shows the supportName of it has been defined and the
      contents of the configuration structure if it exists. Any code that
      extents DBData should append super.toString(level) to any output it
      generates.</dd>
  <dt style="font-family: courier;">getDBDField</dt>
    <dd>Get the DBDField introspection interface</dd>
  <dt style="font-family: courier;">getParent</dt>
    <dd>Get the interface for the parent of this field</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the interface of the record instance that has this field.</dd>
  <dt style="font-family: courier;">addListener</dt>
    <dd>Add a record listener. This is normally only called by code that
      wants to be notified of any data updates. The caller must first create
      a RecordListener by calling DBRecord.createListener.</dd>
  <dt style="font-family: courier;">removelistener</dt>
    <dd>Remove a listener.</dd>
  <dt style="font-family: courier;">postPut()</dt>
    <dd>This is called by the code that implements the put method for a
      DBData instance. It is implemented by AbstractDBData.</dd>
  <dt style="font-family: courier;">postPut(DBData dbdata)</dt>
    <dd>This is called AbstractDBData whenever the field or any subfield of a
      field changes value. It is implemented and called by
    ABStractDBData.</dd>
  <dt style="font-family: courier;">getConfigurationStructure</dt>
    <dd>Get the configuration structure or null if no configuration exists
      for the field instance. A value is determined when setSupportName is
      called.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the support or return null if no support exists for the
    field.</dd>
  <dt style="font-family: courier;">setSupport</dt>
    <dd>Set the support for the field.</dd>
</dl>

<p>Field is the introspection interface for pvAccess Types. DBDField is the
introspection interface for DBTypes.</p>

<h3 id="Scalar"><a id="DBPVData"></a>Scalar and String Data</h3>
The following are the data interfaces for fields that have a pvAccess Type.
<pre>    public interface DBBoolean extends DBData, PVBoolean{}
    public interface DBByte extends DBData, PVByte{}
    public interface DBShort extends DBData, PVShort{}
    public interface DBInt extends DBData, PVInt{}
    public interface DBLong extends DBData, PVLong{}
    public interface DBFloat extends DBData, PVFloat{}
    public interface DBDouble extends DBData, PVDouble{}
    public interface DBString extends DBData, PVString{}</pre>
Since each interface implements a PV data interface it has get/put methods to
get and put data values.

<p>The following example shows how a double field can be read.</p>
<pre>     double getValue(DBData db) {
        Type type = db.getField().getType();
        if(type != Type.pvDouble) throw new IllegaStateException("not double");
        PVDouble data = (PVDouble)db;
        return data.get();
    }</pre>

<p>The following accomplishes the same but an exception will be thrown if the
DBData is not a PVDouble:</p>
<pre>     double getValue(DBData db) {
        PVDouble data = (PVDouble)db; // exception may be thrown
        return data.get();
    }</pre>

<h3 id="Enumerated"><a id="EnumData"></a>Enumerated Data</h3>
An enumerated field is accessed via the interface
<pre>    public interface DBEnum extends DBData, PVEnum{}</pre>

<h3 id="Menu"><a id="MenuData"></a>Menu Data</h3>
A menu field is accessed via the interface:
<pre>    public interface DBMenu extends DBData, DBEnum {
        String getMenuName();
    }</pre>

<p>The following shows how to access a menu field:</p>
<pre>    void dumpMenuField(DBMenu menu) {
        String[] choice = menu.getChoices();
        int index = menu.getIndex();
        printf("field %s is menu %s. Value is %d %s\n",
            menu.getField().getName(),menu.getMenuName(),
            menu.getIndex(),choice[index]);
    }</pre>

<h3 id="Structure"><a id="StructureData"></a>Structure Data</h3>
<pre>    public interface DBStructure extends DBData, PVStructure {
         boolean createFields(DBDStructure dbdStructure);
         DBDStructure getDBDStructure();
         DBData[] getFieldDBDatas();
         int getFieldDBDataIndex(String fieldName);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createFields</dt>
    <dd>If the database definition for the field did not specify a
      structureName than when a field is being created this must be called to
      associate a structure with the field.</dd>
  <dt style="font-family: courier;">getDBDStructure</dt>
    <dd>This returns the DBDStructure for the field, i.e. the interface that
      describes the structure.</dd>
  <dt style="font-family: courier;">getFieldDBDatas</dt>
    <dd>Get the array of interfaces for the fields of the structure
    instance.</dd>
  <dt style="font-family: courier;">getFieldDBDataIndex</dt>
    <dd>Get the index into DBData for the specified field.</dd>
</dl>

<h3 id="RecordData1"><a id="RecordData"></a>RecordData</h3>
<pre>    public interface RecordStateListener {
        void newState(RecordState newState);
    }

    public interface DBRecord extends DBStructure {
        String getRecordName();
        RecordState getRecordState();
        void setRecordState(RecordState state);
        void addRecordStateListener(RecordStateListener listener);
        void removeRecordStateListener(RecordStateListener listener);
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginSynchronous();
        void endSynchronous();
        RecordListener createListener(DBListener listener);
        void removeListener(RecordListener listener);
        void removeListeners();
        void addListenerSource(AbstractDBData dbData);
        DBD getDBD();
        void setDBD(DBD dbd);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getRecordName</dt>
    <dd>Get the name of the record intsance.</dd>
  <dt style="font-family: courier;">getRecordState</dt>
    <dd>Get the state of record processing.</dd>
  <dt style="font-family: courier;">setRecordState</dt>
    <dd>Set the state of record processing. This is called by
    RecordProcess.</dd>
  <dt style="font-family: courier;">addRecordStateListener</dt>
    <dd>Add a listener to call wheneven the state of record processing
      changes.</dd>
  <dt style="font-family: courier;">removeRecordStateListener</dt>
    <dd>Remove a record state listener.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the record. The record must be locked for record processing and
      whenever the data of any field in a record is accessed.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the record.</dd>
  <dt style="font-family: courier;">lockOtherRecord</dt>
    <dd>While holding the lock for this record lock another record. The lock
      for the cxurrent record might be unlocked while this call is active but
      upon retirn both record will be locked. The caller must unlock both
      records when the caller is done. Noremally it unlocks the other record,
      via it's unlock method, first.</dd>
  <dt style="font-family: courier;">getRecordProcess</dt>
    <dd>Get the interface of the RecordProcess for this instance.</dd>
  <dt style="font-family: courier;">setRecordProcess</dt>
    <dd>Set the RecordProcess inyerface for this record instance.</dd>
  <dt style="font-family: courier;">getRecordID</dt>
    <dd>Normally only called by AbstractDBRecord.lock. Each record instance
      is assigned a unique id.</dd>
  <dt style="font-family: courier;">beginSynchronous</dt>
    <dd>Called by record processing when a set of synchronous puts is
    started.</dd>
  <dt style="font-family: courier;">endSynchronous</dt>
    <dd>End of a set of synchronous puts.</dd>
  <dt style="font-family: courier;">createListener</dt>
    <dd>Create a RecordListener than can be used to call
    DBData.addListener.</dd>
  <dt style="font-family: courier;">removeListener</dt>
    <dd>Remove a listener. This also calls DBData.removeListener.</dd>
  <dt style="font-family: courier;">removeListeners</dt>
    <dd>Remove all listeners. This is called if a record insance is being
      removed or if it's structure is being changed.</dd>
  <dt style="font-family: courier;">addListenerSource</dt>
    <dd>Add a listener source. Used for communication between
      AbstractDBRecord and AbstractDBData. AbstractDBData calls this the
      first time DBData.addListener is called. It should not be called by
      other code.</dd>
  <dt style="font-family: courier;">getDBD</dt>
    <dd>Get the DBD that holds this record instance.</dd>
  <dt style="font-family: courier;">setDBD</dt>
    <dd>Set the DBD that holds this record instance.</dd>
    <dd></dd>
</dl>

<h3 id="Link1">Link Data</h3>
<pre>    public interface DBLink extends DBData {}</pre>

<p>A DBLink is a link to external support. It has no data other than
configuration data.</p>

<h3 id="Array">Array Data</h3>

<p>The base interface for array fields is:</p>
<pre>    public interface DBArray extends DBData, PVArray {
        DBType getElementDBType();
    }</pre>

<p></p>

<p>The following are the interfaces for each of the array types:</p>
<pre>    public interface DBBooleanArray extends DBArray, PVBooleanArray{}
    public interface DBByteArray extends DBArray, PVByteArray{}
    public interface DBShortArray extends DBArray, PVShortArray{}
    public interface DBIntArray extends DBArray, PVIntArray{}
    public interface DBLongArray extends DBArray, PVLongArray{}
    public interface DBFloatArray extends DBArray, PVFloatArray{}
    public interface DBDoubleArray extends DBArray, PVDoubleArray{}
    public interface DBStringArray extends DBArray, PVStringArray{}
    public interface DBEnumArray extends DBArray, PVEnumArray{}

    public class MenuArrayData {
        public DBMenu[] data;
        public int offset;
    }
    public interface DBMenuArray extends DBArray{
        int get(int offset, int len, MenuArrayData data);
        int put(int offset, int len, DBMenu[]from, int fromOffset);
    }
    
    public class DBStructureArrayData {
        public DBStructure[] data;
        public int offset;
    }
    public interface DBStructureArray extends DBArray{
        int get(int offset, int len, DBStructureArrayData data);
        int put(int offset, int len, DBStructure[]from, int fromOffset);
    }

    public class DBArrayArrayData {
        public DBArray[] data;
        public int offset;
    }
    public interface DBArrayArray extends DBArray{
        int get(int offset, int len, DBArrayArrayData data);
        int put(int offset, int len, DBArray[]from, int fromOffset);
    }

    public class LinkArrayData {
        public DBLink[] data;
        public int offset;
    }
    public interface DBLinkArray extends DBArray{
        int get(int offset, int len, LinkArrayData data);
        int put(int offset, int len, DBLink[]from, int fromOffset);
    }</pre>

<p>The array interfaces are an extension of the pvAccess array interfaces.
See pvAccess for details about how arrays are supported.</p>
<hr />

<h2 style="text-align: center" id="Factory"><a
id="FieldDataFactory"></a>Factory for creating Data Fields</h2>
<hr />

<p>A factory is available that implements the interfaces for record instance
fields. The methods are called by XMLToIOCDBFactory when it is reading
instance definitions.</p>
<pre>    public class FieldDataFactory {
        public static DBData createData(DBStructure parent,
            DDBDField dbdField);
        public static DBData createEnumData(DBStructure parent,
            DDBDField dbdField, String[] choice);
        public static DBArray createArrayData(DBStructure parent,
            DDBDField dbdField, int capacity,boolean capacityMutable);
        public static DBRecord createRecord(String recordName,
             DBDRecordType dbdRecordType);
    }</pre>
where
<dl>
  <dt style="font-family: courier;">createData</dt>
    <dd>Creates an instance of any type of field except enum, array fields,
      or a record instance itself.</dd>
  <dt style="font-family: courier;">createEnumData</dt>
    <dd>Create an enum field instance.</dd>
  <dt style="font-family: courier;">createArrayData</dt>
    <dd>Create an array field instance.</dd>
  <dt style="font-family: courier;">createRecord</dt>
    <dd>Create a record instance.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Abstract"><a
id="AbstractClasses"></a>Abstract Classes</h2>
<hr />

<p>This section describes abstract classes for implementing the data
interface for database fields. These classes are used by FieldDataFactory and
can also be used by code that wants to provide special implementations of
database fields.</p>

<h3 id="AbstractDB"><a id="AbstractDBData"></a>AbstractDBData</h3>

<p>Abstract base class for a scalar field.</p>
<pre>    public abstract class AbstractDBData implements DBData{
        public Field getField();
        public String getSupportName();
        public String setSupportName(String name);
        public String toString();
        public String toString(int indentLevel);
        // DBData methods
        public DBDField getDBDField();
        public DBStructure getParent();
        public DBRecord getRecord();
        public Support getSupport();
        public void setSupport(Support support);
        public DBStructure getConfigurationStructure();
        public void addListener(Listener listener);
        public void removeListener(Listener listener);
        public void postPut();
        public void postPut(DBData dbData);
        // convenience method for derived classes
        protected static void newLine(StringBuilder builder, int indentLevel);
        // constructor
        protected AbstractDBData(DBStructure parent, DBDField dbdField);
        // must be called by derived class 
        protected void setRecord(DBRecord record);
    }</pre>

<h3 id="AbstractDB1"><a id="AbstractDBEnum"></a>AbstractDBEnum</h3>

<p>Abstract base class for an enumerated field.</p>
<pre>    public abstract class AbstractDBEnum extends AbstractDBData implements DBEnum {
        protected AbstractDBEnum(DBStructure parent,
            DBDEnumField dbdEnumField, String[]choice);
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB2"><a id="AbstractDBMenu"></a>AbstractDBMenu</h3>

<p>Abstract base class for a menu field.</p>
<pre>    public abstract class AbstractDBMenu extends AbstractDBData implements DBMenu
    {
        protected AbstractDBMenu(DBStructure parent, DBDMenuField dbdMenuField);
        // DBMenu methods
        public String getMenuName();
        // PVEnum methods
        public int getIndex();
        public void setIndex(int index);
        public String[] getChoices();
        public boolean setChoices(String[] choice);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB3"><a id="AbstractDBStructure"></a>AbstractDBStructure</h3>

<p>Abstract base class for a structure field.</p>
<pre>    public abstract class AbstractDBStructure extends AbstractDBData
    implements DBStructure
    {
        // constructor for structure fields
        protected AbstractDBStructure(DBStructure parent, DBDStructureField dbdStructureField);
        // constructor for record instances
        protected AbstractDBStructure(DBDRecordType dbdRecordType));
        // called by record instance constructor
        protected void createFields(DBRecord record);
        public PVData[] getFieldPVDatas();
        public boolean createFields(DBDStructure dbdStructure);
        public DBDStructure getDBDStructure();
        public DBData[] getFieldDBDatas();
        public int getFieldDBDataIndex(String fieldName);
        public String toString();
        public String toString(int indentLevel);
        public String toString(String prefix,int indentLevel)
    }</pre>

<h3 id="AbstractDB4"><a id="AbstractDBRecord"></a>AbstractDBRecord</h3>

<p>Abstract base class for a record instance.</p>
<pre>    public class AbstractDBRecord extends AbstractDBStructure implements DBRecord {
        protected AbstractDBRecord(String recordName, DBDRecordType dbdRecordType);
        // DBRecord methods
        public String getRecordName();
        public RecordState getRecordState();
        public void setRecordState(RecordState state);
        public void addRecordStateListener(RecordStateListener listener);
        public void removeRecordStateListener(RecordStateListener listener);
        public void lock();
        public void unlock();
        public void lockOtherRecord(DBRecord otherRecord);
        public RecordProcess getRecordProcess();
        public boolean setRecordProcess(RecordProcess recordProcess);
        public RecordSupport getRecordSupport();
        public boolean setRecordSupport(RecordSupport support);
        public int getRecordID();
        public void beginSynchronous();
        public void endSynchronous();
        Listener createListener(DBListener listener);
        void removeListener(Listener listener);
        public void removeListeners();
        public void addListenerSource(AbstractDBData dbData);
        public DBD getDBD();
        public void setDBD(DBD dbd);
        // DBData methods
        public String toString();
        public String toString(int indentLevel);
    }</pre>

<h3 id="AbstractDB5"><a id="AbstractDBArray"></a>AbstractDBArray</h3>

<p>Abstract base class for an array field.</p>
<pre>    public abstract class AbstractDBArray
    extends AbstractDBData implements DBArray
    {
        protected AbstractDBArray(DBStructure parent,DBDArrayField dbdArrayField);
        // PVArray methods
        public boolean isCapacityMutable();
        public DBType getElementDBType() ();
        abstract public int getCapacity();
        abstract public int getLength();
        abstract public void setCapacity(int len);
        abstract public void setLength(int len);
    }</pre>

<p>This is probably the most usefull abstract class.</p>
<hr />

<h2 style="text-align: center" id="IOCDB1"><a id="IOCDB"></a> IOCDB: IOC
Database</h2>
<hr />

<p>An IOCDB is a database for a java IOC.</p>
<pre>    public interface IOCDB {
        String getName();
        DBD getDBD();
        DBRecord findRecord(String recordName);
        DBAccess createAccess(String recordName);
        boolean createRecord(String recordName, DBDRecordType dbdRecordType);
        Map&lt;String,DBRecord&gt; getRecordMap();
    }
    
    public class IOCDBFactory {
        public static IOCDB create(DBD dbd, String name);
        public static IOCDB find(String name);
        public static Collection&lt;IOCDB&gt; getIOCDBList();
        public static void remove(IOCDB iocdb);
    }</pre>
<hr />

<h2 style="text-align: center" id="Database1"><a id="DatabaseAccess"></a>IOC
Database Access</h2>
<hr />
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    public interface DBAccess {
        DBRecord getDbRecord();
        AccessSetResult setField(String name);
        String getOtherRecord();
        String getOtherField();
        void setField(DBData dbData);
        DBData getField();
        DBData getPropertyField(Property property);
        DBData getPropertyField(String propertyName);
        void replaceField(DBData oldField, DBData newField);
    }</pre>
<hr />

<h2 style="text-align: center" id="Listener1">Listener Support</h2>
<hr />

<p>The classes AbstractDBData and AbstractDBRecord provide support for
implementing database monitors, i.e. support for notifying a client whenever
a field of a database instance changes value.</p>

<p>A client must implement the interface:</p>
<pre>    public interface DBListener {
        void newData(DBData dbData);
        void beginSynchronous();
        void endSynchronous();
    }</pre>

<p>A client can listen to an arbitrary number of fields in a record. It must
first obtain a Listen interface by calling dbRecord..createListener:</p>
<pre>    DBRecord dbRecord;
    ...
    Listener listener = dbRecord.createListener(this);</pre>

<p>and then, for each field it wants to monitor makes the call:</p>
<pre>    dbData.addListener(listener);</pre>

<p>The support provides the following features:</p>
<ul>
  <li>The client can ask to listen at any level of a record instance
    hierarchy.
    <p>For example the client could ask to listen for changes to a scalar
    field or a field that is an array with the element type being a scalar.
    In this case the client will be called whenever the put methods of the
    field is called.</p>
    <p>The client can also ask to listen to a structure field. In this case
    the client is called whenever any field of the structure changes value.
    Note that a separate call will be made for each "elementary" field that
    has a change, where an elmentary filed is a field that has an associated
    put method.</p>
    <p>Since a record instance is an extension of a structure instance, the
    client can ask to listen for any changes to an field of a record
    instance.</p>
  </li>
  <li>Support is provided for synchronous puts, i.e. a set of fields that are
    modified at the same time. The primary user of this facility is record
    processing but other support could implement synchronous puts.</li>
</ul>

<p>The following is sample code that listens for all changes to a field and
all properties of the field.</p>
<pre>   class TestListener implements DBListener{
        private Listener listener;
        private String recordName;
        private String field = null;
        private boolean synchronousData = false;

        TestListener(IOCDB iocdb,String recordName,String field) {
            this.recordName = recordName;
            this.field = field;
            DBAccess dbAccess = iocdb.createAccess(recordName);
            if(dbAccess==null) {
                System.out.printf("record %s not found\n",recordName);
                return;
            }
            DBData dbData;
            if(dbAccess.setField(field)!=AccessSetResult.thisRecord){
                System.out.printf("name %s not in record %s\n",field,recordName);
                return;
            }
            dbData = dbAccess.getField();
            listener = dbData.getRecord().createListener(this);
            dbData.addListener(listener);
            if(dbData.getField().getType()!=Type.pvStructure) {
                Property[] property = dbData.getField().getPropertys();
                for(Property prop : property) {
                    dbData = dbAccess.getPropertyField(prop);
                    dbData.addListener(listener);
                }
            }
        }

        public void beginSynchronous() {
            synchronousData = true;
        }

        public void endSynchronous() {
            synchronousData = false;
        }

        public void newData(DBData dbData) {
            System.out.printf(" actualField %s value %s\n",
                dbData.getField().getName(), dbData.toString());
            System.out.printf("TestListener recordName %s is Synchronous %b"
                    + " field %s",
                recordName,
                synchronousData,
                field);
            String dbDataName = dbData.getField().getName();
            DBData parent = dbData.getParent();
            while(parent!=dbData.getRecord()) {
                dbDataName = parent.getField().getName() + "." + dbDataName;
                parent = parent.getParent();
            }
            String value = dbData.toString();
            System.out.printf("    dbDataName %s value %s\n",
                dbDataName,value);
        }
    }</pre>

<p>In order for the listen support to work support that implements the
DBRecord interface must extend AbstractDBRecord and support that implements
any other DB field interface must extend AbstractDBdata. In addition any code
that implements a put methods must call</p>
<pre>    postPut();</pre>

<p>whenever the put method is called. It must call postPut whenever if
modifies its internal data for the field. It must call postPut even if the
new value is the same as the old value.</p>
</body>
</html>
