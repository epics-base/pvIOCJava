<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS V4: dbAccess</title>
</head>

<body>
<h1 style="text-align: center">EPICS V4: Database Access <br />
2006.03.09</h1>
<a href="#Overview">Overview</a><br />
<a href="#DBDataTypes">Database Types</a><br />
<a href="#DBDataReflection">Database Definitions</a><br />

<ul>
  <li><a href="#Menu">Menu</a></li>
  <li><a href="#Structure">Structure</a></li>
  <li><a href="#Record">Record Type</a></li>
  <li><a href="#LinkSupport">Link Support</a></li>
  <li><a href="#RecordSupport">Record Support</a></li>
</ul>
<a href="#DBDataAccess">Record Instance Access</a><br />

<ul>
  <li><a href="#PVDataField">Process Variable Fields</a></li>
  <li><a href="#MenuField">Menu Field</a></li>
  <li><a href="#EnumField">Enum Field</a></li>
  <li><a href="#LinkField">Link Field</a></li>
</ul>
<a href="#DBDatabaseAccess">Database Access</a><br />
<a href="#DBRuntime">Runtime Support</a><br />

<ul>
  <li><a href="#RuntimeRecordSupport">Record Support</a></li>
  <li><a href="#RuntimeLinkSupport">Link Support</a></li>
  <li><a href="#RuntimeCALinkSupport">Channel Access Link Support</a></li>
  <li><a href="#RuntimeAsynLinkSupport">AsynDriver Link Support</a></li>
</ul>
<a href="#ProcessSemantics">Record Processing Semantics</a><br />

<ul>
  <li><a href="#ProcessSemanticsOverview">Overview</a></li>
  <li><a href="#ProcessLifetime">Process Lifetime</a></li>
  <li><a href="#Monitors">Posting Monitors</a></li>
  <li><a href="#MutualExclusion">Mutual Exclusion</a></li>
  <li><a href="#AlarmStatusProcessing">Alarm and Status Processing</a></li>
</ul>
<hr />

<h1 style="text-align: center"><a name="Overview"
id="Overview"></a>Overview</h1>
<hr />

<p>This document describes definitions for code that accessses IOC records,
i.e. the records created from Database Definitions: menu, structure, record,
linkSupport, recordSupport, and record instances.</p>

<p>The interfaces support introspection of everything created from Database
Definitions. The interfaces can be used by tools such as VDCT or on a running
IOC database. The interfaces are also used by record support, link support,
and the database itself.</p>

<p>dbAccess builds on pvAccess, which defines the following types: boolean,
byte, short, int, long, float, double, string, structure, and array. dbAccess
adds the following types menu, enum,and link, which are defined using the
pvAcess types. Thus each can be accessed via pvAccess.</p>

<p>Runtime support consists of record and link support. This is designed to
support the linkSupport and recordSupport Database Definitions.</p>
<hr />

<h1 style="text-align: center"><a id="DBDataTypes"></a>Database Types</h1>
<hr />

<p>The types are defined by:</p>
<pre>    enum DBType {
        dbPVType, // It is a plain PVType
        dbMenu,
        dbEnum,
        dbLink
    }</pre>

<p>The PVType for these are:</p>
<dl>
  <dt style="font-family: courier;">dbMenu</dt>
    <dd>An Enumeration. The choice names will be read only</dd>
  <dt style="font-family: courier;">dbEnum</dt>
    <dd>An Enumeration.</dd>
  <dt style="font-family: courier;">dbLink</dt>
    <dd>In a record type the type is unknown. In a record instance it is a
      structure which depends on the link support attached to a link
    field.</dd>
</dl>

<p>The following provides access to the description of a field of a structure
or recordType</p>
<pre>    interface DBField extends Field {
        DBType getDBType();
    }</pre>

<p>Since DBField extends Field it has the following methods: getName,
getPVType, isConstant, getPropertyNames, getProperty, getProperties, and
getDBType.</p>
<hr />

<h1 style="text-align: center"><a id="DBDataReflection"></a>Database
Definitions</h1>
<hr />

<p>This section describes interfaces for accessing menus, record types,
linkSupport, and recordSupport, i.e. everything defined in Database
Definition files except record instances. Access to record instances is
discussed in the next section. These definitions are mostly of interest to
the database itself.</p>

<h2><a id="Menu"></a>Menu</h2>

<p>The interface is:</p>
<pre>    interface Menu extends PVStructure{
        String getMenuName();
        String[] getChoices();
    }</pre>

<p>For example the following dumps a menu</p>
<pre>    void dumpMenu(Menu menu) {
        String[] choices = menu.getChoices();
        printf("menu %s {\n",menu.getMenuName();
        for(choice: choices) printf("    %s\n",choice);
        printf("}\n");
    }</pre>

<h2><a id="Structure"></a>Structure</h2>

<p>The interface is:</p>
<pre>    interface Structure extends Structure{
        DBField getDBField(String fieldName);
        DBField[] getDBFields();
    }</pre>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(Structure structure) {
        DBField[] fields = structure.getDBFields();
        printf("structure %s {\n",structure.getStructureName();
        for(DBField field : fields) {
            DBType type = field.getDBType();
            PVType pvtype = field.getPVType();
            printf("field %s dbtype %s pvtype %s",
                field.getName(),type.toString(),pvtype.toString());
        }
    }</pre>

<h2><a id="Record"></a>Record Type</h2>

<p>Record is only an introspection interface, i.e. it has no data. The
following is for introspecting a record type.</p>
<pre>    interface RecordType extends Structure{
        DBField getDBField(String fieldName);
        DBField[] getDBFields();
    }</pre>

<p>The meaning of the Structure and Field methods are:</p>
<dl>
  <dt style="font-family: courier;">String getStructureName()</dt>
    <dd>Returns the record type name.</dd>
  <dt style="font-family: courier;">String[] getFieldNames()</dt>
    <dd>Returns the names of the fields in the record type.</dd>
  <dt style="font-family: courier;">Property getField(String fieldName)</dt>
    <dd>Returns the Property for the field.</dd>
  <dt style="font-family: courier;">Property[] getFields()</dt>
    <dd>Returns properties for all fields. For a link field Property.getField
      return null.</dd>
  <dt style="font-family: courier;">String getName()</dt>
    <dd>Returns an empty string.</dd>
  <dt style="font-family: courier;">PVType getPVType()</dt>
    <dd>Returns pvStructure</dd>
  <dt style="font-family: courier;">boolean isConstant()</dt>
    <dd>Returns true</dd>
</dl>

<p>For example the following dumps a record type</p>
<pre>    void dumpRecord(RecordType record) {
        DBField[] fields = record.getDBFields();
        printf("recordType %s {\n",record.getStructureName();
        for(DBField field : fields) {
            DBType type = field.getDBType();
            PVType pvtype = field.getPVType();
            printf("field %s dbtype %s pvtype %s",
                field.getName(),type.toString(),pvtype.toString());
        }
    }</pre>

<h2><a id="LinkSupport"></a>Link Support</h2>

<p>In psuedo code Link support looks like:</p>
<pre>    structure LinkSupport {
        string name;
        string configStructName;
    }</pre>

<p>LinkSupport is a structure with two fields: name which is a string, and
configStructName which is the name of a support dependent structure. The
following convenience interface is provided for accessing link support.</p>
<pre>    interface LinkSupport extends PVStructure{
        String getLinkSupportName();
        String getConfigStructName();
    }</pre>

<h2><a id="RecordSupport"></a>Record Support</h2>

<p>In psuedo code Record Support looks like:</p>
<pre>    structure Arg {
        string name;
        string[] types; // Allowed types for arg
    }

    structure RecordSupport {
        string name;
        string configStructName;
        Arg[] args;
    }</pre>

<p>RecordSupport is a structure with three fields: name which is a string,
support which is a support dependent structure, and args which is an array of
structures of type Arg. Arg is a structure with two fields: name which is a
string and types which is an array of strings specifying the valid types for
the argument. These types must be one of the types as specified in the
databaseSyntax, i.e. boolean, byte, short, int, long, float, double, menu,
enum, link. The type null is also allowed, which means the argument is
optional.</p>

<p>The following convenience interface is provided for accessing record
support.</p>
<pre>    interface RecordSupport extends PVStructure{
        String getRecordSupportName();
        String getConfigStructName();
        String[] getArgNames();
        String[] getArgTypes(String name);
    }</pre>
<hr />

<p>The following is for locating menu, structure, record, linkSupport, and
recordSupport interfaces.</p>
<pre>    interface DatabaseDefinition {
        Menu getMenu(String menuName);
        LinkedList&lt;String&gt; getMenuList();
        Structure getStructure(String structureName);
        LinkedList&lt;String&gt; getStructureList();
        RecordType getRecordType(String recordName);
        LinkedList&lt;String&gt; getRecordTypeList();
        LinkSupport getLinkSupport(String linkSupportName);
        LinkedList&lt;String&gt; getLinkSupportList();
        RecordSupport getRecordSupport(String recordSupportName);
        LinkedList&lt;String&gt; getRecordSupportList();
    }

    public class DatabaseDefinitionFactory {
        public Database getDatabaseDefinition();
    }</pre>

<h1 style="text-align: center"><a id="DBDataAccess"></a>Record Instance
Access</h1>
<hr />

<p>This section describes interfaces for acessing fields of record instances.
These interfaces are of interest to the database, record support, link
support, Channel Access, etc. The following is the base interface for
accessing a field of a record instance.</p>
<pre>    interface DBData extends PVData {
        DBField getDBField();
    }</pre>

<h2><a id="PVDataField"></a>Process Variable Fields</h2>

<p>If a database field has type dbPVType then the field is accessed via a
PVData interface.</p>

<p>The following example shows how a double field can be read.</p>
<pre>     double getValue(DBData db) {
        DBField field = db.getDBField();
        if(field.getDBType != dbPVType) throw new IllegalType;
        if(field.getPVType() != pvDouble) throw new IllegalType;
        PVDouble data = (PVDouble)db;
        return data.get();
    }</pre>

<p>the following accomplishes the same but an exception will be thrown if the
DBData is not a PVDouble:</p>
<pre>     double getValue(DBData db) {
        PVDouble data = (PVDouble)db; // exception may be thrown
        return data.get();
    }</pre>

<h2><a id="MenuField"></a>Menu Field</h2>

<p>A meny field is accessed via interface <span
style="font-family: courier;">Enumerated</span>, which is descrived in
pvAccess. The following shows how to access a menu field:</p>
<pre>    void dumpMenuField(DBData db) {
        DBField field = db.getDBField();
        if(field.getDBType != dbMenu) throw new IllegalType;
        // struct is for reflection
        Structure struct = (Structure)db.getField();
        // menu accesses data
        Enumerated menu = (Enumerated)db;
        int choice = menu.getIndex();
        printf("field %s is menu %s. Value is %d %s\n",
            field.getName(),struct.getStructureName(),
            choice,menu.getChoice(choice));
    }</pre>

<h2><a id="EnumField"></a>Enum Field</h2>

<p>This is also accessed via interface Enumerated.</p>

<h2><a id="LinkField"></a>Link Field</h2>

<p>A psuedo definition for a link field is:</p>
<pre>    structure LinkField {
        structure &lt;some config structure&gt; config;
        string linkSupportName;
        string linkInterfaceType;
    }</pre>

<p>The following can be used to access a link</p>
<pre>    interface DBLink extends PVStructure {
        PVStructure getConfigStruct();
        String getLinkSupportName();
        String getInterfaceTypeName();
    }</pre>
<hr />

<h1 style="text-align: center"><a id="DBDatabaseAccess"></a>Database
Access</h1>
<hr />

<p>The following is for accessing a record instance</p>
<pre>    interface RecordInstance {
        Record getRecord(); // For reflection
        DBData getDBData(String fieldName);
        DBData[] getDBData();
    }</pre>

<p>The following is for locating menu, structure, record, linkSupport,
recordSupport, and recordInstance interfaces.</p>
<pre>    interface Database {
        DatabaseDefinition getDatabaseDefinition();
        RecordInstance getRecordInstance(String name);
        LinkedList&lt;String&gt; getRecordInstanceList();
    }

    abstract public class DatabaseFactory {
        abstract public Database getDatabase();
    }</pre>
<hr />

<h1 style="text-align: center"><a name="DBRuntime" id="DBRuntime"></a>Runtime
Support</h1>
<hr />

<p>This section describes the interfaces implemented by record and link
support.</p>

<h2><a id="RuntimeRecordSupport"></a>Record Support</h2>

<p>Every record support module implements the following interface:</p>
<pre>    interface Callback {
        void done();
        void failure(String reason);
    }

    enum ProcessState {
        idle,
        cancel,
        start,
        continue,
        finish
    }

    enum ProcessReturn {
        noop,
        done,
        abort,
        active
    }

    interface RecordSupport {
        void destroy();
        void initialize(int16 pass);
        ProcessReturn process(ProcessState state,Callback done);
    }

    interface RecordSupportFactory {
        RecordSupport create(RecordInstance recordInstance,
             PVStructure config, DB[] field);
    }</pre>

<p>Callback has the following methods:</p>
<dl>
  <dt style="font-family: courier;">done</dt>
    <dd>The requested process has completed successfully</dd>
  <dt style="font-family: courier;">failure</dt>
    <dd>The requested process has failed.</dd>
</dl>

<p>ProcessState has the following states:</p>
<dl>
  <dt style="font-family: courier;">idle</dt>
    <dd>This is the state when a record is not being processed. Record
      support will vever be called with this state.</dd>
  <dt style="font-family: courier;">cancel</dt>
    <dd>Cancel any outstanding activity.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start processing</dd>
  <dt style="font-family: courier;">active</dt>
    <dd>Continue processing. Record support is called with this state only
      when it is already active, i.e. it returned active the last time it was
      called.</dd>
</dl>

<p>Record Support must implement the following methods:</p>
<dl>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Clean up and go away.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>This gets called twice at record instance initialization. The first
      time record support should do all initialization that does not involve
      links to other records. During the second call, it can link to other
      records.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process. What it does depends on state. It can return:
      <dl>
        <dt style="font-family: courier;">noop</dt>
          <dd>The record support has done nothing. For example link support
            will return noop if the link is null.</dd>
        <dt><span style="font-family: courier;">done</span></dt>
          <dd>The record support has completed successfully.</dd>
        <dt><span style="font-family: courier;">abort</span></dt>
          <dd>Returning abort means no further record support should be
            called. This is not necessarily an error. For example the record
            might be disabled.</dd>
        <dt><span style="font-family: courier;">active.</span></dt>
          <dd>Returning active says the the process request is active. When
            it completes callback will be called. Record support may be
            called repeatedly while it is active with state continue. It
            willEU cops to get Europe-wideEU cops to get Europe-wideEU cops
            to get Europe-wideEU cops to get Europe-wideEU cops to get
            Europe-wideEU cops to get Europe-wide be called again after it
            calls callback.done().</dd>
      </dl>
    </dd>
</dl>

<p>Each record support module must implement RecordSupportFactory, which is
called to create a new instance of RecordSupport. It is passed two
arguments:</p>
<dl>
  <dt>recordInstance</dt>
    <dd>The record instance being created.</dd>
  <dt style="font-family: courier;">config</dt>
    <dd>The structure containing configuration informatio.</dd>
  <dt>field</dt>
    <dd>An array of DBData. There is an element for each of the argument
      names specified in the recordSupport definition. A null value means
      that argument has no associated field.</dd>
</dl>

<h2><a id="RuntimeLinkSupport"></a>Link Support</h2>

<p>A link support module can implement an arbitrary number of interfaces but
record support must be available that understands each interface. The
following is the base for the interface implemented by all link support.</p>
<pre>    enum LinkInitializeReturn{ success, noop, failure);
    enum LinkReturn{ success, active);

    interface LinkCallback(
        void done();
        void failure(String reason);
    }

    interface LinkSupportBase {
        void destroy();
        LinkInitializeReturn initialize();
        LinkReturn connect(LinkCallback callback);
        LinkReturn disconnect(LinkCallback callback);
    }

    interface LinkSupportFactory {
        LinkSupportBase create(RecordInstance instance,DBLink link);
        LinkSupportBase find(RecordInstance instance,DBLink link);
    }</pre>

<p>Specific link support extends this support.</p>

<p>LinkSupportBase has the following methods:</p>
<dl>
  <dt style="font-family: courier;">destroy</dt>
    <dd>The support must clean up all resources. If it is connected its
      disconnect method will be called first.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Create any resources necessary but do not connect. <span
      style="font-family: courier;">initilize</span> returns one of the
      following:
      <dl>
        <dt style="font-family: courier;">success</dt>
          <dd>Initialization was successful</dd>
        <dt style="font-family: courier;">noop</dt>
          <dd>There is nothing to do for this link.</dd>
        <dt style="font-family: courier;">failure</dt>
          <dd>The support failed.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to whatever. It returns either <span
      style="font-family: courier;">success</span> or <span
      style="font-family: courier;">active</span>. It should only return
      <span style="font-family: courier;">success</span> if it can connect
      immediately, e.g. register based support. In all other cases it should
      return <span style="font-family: courier;">active</span> and call the
      callback. It calls <span style="font-family: courier;">done</span> if
      it successfully connects and <span
      style="font-family: courier;">failure</span> otherwise.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect. It follows rules similar to <span
      style="font-family: courier;">connect.</span></dd>
</dl>

<p>Each link support module must implement LinkSupportFactory, which is
called to create a new instance of LinkSupport. It is passed two
arguments:</p>
<dl>
  <dt>recordInstance</dt>
    <dd>The record instance being created.</dd>
  <dt style="font-family: courier;">config</dt>
    <dd>The structure containing configuration informatio.</dd>
  <dt>link</dt>
    <dd>The link to which it is connected.</dd>
</dl>

<h2><a id="RuntimeCALinkSupport"></a>Channel Access Link Support</h2>

<p>The channel access link support that comes with base implements the
following interface:</p>
<pre>    interface ChannelAccessLinkSupport extends LinkSupportBase {
        ProcessReturn process(ProcessState state,Callback callback, double timeout);
    }</pre>

<p>The fieldNames argument of LinkSupportFactory depends on the link support
type.</p>
<ul>
  <li>processLink - A single field, which must be a
  structure(ProcessLink).</li>
  <li>monitorLink - Two fields which must be:
    <ol>
      <li>structure(MonitorLink)</li>
      <li>The field in which to store the monitored data.</li>
    </ol>
  </li>
  <li>inputLink - Two fields which must be:
    <ol>
      <li>structure(InputLink)</li>
      <li>The field in which to store the data.</li>
    </ol>
  </li>
  <li>outputLink - Two fields which must be:
    <ol>
      <li>structure(OutputLink)</li>
      <li>The field from which to get the data.</li>
    </ol>
  </li>
</ul>

<p>NOTE: At least in the initial implementation monitorLink, inputLink, and
outputLink will only handle data that is a primitive type or string or an
array of primitive type or string.</p>

<h2><a id="RuntimeAsynLinkSupport"></a>AsynDriver Link Support</h2>

<p>Not Yet Defined. It will be modeled after V3 asynDriver support.</p>

<h2><a id="RuntimeProcessSupport"></a>Runtime Process Support</h2>

<p>The following interfaces are available:</p>
<pre>    enum alarmSeverity(none,minor,major,invalid)

    interface RecordProcess {
        void lock();
        void unlock();
        void lockOther(RecordProcess otherRecord);
        ProcessState getProcessState();
        ProcessReturn process(Callback done);
        void requestProcess(RecordProcess otherRecord,Callback done);
        boolean registerDataSource(String field, PV dataSource);
        boolean setTimeStamp(long seconds, int nanoSeconds);
        boolean setAlarmSeverity(alarmSeverity severity);
        boolean setStatus(String status);
    }

    public class RecordProcessFactory {
        public RecordProcess getRecordProcess(RecordInstance recordInstance);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">lock</dt>
    <dd>lock the record. This must be done before accessing any field other
      then from record or link support. It must also be done before calling
      process.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>unlock the record. It must be called by the same thread that called
      lock</dd>
  <dt style="font-family: courier;">lockOther</dt>
    <dd>Lock another record. The caller must have already locked the current
      record. Making this call may temporily unlock the current record. This
      call is used to access data in another record. The caller must call
      unlock for otherRecord when it is done.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>A request to process a record. The caller can be notified when the
      record completes processing.</dd>
  <dt style="font-family: courier;">requestProcess</dt>
    <dd>Called by record of link support to request that a linked record be
      processed. The record must be local.</dd>
  <dt style="font-family: courier;">registerDataSource</dt>
    <dd>Register to be the data source for a field. For example this can be
      used to implement a circular buffer.</dd>
  <dt style="font-family: courier;">setAlarmSeverity</dt>
    <dd>This is the only way to modify the alarm severity since it is a
      readonly field.</dd>
  <dt style="font-family: courier;">setStatus</dt>
    <dd>This is the only way to modify status since it is a readonly
    foeld.</dd>
</dl>
<hr />

<h1 style="text-align: center"><a name="ProcessSemantics"
id="ProcessSemantics"></a>Record Processing Semantics</h1>
<hr />

<h2><a id="ProcessSemanticsOverview"></a>Overview</h2>

<p>The database calls RecordProcess.process. RecordProcess calls each
attached record support and record support calls link support. An arbitrary
number of record and link support modules can be attached to a record
instance.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>Database fields
    <ul>
      <li>Are owned by the database. The only access is via the DB
      interfaces.</li>
      <li>Support can, optionally, register to provide storage for a field.
        This is particularly valuable for array fields. For example this is
        how a circular buffer can be implemented.</li>
    </ul>
  </li>
  <li>RecordProcess.process, which is what calls record support,
    <ul>
      <li>Calls each record support module until it returns ProcessReurn.done
        or ProcessReturn.abort.</li>
      <li>When record support returns ProcessReturn.active, dbProcess again
        calls the same record support when the Callback passed to process is
        called. Other threads, e.g. periodic scan threads, can call
        RecordProcess.process while a record is active. It will call the
        currently active record support.</li>
      <li>The record support modules are called in the order they are
        specified when a record instance is created.</li>
    </ul>
  </li>
  <li>link support
    <ul>
      <li>Can support a link to another record or can be a link to something
        else, e.g. hardware</li>
      <li>Is called by a record support module. The record support must
        understand how to use the interfaces implemented by link support</li>
    </ul>
  </li>
  <li>record link
    <ul>
      <li>Can request that the linked record be processed. The request is
        always implemented by queuing a request, NOT by directly processing
        the record. If the record is synchronous, however, the record is
        processed without requiring a context switch.</li>
      <li>Can ask to wait until linked record finishes. Again if the linked
        record is synchronous, no context switch is required.</li>
      <li>For asynchronous links, the record can again be processed while the
        link is active.</li>
    </ul>
  </li>
</ul>

<h2><a id="ProcessLifetime"></a>Process Lifetime</h2>

<p>The following describes how a typical process request is handled.</p>

<p>Assume a record instance is idle, i.e. is ready to start processing and
RecordProcess.process is called with state ProcessState.start. The following
happens</p>

<p>RecordProcess.process calls each of the record support modules connected
to the record instance. It calls them in the order specified by the record
instance.</p>

<p>If a record support module returns done then RecordProcess.process
proceeds to the next record support module. If a record support module
returns abort, no additional record support is called.</p>

<p>If record support returns active then RecordProcess will again call the
same record support when 1) its callback is called, or 2) someone else calls
RecordProcess.process with state active.</p>

<p>Whenever record support returns active or when all record support is done,
monitors are raised for all fields modified by record or link support.</p>

<p>If record or link support calls requestProcess the request is queued. When
any record support returns active or when the last record support finishes
the first entry on the queue is called.</p>

<p>If RecordProcess.process is called with ProcessState cancel then it will
call the active record support and tell it to cancel. No other record support
will be called.</p>

<h2><a id="Monitors"></a>Posting Monitors</h2>

<p>RecordProcess posts monitors every time record support returns active and
at the completion of all record processing. It posts any field that was
modified by record or link support together with any dynamic fields that were
modified by record or link support.</p>

<p>Any fields that are modified by other support are posted immediately.</p>

<h2><a id="MutualExclusion"></a>Mutual Exclusion</h2>

<p>A lock is associated with each record instance. When record support is
called the lock is already taken. Thus record support and link support do not
have to lock or unlock when they access the fields of their record instance.
Any other code must call lock before accessing a field or calling any other
RecordProcess method. If record or link support needs to access another
record then it can call lockOther. Calling this might cause a lock/unlock of
its own record instance.</p>

<p>When RecordProcess.process returns the caller is expected to call unlock.
Thus even when it returns active, the record is unlocked. Thus the record can
again be processed and fields in the record can be modified. Record and link
support must be aware that this can happen.</p>

<h2><a id="AlarmStatusProcessing"></a>Alarm and Status Processing</h2>

<p>Alarm processing is handled by RecordProcess. It does this as follows:</p>

<p>When process is called to start processing, it saves the current value of
alarmSeverity and status. Call these originalSeverity and originalStatus. It
then sets newSeverity to none and newStatus to null.</p>

<p>When setAlarmSeverity is called it only accepts the new value if the
severity is higher than newSeverity. When setStatus is called it only accepts
the new value if newStatus is null.</p>

<p>When record support post monitore it posts an alarmSeverity only if
newSeverity is different than originalSeverity and only posts a status
monitor if newStatus is different than originalStatus. It then sets
originalSeverity = newSeverity and originalStatus = newStatus.</p>
</body>
</html>
