<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: support</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: support<br />
package: org.epics.ioc.support<br />
2010.09.01</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a> 
    <ul>
      <li><a href="#RecordProc">RecordProcess</a></li>
      <li><a href="#Support">Support</a></li>
    </ul>
  </li>
  <li><a href="#Record">Record Processing Theory of Operation</a> 
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Requester">Requester Examples</a></li>
      <li><a href="#RecordProc1">RecordProcess Overview</a></li>
      <li><a href="#Local">Local Channel Access Example</a></li>
      <li><a href="#Link">Link Support Example</a></li>
      <li><a href="#Locking">Locking</a></li>
      <li><a href="#Support1">Support Overview</a></li>
    </ul>
  </li>
  <li><a href="#Record1">Record Process</a> 
    <ul>
      <li><a href="#Definition1">Definitions</a></li>
      <li><a href="#RecordProc2">RecordProcess - General Purpose
      Methods</a></li>
      <li><a href="#RecordProc3">RecordProcess - Record Lifetime
      Methods.</a></li>
      <li><a href="#RecordProc4">RecordProcess - Record Process Requester
        Methods</a></li>
      <li><a href="#RecordProc5">RecordProcess - Support Processing
        methods.</a></li>
      <li><a href="#RecordProc6">RecordProcessRequester</a></li>
      <li><a href="#ProcessCal">ProcessCallbackRequester</a></li>
      <li><a href="#ProcessCon">ProcessContinueRequester</a></li>
      <li><a href="#RecordProc7">RecordProcessFactory</a></li>
    </ul>
  </li>
  <li><a href="#Support2">Support</a> 
    <ul>
      <li><a href="#Support3">Support State</a></li>
      <li><a href="#Support4">Support</a></li>
      <li><a href="#Record2">Record Support</a></li>
    </ul>
  </li>
  <li><a href="#AbstractSu">AbstractSupport</a> 
    <ul>
      <li><a href="#AbstractSu1">AbstractSupport</a></li>
      <li><a href="#Definition2">Definitions</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package describes how records are processed. Package install
describes how records are initialized and started. During database creation
each record is assigned an instance of RecordProcess, which coordinates
record processing. In addition each record has a Support instance and each
field can optionally have an associated Support instance. </p>

<h3 id="RecordProc">RecordProcess</h3>

<p>The following interfaces are involved with record processing:</p>
<dl>
  <dt><span style="font-family: courier;">RecordProcess</span></dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt><span style="font-family: courier;">ProcessToken</span></dt>
    <dd>A token that allocated by RecordProcess and used by
      RecordProcessRequesters.</dd>
  <dt><span style="font-family: courier;">RecordProcessRequester</span></dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt><span style="font-family: courier;">ProcessCallbackRequester</span></dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt><span style="font-family: courier;">ProcessContinueRequester</span></dt>
    <dd>Implemented by code that calls recordProcess.processContinue.</dd>
</dl>

<h3 id="Support">Support</h3>

<p>Every JavaIOC record instance has associated support code and each field
of a record instance can optionally have associated support code. This
package contains: </p>
<dl>
  <dt><span style="font-family: courier;">Support</span></dt>
    <dd>The interface which is implemented by every support module.</dd>
  <dt><span style="font-family: courier;">AbstractSupport</span></dt>
    <dd>An abstract class that is the base class for every support
    module.</dd>
</dl>

<p>This package has sub-packages for the support modules implemented by the
javaIOC itself. Other JavaIOC applications can implement additional support
modules. The sub-packages are:</p>
<dl>
  <dt><a href="basic/package-summary.html">basic</a></dt>
    <dd>Implements the following support: 
      <dl>
        <dt>generic</dt>
          <dd>Generic support for a record type, structure, and an array of
            arrays or structures.</dd>
        <dt>noop</dt>
          <dd>Support that does nothing except complete successfully.</dd>
        <dt>linearConvert</dt>
          <dd>Implements linear conversion for a numeric scalar field.</dd>
        <dt>digital</dt>
          <dd>Support for digital I/O.</dd>
        <dt>incremental</dt>
          <dd>Support for incremental output.</dd>
        <dt>delay</dt>
          <dd>Adds a delay to record processing.</dd>
        <dt>event</dt>
          <dd>Support for a string field that is the name of an event.</dd>
        <dt>processControl</dt>
          <dd>Support for the processControl record type. This is a record
            type that attaches to another record. The scan state of the
            record can be changed, the trace and enable states can be
            changed, and the structure of a sub-field can be changed.</dd>
        <dt>scan</dt>
          <dd>Support for the scan field.</dd>
        <dt>supportArray</dt>
          <dd>Support for an array field where each element is a
          structure.</dd>
      </dl>
    </dd>
  <dt><a href="basic/package-summary.html">ca</a></dt>
    <dd>Implements support for channel access links, i.e. links to other
      records.</dd>
  <dt><a href="basic/package-summary.html">dbLink</a></dt>
    <dd>Implements support for database links, i.e. links to other records in
      the same javaIOC.</dd>
  <dt><a href="alarm/package-summary.html">alarm</a></dt>
    <dd>Raises alarms for value fields.</dd>
  <dt><a href="calc/package-summary.html">calc</a></dt>
    <dd>Support for performing calculations.</dd>
  <dt><a href="device/package-summary.html">device</a></dt>
    <dd>Examples of support that implements device abstractions.</dd>
  <dt><a href="pdrv/package-summary.html">pdrv</a></dt>
    <dd>Support for communicating with portDriver.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Record">Record Processing Theory of
Operation</h2>
<hr />

<p>A JavaIOC Database is a "smart" database. Each record has associated
support code and each field of a record can optionally have associated
support.</p>

<p>Each record has an implementation of recordProcess associated with it.
recordProcess can be requested to process the record. It in turn calls the
process method of the support attached to the record. A record is also the
top level structure. The record support process method calls the support for
any field of the top level structure that has associated support. Any support
can call other support.</p>

<h3 id="Definition">Definitions</h3>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke
      other support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance. Support that is attached
      to a structure can also be record support if the structure is the top
      level structure. </dd>
  <dt>recordProcess</dt>
    <dd>During database initialization every record instance is assigned an
      instances of RecordProcess, which coordinates record processing.</dd>
  <dt>process requester</dt>
    <dd>Code that asks recordProcess to process a record. A process requester
      must get a ProcessToken from record process in order to request that a
      record can be processed. A record instance can optionally be set to
      allow only a single process requester, in which case only the first
      requester that asks for a token will receive a token..</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h3 id="Requester">Requester Examples</h3>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests: 
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status,
            severity, and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be
      done with as few lock/unlock cycles and context switches as possible.
      In particular only asynchronous support should cause a context switch.
      <br />
      Typical requests are: 
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or
          severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>

<h3 id="RecordProc1">RecordProcess Overview</h3>

<p>A record is processed via a call to RecordProcess.process. It in turn
calls the record support process method. Record support optionally calls the
process methods of field support modules. Each support module can optionally
call the process method of support code for subfields. Record support is just
like field support except that it is attached to the record rather than to a
subfield of the record.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support 
    <p>Synchronous support is suport that can implemented without blocking.
    Asynchronous support is support that must wait. For example network
    requests must block. Asynchronous support does not cause record
    processing to block. Instead the support code returns without completing
    and arranges some other way to perform it's function. When it is done it
    again interacts with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active
    and other requests to process the record will fail.</p>
  </li>
  <li>record locking 
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
  <li>RecordProcsssRequester 
    <p>A record instance can have 0 or more record process requesters. A
    record can optionally be set to allow at most one record process
    requesters. Code that wants to request processing must first request a
    ProcesssToken. Then it can queue requests to call process.</p>
  </li>
  <li>RecordProcess 
    <p>Each record has an instance of RecordProcess. It manages all process
    related activities.</p>
  </li>
</ul>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess 
    <ul>
      <li>queueRequest 
        <p>A process requester calls this method to request processing. When
        a request is taken from the queue, the record is set active and the
        becomeProcessr method implemented by the process requester is called.
        The requester can optionally put data into the record and then calls
        process.</p>
      </li>
      <li>process 
        <p>recordSupport.process is called. The results of processing are
        sent to the requester via the RecordProcessRequester methods. The
        requester can request the record be left active when processing
        completes.</p>
      </li>
      <li>setInactive 
        <p>Must be called if the requester asked that the record be left
        active when processing completes.</p>
      </li>
      <li>processContinue 
        <p>Called by asynchronous support when it is ready to continue
        processing. The record is locked and
        processContinueRequester.processContinue is called..</p>
      </li>
      <li>requestProcessCallback 
        <p>Any support code called directly or indirectly by process or
        processContinue can call this method.
        processRequestRequester.processCallback is called with the record
        unlocked. Support code that processes other records must only issue
        the process requests via this method or deadlocks can occur.</p>
      </li>
    </ul>
  </li>
  <li>Support - defined in package org.epics.ioc.support 
    <ul>
      <li>process(SupportProcessRequester supportProcessRequester) 
        <p>This is a method that must be implemented by all support modules.
        When the support is done it calls the supportProcessRequester to
        report completion.</p>
      </li>
    </ul>
  </li>
  <li>RecordProcessRequester 
    <ul>
      <li>becomeProcessor 
        <p>Called as a result of a queueRequest.</p>
      </li>
      <li>canNotProcess 
        <p>The requester has issued a queue request but is not able to
        process the record, for example the record might be disabled.</p>
      </li>
      <li>lostRightToProcess 
        <p>The requester has lost the right to issue queue requests. One
        reason why this could be called is the a recod is dynamically
        declared to have only a single process requester.</p>
      </li>
    </ul>
    <ul>
      <li>recordProcessResult 
        <p>Called with the record locked and all processing is complete.</p>
      </li>
      <li>recordProcessComplete() 
        <p>Called with the record inlocked and processing complete.</p>
      </li>
    </ul>
  </li>
  <li>SupportProcessRequester 
    <ul>
      <li>supportProcessDone(RequestResult requestResult) 
        <p>called by whoever calls support.process. In particular
        recordSupport implements this interface</p>
      </li>
    </ul>
  </li>
  <li>ProcessCallbackRequester 
    <ul>
      <li>processCallback() 
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
  <li>ProcessContinueRequester 
    <ul>
      <li>processContinue() 
        <p>called by recordProcess with record locked.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="Local">Local Channel Access Example</h3>

<p>As an example assume that a channel access server does the following to a
record:</p>
<ul>
  <li>Puts data into the record.</li>
  <li>Processes the record.</li>
  <li>Reads a large array from the record. The array is too big to fit in a
    single network buffer.</li>
</ul>

<p>This can be implemented as follows:</p>
<ul>
  <li>server calls recordSupport.queueRequest. As a result becomeProcessor
    will be called.</li>
  <li>server locks the record, puts data, unlocks the record.</li>
  <li>server calls recordSupport.process and specifies that the record be
    left active.</li>
  <li>When processing is complete recordSupport calls
    server.recordProcessResult and server.recordProcessDone.</li>
  <li>The server gets the array. It may have to access the array multiple
    times because of the network buffer restrictions. It must lock the record
    as it reads each segment.</li>
  <li>The server calls recordSupport.setInactive.</li>
</ul>

<h3 id="Link">Link Support Example</h3>

<p>As an example assume that a record type double has the following
fields:</p>
<dl>
  <dt>value</dt>
    <dd>A PVDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A PVStructure field which is by default a null structure, i.e. it has
      no fields and no support. A record instance can override this to be any
      structure defined in the master Database Definition Database. The
      default support can also be overridden.</dd>
  <dt>output</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>valueAlarm</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>supportArray</dt>
    <dd>An array field with the elementType set to structure and the
      supportName set to supportArray.</dd>
  <dt>...</dt>
    <dd>Several other null PVStructure fields are present.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>generic</dt>
    <dd>Support for a structure. For each field in the structure that has
      support, generic calls it. </dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e.
      a link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links,
      i.e. a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e.
      a link that can put data to another record.</dd>
  <dt>...</dt>
    <dd>Support modules are also available that can be attached to other null
      PVStructure fields.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "generic"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "display" type = "display" /&gt;
    &lt;structure name = "input" type = "inputSupport"&gt;
        &lt;scalar name = "pvname"&gt;recordForInput&lt;/scalar&gt;
        &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;scalar name = "propertyNames"&gt;alarm,display&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "generic" &gt;
        &lt;structure name = "process" type = "processSupport"&gt;
            &lt;scalar name = "pvname"&gt;processRecord&lt;/scalar&gt;
            &lt;scalar name = "wait" type = "boolean" &gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "output" type = "outputSupport"&gt;
             &lt;scalar name = "pvname"&gt;outputRecord&lt;/scalar&gt;
             &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess locks the record and prepares the for processing. The
    record will remain active until the record is completely processed.</li>
  <li>recordProcess calls doubleRecord.process, which is actually generic
    support. For this example it will be called doubleRecord so that it is
    not confused with the generic support for field link</li>
  <li>doubleRecord calls inputSupport.process.</li>
  <li>Assuming the recordForInput is local and since process is false, the
    input support just: 
    <ul>
      <li>locks the linked record</li>
      <li>transfers data from the linked record to the double record.</li>
      <li>unlocks the linked record.</li>
      <li>notifys doubleRecord that it has completed.</li>
    </ul>
  </li>
  <li>doubleRecord calls link.process.</li>
  <li>generic calls recordProcess.requestProcessCallback.</li>
  <li>doubleRecord returns.</li>
  <li>recordProcess unlocks the record and calls generic.processCallback.<br
    />
    generic calls the process method of both processSupport and
    outputSupport. 
    <p>processSupport does the following:</p>
    <ul>
      <li>calls recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to request
        that the linked record be processed. The request does not block. When
        channel access completes the request it calls the processDone method
        of processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>outputSupport does the following.</p>
    <ul>
      <li>Copies the value field to a private data store. It then calls
        recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to put the
        private data into the linked record and then process the record. When
        channel access completes the request it calls the processDone method
        of processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>generic keeps track of each support it calls. When all have called
    supportProcessDone then supportArray is also done.</p>
  </li>
  <li>generic, when done, calls recordSupport.processContinue.</li>
  <li>recordSupport calls generic.processContinue</li>
  <li>generic calls doubleRecord.supportProcessDone.</li>
  <li>doubleRecord calls recordProcess.supportProcessDone</li>
  <li>recordProcess completes record processing 
    <ul>
      <li>calls recordProcessRequester.recordProcessResult</li>
      <li>unlocks the record and sets the record inactive.</li>
      <li>calls recordProcessRequester.recordProcessComplete.</li>
    </ul>
  </li>
</ul>

<h3 id="Locking">Locking</h3>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when any field is being accessed.</li>
  <li>A record must be locked while processing. 
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support
        interacts with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks taken.</li>
  <li>Locks should always be taken with code that has the form: 
    <pre>record.lock();
try {
     ...

} finally {
    record.unlock();
}
    </pre>
  </li>
  <li>Code must not block while a record is locked.</li>
  <li>Two records can be locked simultaneously via: 
    <pre>record.lockOtherRecord(otherRecord);
try {
     ...

} finally {
    otherRecord.unlock();
}
    </pre>
    While a record is locked another record should never be locked by calling
    it's record.lock directly. Doing so can lead to deadlocks. It is NOT
    permissible to lock more than two records at a time.</li>
</ul>

<h3 id="Support1">Support Overview</h3>

<p>A support module implements the following methods:</p>
<dl>
  <dt><span style="font-family: courier;">initialize</span></dt>
    <dd>The support can do any initialization that does not connect outside
      the record.</dd>
  <dt><span style="font-family: courier;">start</span></dt>
    <dd>The support can connect outside the record. For example channel
      access support can connect to another record.</dd>
  <dt><span style="font-family: courier;">stop</span></dt>
    <dd>The support must terminate outside connections.</dd>
  <dt><span style="font-family: courier;">uninitialize</span></dt>
    <dd>The support must undo everything it did during initialization.</dd>
  <dt><span style="font-family: courier;">process</span></dt>
    <dd>Implements the semantics of record procession.</dd>
</dl>

<p>The methods initialize, start, stop, and uninitialize provide the ability
to dynamically modify a record.</p>

<p>Support is associated with a structure, record, or field definition via an
auxInfo definition that has a name of "supportFactory". In addition there
must be a structure definition for the factory itself. Look at the xml
structure definitions that come with the javaIOC for examples.</p>
<hr />

<h2 style="text-align: center;" id="Record1">Record Process</h2>
<hr />

<h3 id="Definition1">Definitions</h3>

<p>The following are the interfaces for record processing:</p>
<pre>    
    public interface RecordProcess {
        // general purpose methods
        boolean isEnabled();
        boolean setEnabled(boolean value);
        boolean isActive();
        PVRecord getRecord();
        boolean isTrace();
        boolean setTrace(boolean value);
        SupportState getSupportState();
        // support lifecycle methods
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        // record process requester methods
        ProcessToken requestProcessToken(RecordProcessRequester recordProcessRequester);
        void releaseProcessToken(ProcessToken processToken);
        void forceInactive();
        String getRecordProcessRequesterName();
        void queueProcessRequest(ProcessToken processToken);
        void process(ProcessToken processToken,
            boolean leaveActive, TimeStamp timeStamp);
        void setInactive(ProcessToken processToken);
        // support processing methods
        void processContinue(
            ProcessContinueRequester processContinueRequester);
        void requestProcessCallback(
            ProcessCallbackRequester processCallbackRequester);
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
        // self processing method
    }

    public interface ProcessToken {}

    public interface RecordProcessRequester extends Requester{
        void becomeProcessor();
        void canNotProcess(String reason);
        void lostRightToProcess();
        void recordProcessResult(RequestResult requestResult);
        void recordProcessComplete();
    }

    public interface ProcessCallbackRequester extends Requester{
        void processCallback();
    }

    public interface ProcessContinueRequester {
        void processContinue();
    }
    
    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>An instance of RecordProcess is created for each IOCrecord. Each method
falls into one of the following classes:</p>
<ol>
  <li>General Purpose. These are methods that can be called by any code. If
    necessary a method locks the record while performing its action and
    unlocks before returning.</li>
  <li>Record Support Lifetime. Initialize,start,stop,ininitialize.</li>
  <li>Record Process Requester: These are methods for code that requests
    record processing.</li>
  <li>Support Processing. These are methods for use by support code, i.e.
    code that implements record processing.</li>
</ol>

<h3 id="RecordProc2">RecordProcess - General Purpose Methods</h3>
<dl>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>Is the record enabled?</dd>
  <dt style="font-family: courier;">setEnabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when a record is disabled the current process
      is allowed to complete.</dd>
  <dt style="font-family: courier;">isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt style="font-family: courier;">isTrace</dt>
    <dd>Is trace active for this record?</dd>
  <dt style="font-family: courier;">setTrace</dt>
    <dd>Set tracing on or off. When true info messages are sent to
      pvRecord.message whenever any processing related method of
      RecordProcess is called.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the current support state.</dd>
</dl>

<h3 id="RecordProc3">RecordProcess - Record Lifetime Methods.</h3>

<p><span style="font-family: courier;">RecordProcess</span> looks for the
fields <span style="font-family: courier;">timeStamp</span>, <span
style="font-family: courier;">processAfterStart</span> , and <span
style="font-family: courier;">scan</span>. It handled these fields itself.
The record support code must ignore these fields.</p>
<dl>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Initialize record support. record support, in turn, initializes
      support that it invokes. Initialize should perform any initialiation
      not requiring access aanything outside the record. For example it is
      not permissible to connect to other records. If initialize is
      successful record support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span></dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start record support. Again record support calls start for any
      support it invokes. If successful, the support enters state <span
      style="font-family: courier;">SupportState.ready</span>. Until record
      support is in the ready state and attempt to process a record will
    fail.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop record support. Record support calls stop for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span>.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Unitialize record support. It calls unitialize for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForInitialize.</span></dd>
</dl>

<h3 id="RecordProc4">RecordProcess - Record Process Requester Methods</h3>

<p>These are methods called by code that wants a record processed.</p>
<dl>
  <dt style="font-family: courier;">requestProcessToken</dt>
    <dd>Called by a code that wants to call queueProcessRequest.</dd>
  <dt style="font-family: courier;">releaseProcessToken</dt>
    <dd>Called by code that no longer wants to call queueRequest.</dd>
  <dt style="font-family: courier;">forceInactive</dt>
    <dd>Called by code that has a ProcessToken but will no longer be allowed
      to call queueProcessRequest.</dd>
  <dt style="font-family: courier;">getRecordProcessRequesterName</dt>
    <dd>Get the name of the recordProcessRequester.</dd>
  <dt style="font-family: courier;">queueProcessRequest</dt>
    <dd>Request to be the record processor. Each record instance can have
      only one record process requester. If a requester is already registered
      a message is sent to the requester and false is returned.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Request that the record be processed. If the caller has not called
      setActive the record is prepared for processing. In either case if the
      record is ready record support process is called. If true is returned
      the methods implemented by the recordProcessRequester are called to
      show the results of the process request. If <span
      style="font-family: courier;">leaveActive</span> is true than when the
      record completes processing it is left active until setInActive is
      called. Until the record becomes inactive another request to process
      the record will fail. Record support is called with the record
      locked.<br />
      If false is returned the request has failed and
      recordProcessRequester.message is called to provide the reason. If
      recordProcessRequester is null an IllegalStateException is thrown. </dd>
  <dt style="font-family: courier;">setInActive</dt>
    <dd>Call by the record process requester when it is done with processing.
      Calling process with <span
      style="font-family: courier;">leaveActive</span> true and then calling
      setInactive allows the requester to communicated with other code after
      the record is unlocked but before it becomes inactive.</dd>
</dl>

<h3 id="RecordProc5">RecordProcess - Support Processing methods.</h3>

<p>Methods called by support code which may be record support or support
called directly or indirectly by record support. Except for <span
style="font-family: courier;">processContinue</span> these methods throw an
exception unless <span style="font-family: courier;">process</span> or <span
style="font-family: courier;">processContinue</span> is running.</p>
<dl>
  <dt style="font-family: courier;">requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but
      before RecordProcess.process returns. The callback is made with the
      record unlocked. Thus the callback can request that other records be
      processed. This is the way support code can process other records. If
      support code directly request processing of linked records deadlocks
      can occur.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only
      way asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt style="font-family: courier;">setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a
      record is being processed, then RecordProcess will set the time stamp
      if the record has a timeStamp field.</dd>
  <dt style="font-family: courier;">getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <span
      style="font-family: courier;">setTimeStamp</span></dd>
</dl>

<h3 id="RecordProc6">RecordProcessRequester</h3>

<p>Methods implemented by code that requests that a record be processed.</p>
<dl>
  <dt style="font-family: courier;">becomeProcessor</dt>
    <dd>Called as a result of queueRequeProcessst. The requester can the call
      process.</dd>
  <dt style="font-family: courier;">canNotProces</dt>
    <dd>Called as a result of queueProcessRequest but the record can not be
      processed. For example it might be disabled.</dd>
  <dt style="font-family: courier;">lostRightToProcess</dt>
    <dd>Called when code that has a ProcessToken will no longer be allowed to
      call queueProcessRequest. This can happen if a record is dynamically
      set to allow only a single process requester.</dd>
  <dt style="font-family: courier;">recordProcessResult</dt>
    <dd>The results of record processing. This is called with the record
      locked so that the process requester can access data from the
    record.</dd>
  <dt style="font-family: courier;">recordProcessComplete</dt>
    <dd>Processing is complete. This is called with the record unlocked. If
      the process requester called process with <span
      style="font-family: courier;">leaveActive</span> <span
      style="font-family: courier;">true</span> then the requester must call
      <span style="font-family: courier;">setInactive.</span></dd>
</dl>

<h3 id="ProcessCal">ProcessCallbackRequester</h3>

<p>The method implemented by code that calls requestProcessCallback.</p>
<dl>
  <dt style="font-family: courier;">processCallback</dt>
    <dd>The callback to call when the record support process method returns
      it RecordProcess. Any support code that wants to process other records
      must use this interface. The callback is called with the record
      unlocked.</dd>
</dl>

<h3 id="ProcessCon">ProcessContinueRequester</h3>

<p>The method implemented by code that calls processContinue.</p>
<dl>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>A request to call support with the record locked. This is the only
      way asynchronous support should continue processing.</dd>
</dl>

<h3 id="RecordProc7">RecordProcessFactory</h3>

<p>A factory is provided to create an instance of RecordProcess for a record
instance. It has the method:</p>
<pre>public class RecordProcessFactory {
    static public RecordProcess createRecordProcess(
          RecordSupport recordSupport,PVRecord pvRecord);
}</pre>
<hr />

<h2 style="text-align: center" id="Support2">Support</h2>
<hr />

<p>This section describes the interfaces and abstract base class involved
with support for fields of an IOC record. This also means support for the
record itself.</p>

<h3 id="Support3">Support State</h3>

<p>Before support is ready for processing it must be ready. In addition
on-line add and delete is supported. Thus it is possible to dynamically
redefine link fields, array fields, etc. Unless a support module is in the
ready state it's process method should not be called and if it is it should
just report failure.</p>
<pre>    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public static SupportState getSupportState(int value);
    public static Enumerated getSupportState(PVField pvField);</pre>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting
      to other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is being removed and can never again process.</dd>
</dl>

<h3 id="Support4">Support</h3>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>    
    public interface Support extends Requester {
        String getSupportName();
        SupportState getSupportState();
        PVField getPVField();
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
    }

    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt><span style="font-family: courier">getSupportName</span></dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>A requester method to get the name of the support.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>A Requester method. This is called to pass messages to the
    support.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Get the <span style="font-family: courier;">PVField</span> interface
      for the field that is being supported. For record support this will be
      the record itself. <span style="font-family: courier;"></span></dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
</dl>

<p>Every Support module must implement the methods initialize, start, stop,
and uninitialize. Initialize performs initialization related to the record
instance being supported but can not access anything outside the record.
Start completes all initialization including linking to the outside, e.g. to
other records. Stop must remove all access to the outside. Uninitialize must
remove all access to the record instance being supported.</p>

<p><span style="font-family: courier;">SupportProcessRequester</span> has the
method:</p>
<dl>
  <dt style="font-family: courier;">supportProcessDone</dt>
    <dd>The callback to call when support is done . Any support code that
      wants to process other records must implement this interface. This MUST
      be called with either process or processContinue running.</dd>
</dl>

<h3 id="Record2">Record Support</h3>

<p>Every record instance has an attached RecordSupport:</p>
<pre>    public interface RecordSupport {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        Support getSupport(PVField pvField);
        void setSupport(PVField pvField,Support support);
    }</pre>
<hr />

<h2 style="text-align: center" id="AbstractSu">AbstractSupport</h2>
<hr />

<h3 id="AbstractSu1">AbstractSupport</h3>

<h3 id="Definition2">Definitions</h3>
<pre>    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,PVRecordField pvRecordField);
        // methods from Requester
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public PVField getPVField();
        // following normally overridden
        public void initialize();
        public void start(AfterStart afterStart);
        public void stop();
        public void uninitialize();
        public void process(SupportProcessRequester supportProcessRequester);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following is for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
    }</pre>

<p>All support code should extend AbstractSupport. Abstract Support
implements all Support methods. Thus support code only has to override the
methods it needs.</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
      constructor.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Calls pvField.message.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Returns pvField.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Normally overridden. The default version just calls
      supportProcessRequester.supportProcessDone(RequestResult.success);</dd>
  <dt style="font-family: courier;">setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt style="font-family: courier;">checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
</dl>
</body>
</html>
