<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: support</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: support<br />
package: org.epics.ioc.support<br />
2007.08.08</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Support">Support</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#SupportSta">SupportState</a></li>
      <li><a href="#Support1">Support</a></li>
      <li><a href="#LinkSuppor">LinkSupport</a></li>
      <li><a href="#AbstractSu">AbstractSupport</a></li>
      <li><a href="#AbstractLi">AbstractLinkSupport</a></li>
    </ul>
  </li>
  <li><a href="#Generic">Generic Support</a></li>
  <li><a href="#ScanSuppor">ScanSupport</a></li>
  <li><a href="#Alarm">Alarm Support</a>
    <ul>
      <li><a href="#Alarm1">Alarm Support</a></li>
      <li><a href="#Value">Value Alarms</a>
        <ul>
          <li><a href="#Boolean">Boolean Alarms</a></li>
          <li><a href="#Numeric">Numeric Alarms</a></li>
          <li><a href="#Digital">Digital Alarms</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Linear">Linear Conversion</a>
    <ul>
      <li><a href="#linearConv">linearConversion</a></li>
      <li><a href="#LinearConv">LinearConvertInputFactory</a></li>
      <li><a href="#LinearConv1">LinearConvertOutputFactory</a></li>
      <li><a href="#DeviceLimi">DeviceLimit</a></li>
    </ul>
  </li>
  <li><a href="#Digital1">Digital Support</a>
    <ul>
      <li><a href="#Database">Database Definitions</a></li>
      <li><a href="#Java">Java Definitions</a></li>
    </ul>
  </li>
  <li><a href="#Incrementa">Incremental Support</a></li>
  <li><a href="#Calculatio">Calculation Support</a>
    <ul>
      <li><a href="#Database1">Database Definitions for Calculations</a></li>
      <li><a href="#Performing">Performing Calculations</a></li>
      <li><a href="#calcArgArr">calcArgArray</a></li>
      <li><a href="#Calculator">Calculator</a></li>
      <li><a href="#CounterCal">CounterCalculatorFactory</a></li>
      <li><a href="#ArrayIncre">ArrayIncrementCalculatorFactory</a></li>
      <li><a href="#BooleanArr">BooleanArrayToggleCalculatorFactory</a></li>
    </ul>
  </li>
  <li><a href="#Event">Event Support</a></li>
  <li><a href="#CALink">CALink Support</a></li>
  <li><a href="#LinkArray">LinkArray Support</a></li>
  <li><a href="#Link">Link Support</a></li>
  <li><a href="#Noop">Noop Support</a></li>
  <li><a href="#DelayLink">DelayLink Support</a></li>
  <li><a href="#Port">Port Driver Support</a>
    <ul>
      <li><a href="#Java1">Java Definitions</a></li>
      <li><a href="#PDRVLinkSu">PDRVLinkSupport</a></li>
      <li><a href="#AbstractPD">AbstractPDRVLinkSupport</a></li>
      <li><a href="#PDRVLinkFa">PDRVLinkFactory</a></li>
      <li><a href="#PDRVPortCr">PDRVPortCreateFactory</a></li>
      <li><a href="#PDRVPortDe">PDRVPortDeviceControlFactory</a></li>
    </ul>
  </li>
  <li><a href="#Power">Power Supply Support</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package contains support code for javaIOC databases. Rather than
providing support for a particular record type each of the support modules
provides support for one or more fields. Thus each support module is generic
because it can support any structure or record type that contains the fields
required by the support module. Much of the support can be used for "device"
records, i.e. complex records that have the appearence of having embeded
records.</p>

<p>This package provides interfaces and classes for processing fields of IOC
database records. </p>

<p>The following interfaces are available:</p>
<dl>
  <dt>Support</dt>
    <dd>The interfaces and classes that provide the core for support.</dd>
  <dt>LinkSupport</dt>
    <dd>An extension for link fields.</dd>
  <dt>IncrementalSupport</dt>
    <dd>An extension for incremental output.</dd>
  <dt>ScanSupport</dt>
    <dd>An extension for field scan.</dd>
  <dt>AlarmSupport</dt>
    <dd>An extension for field alarm.</dd>
  <dt>CalculatorSupport</dt>
    <dd>An extension for field calculations.</dd>
  <dt>CalcArgArraySupport</dt>
    <dd>An extension for the arguments for calculations;</dd>
  <dt>DeviceLimit</dt>
    <dd>Defines a method implemented by support for analog I/O.</dd>
  <dt>PDRVLinkSupport</dt>
    <dd>An extension for links to portDriver.</dd>
</dl>

<p>The following abstract classes are provided for implementing support:</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>A base class that is extended by most support code. It implements all
      of the Support methods.</dd>
  <dt>AbstractLinkSupport</dt>
    <dd>A base class that extends AbstractSupport to also implement
      LinkSupport.</dd>
  <dt>AbstractPDRVLinkSupport</dt>
    <dd>A base class for portDriver support.</dd>
</dl>

<p>The following factories are provided:</p>
<dl>
  <dt>GenericFactory</dt>
    <dd>Generic support for a record or structure.</dd>
  <dt>ScanFactory</dt>
    <dd>Complete support for the scan field which is defined in comon.xml</dd>
  <dt>Alarm Support.</dt>
    <dd>Support for the alarm field defined in common.xml and for raising
      alarms. 
      <dl>
        <dt>AlarmFactory</dt>
          <dd>Complete support for field alarm.</dd>
        <dt>BooleanAlarmFactory</dt>
          <dd>Alarm support for boolean fields.</dd>
        <dt>ByteAlarmFactory</dt>
          <dd>Alarm support for byte fields.</dd>
        <dt>ShortAlarmFactory</dt>
          <dd>Alarm support for short fields.</dd>
        <dt>IntAlarmFactory</dt>
          <dd>Alarm support for int fields.</dd>
        <dt>LongAlarmFactory</dt>
          <dd>Alarm support for long fields.</dd>
        <dt>FloatAlarmFactory</dt>
          <dd>Alarm support for float fields.</dd>
        <dt>DoubleAlarmFactory</dt>
          <dd>Alarm support for double fields.</dd>
        <dt>DigitalAlarmFactory</dt>
          <dd>Alarm support for enum field..</dd>
      </dl>
    </dd>
  <dt>Support for linear conversions.</dt>
    <dd><dl>
        <dt>LinearConvertInputFactory</dt>
          <dd>Support for linear conversion of input fields.</dd>
        <dt>LinearConvertOutputFactory</dt>
          <dd>Support for linear conversion of output fields.</dd>
      </dl>
    </dd>
  <dt>DigitalFactory</dt>
    <dd>Support for a record or structure that has fields appropriate for
      Digital I/O.</dd>
  <dt>IncrementalFactory</dt>
    <dd>Support for incremental outputs.</dd>
  <dt>Calculation Support</dt>
    <dd>The following provides support for the array of structures for the
      arguments for calculations: 
      <dl>
        <dt>CalcArgArrayFactory</dt>
          <dd>Support for an array of arguments for calculation records.</dd>
      </dl>
    </dd>
    <dd>The following are calculations that are used for testing. They are
      examples of how to implement a calculation. 
      <dl>
        <dt>CounterCalculatorFactory</dt>
          <dd>Test code for a numeric field.</dd>
        <dt>ArrayIncrementCalculatorFactory</dt>
          <dd>Test code for numeric array fields.</dd>
        <dt>BooleanArrayToggleCalculatorFactory</dt>
          <dd>Test support for a boolean array.</dd>
      </dl>
    </dd>
  <dt>EventFactory</dt>
    <dd>Support for a string field that is the name of an event.</dd>
  <dt>CALinkFactory</dt>
    <dd>Support for channel access links.</dd>
  <dt>LinkArrayFactory</dt>
    <dd>Support for an array of links.</dd>
  <dt>LinkFactory</dt>
    <dd>Support for a structure that consists of a single link.</dd>
  <dt>NoopFactory</dt>
    <dd>Support for all fields that just acts like it always succeeds
      successfully.</dd>
  <dt>DelayLinkFactory</dt>
    <dd>Support for testing. It just causes an asynchronous delay before
      completing successfully.</dd>
  <dt>portDriver</dt>
    <dd>The following are for interfacing to portDriver. 
      <dl>
        <dt>PDRVLinkFactory</dt>
          <dd>Creates support for each of the portDriver interfaces.</dd>
        <dt>PDRVPortCreateFactory</dt>
          <dd>Creates a portDriver port.</dd>
        <dt>PDRVPortDeviceControlFactory</dt>
          <dd>Creates support for a portDeviceControl record, which provides
            the ability change the connect, enable, traceMask, and
            traceIOMask states of a port or a device connected to a port. It
            also can get a report for a port and/or device.</dd>
      </dl>
    </dd>
  <dt>PowerSupplyFactory</dt>
    <dd>A simple example of support for a complex device.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Support">Support</h2>
<hr />

<p>This section describes the interfaces and abstract base class involved
with support for fields of an IOC record. This also means support for the
record itself.</p>

<h3 id="Definition">Definitions</h3>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>    // SupportState is defined in org.epics.ioc.process
    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public interface Support extends Requester {
        SupportState getSupportState();
        DBField getDBField();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void allSupportStarted();
        void process(SupportProcessRequester supportProcessRequester);
        void setField(DBField dbField);
    }

    public interface LinkSupport extends Support {
        PVStructure getConfigStructure(String structureName, boolean reportFailure);
    }

    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,DBField dbField);
        // methods from Requester
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public DBField getDBField();
        // following normally overridden
        public void initialize();
        public void start();
        public void stop();
        public void uninitialize();
        public void allSupportStarted();
        public void process(SupportProcessRequester supportProcessRequester);
        public void setField(DBField dbField);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following is for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
    }

    public class AbstractLinkSupport extends AbstractSupport implements LinkSupport{
        protected AbstractLinkSupport(String name,DBField dbField);
        public PVStructure getConfigStructure(String structureName, boolean reportFailure);
    }</pre>

<h3 id="SupportSta">SupportState</h3>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting
      to other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is going away.</dd>
</dl>

<h3 id="Support1">Support</h3>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>A requester method to get the name of the support.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>A Requester method. This is called to pass messages to the
    support.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Get the <span style="font-family: courier;">DBField</span> interface
      for the field that is being supported. For record support this will be
      the record itself. <span style="font-family: courier;"></span></dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">allSupportStarted</dt>
    <dd>This is called after all records currently being initialized had
      successfully started.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
  <dt style="font-family: courier;">setField</dt>
    <dd>This specifies the field in the record to/from the support will
      put/get data.</dd>
</dl>

<h3 id="LinkSuppor">LinkSupport</h3>

<p><span style="font-family: courier;">LinkSupport</span> extends <span
style="font-family: courier;">Support</span> with the method:</p>
<dl>
  <dt style="font-family: courier;">getConfigStructure</dt>
    <dd>This gets the interface for the configuration structure for the
    link.</dd>
</dl>

<h3 id="AbstractSu">AbstractSupport</h3>

<p>All support code should extend AbstractSupport. Abstract Support
implements all Support methods. Thus support code only has to override the
methods it needs.</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
      constructor.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Calls dbField.message.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Returns dbField.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Normally overridden. The default version just calls
      supportProcessRequester.supportProcessDone(RequestResult.success);</dd>
  <dt style="font-family: courier;">setField</dt>
    <dd>Does nothing.</dd>
  <dt style="font-family: courier;">setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt style="font-family: courier;">checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
</dl>

<h3 id="AbstractLi">AbstractLinkSupport</h3>

<p>This extends AbstractSupport to provide method getConfigStructure; </p>
<pre>    public class AbstractLinkSupport extends AbstractSupport implements LinkSupport{
        protected AbstractLinkSupport(String name,DBField dbField);
        public PVStructure getConfigStructure(String structureName, boolean reportFailure);
    }</pre>
where: 
<dl>
  <dt style="font-family: courier;">AbstractLinkSupport</dt>
    <dd>The constructor vwhich must be called by derived classes.</dd>
  <dt style="font-family: courier;">getConfigStructure</dt>
    <dd>Returns the configuration structure for the link.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Generic">Generic Support</h2>
<hr />
<pre>    public class GenericFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>Generic Support is used for many record/structure definitions including:
</p>
<ul>
  <li>boolean, byte, short, int, long, float, double, string.</li>
  <li>Arrays of the previous types.</li>
  <li>aiDouble. aoDouble, aoIncrementalDouble.</li>
  <li>digital - a record with an enum value.</li>
  <li>event - a record that announces events.</li>
</ul>
It can be used for all of these because it just looks for fields that have
associated support and calls the support. It also has a few conventions so
that it works with a variety of support modules. 

<p>GenericSupportFactory implements record or structure support for an
arbitrary set of fields which have associated support. It calls each support
in the order that the fields are defined in the Database Definition File. It
uses the following semantics:</p>
<dl>
  <dt>common</dt>
    <dd>It does not call the support for fields scan, timeStamp, and
      processAfterStart. These are the fields that appear in commom.xml</dd>
  <dt style="font-family: courier;">value</dt>
    <dd>If setField is called then that field becomes the value field.. If
      setField is not called then it looks for a field named "value". The
      value field is passed to the setField method of each support.</dd>
  <dt style="font-family: courier;">alarm</dt>
    <dd>If field alarm is present and has AlarmSupport then it is handled
      properly.</dd>
  <dt>fields with associated support.</dt>
    <dd>For all fields with support, except the fields in common, the support
      methods are called, i.e. initialize,start,stop,uninitialize, and
      process. For each support process must complete before process for the
      next support module is called.</dd>
</dl>

<p>The above rules allow the generic support to be used for many record types
and embeded versions of these record types. Lets consider two examples:
double and aoDouble.</p>

<p>double (either the structure or the recordType) has the following
fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>This field is passed to the setField method of and support attached
      to any of the following fields.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>This is a link field. If support is defined then the record instance
      becomes an input record. The support gets a value and puts it into the
      value field.</dd>
  <dt style="font-family: courier;">output</dt>
    <dd>This is a link field. If support is defined then the record instance
      becomes an output record. The support gets data from the value field
      and sends it somewhere.</dd>
  <dt style="font-family: courier;">valueAlarm</dt>
    <dd>This is a link field. If support is defined it is expected to check
      the value field for alarm conditions.</dd>
  <dt style="font-family: courier;">linkArray</dt>
    <dd>If the linkArray support is defined it is called.</dd>
  <dt style="font-family: courier;">units</dt>
    <dd>This normally has no support.</dd>
  <dt style="font-family: courier;">displayLimit</dt>
    <dd>This normally has no support. </dd>
</dl>

<p>The generic support does not force the support for input to do input, the
support for output to do output, etc. The generic support merely calls
support if it exists. The generic support also does not check the types of
any fields but looks for support and calls it if it exists. Thus the generic
support can be used for many different types of data and many different types
of support.</p>
<hr />

<h2 style="text-align: center" id="ScanSuppor">ScanSupport</h2>
<hr />

<p>Support is provided for the scan field. This support is called by
recordProcess. The support handles all the fields in structure scan:</p>
<pre>&lt;structure name = "scan"&gt;
    &lt;field name = "priority" type = "menu" menuName = "priority" default = "middle" /&gt;
    &lt;field name = "scan" type = "menu" menuName = "scan" default = "passive" /&gt;
    &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
    &lt;field name = "eventName" type = "string" /&gt;
    &lt;field name = "processSelf" type = "boolean" /&gt;
&lt;/structure&gt;</pre>

<p>At initialization and whenever the scan, priority, rate, or eventName
fields are modified, the support interacts with the appropriate scanners to
add or remove the record from the scanner. If processSelf is set true, the
support implements ScanSupport.</p>

<p>IMPORTANT: RecordProcess provides the same methods as ScanSupport. Support
code must call the RecordProcess methods rather than calling the ScanSupport
methods.</p>

<p>The following definitions are provided:</p>
<pre>    public interface ScanSupport extends Support {
        boolean canProcessSelf();
        boolean processSelfRequest(RecordProcessRequester recordProcessRequester);
        void processSelfSetActive(RecordProcessRequester recordProcessRequester);
        void processSelfProcess(RecordProcessRequester recordProcessRequester,
            boolean leaveActive);
        void processSelfSetInactive(RecordProcessRequester recordProcessRequester);
    }
    public class ScanFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p><span style="font-family: courier;">ScanSupport</span>, which MUST only be
called by recordProcess, extends <span
style="font-family: courier;">Support</span> with the methods:</p>
<dl>
  <dt style="font-family: courier;">canScanSelf</dt>
    <dd>Can the record scan itself? This is true if scan.scanSelf is true. In
      this case scanSupport itself owns and processes the record.</dd>
  <dt style="font-family: courier;">processSelfRequest</dt>
    <dd>Request to process the record. This returns true if scanSupport is
      the record processor and the record is not active.</dd>
  <dt style="font-family: courier;">processSelfSetActive</dt>
    <dd>If processSelfRequest returns true this can be called to set the
      record active. This is called when user code wants to modify data in
      the record before calling processSelfProcess.</dd>
  <dt style="font-family: courier;">processSelfProcess</dt>
    <dd>If processSelfRequest returns true this can be called to process the
      record.</dd>
  <dt style="font-family: courier;">processSelfSetInactive</dt>
    <dd>If the call to processSelfProcess said to leave the record active,
      this is called to set the record inactive. This is done if the caller
      wants to read data from the record after processing.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Alarm">Alarm Support</h2>
<hr />

<p>Support is provided for the alarm field itself and alarm calculation for
boolean, int, and double fields. The following xml definiotions are involved
with alarms.</p>
<pre>&lt;structure name = "alarm"&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "message" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "byteAlarmInterval"&gt;
    &lt;field name = "value" type = "byte" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "byteAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortAlarmInterval"&gt;
    &lt;field name = "value" type = "short" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "shortAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "intAlarmInterval"&gt;
    &lt;field name = "value" type = "int" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "intAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "longAlarmInterval"&gt;
    &lt;field name = "value" type = "long" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "longAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatAlarmInterval"&gt;
    &lt;field name = "value" type = "float" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "floatAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleAlarmInterval"&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "booleanAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "falseAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "trueAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "digitalAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
     &lt;!-- each array element must have menuName  alarmSeverity --&gt;
    &lt;field name = "stateSeverity" type = "array" elementType = "menu" design = "false" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "digitalState"&gt;
    &lt;field name = "name" type = "string" /&gt;
    &lt;field name = "value" type = "int" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;


&lt;support name = "alarm"
    factoryName = "org.epics.ioc.support.AlarmFactory"
/&gt;

&lt;linkSupport name = "booleanAlarm"
    configurationStructureName = "booleanAlarm"
   factoryName = "org.epics.ioc.support.BooleanAlarmFactory" /&gt;

&lt;linkSupport name = "byteAlarm"
    configurationStructureName = "byteAlarm"
   factoryName = "org.epics.ioc.support.ByteAlarmFactory" /&gt;

&lt;linkSupport name = "shortAlarm"
    configurationStructureName = "shortAlarm"
   factoryName = "org.epics.ioc.support.ShortAlarmFactory" /&gt;

&lt;linkSupport name = "intAlarm"
    configurationStructureName = "intAlarm"
   factoryName = "org.epics.ioc.support.IntAlarmFactory" /&gt;

&lt;linkSupport name = "longAlarm"
    configurationStructureName = "longAlarm"
   factoryName = "org.epics.ioc.support.LongAlarmFactory" /&gt;

&lt;linkSupport name = "floatAlarm"
    configurationStructureName = "floatAlarm"
   factoryName = "org.epics.ioc.support.FloatAlarmFactory" /&gt;

&lt;linkSupport name = "doubleAlarm"
    configurationStructureName = "doubleAlarm"
   factoryName = "org.epics.ioc.support.DoubleAlarmFactory" /&gt;

&lt;linkSupport name = "digitalAlarm"
    configurationStructureName = "digitalAlarm"
   factoryName = "org.epics.ioc.support.DigitalAlarmFactory" /&gt;</pre>

<p>The field alarm is defined in common.xml and thus is in every record. the
definition is:</p>
<pre>&lt;field name = "alarm" type = "structure" structureName = "alarm"
          supportName = "alarm" /&gt;</pre>

<p>Records or structures that support alarm processing for double fields
contain the definition:</p>
<pre>&lt;field name = "valueAlarm" type = "link" supportName = "doubleAlarm" /&gt;</pre>

<h3 id="Alarm1">Alarm Support</h3>

<p>AlarmSupport is support for a field named "alarm" which must have type
structure and the structure must be an alarm structure. Within the structure
hierarchy of a record multiple alarm fields can exist. Some support, e.g.
generic, calls the support for the alarm field defined in the top level
structure (defined in common.xml). If multiple alarm fields reside in a
record then the top level alarm field, which is what the outside world
normally accesses has a severity at least as great as any of the lower level
alarms.</p>
<pre>    interface AlarmSupport extends Support{
        void beginProcess();
        void endProcess();
        boolean setAlarm(String message, AlarmSeverity severity);
    }

    class AlarmFactory {
        public static Support create(DBStructure dbStructure);
        public static AlarmSupport findAlarmSupport(DBField startDBField);
    }</pre>

<p>AlarmSupport provides the methods:</p>
<dl>
  <dt style="font-family: courier;">Support</dt>
    <dd>Standard support methods..</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>This is called when a record begins processing.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>This is called when a record finishes processing.
      If setAlarm was not called since beginProcess was called than
      it makes sure that the severity is noAlarm. If the severity 
      and/or message was
      changed during record processing it calls postPut.</dd>
  <dt style="font-family: courier;">setAlarm</dt>
    <dd>While a record is processing and code, normally one of the support
      modules described below, can call setAlarm. This method changes the new
      message and severity only if the severity passed to setAlarm is greater
      than the current new severity or if this is the first call since the
      record started processing.</dd>
</dl>

<p>AlarmFactory provides the static methods:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create support for a alarm field. This is called by
    SupportCreation.</dd>
  <dt style="font-family: courier;">findAlarmSupport</dt>
    <dd>Find an alarm field looking up the structure hierarchy. Return it or
      retrurn null if none is found.</dd>
</dl>

<h3 id="Value">Value Alarms</h3>

<p>Support is provided for alarms for the following types of fields: boolean,
numeric, and digital.</p>

<h4 id="Boolean">Boolean Alarms</h4>
<pre>    public class BooleanAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>This provides support for reporting alarms for boolean fields. The
configurationStructure must be a structure booleanAlarm, which has the
fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">falseAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is false.</dd>
  <dt style="font-family: courier;">trueAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is true.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h4 id="Numeric">Numeric Alarms</h4>
<pre>    public class ByteAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class ShortAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class IntAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class LongAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class FloatAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class DoubleAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>The above factories provide alarm support for the associated type of
field, e.g. FloatAlarmFactory provides alarm support for a field of type
float. The support for each type except that float and double also support
hystersis, which is described below. Each has two associated xml structure
definitions. For example the definitions for double are:</p>
<pre>&lt;structure name = "doubleAlarmInterval"&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>The first structure defines an interval for alarm checking. It has the
fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>The upper bound for a value.</dd>
  <dt style="font-family: courier;">severity</dt>
    <dd>The alarm severity for a value that falls into this interval.</dd>
</dl>

<p>The second structure has the following fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">interval</dt>
    <dd>A array of intervals. When the process method of value alarm support
      is called it looks for the interval for the current value. It starts
      with the first interval and continues until it finds an interval such
      that value&lt;=interval.value. This determines the alarm severity.</dd>
  <dt style="font-family: courier;">outOfRange</dt>
    <dd>The alarm severity if no interval is found.</dd>
  <dt style="font-family: courier;">hystersis</dt>
    <dd>If value goes into alarm this is the amount it must come out of alarm
      before the alarm severity is modified. This prevents alarm
    "chatter".</dd>
</dl>

<h4 id="Digital">Digital Alarms</h4>
<pre>    public class DigitalAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>The above factory provides support for an enum field. It has a associated
xml structure:</p>
<pre>&lt;structure name = "digitalAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
     &lt;!-- each array element must have menuName  alarmSeverity --&gt;
    &lt;field name = "stateSeverity" type = "array" elementType = "menu" design = "false" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<p>The structure has the following fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">stateSeverity</dt>
    <dd>An array of stateSeverity alarmSeverity menu definitions. When the
      process method is called the value field is the index for this array.
      The corresponding alarmSeverity menu is found and it determines the
      alarm severity.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Linear">Linear Conversion</h2>
<hr />

<p>Support is available for input and output linear conversions. The xml
definitions for linear conversions are:</p>
<pre>&lt;structure name = "linearConvert" &gt;
    &lt;field name = "engUnitsLow" type = "double" /&gt;
    &lt;field name = "engUnitsHigh" type = "double" /&gt;
    &lt;field name = "deviceHigh" type = "int" /&gt;
    &lt;field name = "deviceLow" type = "int" /&gt;
    &lt;field name = "slope" type = "double" /&gt;
    &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;
  

&lt;structure name = "linearConvertInput" supportName = "linearConvertInput"&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert" type = "structure" structureName = "linearConvert" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertOutput" supportName = "linearConvertOutput"&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert" type = "structure" structureName = "linearConvert" /&gt;
    &lt;field name = "output" type = "link" /&gt;
&lt;/structure&gt;

&lt;support name = "linearConvertInput"
    factoryName = "org.epics.ioc.support.LinearConvertInputFactory"
/&gt;

&lt;support name = "linearConvertOutput"
    factoryName = "org.epics.ioc.support.LinearConvertOutputFactory"
/&gt;</pre>

<p>A structure or recordType that implemnts linear conversion for input must
define a field as follows:</p>
<pre>&lt;field name = "input" type = "structure" structureName = "linearConvertInput"/&gt;</pre>

<p>A structure or recordType that implemnts linear conversion for output must
define a field as follows:</p>
<pre>&lt;field name = "output" type = "structure" structureName = "linearConvertOutput"/&gt;</pre>

<h3 id="linearConv">linearConversion</h3>

<p>The structure linearConversion defines the fields used for linear
conversions. The fields slope and intercept are the values used to convert a
rawValue to engineering units. The rawValue is an integer value usually read
from an ADC (Analog to Digital Convertor). The slope and intercept can be
specified directly of calculated from the low and high engineering and device
values. If the later method is chosen the engUnitsLow and engUnitsHigh must
be provided. deviceLow and deviceHigh are either provided automatically by
support of must be provided. The following are the fields in structure
lineraConversion:</p>
<dl>
  <dt style="font-family: courier;">engUnitsLow</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceHigh.</dd>
  <dt style="font-family: courier;">engUnitsHigh</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceLow.</dd>
  <dt style="font-family: courier;">deviceHigh</dt>
    <dd>An int equal to the maximum value for the rawValue.</dd>
  <dt style="font-family: courier;">deviceLow</dt>
    <dd>An int equal to the minimum value for the rawValue.</dd>
  <dt style="font-family: courier;">slope</dt>
    <dd>The slope for the linear conversion.</dd>
  <dt style="font-family: courier;">intercept</dt>
    <dd>The intercept for the linear conversion.</dd>
</dl>

<h3 id="LinearConv">LinearConvertInputFactory</h3>
<pre>    public class LinearConvertInputFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is the factory that implements linear input conversion, i.e. it
converts a rawValue to engineering units. A field for linear conversion for
input is a structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>The link for reading the rawValue. If a field named "input" is
      defined and has support the support is called.</dd>
</dl>

<h3 id="LinearConv1">LinearConvertOutputFactory</h3>
<pre>    public class LinearConvertOutputFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is the factory that implements linear output conversion, i.e. it
converts a value in engineering units to a rawValue. A field for linear
conversion for output is a structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">output</dt>
    <dd>The link for reading the rawValue. If a field named "output" is
      defined and has support the support is called.</dd>
</dl>

<h3 id="DeviceLimi">DeviceLimit</h3>
<pre>    public interface DeviceLimit {
        void get(DBField low, DBField high);
    }</pre>

<p>This is a convenience class for accessing a structure that has two fields:
"low" and "high".</p>
<hr />

<h2 style="text-align: center" id="Digital1">Digital Support</h2>
<hr />

<p>This is support for a record or structure that supports digital I/O, i.e.
a set of states, an integer register, and a mask that selects bits from the
register.</p>

<h3 id="Database">Database Definitions</h3>

<p>The support uses the following definitions:</p>
<pre>    &lt;structure name=digitalState&gt;
        &lt;field name=name type=string /&gt;
        &lt;field name=value type=int /&gt;
        &lt;field name=severity type=menu menuName=alarmSeverity /&gt;
    &lt;/structure&gt;

    &lt;structure name = "digitalIO" supportName = "digital"&gt;
        &lt;!-- structureName must be digitalState --&gt;
        &lt;field name = "states" type = "array" elementType = "structure" /&gt;
        &lt;field name = "numberOfBits" type = "int" /&gt;
        &lt;field name = "registerValue" type = "int" design = "false" /&gt;
        &lt;field name = "input" type = "link" /&gt;
        &lt;field name = "valueAlarm" type = "link" supportName = "digitalAlarm" /&gt;
        &lt;field name = "output" type = "link" /&gt;
    &lt;/structure&gt;</pre>

<p>In addition a value field which must be an enum must be defined.</p>

<h3 id="Java">Java Definitions</h3>
<pre>    public class DigitalFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>During initialization it sets the array of choices for the value field. It
uses the name fields in the states array to create the choices.</p>

<p>When the process method is called it does the following:</p>
<ul>
  <li>If input has support it is called to put a new value in
  registerValue.</li>
  <li>Gets a new value from the registerValue field.</li>
  <li>The value is anded with the mask created from the low order
    numberOfBits of the registerValue.</li>
  <li>It compares the new value with the values in the array of states. If a
    match occurs it determines the new index for the value field.</li>
  <li>Calls support for valueAlarm.</li>
  <li>Calls support for output.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Incrementa">Incremental Support</h2>
<hr />

<p>This is support for incremental outputs.For example it supports the
aoIncrementalOutut record.</p>

<p>This uses the Java definitions:</p>
<pre>    public interface IncrementalSupport extends Support{
        void setDesiredField(DBField dbField);
    }

    public class IncrementalFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This supports the following fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>The value field.</dd>
  <dt style="font-family: courier;">desiredValue</dt>
    <dd>This must be a double field. It can either be a field named
      "desiredValue" in the record or structure being supported or it can be
      a field passed as an argument to the double support setDesiredField
      method. When this field changes the support changes the value field
      until it has the desired value. If control limits are specified then
      the desired value is forced to be within the control limits. If
      incrementalOutput is true then each time the record is processed the
      value field is changed by rateOfChange until the desired value is
      reached.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>If this field exists and has support it is called to get the
      desiredValue.</dd>
  <dt style="font-family: courier;">controlLimit</dt>
    <dd>This field is optional. If present it must be a structure that has
      two double fields named "low" and "high". If the low value is strictly
      less that the high value then limits are enforced, i.e. the desired
      value is forced to be within the control limits.</dd>
  <dt style="font-family: courier;">incrementalOutput</dt>
    <dd>This field is optional. If the record/structure has a field named
      "incrementalOutput" then it must be have type boolean. If not present
      the default is true. If this has the value true the output is adjusted
      by rateOfChange otherwise the value field is changed in one step to the
      desired value.</dd>
  <dt style="font-family: courier;">rateOfChange</dt>
    <dd>If incrementalOutput is true this is the amount the value will change
      each time the record is processed.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Calculatio">Calculation Support</h2>
<hr />

<p>Support is provided for performing calculations. Currently there is no
generic calculation support similar to calcPerform.c that is part of EPICS
V3. A calculation support module could be implemented that provides similar
functionality. A support module is available for field calcArgArray. A
structure that supports calculations normally has the fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>It can either be a field named "value" in the record or structure
      being supported or it can be a field passed as an argument to the
      support setField method. This field is assigned a value by the
      calculation module and must have a type compatible with the calculator.
    </dd>
  <dt style="font-family: courier;">calcArgArray</dt>
    <dd>The calcArgArray field is normally an array of structures with each
      element being a calcArg structure and the support for calcArgArray is
      the calcArgArray support described in
      org.epics.ioc.support.CalcArgArraySupport. This field must be present
      and must have support. The support must complete before the support for
      calculator is called.</dd>
  <dt style="font-family: courier;">calculator</dt>
    <dd>This field is normally a link that has support that implements the
      calculation. org.epics.ioc.support.CounterCalculationFactory provides
      an example. This field must be present and must have support. The
      support must complete before the support for valueAlarm is called.</dd>
</dl>

<h3 id="Database1">Database Definitions for Calculations</h3>

<p>This is example support for use with the calcDouble record or structure.
File calcDoubleCommon.xml defines the fields:</p>
<pre>&lt;DBDefinition&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "calcArgArray" type = "array"
         elementType = "structure" supportName = "calcArgArray" /&gt;
    &lt;field name = "calculator" type = "link" /&gt;
    &lt;field name = "valueAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>Field calcDoubleRecord.xml defines:</p>
<pre>&lt;structure name = "calcArg" &gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "name" type = "string" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;

&lt;structure name = "calcDouble" supportName = "calcDoubleRecord" &gt;
    &lt;include href = "calcDoubleCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "calcDouble" supportName = "calcDoubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;include href = "calcDoubleCommon.xml" /&gt;
&lt;/recordType&gt;

&lt;support name = "calcDoubleRecord"
   factoryName = "org.epics.ioc.recordSupport.CalcDoubleFactory" /&gt;</pre>

<p>The following support is defined in support.xml</p>
<pre>&lt;support name = "calcArgArray"
   factoryName = "org.epics.ioc.support.CalcArgArrayFactory" /&gt;</pre>

<h3 id="Performing">Performing Calculations</h3>

<p>A calculation is performed by a calculation link support. The following is
done. When the calcRecord support is called it calls the calcArgArray support
and when it completes the calculation link support. For each element if the
calcArgArray, the calcArgArray support calls the input link support (if it is
specified) to get the calcArg value. The calculation support uses the
calcArgArray values to compute the calculated value. At present generic
calculation support is not implemented. It is envisioned that it will allow
the user to enter expressions like "voltage*current". The calcArgArray would
have two elements with calcArg.name set to "voltage" and "current".</p>

<h3 id="calcArgArr">calcArgArray</h3>

<p>The support for a calcArgArray implements support for an array of calcArg
structures, which has the fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>A value for this argument.</dd>
  <dt style="font-family: courier;">name</dt>
    <dd>A string which provides a name for the argument.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>A link for obtaining the value for this argument. Note that if no
      support is specified then no input is read and the value field can just
      be set by the user.</dd>
</dl>

<p>calcArgArray uses the following definitions:</p>
<pre>    public interface CalcArgArraySupport extends Support{
        PVField getPVField(String argName);
    }

    public class CalcArgArrayFactory {
        public static Support create(DBField dbField);
    }</pre>

<p>CalcArgArraySupport extends Support to provide the method:</p>
<dl>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>This is a convience metod for calculator support. It looks in the
      calcArgArray for a field with the specified name and returns it's
      interface.</dd>
</dl>

<h3 id="Calculator">Calculator</h3>

<p>Support for a calculation field, which is a link, must implement:</p>
<pre>    public interface CalculatorSupport extends LinkSupport {
        void setCalcArgArraySupport(CalcArgArraySupport calcArgArraySupport);
    }</pre>

<p>CalculatorSupport extends LinkSupport to add the method:</p>
<dl>
  <dt style="font-family: courier;">setCalcArgArraySupport</dt>
    <dd>This is called by calcDoubleRecord support.</dd>
</dl>

<h3 id="CounterCal">CounterCalculatorFactory</h3>

<p>An example calculation support is provided as part of javaIOC. It is:</p>
<pre>public class CounterCalculatorFactory {

    public static LinkSupport create(DBLink dbLink) {
        return new CounterCalculatorImpl(dbLink);
    }

    private static String supportName = "counterCalculator";

    private static class CounterCalculatorImpl extends AbstractLinkSupport
    implements CalculatorSupport
    {
        private PVLink pvLink;
        private CalcArgArraySupport calcArgArraySupport = null;
        private DBField valueDBField;
        private PVDouble valuePVField= null;;
        private PVDouble minPVField = null;
        private PVDouble maxPVField = null;
        private PVDouble incPVField = null;

        private CounterCalculatorImpl(DBLink dbLink) {
            super(supportName,dbLink);
            pvLink = dbLink.getPVLink();
        }

        public void initialize() {
            if(!super.checkSupportState(SupportState.readyForInitialize,supportName)) return;
            if(valuePVField==null) {
                pvLink.message("setField was not called", MessageType.error);
                return;
            }
            PVField pvField = calcArgArraySupport.getPVField("min");
            if(pvField==null) {
                pvLink.message("field min not found", MessageType.error);
                return;
            }
            if(pvField.getField().getType()!=Type.pvDouble) {
                pvLink.message("field min is not double", MessageType.error);
                return;
            }
            minPVField = (PVDouble)pvField;
            pvField = calcArgArraySupport.getPVField("max");
            if(pvField==null) {
                pvLink.message("field max not found", MessageType.error);
                return;
            }
            if(pvField.getField().getType()!=Type.pvDouble) {
                pvLink.message("field max is not double", MessageType.error);
                return;
            }
            maxPVField = (PVDouble)pvField;
            pvField = calcArgArraySupport.getPVField("inc");
            if(pvField==null) {
                pvLink.message("field inc not found", MessageType.error);
                return;
            }
            if(pvField.getField().getType()!=Type.pvDouble) {
                pvLink.message("field inc is not double", MessageType.error);
                return;
            }
            incPVField = (PVDouble)pvField;
            setSupportState(SupportState.readyForStart);

        }

        public void process(SupportProcessRequester supportProcessRequester) {
            double value = valuePVField.get();
            double min = minPVField.get();
            double max = maxPVField.get();
            double inc = incPVField.get();
            value += inc;
            if(inc&gt;0) {
                if(value&gt;max) value = min;
                if(value&lt;min) value = min;
            } else {
                if(value&lt;min) value = max;
                if(value&gt;max) value = max;
            }
            valuePVField.put(value);
            valueDBField.postPut();
            supportProcessRequester.supportProcessDone(RequestResult.success);
        }

        public void setField(DBField dbField) {
            valueDBField = dbField;
            valuePVField = (PVDouble)dbField.getPVField();
        }

        public void setCalcArgArraySupport(CalcArgArraySupport calcArgArraySupport) {
            this.calcArgArraySupport = calcArgArraySupport;
        }
    }
}</pre>

<h3 id="ArrayIncre">ArrayIncrementCalculatorFactory</h3>
<pre>    public class ArrayIncrementCalculatorFactory {
        `public static LinkSupport create(DBLink dbLink);
    }</pre>

<p>This is support for testing. It supports numeric array fields. Each time
process is called it just incrememnts each element of the array.</p>

<h3 id="BooleanArr">BooleanArrayToggleCalculatorFactory</h3>
<pre>    public class BooleanArrayToggleCalculatorFactory {
        public static LinkSupport create(DBLink dbLink);
    };</pre>

<p>This is support for testing. It supports boolean array fields. Each time
process is called it just toggles each element of the array, if the value us
false it becomes true and if true becomes false.</p>
<hr />

<h2 style="text-align: center" id="Event">Event Support</h2>
<hr />
<pre>    public class EventFactory {
        public static Support create(DBField dbField);
    }</pre>

<p>EventFactory implements record or structure support for announcing a scan
event. The event name is given in the field:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>This must be a string field. It can either be a field named "value"
      in the record or structure being supported or it can be a field passed
      as an argument to the event support setField method.</dd>
</dl>

<p>Whenever the record is processed eventScanner.announce is called, i.e. the
support announces an event. All event scanned records with the event name
associated with the value field are processed. Each time process is called,
the event support checks to see if the event name has changed.</p>
<hr />

<h2 style="text-align: center" id="CALink">CALink Support</h2>
<hr />
<pre>    public class CALinkFactory {
        public static LinkSupport create(DBLink dbLink);
    }</pre>

<p>This is a factory that provides an implementation of link support for the
following:</p>
<dl>
  <dt>processLink</dt>
    <dd>Support for a link that requests that another record process without
      transfering any data.</dd>
  <dt>inputLink</dt>
    <dd>Support for a link that 1) optionally requests that another record
      process, and 2) transfers data from the other record to the record
      containing the link.</dd>
  <dt>outputLink</dt>
    <dd>Support for a link that 1) transfers data to another record, and 2)
      optionally requests that the other record process.</dd>
  <dt>monitorLink</dt>
    <dd>Support for monitoring another record. A monitor returns data.</dd>
  <dt>monitorNotifyLink</dt>
    <dd>Support for monitoring another record. A monitor does not return
    data.</dd>
</dl>

<p>Each requires that other support code, e.g. record support knows how to
call them. In addition the code that calls them must call
linkSupport.setField for inputLink, outputLink, and monitorLink.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.ioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the link pvname.</dd>
</dl>

<p>Look at the menu and structure definitions in menuStructureSupportDBD for
a description of how the various links are defined.</p>
<hr />

<h2 style="text-align: center;" id="LinkArray">LinkArray Support</h2>
<hr />
<pre>    public class LinkArrayFactory {
        public static Support create(DBField dbField);
    }</pre>

<p>This is a factory that provides support for an array of links. The
supportName is linkArray. Each array element, which must have element type
link, can be reference any support that implements LinkSupport.</p>

<p>For example any record support could optionally support a field called
process, which is an array of process links. When the record instance
completes processing, it can request the the support for the process field
process. Support for an output record would allow process and output links.
Many other possibilities are possible.</p>
<hr />

<h2 style="text-align: center;" id="Link">Link Support</h2>
<hr />
<pre>    public class LinkFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is support for a structure that has a single field which must be a
link. It's purpose is the allow link support to be attached to a field that
can be a structure but in a record instance only a link is desired.</p>
<hr />

<h2 style="text-align: center" id="Noop">Noop Support</h2>
<hr />
<pre>    public class NoopFactory {
        public static Support create(DBStructure dbStructure);
        public static Support create(DBField dbField);
        public static LinkSupport create(DBLink dbLink);
    }</pre>

<p>This can be used for record types that just hold data. It can also be used
to provide support for any field. The support acts as though it is
synchronous. All Support or LinkSupport methods are implemented by just
extending AbstractSupport or AbstractLinkSupport without overriding any
methods.</p>
<hr />

<h2 style="text-align: center;" id="DelayLink">DelayLink Support</h2>
<hr />

<p>This is link support that simulates asynchronous support. It uses a
configStructure that has the definition:</p>
<pre>&lt;structure name = "delayLink"&gt;
    &lt;!-- min, max, inc are delay in milliseconds --&gt;
    &lt;field name = "min" type = "long" /&gt;
    &lt;field name = "max" type = "long" /&gt;
    &lt;field name = "inc" type = "long" /&gt;
&lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">min</dt>
    <dd>The minimum delay</dd>
  <dt style="font-family: courier;">max</dt>
    <dd>The maximum delay</dd>
  <dt style="font-family: courier;">inc</dt>
    <dd>The delay increment between process requests</dd>
</dl>

<p>Each time process is called it delays a number of milliseconds determined
by min,max, and inc. It starts with a delay on min. Each time it proceses it
increases the delay by inc until it reaches max. It then goes back to a delay
of min.</p>

<p>The factory definition is:</p>
<pre>    public class DelayLinkFactory {
        public static LinkSupport create(DBLink dbLink);
    }</pre>
<hr />

<h2 style="text-align: center" id="Port">Port Driver Support</h2>
<hr />

<p>This section describes the support for connecting database fields to
portDriver.</p>

<h3 id="Java1">Java Definitions</h3>

<p>The following are the interface, abstract support, and factories for
portDriver support..</p>
<pre>    public interface PDRVLinkSupport extends LinkSupport {
        boolean isProcess();
        abstract void queueCallback();
    }

    public class PDRVLinkFactory {
        public static LinkSupport create(DBLink dbLink);
    }
    
    public abstract class AbstractPDRVLinkSupport extends AbstractLinkSupport implements
    ProcessContinueRequester,QueueRequestCallback,
    PDRVLinkSupport,
    RecordProcessRequester
    {
        protected AbstractPDRVLinkSupport(String supportName,DBLink dbLink);
        protected String supportName;
        protected DBLink dbLink;
        protected PVLink pvLink;
        protected DBField valueDBField = null;
        protected PVField valuePVField = null;
        protected DBRecord dbRecord = null;
        protected PVRecord pvRecord = null;
        protected String recordName = null;
        protected String fullName = null;
        protected RecordProcess recordProcess = null;
    
        protected AlarmSupport alarmSupport = null;
        protected PVStructure configStructure = null;;
        protected PVString pvPortName = null;
        protected PVInt pvAddr = null;
        protected PVInt pvMask = null;
        protected PVInt pvSize = null;
        protected PVDouble pvTimeout = null;
        protected PVBoolean pvProcess = null;
        protected PVString pvDrvParams = null;
    
        protected User user = null;
        protected Port port = null;
        protected Device device = null;
        protected Trace portTrace = null;
        protected Trace deviceTrace = null;
    
        protected DriverUser driverUser = null;
    
        protected SupportProcessRequester supportProcessRequester = null;
        public void initialize();
        public void uninitialize();
        public void start();
        public void stop();
        public void process(SupportProcessRequester supportProcessRequester);
        public void setField(DBField dbField);
        public void message(String message,MessageType messageType);
        public void processContinue();
        public void callback(Status status, User user);
        public boolean isProcess();
        public void queueCallback();
        public void recordProcessComplete();
        public void recordProcessResult(RequestResult requestResult)
    }

    public class PDRVPortCreateFactory {
        public static Support create(DBStructure dbStructure);
    }

    public class PDRVPortDeviceControlFactory {
        public static Support create(DBStructure dbStructure)
    }</pre>

<h3 id="PDRVLinkSu">PDRVLinkSupport</h3>

<p>This defines the two methods:</p>
<dl>
  <dt style="font-family: courier;">isProcess</dt>
    <dd>If the support is interrupt driver should it process the record. The
      answer will be true only if: 
      <ol>
        <li>The constructor for AbstractPDRVLinkSupport is called with
          interruptOK true</li>
        <li>pdrvLink.interrupt is true.</li>
        <li>The support is the record processor.</li>
      </ol>
    </dd>
  <dt style="font-family: courier;">queueCallback</dt>
    <dd>A method that must be implemented by all asynchronous support. his
      probably means all support except interrupt listeners. </dd>
</dl>

<h3 id="AbstractPD">AbstractPDRVLinkSupport</h3>

<p>This implements muck of the work involved in connecting and managing the
connection to a port and device. Look at some of the code in PDRVLinkFactory
for how to use the abstract support.</p>

<h3 id="PDRVLinkFa">PDRVLinkFactory</h3>

<p>This implements all of the link support defined in the dbd/pdrv.xml
file.</p>
<pre>&lt;structure name = "pdrvLink"&gt;
    &lt;field name = "portName" type = "string" /&gt;
    &lt;field name = "addr" type = "int" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
    &lt;field name = "mask" type = "int" /&gt;
    &lt;field name = "size" type = "int" /&gt;
    &lt;field name = "process" type = "boolean" default = "false" /&gt;
    &lt;field name = "drvParams" type = "string" /&gt;
&lt;/structure&gt;

&lt;linkSupport name = "pdrvOctetInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvOctetInterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvOctetOutput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;linkSupport name = "pdrvInt32Input"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvInt32InterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvInt32AverageInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvInt32Output"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;linkSupport name = "pdrvInt32ArrayInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvInt32ArrayInterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvInt32ArrayOutput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;linkSupport name = "pdrvFloat64Input"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvFloat64InterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvFloat64AverageInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvFloat64Output"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;linkSupport name = "pdrvFloat64ArrayInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvFloat64ArrayInterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvFloat64ArrayOutput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;linkSupport name = "pdrvUInt32DigitalInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvUInt32DigitalInterruptInput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;linkSupport name = "pdrvUInt32DigitalOutput"
    configurationStructureName = "pdrvLink" 
    factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;</pre>

<h3 id="PDRVPortCr">PDRVPortCreateFactory</h3>

<p>This implements support for the portRecord which has the definition:</p>
<pre>&lt;recordType name = "port" supportName = "portRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;field name = "factoryName" type = "string" /&gt;
    &lt;field name = "portName" type = "string" /&gt;
    &lt;field name = "autoConnect" type = "boolean" default = "true" /&gt;
    &lt;field name = "priority" type = "menu" menuName = "priority" /&gt;
    &lt;field name = "driverParameters" type = "structure" structureName = "null"/&gt;
&lt;/recordType&gt;

&lt;support name = "portCreate"
   factoryName = "org.epics.ioc.support.PDRVPortCreateFactory" /&gt;</pre>

<p>This is support for a record or structure that initializes a portDriver
port.</p>

<h3 id="PDRVPortDe">PDRVPortDeviceControlFactory</h3>

<p>This implements support for the portDeviceControl which has the
definition:</p>
<pre>&lt;recordType name = "portDeviceControl" supportName = "portDeviceControl" &gt;
    &lt;field name = "message" type = "string" /&gt;
    &lt;field name = "portDevice" type = "string" /&gt;
    &lt;field name = "connect" type = "menu" menuName = "connectDisconnect" /&gt;
    &lt;field name = "enable" type = "menu" menuName = "enableDisable" /&gt;
    &lt;field name = "autoConnect" type = "boolean" /&gt;
    &lt;field name = "traceMask" type = "int" /&gt;
    &lt;field name = "traceIOMask" type = "int" /&gt;
    &lt;field name = "report" type = "int" /&gt;
&lt;/recordType&gt;

&lt;support name = "portDeviceControl"
   factoryName = "org.epics.ioc.support.PDRVPortDeviceControlFactory" /&gt;</pre>
<hr />

<h2 style="text-align: center" id="Power">Power Supply Support</h2>
<hr />
<pre>    public class PowerSupplyFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is an example of support for a "device". Given a voltage and power to
computes the current. It supports fields for reading the voltage and for
writing the current. The complete set of fields it suppports are:</p>
<dl>
  <dt style="font-family: courier;">voltage</dt>
    <dd>This is required. The record/structure must have a field named
      "voltage" and the field type must be double.</dd>
  <dt style="font-family: courier;">current</dt>
    <dd>This is required. The record/structure must have a field named
      "current" and the field type must be double.</dd>
  <dt style="font-family: courier;">power</dt>
    <dd>This is required. The record/structure must have a field named
      "power" and the field type must be double.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>This is optional. If the record/structure has a field named "input"
      and, if that field has associated support, the support is called. The
      power field is passed to support.setField. The input support must
      complete processing before the power is computed.</dd>
  <dt style="font-family: courier;">voltageInput</dt>
    <dd>This is optional. If the record/structure has a field named
      "voltageInput" and, if that field has associated support, the support
      is called. The voltage field is passed to support.setField. The support
      must complete processing before the power is computed.</dd>
  <dt style="font-family: courier;">valueAlarm</dt>
    <dd>This is optional. If the record/structure has a field named
      "valueAlarm" and, if that field has associated support, the support is
      called after the power is computed. The power field is passed to
      support.setField. The valueAlarm support must complete processing
      before currentOutput support is called.</dd>
  <dt style="font-family: courier;">currentOutput</dt>
    <dd>This is optional. If the record/structure has a field named
      "currentOutput" and, if that field has associated support, the support
      is called. The current field is passed to support.setField. The support
      must complete processing before linkArray support is called.</dd>
  <dt style="font-family: courier;">linkArray</dt>
    <dd>This is optional. If the record/structure has a field named
      "linkArray" and, if that field has associated support, the support is
      called. The value field is passed to support.setField. When linkArray
      support completes double support completes processing.</dd>
</dl>
</body>
</html>
