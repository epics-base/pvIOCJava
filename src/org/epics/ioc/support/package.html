<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: support</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: support<br />
package: org.epics.ioc.support<br />
2007.07.11</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Support">Support</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#SupportSta">SupportState</a></li>
      <li><a href="#Support1">Support</a></li>
      <li><a href="#LinkSuppor">LinkSupport</a></li>
      <li><a href="#AbstractSu">AbstractSupport</a></li>
    </ul>
  </li>
  <li><a href="#ScanSuppor">ScanSupport</a></li>
  <li><a href="#Alarm">Alarm Support</a>
    <ul>
      <li><a href="#Alarm1">Alarm Support</a></li>
      <li><a href="#Value">Value Alarms</a>
        <ul>
          <li><a href="#Boolean">Boolean Alarms</a></li>
          <li><a href="#Numeric">Numeric Alarms</a></li>
          <li><a href="#Digital">Digital Alarms</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Linear">Linear Conversion</a>
    <ul>
      <li><a href="#linearConv">linearConversion</a></li>
      <li><a href="#LinearConv">LinearConvertInputFactory</a></li>
      <li><a href="#LinearConv1">LinearConvertOutputFactory</a></li>
      <li><a href="#DeviceLimi">DeviceLimit</a></li>
    </ul>
  </li>
  <li><a href="#Noop">Noop Support</a></li>
  <li><a href="#CALink">CALink Support</a></li>
  <li><a href="#LinkArray">LinkArray Support</a></li>
  <li><a href="#Link">Link Support</a></li>
  <li><a href="#DelayLink">DelayLink Support</a></li>
  <li><a href="#Double">Double Calculation Support</a>
    <ul>
      <li><a href="#Performing">Performing Calculations</a></li>
      <li><a href="#calcArgArr">calcArgArray</a></li>
      <li><a href="#Calculator">Calculator</a></li>
    </ul>
  </li>
  <li><a href="#ArrayIncre">ArrayIncrementCalculatorFactory</a></li>
  <li><a href="#BooleanArr">BooleanArrayToggleCalculatorFactory</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package provides interfaces and classes for processing fields of IOC
database records. It defines the following interfaces:</p>
<dl>
  <dt>Support</dt>
    <dd>The interfaces and classes that provide the core for support.</dd>
  <dt>LinkSupport</dt>
    <dd>An extension of Support for link fields.</dd>
  <dt>ScanSupport</dt>
    <dd>An extension of Support for field scan.</dd>
  <dt>AlarmSupport</dt>
    <dd>An extension of Support for field alarm.</dd>
  <dt>CalculatorSupport</dt>
    <dd>An extension of Support for field calculations.</dd>
  <dt>CalcArgArraySupport</dt>
    <dd>An extension of Support for the arguments for calculations;</dd>
  <dt>DeviceLimit</dt>
    <dd>defines a method implemented by support for analog I/O.</dd>
</dl>

<p>The following abstract classes are provided for implementing support:</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>A base class that is extended by most support code. It implements all
      of the Support methods.</dd>
  <dt>AbstractLinkSupport</dt>
    <dd>A base class that extends AbstractSupport to also implement
      LinkSupport.</dd>
</dl>

<p>The following factories are provided:</p>
<dl>
  <dt>ScanFactory</dt>
    <dd>Complete support for the scan field.</dd>
  <dt>AlarmFactory</dt>
    <dd>Complete support for an alarm field.</dd>
  <dt>BooleanAlarmFactory</dt>
    <dd>Alarm support for boolean fields.</dd>
  <dt>ByteAlarmFactory</dt>
    <dd>Alarm support for byte fields.</dd>
  <dt>ShortAlarmFactory</dt>
    <dd>Alarm support for short fields.</dd>
  <dt>IntAlarmFactory</dt>
    <dd>Alarm support for int fields.</dd>
  <dt>LongAlarmFactory</dt>
    <dd>Alarm support for long fields.</dd>
  <dt>FloatAlarmFactory</dt>
    <dd>Alarm support for float fields.</dd>
  <dt>DoubleAlarmFactory</dt>
    <dd>Alarm support for double fields.</dd>
  <dt>DigitalAlarmFactory</dt>
    <dd>Alarm support for enum fields.</dd>
  <dt>CALinkFactory</dt>
    <dd>Support for channel access links.</dd>
  <dt>LinearConvertInputFactory</dt>
    <dd>Support for linear conversion of input fields.</dd>
  <dt>LinearConvertOutputFactory</dt>
    <dd>Support for linear conversion of output fields.</dd>
  <dt>ArrayIncrementCalculatorFactory</dt>
    <dd>Support for testing array fields.</dd>
  <dt>LinkArrayFactory</dt>
    <dd>Support for an array of links.</dd>
  <dt>CalcArgArrayFactory</dt>
    <dd>Support for an array of arguments for calculation records.</dd>
  <dt>LinkFactory</dt>
    <dd>Support for a structure that consists of a single link.</dd>
  <dt>NoopFactory</dt>
    <dd>Support for all fields that just acts like it always succeeds
      successfully.</dd>
  <dt>DelayLinkFactory</dt>
    <dd>Support for testing. It just causes an asynchronous delay before
      completing successfully.</dd>
  <dt>BooleanArrayToggleCalculatorFactory</dt>
    <dd>Test support for a boolean array.</dd>
  <dt>CounterCalculatorFactory</dt>
    <dd>Test code for a numeric field.</dd>
  <dt>ArrayIncrementCalculatorFactory</dt>
    <dd>Test code for numeric array fields.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Support">Support</h2>
<hr />

<p>This section describes the interfaces and abstract base class involved
with support for fields of an IOC record. This also applys to the support for
the record itself.</p>

<h3 id="Definition">Definitions</h3>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>    // SupportState is defined in org.epics.ioc.process
    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public interface Support extends Requester {
        SupportState getSupportState();
        DBField getDBField();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
        void setField(DBField dbField);
    }

    public interface LinkSupport extends Support {
        PVStructure getConfigStructure(String structureName, boolean reportFailure);
    }


    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,DBField dbField);
        // methods from Requester
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public DBField getDBField();
        // following normally overridden
        public void initialize();
        public void start();
        public void stop();
        public void uninitialize();
        public void process(SupportProcessRequester supportProcessRequester);
        public void setField(DBField dbField);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following is for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
    }

    public class AbstractLinkSupport extends AbstractSupport implements LinkSupport{
        protected AbstractLinkSupport(String name,DBField dbField);
        public PVStructure getConfigStructure(String structureName, boolean reportFailure);
    }</pre>

<h3 id="SupportSta">SupportState</h3>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting
      to other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is going away.</dd>
</dl>

<h3 id="Support1">Support</h3>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>A requester method to get the name of the support.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>A Requester method. This is called to pass messages to the
    support.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Get the <span style="font-family: courier;">DBField</span> interface
      for the field that is being supported. For record support this will be
      the record itself. <span style="font-family: courier;"></span></dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
  <dt style="font-family: courier;">setField</dt>
    <dd>This specifies the field in the record to/from the support will
      put/get data.</dd>
</dl>

<h3 id="LinkSuppor">LinkSupport</h3>

<p><span style="font-family: courier;">LinkSupport</span> extends <span
style="font-family: courier;">Support</span> with the method:</p>
<dl>
  <dt style="font-family: courier;">getConfigStructure</dt>
    <dd>This gets the interface for the configuration structure for the
    link.</dd>
</dl>

<h3 id="AbstractSu">AbstractSupport</h3>

<p>All support code should extend AbstractSupport. Abstract Support
implements all Support methods. Thus support code only has to override the
methods it needs.</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
      constructor.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Calls dbField.message.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt style="font-family: courier;">getDBField</dt>
    <dd>Returns dbField.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Normally overridden. The default version just calls
      supportProcessRequester.supportProcessDone(RequestResult.success);</dd>
  <dt style="font-family: courier;">setField</dt>
    <dd>Does nothing.</dd>
  <dt style="font-family: courier;">setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt style="font-family: courier;">checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="ScanSuppor">ScanSupport</h2>
<hr />

<p>Support is provided for the scan field. This support is called by
recordProcess. The support handles all the fields in structure scan:</p>
<pre>&lt;structure name = "scan"&gt;
    &lt;field name = "priority" type = "menu" menuName = "priority" default = "middle" /&gt;
    &lt;field name = "scan" type = "menu" menuName = "scan" default = "passive" /&gt;
    &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
    &lt;field name = "eventName" type = "string" /&gt;
    &lt;field name = "processSelf" type = "boolean" /&gt;
&lt;/structure&gt;</pre>

<p>At initialization and whenever the scan, priority, rate, or eventName
fields are modified, the support interacts with the appropriate scanners to
add or remove the record from the scanner. If processSelf is set true, the
support implements ScanSupport.</p>

<p>IMPORTANT: RecordProcess provides the same methods as ScanSupport. Support
code must call the RecordProcess methods rather than calling the ScanSupport
methods.</p>

<p>The following definitions are provided:</p>
<pre>    public interface ScanSupport extends Support {
        boolean canProcessSelf();
        boolean processSelfRequest(RecordProcessRequester recordProcessRequester);
        void processSelfSetActive(RecordProcessRequester recordProcessRequester);
        void processSelfProcess(RecordProcessRequester recordProcessRequester,
            boolean leaveActive);
        void processSelfSetInactive(RecordProcessRequester recordProcessRequester);
    }
    public class ScanFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p><span style="font-family: courier;">ScanSupport</span>, which MUST only be
called by recordProcess, extends <span
style="font-family: courier;">Support</span> with the methods:</p>
<dl>
  <dt style="font-family: courier;">canScanSelf</dt>
    <dd>Can the record scan itself? This is true if scan.scanSelf is true. In
      this case scanSupport itself owns and processes the record.</dd>
  <dt style="font-family: courier;">processSelfRequest</dt>
    <dd>Request to process the record. This returns true if scanSupport is
      the record processor and the record is not active.</dd>
  <dt style="font-family: courier;">processSelfSetActive</dt>
    <dd>If processSelfRequest returns true this can be called to set the
      record active. This is called when user code wants to modify data in
      the record before calling processSelfProcess.</dd>
  <dt style="font-family: courier;">processSelfProcess</dt>
    <dd>If processSelfRequest returns true this can be called to process the
      record.</dd>
  <dt style="font-family: courier;">processSelfSetInactive</dt>
    <dd>If the call to processSelfProcess said to leave the record active,
      this is called to set the record inactive. This is done if the caller
      wants to read data from the record after processing.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Alarm">Alarm Support</h2>
<hr />

<p>Support is provided for the alarm field itself and alarm calculation for
boolean, int, and double fields. The following xml definiotions are involved
with alarms.</p>
<pre>&lt;structure name = "alarm"&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "message" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "byteAlarmInterval"&gt;
    &lt;field name = "value" type = "byte" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "byteAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortAlarmInterval"&gt;
    &lt;field name = "value" type = "short" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "shortAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "intAlarmInterval"&gt;
    &lt;field name = "value" type = "int" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "intAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "longAlarmInterval"&gt;
    &lt;field name = "value" type = "long" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "longAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatAlarmInterval"&gt;
    &lt;field name = "value" type = "float" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "floatAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleAlarmInterval"&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "booleanAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "falseAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "trueAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "digitalAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
     &lt;!-- each array element must have menuName  alarmSeverity --&gt;
    &lt;field name = "stateSeverity" type = "array" elementType = "menu" design = "false" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "digitalState"&gt;
    &lt;field name = "name" type = "string" /&gt;
    &lt;field name = "value" type = "int" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;


&lt;support name = "alarm"
    factoryName = "org.epics.ioc.support.AlarmFactory"
/&gt;

&lt;linkSupport name = "booleanAlarm"
    configurationStructureName = "booleanAlarm"
   factoryName = "org.epics.ioc.support.BooleanAlarmFactory" /&gt;

&lt;linkSupport name = "byteAlarm"
    configurationStructureName = "byteAlarm"
   factoryName = "org.epics.ioc.support.ByteAlarmFactory" /&gt;

&lt;linkSupport name = "shortAlarm"
    configurationStructureName = "shortAlarm"
   factoryName = "org.epics.ioc.support.ShortAlarmFactory" /&gt;

&lt;linkSupport name = "intAlarm"
    configurationStructureName = "intAlarm"
   factoryName = "org.epics.ioc.support.IntAlarmFactory" /&gt;

&lt;linkSupport name = "longAlarm"
    configurationStructureName = "longAlarm"
   factoryName = "org.epics.ioc.support.LongAlarmFactory" /&gt;

&lt;linkSupport name = "floatAlarm"
    configurationStructureName = "floatAlarm"
   factoryName = "org.epics.ioc.support.FloatAlarmFactory" /&gt;

&lt;linkSupport name = "doubleAlarm"
    configurationStructureName = "doubleAlarm"
   factoryName = "org.epics.ioc.support.DoubleAlarmFactory" /&gt;

&lt;linkSupport name = "digitalAlarm"
    configurationStructureName = "digitalAlarm"
   factoryName = "org.epics.ioc.support.DigitalAlarmFactory" /&gt;</pre>

<p>The field alarm is defined in common.xml and this is in every record. the
definition is:</p>
<pre>&lt;field name = "alarm" type = "structure" structureName = "alarm"
          supportName = "alarm" /&gt;</pre>

<p>Records or structures that support alarm processing for double fields
contain the definition:</p>
<pre>&lt;field name = "valueAlarm" type = "link" supportName = "doubleAlarm" /&gt;</pre>

<h3 id="Alarm1">Alarm Support</h3>

<p>AlarmSupport is support for a field names "alarm" which must have type
structure and the structure must be an alarm structure. Within the structure
hierarchy of a record multiple alarm fields can exist. RecordProcess calls
the support for the alarm field defined in the top level structure (defined
in common.xml). If other alarm fields are present AlarmSupport calls itself,
i.e. no code except RecordProcess and AlarmSupport should call the Support
methods of AlarmSupport. If multiple alarm fields reside in a record then the
top level alarm field, which is what the outside world normally accesses has
a severity at least as great as any of the lower level alarms.</p>
<pre>    interface AlarmSupport extends Support{
        void beginProcess();
        void endProcess();
        boolean setAlarm(String message, AlarmSeverity severity);
        void getAlarmStamp(AlarmStamp alarmStamp);
        String getMessage();
        AlarmSeverity getSeverity();
    }

    class AlarmFactory {
        public static Support create(DBStructure dbStructure);
        public static AlarmSupport findAlarmSupport(DBField startDBField);
    }</pre>

<p>AlarmSupport provides the methods:</p>
<dl>
  <dt style="font-family: courier;">Support</dt>
    <dd>As mentioned above only RecordProcess and AlarmSupport call the
      Support methods implemented by AlarmSupport.</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>This also is only called by RecordProcess or AlarmSupport. It is
      called when a record begins processing. It saves the current message
      and severity and initialize the new severity to no alarm and the new
      message to null.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>This also is only called by RecordProcess or AlarmSupport. It is
      called when a record finishes processing. If the new alarm severity
      and/or message are different than what they were when the record
      started processing, the alarm massage and severity are changed and the
      alarm field posted so that monitors are issued.</dd>
  <dt style="font-family: courier;">setAlarm</dt>
    <dd>While a record is processing and code, normally one of the support
      modules described below, can call setAlarm. This method changes the new
      message and severity only if the severity passed to setAlarm is greater
      than the current new severity or if this is the first call since the
      record started processing.</dd>
  <dt style="font-family: courier;">getAlarmStamp</dt>
    <dd>Sets the alarmStamp to the current new severity and message.</dd>
  <dt style="font-family: courier;">getMessage</dt>
    <dd>Returns the current new message.</dd>
  <dt style="font-family: courier;">getSeverity</dt>
    <dd>Returns the current new severity.</dd>
</dl>

<p>AlarmFactory provides the static methods:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create support for a alarm field. This is called by
    SupportCreation.</dd>
  <dt style="font-family: courier;">findAlarmSupport</dt>
    <dd>Find an alarm field looking up the structure hierarchy. Return it or
      retrurn null if none is found.</dd>
</dl>

<h3 id="Value">Value Alarms</h3>

<p>Support is provided for alarms for the following types of fields: boolean,
numeric, and digital.</p>

<h4 id="Boolean">Boolean Alarms</h4>
<pre>    public class BooleanAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>This provides support for reporting alarms for boolean fields. The
configurationStructure must be a structure booleanAlarm, which has the
fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">falseAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is false.</dd>
  <dt style="font-family: courier;">trueAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is true.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h4 id="Numeric">Numeric Alarms</h4>
<pre>    public class ByteAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class ShortAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class IntAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class LongAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class FloatAlarmFactory {
        public static Support create(DBLink dbLink);
    }
    public class DoubleAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>The above factories provide alarm support for the associated type of
field, e.g. FloatAlarmFactory provides alarm support for a field of type
float. The support for each type except that float and double also support
hystersis, which is described below. Each has two associated xml structure
definitions. For example the definitions for double are:</p>
<pre>&lt;structure name = "doubleAlarmInterval"&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm"&gt;
    &lt;field name = "active" type = "boolean" /&gt;
    &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
    &lt;field name = "outOfRange" type = "menu" menuName = "alarmSeverity" /&gt;
    &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>The first structure defines an interval for alarm checking. It has the
fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>The upper bound for a value.</dd>
  <dt style="font-family: courier;">severity</dt>
    <dd>The alarm severity for a value that falls into this interval.</dd>
</dl>

<p>The second structure has the following fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">interval</dt>
    <dd>A array of intervals. When the process method of value alarm support
      is called it looks for the interval for the current value. It starts
      with the first interval and continues until it finds an interval such
      that value&lt;=interval.value. This determines the alarm severity.</dd>
  <dt style="font-family: courier;">outOfRange</dt>
    <dd>The alarm severity if no interval is found.</dd>
  <dt style="font-family: courier;">hystersis</dt>
    <dd>Only present for float and double. If value goes into alarm this is
      the amount it must come out of alarm before the alarm severity is
      modified. This prevents alarm "chatter".</dd>
</dl>

<h4 id="Digital">Digital Alarms</h4>
<pre>    public class DigitalAlarmFactory {
        public static Support create(DBLink dbLink);
    }</pre>

<p>The above factory provides support for an enum field. It has a associated
xml structure:</p>
<pre>&lt;structure name = "digitalAlarm" &gt;
    &lt;field name = "active" type = "boolean" /&gt;
     &lt;!-- each array element must have menuName  alarmSeverity --&gt;
    &lt;field name = "stateSeverity" type = "array" elementType = "menu" design = "false" /&gt;
    &lt;field name = "changeStateAlarm" type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<p>The structure has the following fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">stateSeverity</dt>
    <dd>An array of stateSeverity alarmSeverity menu definitions. When the
      process method is called the value field is the index for this array.
      The corresponding alarmSeverity menu is found and it determines the
      alarm severity.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Linear">Linear Conversion</h2>
<hr />

<p>Support is available for input and output linear conversions. The xml
definitions for linear conversions are:</p>
<pre>&lt;structure name = "linearConvert" &gt;
    &lt;field name = "engUnitsLow" type = "double" /&gt;
    &lt;field name = "engUnitsHigh" type = "double" /&gt;
    &lt;field name = "deviceHigh" type = "int" /&gt;
    &lt;field name = "deviceLow" type = "int" /&gt;
    &lt;field name = "slope" type = "double" /&gt;
    &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;
  

&lt;structure name = "linearConvertInput" supportName = "linearConvertInput"&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert" type = "structure" structureName = "linearConvert" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertOutput" supportName = "linearConvertOutput"&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert" type = "structure" structureName = "linearConvert" /&gt;
    &lt;field name = "output" type = "link" /&gt;
&lt;/structure&gt;

&lt;support name = "linearConvertInput"
    factoryName = "org.epics.ioc.support.LinearConvertInputFactory"
/&gt;

&lt;support name = "linearConvertOutput"
    factoryName = "org.epics.ioc.support.LinearConvertOutputFactory"
/&gt;</pre>

<p>A structure or recordType that implemnts linear conversion for input must
define a field as follows:</p>
<pre>&lt;field name = "input" type = "structure" structureName = "linearConvertInput"/&gt;</pre>

<p>A structure or recordType that implemnts linear conversion for output must
define a field as follows:</p>
<pre>&lt;field name = "output" type = "structure" structureName = "linearConvertOutput"/&gt;</pre>

<h3 id="linearConv">linearConversion</h3>

<p>The structure linearConversion defines the fields used for linear
conversions. The fields slope and intercept are the values used to convert a
rawValue to engineering units. The rawValue is an integer value usually read
from an ADC (Analog to Digital Convertor). The slope and intercept can be
specified directly of calculated from the low and high engineering and device
values. If the later method is chosen the engUnitsLow and engUnitsHigh must
be provided. deviceLow and deviceHigh are either provided automatically by
support of must be provided. The following are the fields in structure
lineraConversion:</p>
<dl>
  <dt style="font-family: courier;">engUnitsLow</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceHigh.</dd>
  <dt style="font-family: courier;">engUnitsHigh</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceLow.</dd>
  <dt style="font-family: courier;">deviceHigh</dt>
    <dd>An int equal to the maximum value for the rawValue.</dd>
  <dt style="font-family: courier;">deviceLow</dt>
    <dd>An int equal to the minimum value for the rawValue.</dd>
  <dt style="font-family: courier;">slope</dt>
    <dd>The slope for the linear conversion.</dd>
  <dt style="font-family: courier;">intercept</dt>
    <dd>The intercept for the linear conversion.</dd>
</dl>

<h3 id="LinearConv">LinearConvertInputFactory</h3>
<pre>    public class LinearConvertInputFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is the factory that implements linear input conversion, i.e. it
converts a rawValue to engineering units. A field for linear conversion for
input is a structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>The link for reading the rawValue. If a field named "input" is
      defined and has support the support is called.</dd>
</dl>

<h3 id="LinearConv1">LinearConvertOutputFactory</h3>
<pre>    public class LinearConvertOutputFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is the factory that implements linear output conversion, i.e. it
converts a value in engineering units to a rawValue. A field for linear
conversion for output is a structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">output</dt>
    <dd>The link for reading the rawValue. If a field named "output" is
      defined and has support the support is called.</dd>
</dl>

<h3 id="DeviceLimi">DeviceLimit</h3>
<pre>    public interface DeviceLimit {
        void get(DBField low, DBField high);
    }</pre>

<p>This is a convenience class for accessing a structure that has two fields:
"low" and "high".</p>
<hr />

<h2 style="text-align: center" id="Noop">Noop Support</h2>
<hr />
<pre>    public class NoopFactory {
        public static Support create(DBStructure dbStructure);
        public static Support create(DBField dbField);
        public static LinkSupport create(DBLink dbLink);
    }</pre>

<p>This can be used for record types that just hold data. It can also be used
to provide support for any field. The support acts as though it is
synchronous. All Support or LinkSupport methods are implemented by just
extending AbstractSupport or AbstractLinkSupport without overriding any
methods.</p>
<hr />

<h2 style="text-align: center" id="CALink">CALink Support</h2>
<hr />
<pre>    public class CALinkFactory {
        public static LinkSupport create(DBLink dbLink);
    }</pre>

<p>This is a factory that provides an implementation of link support for the
following:</p>
<dl>
  <dt>processLink</dt>
    <dd>Support for a link that requests that another record process without
      transfering any data.</dd>
  <dt>inputLink</dt>
    <dd>Support for a link that 1) optionally requests that another record
      process, and 2) transfers data from the other record to the record
      containing the link.</dd>
  <dt>outputLink</dt>
    <dd>Support for a link that 1) transfers data to another record, and 2)
      optionally requests that the other record process.</dd>
  <dt>monitorLink</dt>
    <dd>Support for monitoring another record. A monitor returns data.</dd>
  <dt>monitorNotifyLink</dt>
    <dd>Support for monitoring another record. A monitor does not return
    data.</dd>
</dl>

<p>Each requires that other support code, e.g. record support knows how to
call them. In addition the code that calls them must call
linkSupport.setField for inputLink, outputLink, and monitorLink.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.ioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the link pvname.</dd>
</dl>

<p>Look at the menu and structure definitions in menuStructureSupportDBD for
a description of how the various links are defined.</p>
<hr />

<h2 style="text-align: center;" id="LinkArray">LinkArray Support</h2>
<hr />
<pre>    public class LinkArrayFactory {
        public static Support create(DBField dbField);
    }</pre>

<p>This is a factory that provides support for an array of links. The
supportName is linkArray. Each array element, which must have element type
link, can be reference any support that implements LinkSupport.</p>

<p>For example any record support could optionally support a field called
process, which is an array of process links. When the record instance
completes processing, it can request the the support for the process field
process. Support for an output record would allow process and output links.
Many other possibilities are possible.</p>
<hr />

<h2 style="text-align: center;" id="Link">Link Support</h2>
<hr />
<pre>    public class LinkFactory {
        public static Support create(DBStructure dbStructure);
    }</pre>

<p>This is support for a structure that has a single field which must be a
link. It's purpose is the allow link support to be attached to a field that
can be a structure but in a record instance only a link is desired.</p>
<hr />

<h2 style="text-align: center;" id="DelayLink">DelayLink Support</h2>
<hr />

<p>This is link support that simulates asynchronous support. It uses a
configStructure that has the definition:</p>
<pre>&lt;structure name = "delayLink"&gt;
    &lt;!-- min, max, inc are delay in milliseconds --&gt;
    &lt;field name = "min" type = "long" /&gt;
    &lt;field name = "max" type = "long" /&gt;
    &lt;field name = "inc" type = "long" /&gt;
&lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">min</dt>
    <dd>The minimum delay</dd>
  <dt style="font-family: courier;">max</dt>
    <dd>The maximum delay</dd>
  <dt style="font-family: courier;">inc</dt>
    <dd>The delay increment between process requests</dd>
</dl>

<p>Each time process is called it delays a number of milliseconds determined
by min,max, and inc. It starts with a delay on min. Each time it proceses it
increases the delay by inc until it reaches max. It then goes back to a delay
of min.</p>

<p>The factory definition is:</p>
<pre>    public class DelayLinkFactory {
        public static LinkSupport create(DBLink dbLink);
    }</pre>
</body>
<hr />

<h2 style="text-align: center" id="Double">Double Calculation Support</h2>
<hr />

<p>This is support for use with the calcDouble record or structure. File
calcDoubleCommon.xml defines the fields:</p>
<pre>&lt;DBDefinition&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "calcArgArray" type = "array"
         elementType = "structure" supportName = "calcArgArray" /&gt;
    &lt;field name = "calculator" type = "link" /&gt;
    &lt;field name = "doubleAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>Field calcDoubleRecord.xml defines:</p>
<pre>&lt;structure name = "calcArg" &gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "name" type = "string" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;

&lt;structure name = "calcDouble" supportName = "calcDoubleRecord" &gt;
    &lt;include href = "calcDoubleCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "calcDouble" supportName = "calcDoubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;include href = "calcDoubleCommon.xml" /&gt;
&lt;/recordType&gt;

&lt;support name = "calcDoubleRecord"
   factoryName = "org.epics.ioc.recordSupport.CalcDoubleFactory" /&gt;</pre>

<p>The following support is defined in support.xml</p>
<pre>&lt;support name = "calcArgArray"
   factoryName = "org.epics.ioc.support.CalcArgArrayFactory" /&gt;</pre>

<h3 id="Performing">Performing Calculations</h3>

<p>A calculation is performed by a calculation link support. The following is
done. When the calcRecord support is called it calls the calcArgArray support
and when it completes the calculation link support. For each element if the
calcArgArray, the calcArgArray support calls the input link support (if it is
specified) to get the calcArg value. The calculation support uses the
calcArgArray values to compute the calculated value. At present generic
calculation support is not implemented. It is envisioned that it will allow
the user to enter expressions like "voltage*current". The calcArgArray would
have two elements with calcArg.name set to "voltage" and "current".</p>

<h3 id="calcArgArr">calcArgArray</h3>

<p>The support for a calcArgArray implements support for an array of calcArg
structures, which has the fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>A double value for this argument.</dd>
  <dt style="font-family: courier;">name</dt>
    <dd>A string which provides a name for the argument.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>A link for obtaining the value for this argument. Note that if no
      support is specified then no input is read and the value field can just
      be set by the user.</dd>
</dl>

<p>calcArgArray uses the following definitions:</p>
<pre>    public interface CalcArgArraySupport extends Support{
        PVDouble getPVDouble(String argName);
    }

    public class CalcArgArrayFactory {
        public static Support create(DBField dbField);
    }</pre>

<p>CalcArgArraySupport extends Support to provide the method:</p>
<dl>
  <dt style="font-family: courier;">getPVDouble</dt>
    <dd>This is a convience metod for calculator support. It looks in the
      calcArgArray for a field with the specified name and returns it's
      interface.</dd>
</dl>

<h3 id="Calculator">Calculator</h3>

<p>Support for a calculation field, which is a link, must implement:</p>
<pre>    public interface CalculatorSupport extends LinkSupport {
        void setCalcArgArraySupport(CalcArgArraySupport calcArgArraySupport);
    }</pre>

<p>CalculatorSupport extends LinkSupport to add the method:</p>
<dl>
  <dt style="font-family: courier;">setCalcArgArraySupport</dt>
    <dd>This is called by calcDoubleRecord support.</dd>
</dl>

<p>An example calculation support is provided as part of javaIOC. It is:</p>
<pre>public class CounterCalculatorFactory {

    public static LinkSupport create(DBLink dbLink) {
        return new CounterCalculatorImpl(dbLink);
    }

    private static String supportName = "counterCalculator";

    private static class CounterCalculatorImpl extends AbstractLinkSupport
    implements CalculatorSupport
    {
        private PVLink pvLink;
        private CalcArgArraySupport calcArgArraySupport = null;
        private DBField valueDBField;
        private PVDouble valuePVField= null;;
        private PVDouble minPVField = null;
        private PVDouble maxPVField = null;
        private PVDouble incPVField = null;

        private CounterCalculatorImpl(DBLink dbLink) {
            super(supportName,dbLink);
            pvLink = dbLink.getPVLink();
        }

        public void initialize() {
            if(!super.checkSupportState(SupportState.readyForInitialize,supportName)) return;
            minPVField = calcArgArraySupport.getPVDouble("min");
            if(minPVField==null) {
                pvLink.message("min not found", MessageType.error);
                return;
            }
            maxPVField = calcArgArraySupport.getPVDouble("max");
            if(maxPVField==null) {
                pvLink.message("max not found", MessageType.error);
                return;
            }
            incPVField = calcArgArraySupport.getPVDouble("inc");
            if(incPVField==null) {
                pvLink.message("inc not found", MessageType.error);
                return;
            }
            setSupportState(SupportState.readyForStart);
        }

        public void process(SupportProcessRequester supportProcessRequester) {
            double value = valuePVField.get();
            double min = minPVField.get();
            double max = maxPVField.get();
            double inc = incPVField.get();
            value += inc;
            if(inc&gt;0) {
                if(value&gt;max) value = min;
                if(value&lt;min) value = min;
            } else {
                if(value&lt;min) value = max;
                if(value&gt;max) value = max;
            }
            valuePVField.put(value);
            valueDBField.postPut();
            supportProcessRequester.supportProcessDone(RequestResult.success);
        }

        public void setField(DBField dbField) {
            valueDBField = dbField;
            valuePVField = (PVDouble)dbField.getPVField();
        }

        public void setCalcArgArraySupport(CalcArgArraySupport calcArgArraySupport) {
            this.calcArgArraySupport = calcArgArraySupport;
        }
    }
}</pre>
<hr />

<h2 style="text-align: center"
id="ArrayIncre">ArrayIncrementCalculatorFactory</h2>
<hr />

<p>This is support for testing. It supports numeric array fields. Each time
process is called it just incrememnts each element of the array.</p>
<hr />

<h2 style="text-align: center"
id="BooleanArr">BooleanArrayToggleCalculatorFactory</h2>
<hr />

<p>This is support for testing. It supports boolean array fields. Each time
process is called it just toggles each element of the array, if the value us
false it becomes true and if true becomes false.</p>
</html>
