<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: channel Access</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: channel Access<br />
package: org.epics.ioc.ca<br />
2008.01.10</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Channel">Channel Definitions</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Channel1">Channel</a></li>
      <li><a href="#ChannelLis">ChannelListener</a></li>
      <li><a href="#AccessRigh">AccessRights</a></li>
      <li><a href="#ChannelFie">ChannelField</a></li>
      <li><a href="#ChannelFie1">ChannelFieldGroupListener</a></li>
      <li><a href="#ChannelFie2">ChannelFieldGroup</a></li>
      <li><a href="#ChannelMon">ChannelMonitorRequester</a></li>
      <li><a href="#ChannelMon1">ChannelMonitor</a></li>
      <li><a href="#ChannelFac">ChannelFactory</a></li>
      <li><a href="#ChannelPro">ChannelProvider</a></li>
    </ul>
  </li>
  <li><a href="#Channel2">Channel Process, Get, Put, PutGet, and Monitor</a>
    <ul>
      <li><a href="#Definition1">Definitions</a></li>
      <li><a href="#ChannelPro1">ChannelProcess</a></li>
      <li><a href="#ChannelGet">ChannelGet</a></li>
      <li><a href="#ChannelPut">ChannelPut</a></li>
      <li><a href="#ChannelPut1">ChannelPutGet</a></li>
    </ul>
  </li>
  <li><a href="#Abstract">Abstract and Base Classes</a></li>
  <li><a href="#ChannelMon2">ChannelMonitorNotify</a>
    <ul>
      <li><a href="#ChannelMon3">ChannelMonitorNotify</a></li>
    </ul>
  </li>
  <li><a href="#Local">Local Channel Provider</a></li>
  <li><a href="#Channel3">CD - Channel Data</a>
    <ul>
      <li><a href="#Definition2">CD Definitions</a></li>
      <li><a href="#CD">CD</a></li>
      <li><a href="#CDQueue">CDQueue</a></li>
      <li><a href="#CDFactory">CDFactory</a></li>
    </ul>
  </li>
  <li><a href="#CDField">CDField - Channel Data Fields</a>
    <ul>
      <li><a href="#CDField1">CDField Definitions</a></li>
      <li><a href="#CDField2">CDField</a></li>
      <li><a href="#CDRecord">CDRecord</a></li>
      <li><a href="#CDStructur">CDStructure</a></li>
      <li><a href="#CDArray">CDArray</a></li>
      <li><a href="#CDStructur1">CDStructureArray</a></li>
      <li><a href="#CDArrayArr">CDArrayArray</a></li>
      <li><a href="#Base">Base CD Classes</a></li>
    </ul>
  </li>
  <li><a href="#CDGet">CDGet, CDPUT, CDMonitor</a>
    <ul>
      <li><a href="#CDGet1">CDGet</a></li>
      <li><a href="#CDPut">CDPut</a></li>
      <li><a href="#CDMonitor">CDMonitor</a></li>
    </ul>
  </li>
  <li><a href="#Example">Example For CD</a>
    <ul>
      <li><a href="#Discussion">Discussion</a></li>
      <li><a href="#Implementa">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Process">Process Example</a>
    <ul>
      <li><a href="#Discussion1">Discussion</a></li>
      <li><a href="#Implementa1">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Example1">Get Example</a>
    <ul>
      <li><a href="#Discussion2">Discussion</a></li>
      <li><a href="#Implementa2">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Example2">Put Example</a>
    <ul>
      <li><a href="#Discussion3">Discussion</a></li>
      <li><a href="#Implementa3">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#PutGet">PutGet Example</a>
    <ul>
      <li><a href="#Discussion4">Discussion</a></li>
      <li><a href="#Implementa4">Implementation</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package contains Java definitions for Channel Access clients</p>

<p>A channel is an interface for acessing data. A channel is implemented by a
channelProvider. An arbitrary number of channelProviders are allowed. Each
channelProvider has a name and must register itself to ChannelFactory. The
underlying data is presented as PVData via a ChannelField. The client can
access multiple ChannelFields via a ChannelFieldGroup.</p>

<p>CD (ChannelData) is a facility that, given a ChannelFieldGroup, creates a
PVRecord that contains a PVData for each ChannelField as well as a reference
to the ChannelField. </p>

<p>A channelProvider must implement the following: Channel, ChannelProvider,
ChannelGet, ChannelPut, ChannelPutGet, and ChannelMonitor. All other
interfaces, i.e. ChannelMonitorNotify and all the CD interfaces are generic,
i.e. implemented by factories provided by the package.</p>
<hr />

<h2 style="text-align: center" id="Channel">Channel Definitions</h2>
<hr />

<p>This section defines the interface and factory classes for connecting to a
channel and creating interfaces for accessing a channel. The interfaces for
accessing a channel are defined in later sections. </p>

<p>A channel is created via a call to ChannelFactory.create(pvName,...). The
pvName can optionally consist of three components: 1) A channelName, 2) A
fieldName, and 3) options. The details are provider dependent but if possible
a provider should support the following syntax:</p>
<pre>    channelName.fieldName{options}</pre>

<p>The channelName is any set of characters not including '.'. The fieldName
is all characters after the first '.' up to the optional '{'. If the '{' is
present than all characters between the braces are the options. These
conventions are supported by the ChannelProviderLocalFactory, which provides
access to the local DB database. Other providers may optionally support the
same conventions.</p>

<p>For a javaIOC a channelName is a recordName. This is also true for EPICS
databases.</p>

<h3 id="Definition">Definitions</h3>
<pre>    interface ChannelListener extends Requester {
        void channelStateChange(Channel c,boolean isConnected);
         void destroy(Channel c);
    }
    interface Channel  extends Requester {
        void connect();
        void disconnect();
        void destroy();
        String getChannelName();
        ChannelListener getChannelListener();
        boolean isConnected();
        String getPropertyName();
        String getFieldName();
        String getOptions();
        ChannelField createChannelField(String name);
        ChannelFieldGroup createFieldGroup(ChannelFieldGroupListener listener);
        ChannelProcess createChannelProcess(
            ChannelProcessRequester channelProcessRequester);
        ChannelGet createChannelGet(ChannelFieldGroup channelFieldGroup,
            ChannelGetRequester channelGetRequester,
            boolean process);
        ChannelPut createChannelPut(ChannelFieldGroup channelFieldGroup,
            ChannelPutRequester channelPutRequester,
            boolean process);
        ChannelPutGet createChannelPutGet(
            channelFieldGroup putFieldGroup,ChannelFieldGroup getFieldGroup,
            ChannelPutGetRequester channelPutGetRequester,
            boolean process);
        ChannelMonitor createChannelMonitor(
            ChannelMonitorRequester channelMonitorRequester);
    }

    enum AccessRights {
        none,
        read,
        readWrite
    }

    interface ChannelField {
        Field getField();
        PVField getPVField();
        void postPut();
        ChannelField findProperty(String propertyName);
        ChannelField createChannelField(String fieldName);
        String[] getPropertyNames();
        PVEnumerated getEnumerated();
        AccessRights getAccessRights();
    }

    interface ChannelFieldGroupListener {
        void accessRightsChange(Channel channel,ChannelField channelField);
    }

    interface ChannelFieldGroup {
        void addChannelField(ChannelField channelField);
        void removeChannelField(ChannelField channelField);
        List&lt;ChannelField&gt; getList();
        ChannelField[] getArray();
    }

    interface ChannelMonitorRequester extends Requester{
        void beginPut();
        void endPut();
        void dataPut(PVField modifiedPVField);
        void dataPut(PVField requestedPVField,PVField modifiedPVField);
    }
    
    interface ChannelMonitor {
        void setFieldGroup(ChannelFieldGroup channelFieldGroup);
        void getData(CD cd);
        void start();
        void stop();
        void destroy();
    }

    class ChannelFactory {
        static Channel createChannel(
            String pvName,String providerName,ChannelListener listener);
        static void registerChannelProvider(
            ChannelProvider channelProvider);
        static ChannelProvider getChannelProvider(String providerName);
        static boolean isChannelProvider(String channelName,String providerName);
    }

    interface ChannelProvider {
        Channel createChannel(String pvName,ChannelListener listener);
        String getProviderName();
        boolean isProvider(String channelName);
    }</pre>

<h3 id="Channel1">Channel</h3>

<p>A channel provides access to an arbitrary number of fields in the record.
The methods are:</p>
<dl>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the data source.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the data source.</dd>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy the channel. Any active requests will still occur but no new
      requests will be accepted for the channel.</dd>
  <dt style="font-family: courier;">getChannelName</dt>
    <dd>Get the channelName.</dd>
  <dt style="font-family: courier;">getChannelListener</dt>
    <dd>Get the ChannelListener.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Channel Access code calls this to report errors and/or diagnostic
      information.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>Is the channel connected?</dd>
  <dt style="font-family: courier;">getPropertyName</dt>
    <dd>Get the propertyName for this channel. The details are
      channelProvider dependent.</dd>
  <dt style="font-family: courier;">getFieldName</dt>
    <dd>Get the fieldName. The details are channelProvider dependent.</dd>
  <dt style="font-family: courier;">getOptions</dt>
    <dd>Get the options. The details are channelProvider dependent.</dd>
  <dt style="font-family: courier;">createChannelField</dt>
    <dd>Create a ChannelField if the field is found and return the interface.
      If not found null is returned.</dd>
  <dt style="font-family: courier;">createFieldGroup</dt>
    <dd>get, put, putGet, and monitor all use fieldGroup to specify the data
      to get/put from/to a channel.</dd>
  <dt style="font-family: courier;">createChannelProcess</dt>
    <dd>Create a process request. This is used to ask a channel to
    process.</dd>
  <dt style="font-family: courier;">createChannelGet</dt>
    <dd>Create a get request.</dd>
  <dt style="font-family: courier;">createChannelPut</dt>
    <dd>Create a put request.</dd>
  <dt style="font-family: courier;">createChannelPutGet</dt>
    <dd>Create a putGet request.</dd>
  <dt style="font-family: courier;">createChannelMonitor</dt>
    <dd>Create a channel monitor. This is used to create monitors for the
      channel.</dd>
</dl>

<h3 id="ChannelLis">ChannelListener</h3>

<p><span style="font-family: courier;">ChannelListener</span> is an interface
that must be implemented by code that creates a channel. It has the
methods:</p>
<dl>
  <dt style="font-family: courier;">channelStateChange</dt>
    <dd>The connection state changed. The listener can call <span
      style="font-family: courier;">channel.isConnected</span> to find the
      connection state.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>The channel is going away. The channel will not accept any further
      requests.</dd>
</dl>

<h3 id="AccessRigh">AccessRights</h3>

<p>AccessRights is an enum specifying access rights to fields of a channel.
Note that access rights are not currently implemented.</p>
<dl>
  <dt style="font-family: courier;">none</dt>
    <dd>The channel can neither read or write the field.</dd>
  <dt style="font-family: courier;">read</dt>
    <dd>The channel can read but not modify the channel.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>The channel can both read and modify the channel</dd>
</dl>

<h3 id="ChannelFie">ChannelField</h3>

<p><span style="font-family: courier;">ChannelField</span> describes a
specific field in a channel.</p>
<dl>
  <dt style="font-family: courier;">getField</dt>
    <dd>Returns the Field that describes the field. See package
      org.epics.ioc.pv for details.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Gets the PVField that holds the data.</dd>
  <dt style="font-family: courier;">postPut</dt>
    <dd>When a client does a put to the PVField, this muset be called.</dd>
  <dt style="font-family: courier;">findProperty</dt>
    <dd>Find a ChannelField for the specified propertyName.</dd>
  <dt style="font-family: courier;">getPropertyNames</dt>
    <dd>Get all the names of all the properties associated with this
    field..</dd>
  <dt style="font-family: courier;">getEnumerated</dt>
    <dd>If the associated PVField is an enumerated structure return the
      Enumerated interface. Returns null if the PVField is not an enumerated
      structure.</dd>
  <dt style="font-family: courier;">getAccessRights</dt>
    <dd>Get the access rights for the field.</dd>
</dl>

<h3 id="ChannelFie1">ChannelFieldGroupListener</h3>

<p><span style="font-family: courier;">ChannelFieldGroupListener</span>
provides a method that is called whenever the access rights change. The
method is:</p>
<dl>
  <dt style="font-family: courier;">accessRightsChange</dt>
    <dd>The listener can call <span
      style="font-family: courier;">channelField.getAccessRights</span> to
      get the current rights.</dd>
</dl>

<h3 id="ChannelFie2">ChannelFieldGroup</h3>

<p><span style="font-family: courier;">ChannelFieldGroup</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">addChannelField</dt>
    <dd>Add a channelField to the group. Note that channel.findField returns
      a channelField.</dd>
  <dt style="font-family: courier;">removeChannelField</dt>
    <dd>Remove a channelField from the group.</dd>
  <dt style="font-family: courier;">getList</dt>
    <dd>Get the list of channelFields in the group.</dd>
  <dt style="font-family: courier;">getArray</dt>
    <dd>Get the array of ChannelField</dd>
</dl>

<h3 id="ChannelMon">ChannelMonitorRequester</h3>

<p><span style="font-family: courier;">ChannelMonitorRequester</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">beginPut</dt>
    <dd>This is called when a new set of monitored data is available. Between
      beginPut and endPut a set of dataPut calls are made. </dd>
  <dt style="font-family: courier;">endPut</dt>
    <dd>This is called when at the end of a new set of monitored data.</dd>
  <dt style="font-family: courier;">dataPut(PVField modifiedPVField);</dt>
    <dd>A put to the modifiedPVField has occured.</dd>
  <dt style="font-family: courier;">dataPut(PVField requestedPVField,PVField
  modifiedPVField);</dt>
    <dd>A put to the modifiedPVField has occured. The requestedPVField is the
      PVField in an associated ChannelField. </dd>
</dl>

<h3 id="ChannelMon1">ChannelMonitor</h3>

<p><span style="font-family: courier;">ChannelMonitor</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">setFieldGroup</dt>
    <dd>Set the fieldGroup to monitor.</dd>
  <dt style="font-family: courier;">getData</dt>
    <dd>Get the current data and put it into the CD.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start monitoring.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop monitoring.</dd>
</dl>

<h3 id="ChannelFac">ChannelFactory</h3>

<p>A channelFactory creates a channel. A channel is either local, i.e. code
running in an IOC is accessing a field in the local IOC database, or remote,
code is accessing a channel that is available over the network.
Channelfactory also has methods called by support for local access and by
support for remote access.</p>

<p>The methods implemented by ChannelFactory are:</p>
<dl>
  <dt style="font-family: courier;">createChannel</dt>
    <dd>A client calls this to create a channel. A Channel is created and
      returned only if the channelProvider is registered and if the
      channelProvider can locate the channelName. If a channel is created
      connection managment is started. A null is returned if the request
      fails. </dd>
  <dt style="font-family: courier;">registerChannelProvider</dt>
    <dd>This is the registration call for a channel access provider.</dd>
  <dt style="font-family: courier;">getChannelProvider</dt>
    <dd>Return the ChannelProvider or null if the providerName is not
      registered.</dd>
  <dt style="font-family: courier;">isChannelProvider</dt>
    <dd>Is channelName supported by providerName?</dd>
</dl>

<h3 id="ChannelPro">ChannelProvider</h3>

<p>This is an interface that must be implemented by code that implements
channel access. It is called by ChannelFactory. It has only one method</p>
<dl>
  <dt style="font-family: courier;">createChannel</dt>
    <dd>ChannelFactory calls this first for local channel access and if the
      channel is not found then for remote channel access.</dd>
  <dt style="font-family: courier;">getProviderName</dt>
    <dd>Get the provider name.</dd>
  <dt style="font-family: courier;">isProvider</dt>
    <dd>Can the provider access channelName?</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Channel2">Channel Process, Get, Put,
PutGet, and Monitor</h2>
<hr />

<h3 id="Definition1">Definitions</h3>
<pre>    interface ChannelProcess {
        boolean process();
        void destroy();
    }

    interface ChannelProcessRequester extends Requester {
            void processDone(RequestResult requestResult);
    }

    interface ChannelGet {
        boolean get();
        void getDelayed(PVField pvField);
        void destroy();
    }

    interface ChannelGetRequester extends Requester {
        boolean nextGetField(ChannelField field,PVField pvField);
        boolean nextDelayedGetField(PVField pvField);
        void getDone(RequestResult requestResult);
    }

    interface ChannelPut {
        boolean put();
        void putDelayed(PVField pvField);
        void destroy();
    }

    interface ChannelPutRequester extends Requester {
        boolean nextPutField(ChannelField field,PVField pvField);
        boolean nextDelayedPutField(PVField pvField);
        void putDone(RequestResult requestResult);
    }


    interface ChannelPutGet {
        boolean putGet();
        void putDelayed(PVField pvField);
        void getDelayed(PVField pvField);
        void destroy();
    }

    interface ChannelPutGetRequester extends
        ChannelPutRequester,ChannelGetRequester {}</pre>

<h3 id="ChannelPro1">ChannelProcess</h3>

<p>ChannelProcess has the methods:</p>
<dl>
  <dt style="font-family: courier;">process</dt>
    <dd>Process the channel. If the channel is a database record, process the
      record. <span style="font-family: courier;">process</span> returns
      (false, true) if the request (can not, can) be done. Normally true is
      returned. A false value probably means that the channel is not
      connected or channelProcess is not the requester.</dd>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy any state. This is called automatically when
      channel.destroy() id called.</dd>
</dl>

<p>ChannelProcessRequester has the methods:</p>
<dl>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>Determined by the requester.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Called for error or informational messages.</dd>
  <dt style="font-family: courier;">processDone</dt>
    <dd>Called when the record associated with the channel completes
      processing.</dd>
</dl>

<p>A ChannelProcess is created via a call:</p>
<pre>    ChannelProcess channelProcess = channel.createChannelProcess(this).</pre>

<p>The requester must implement interface <span
style="font-family: courier;">ChannelProcessRequester</span>. <span
style="font-family: courier;">null</span> is returned if the requester is not
allowed to process the channel. For example the channel is connected to a
record that already has an assigned record processor.</p>

<p>If <span style="font-family: courier;">createChannelProcess</span> or
<span style="font-family: courier;">process</span> itself fails, <span
style="font-family: courier;">channelProcessRequester.message</span> is
called. If <span style="font-family: courier;">process</span> returns true,
then <span
style="font-family: courier;">channelProcessRequester.requestDone</span> is
called when the channel completes processing.</p>

<h3 id="ChannelGet">ChannelGet</h3>

<p><span style="font-family: courier;">ChannelGet</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">get</dt>
    <dd>Get all data for the fieldGroup. The data is returned via calls to
      channelGetRequester.</dd>
  <dt style="font-family: courier;">getDelayed</dt>
    <dd>If <span
      style="font-family: courier;">channelGetRequester.nextGetField</span>
      returns true, meaning the requester is not done retrieving the data,
      then the requester calls <span
      style="font-family: courier;">getDelayed</span> to retrieve the
    data.</dd>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy any state. This is called automatically when
      channel.destroy() id called.</dd>
</dl>

<p><span style="font-family: courier;">ChannelGetRequester</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">nextGetField</dt>
    <dd>The next pvField in the fieldGroup. The requester returns false if it
      is done with the data and true otherwise. If true is returned the the
      requester calls <span
      style="font-family: courier;">channelGet.getDelayed</span> when it is
      ready.</dd>
  <dt style="font-family: courier;">nextDelayedGetField</dt>
    <dd>When the requester calls <span
      style="font-family: courier;">channelGet.getDelayed</span> the data is
      returned via a call to <span
      style="font-family: courier;">nextDelayedGetField</span></dd>
  <dt style="font-family: courier;">getDone</dt>
    <dd>The request is done.</dd>
</dl>

<p>Delayed gets are provided for channel access servers that need to block
while handling data. Consider a server that needs to send an array over the
network. If it is a very large array, the server has to send the array in
multuple network buffers. In order not to lock a database record while the
array is being sent it can use the delayed methods. It implements something
like:</p>
<pre>    PVArray pvArray;
    int size,offset;

    boolean nextGetField(Channel channel,ChannelField field,PVField pvField) {
        // recognize that data is actually an array
        pvArray = (PVArray)pvField;
        size = pvArray.getLength();
        offset = 0;
        return true;
    }
    ...
    while(moreToDo) {
       // get networkBuffer. This may block while waiting
       channelGet.getDelayed(pvArray();
       // send buffer. This might block
       if(offset&gt;=size) break; // all done
    }
    ...
    boolean nextDelayedGetField(PVField pvField) {
        // transfer data to network buffer
        // update offset
        if(offset&lt;size) return true // getDelayed will again be called
        return false // all done
    }</pre>

<h3 id="ChannelPut">ChannelPut</h3>

<p><span style="font-family: courier;">ChannelPut</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">put</dt>
    <dd>Put all data for the fieldGroup. The data is fetched via calls to
      <span style="font-family: courier;">channelPutRequester.</span></dd>
  <dt style="font-family: courier;">putDelayed</dt>
    <dd>If <span
      style="font-family: courier;">channelPutRequester.nextPutField</span>
      returns true, meaning the requester has not put the data, then the
      requester calls <span style="font-family: courier;">putDelayed</span>
      when it is ready to put the data.</dd>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy any state. This is called automatically when
      channel.destroy() id called.</dd>
</dl>

<p><span style="font-family: courier;">ChannelPutRequester</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">nextPutField</dt>
    <dd>The next pvField in the fieldGroup. The requester returns false if it
      is done with that data and true if it is not ready to put the data. If
      true is returned the the requester calls <span
      style="font-family: courier;">channelPut.putDelayed</span> when it is
      ready.</dd>
  <dt style="font-family: courier;">nextDelayedPutField</dt>
    <dd>When the requester calls <span
      style="font-family: courier;">channelPut.putDelayed</span> the data is
      put via a call to <span
      style="font-family: courier;">nextDelayedPutField</span></dd>
  <dt style="font-family: courier;">putDone</dt>
    <dd>The put request is complete.</dd>
</dl>

<p>Like delayed gets delayed puts are used by servers that need to block. For
example servers that transfer data from the network to an IOC database.</p>

<h3 id="ChannelPut1">ChannelPutGet</h3>

<p>This is a combination of <span
style="font-family: courier;">ChannelPut</span> and <span
style="font-family: courier;">ChannelGet</span>. A typical example is a
client request to:</p>
<ul>
  <li>Put data to a record.</li>
  <li>Process the record</li>
  <li>Return the status and severity to the client.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Abstract">Abstract and Base Classes</h2>
<hr />
<pre>    public abstract class AbstractChannel implements Channel{
        protected AbstractChannel(ChannelListener channelListener,
        String fieldName, String options);
        protected synchronized void SetPVRecord(PVRecord pvRecord);
        protected synchronized PVRecord getPVRecord();
        protected synchronized boolean add(ChannelProcess channelProcess);
        protected synchronized boolean add(ChannelGet channelGet);
        protected synchronized boolean add(ChannelPut channelPut);
        protected synchronized boolean add(ChannelPutGet channelPutGet);
        protected synchronized boolean add(ChannelMonitor channelMonitor);
        protected synchronized boolean remove(ChannelProcess channelProcess);
        protected synchronized boolean remove(ChannelGet channelGet);
        protected synchronized boolean remove(ChannelPut channelPut);
        protected synchronized boolean remove(ChannelPutGet channelPutGet);
        protected synchronized boolean remove(ChannelMonitor channelMonitor);
        public synchronized String getChannelName();
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        public void connect();
        public void disconnect();
        public synchronized boolean isConnected();
        public void destroy();
        public ChannelListener getChannelListener();
        public synchronized boolean isConnected();
        public synchronized String getFieldName();
        public synchronized String getOptions();
        public synchronized String getPropertyName();
        public synchronized ChannelFieldGroup createFieldGroup(
           ChannelFieldGroupListener listener);
    }

    public class BaseChannelField implements ChannelField { ... }
    public class BaseChannelFieldGroup implements ChannelFieldGroup { ... }</pre>

<p>AbstractChannel is for use by Channel Providers. The public methods are
sufficent for most providers and do not need to be overriden. The provider
must call the add and remove methods whenever the corresponding interface is
implemented or destroyed. When destroy is called AbstractChannel calls the
destroy method of each of the process/get/put/putGet/monitor interfaces.</p>

<p>BaseChannelField implements all ChannelField methods. However the provider
must provide a PVField interface to the constructor and often needs to
override some of the methods.</p>

<p>BaseChannelFieldGroup implements all ChannelFieldGroup methods. A provider
normally can use BaseChannelFieldGroup without overriding any of the
methods.</p>
<hr />

<h2 style="text-align: center" id="ChannelMon2">ChannelMonitorNotify</h2>
<hr />

<h3 id="ChannelMon3">ChannelMonitorNotify</h3>

<p>This is support for being notified when a put is issued to a field of an
IOC database. The notification does not include data.</p>
<pre>    public interface ChannelMonitorNotify extends ChannelMonitor{}
    
    interface ChannelMonitorNotifyRequester extends Requester{
        void monitorEvent();
    }
    
    class ChannelMonitorNotifyFactory {
        ChannelMonitorNotify create(Channel channel,
            ChannelMonitorNotifyRequester monitorNotifyRequestor);
    } </pre>
<hr />

<h2 style="text-align: center;" id="Local">Local Channel Provider</h2>
<hr />

<p>An implementation of a channel access client for accessing records in the
IOC database is provided. It has the name "local" This is created
automatically by <span
style="font-family: courier;">ChannelProviderLocalFactory</span> . The
factory creates a single instance of an implementation of a channel access
client for accessing local records. <span
style="font-family: courier;">ChannelProviderLocalFactory</span> has only one
public method.</p>
<pre>    public class ChannelProviderLocalFactory  {
        static public void register();
    }</pre>

<p>This method is called by ChannelFactory when it is called before a local
Channel Access is registered.</p>
<hr />

<h2 style="text-align: center" id="Channel3">CD - Channel Data</h2>
<hr />

<p>CD (ChannelData) is a facility that holds a copy of the data contained in
a fieldGroup. CD helps solve two problems:</p>
<ol>
  <li>Blocking with a record locked.<br />
    An example is a channel access server. Instead of pre allocating network
    buffers for a fieldGroup it can create a CD, transfer data from a record
    to the CD, and then transfer the CD to a network buffer. In the case of a
    large array multiple network buffers will be required.</li>
  <li>Data repository for database monitoring.<br />
    For database monitoring a queue of CDs can be created. When a monitored
    record changes, a CD can be taken from the queue, and the data values
    stored in the CD. This can be done without blocking. When the server is
    ready it can empty the queue and send the CDs over the network.</li>
</ol>

<p>A CD is associated with a channel and channelFieldGroup. When a CD is
created via a call to CDFactory.createCD it automatically creates a CDRecord
and associated subfields, which are described in the next section.</p>

<h3 id="Definition2">CD Definitions</h3>
<pre>    interface CD {
        void destroy();
        Channel getChannel();
        ChannelFieldGroup getChannelFieldGroup();
        CDRecord getCDRecord();
        void clearNumPuts();
        void get(PVField pvField);
        void put(PVField pvField);
        void put(PVField pvField,PVField pvSubField);
        CDGet createCDGet(
            CDGetRequester channelCDGetRequester,
            boolean process);
        void destroy(CDGet channelCDGet);
        CDPut createCDPut(
            CDPutRequester cdPutRequester,
            boolean process);
        void destroy(CDPut cdPut);
    }


    interface CDQueue {
        int getNumberFree();
        int capacity();
        CD getFree(boolean forceFree);
        void setInUse(CD cd);
        CD getNext();
        int getNumberMissed();
        void releaseNext(CD cd);
    }

    class CDFactory {
         static CD createCD(
             Channel channel,ChannelFieldGroup channelFieldGroup);
         static CDQueue createQueue(
             int queueSize,Channel channel,ChannelFieldGroup channelFieldGroup);
    }

    class BaseCD { ... }
    class BaseCDQueue { ... }
    class BaseCDPut { ... }
    class BaseCDGet { ... }
    classs BaseCDMonitor { ... }</pre>

<h3 id="CD">CD</h3>

<p>CD has the following methods:</p>
<dl>
  <dt style="font-family: courier;">delete</dt>
    <dd>Delete the CD. Thias automatically call delete for each CDGet, CVPut,
      and CDModify.</dd>
  <dt style="font-family: courier;">getChannel</dt>
    <dd>Get the channel to which this channelFieldGroup belongs.</dd>
  <dt style="font-family: courier;">getChannelFieldGroup</dt>
    <dd>Get the ChannelFieldGroup for this CD.</dd>
  <dt style="font-family: courier;">getCDRecord</dt>
    <dd>Get the CDRecord that holds the data.</dd>
  <dt style="font-family: courier;">getMaxPutsToField</dt>
    <dd>Get the maxNumPuts to any field.</dd>
  <dt style="font-family: courier;">clearNumPuts</dt>
    <dd>Clear the internal list of items that have been added.</dd>
  <dt style="font-family: courier;">get</dt>
    <dd>Get data from the CD and put it into pvField.</dd>
  <dt style="font-family: courier;">put</dt>
    <dd>The PVField has been modified. Two versions are provided. One is if a
      ChannelField is connected to the PVField itself and the other if the
      PVField is a subfield of the PVStructure to which the ChannelField is
      connected. NOTE that the pvFields are from the ChannelField NOT the
      pvField from the CD. </dd>
  <dt style="font-family: courier;">createCDGet</dt>
    <dd>Create a CDGet.</dd>
  <dt style="font-family: courier;">destroy(CDGet channelCDGet)</dt>
    <dd>Delete a CDGet.</dd>
  <dt style="font-family: courier;">createCDPut</dt>
    <dd>Create a CDPut.</dd>
  <dt style="font-family: courier;">destroy(CDPut channelCDPut)</dt>
    <dd>Delete a CDPut.</dd>
</dl>

<p>A CD is allocated as follows:</p>
<pre>    CD cd = CDFactory.createData(
        channel,channelFieldGroup);</pre>

<p>This creates storage for each element of the field group. It can create
storage for all pvTypes. For Array types, the initial size and capacity is 0.
The arrays will grow as data is placed in them but will not be released.</p>

<h3 id="CDQueue">CDQueue</h3>

<p>CDQueue has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getNumberFree</dt>
    <dd>Get the number of unused cd elements in the queue.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>Get the number of cd elements in the queue.</dd>
  <dt style="font-family: courier;">getFree</dt>
    <dd>Get a cd element from the queue. If there are no more free elements
      numberMissed is incremented. If forceFree is true the oldest used
      element is reused. If no free element is available then null is
      returned.</dd>
  <dt style="font-family: courier;">setInUse</dt>
    <dd>Sets the CD in use. This must be called for each cd returned by
      getFree. The caller can make changes to the CD before it is set in
    use.</dd>
  <dt style="font-family: courier;">getNext</dt>
    <dd>Get the next cd element that has new data in it. Return null if there
      are no more elements.</dd>
  <dt style="font-family: courier;">getNumberMissed</dt>
    <dd>Get the number of times getGree has been called since the last call
      to releaseNext.</dd>
  <dt style="font-family: courier;">releaseNext</dt>
    <dd>Release the element returned by getNext.</dd>
</dl>

<p>A CDQueue is created as follows:</p>
<pre>    CDQueue cdQueue = CDFactory.createQueue(
         queueSize,channel,channelFieldGroup);</pre>

<p>This creates <span style="font-family: courier;">queueSize</span> <span
style="font-family: courier;">channelFieldGroup</span>s and a queue to manage
them. As an example of how a queue is used consider a channel access server
monitoring a fieldGroup of an IOC database record.</p>

<h3 id="CDFactory">CDFactory</h3>

<p>CDFactory has the following methods:</p>
<dl>
  <dt style="font-family: courier;">createData</dt>
    <dd>Create a CD.</dd>
  <dt style="font-family: courier;">createQueue</dt>
    <dd>Create a CDQueue.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="CDField">CDField - Channel Data Fields</h2>
<hr />

<p>Each cd provides a set of interfaces for accessing the data values. The
data is stored in PVField objects. The complete set of PVFields form a
PVRecord, Each CD interface provides access to it's corresponding PV
interface. The CD interfaces provide additional methods that allow the client
to determine how often each PVField was written.</p>

<h3 id="CDField1">CDField Definitions</h3>
<pre>    interface CDField {
        CDField getParent();
        CDRecord getCDRecord();
        ChannelField getChannelField();
        PVField getPVField();
        int getNumPuts();
        void incrementNumPuts();
        int getMaxNumPuts();
        void setMaxNumPuts(int numPuts);
        void clearNumPuts();
        void get(PVField pvField,boolean postPut);
        void put(PVField pvField);
        void put(PVField pvField,PVField pvSubField);
        String toString();
        String toString(int indentLevel);
    }

    interface CDRecord {
        CDField findCDField(PVField pvField);
        CDField findSourceCDField(PVField sourcePVField);
        PVRecord getPVRecord();
        CDStructure getCDStructure();
        PVDataCreate getPVDataCreate();
    }
    
    interface CDStructure extends CDField {
        CDField findCDField(PVField pvField);
        CDField findSourceCDField(PVField sourcePVField);
        CDField[] getCDFields();
        PVStructure getPVStructure();
    }

    interface CDArray extends CDField{
        PVArray getPVArray();
    }
    
    interface CDArrayArray extends CDArray {
        CDField findCDField(PVField pvField);
        CDField findSourceCDField(PVField sourcePVField);
        CDArray[] getElementCDArrays();
    }

    interface CDStructureArray extends CDArray {
        CDField findCDField(PVField pvField);
        CDField findSourceCDField(PVField sourcePVField);
        CDStructure[] getElementCDStructures();
    }

    class BaseCDRecord { ... }
    class BaseCDField { ... }
    class BaseCDArray { ... }
    class BaseCDStructure { ... }
    class BaseCDStructureArray { ... }
    class BaseCDArrayArray { ... }</pre>

<h3 id="CDField2">CDField</h3>

<p>Each field in the PVRecord associated with CDRecord has an associated
CDField or an extension. CDField has the methods:</p>
<dl>
  <dt style="font-family: courier;">getParent</dt>
    <dd>Get the parent of this field. If CDField is the CDStructure for the
      fieldGroup than the parent is null.</dd>
  <dt style="font-family: courier;">getCDRecord</dt>
    <dd>Get the CDRecord to which this CDField belongs.</dd>
  <dt style="font-family: courier;">getChannelField</dt>
    <dd>Get the ChannelField for this CDField.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Get the PVField associated with this CDField.</dd>
  <dt style="font-family: courier;">getNumPuts</dt>
    <dd>Get the number of dataPuts to this field.</dd>
  <dt style="font-family: courier;">incrementNumPuts</dt>
    <dd>Increment the number of dataPuts to this field. This is called by
      extensions to CDField.</dd>
  <dt style="font-family: courier;">getMaxNumPuts</dt>
    <dd>Get the maximum number of puts since the last clearNumPuts. This is
      the maximum number of puts to any particular element of the associated
      PVField. If PVField is a scalar or an array of scalars then this is the
      number of calls to dataPut.</dd>
  <dt style="font-family: courier;">setMaxNumPuts</dt>
    <dd>Set the maximum number of puts. This is called by derived
    classes.</dd>
  <dt style="font-family: courier;">clearNumPuts</dt>
    <dd>Set all number of puts to 0.</dd>
  <dt style="font-family: courier;">get</dt>
    <dd>Get data from the CDField and put it into pvField. If postPut is true
      channelField.postPut is called if the data is written.</dd>
  <dt style="font-family: courier;">get</dt>
    <dd>Put the CDField PVField with data from pvField or pvSubField.</dd>
</dl>

<h3 id="CDRecord">CDRecord</h3>

<p>CDRecord is for the ChannelFieldGroup. It has the methods:</p>
<dl>
  <dt style="font-family: courier;">findCDField</dt>
    <dd>Given a pvField find the ChannelField that holds the pvField.</dd>
  <dt style="font-family: courier;">findSourceCDField</dt>
    <dd>Given a pvField find the ChannelField that references the source
      pvField.</dd>
  <dt style="font-family: courier;">getPVRecord</dt>
    <dd>Get the PVRecord interface. This PVRecord will have a recordName
      which is the channelName, which is he name of the record to which the
      channel is connected.</dd>
  <dt style="font-family: courier;">getCDStructure</dt>
    <dd>Get the CDStructure for the CDRecord itself. The CDStructure will
      have a subfield for each member of the channelFieldGroup that the cd
      describes. Each subfield describes the data for it's ChannelField.</dd>
  <dt style="font-family: courier;">getPVDataCreate</dt>
    <dd>This is used by the code that creates CD interfaces. It returns a
      factory to create PVDat objects.</dd>
</dl>

<h3 id="CDStructur">CDStructure</h3>

<p>CDStructure is associated with a PVStructure. It has the methods:</p>
<dl>
  <dt style="font-family: courier;">findCDField</dt>
    <dd>Given a pvField find the ChannelField that holds the pvField.</dd>
  <dt style="font-family: courier;">findSourceCDField</dt>
    <dd>Given a pvField find the ChannelField that references the source
      pvField.</dd>
  <dt style="font-family: courier;">getCDFields</dt>
    <dd>Get the CDField array for the fields of the structure.</dd>
  <dt style="font-family: courier;">getPVStructure</dt>
    <dd>Get the PVStructure.</dd>
</dl>

<h3 id="CDArray">CDArray</h3>

<p>CDArray is associated with a PVArray. It has the method:</p>
<dl>
  <dt style="font-family: courier;">getPVArray</dt>
    <dd>Get the PVArray for this array.</dd>
</dl>

<p>CDArray is associated with a PVArray. It has the method:</p>

<h3 id="CDStructur1">CDStructureArray</h3>

<p>CDStructureArray is associated with a PVArray with structure elements.</p>
<dl>
  <dt style="font-family: courier;">findCDField</dt>
    <dd>Given a pvField find the ChannelField that holds the pvField.</dd>
  <dt style="font-family: courier;">findSourceCDField</dt>
    <dd>Given a pvField find the ChannelField that references the source
      pvField.</dd>
  <dt style="font-family: courier;">getElementCDStructures</dt>
    <dd>Get the CDStructure array.</dd>
</dl>

<h3 id="CDArrayArr">CDArrayArray</h3>

<p>CDArrayArray is associated with a PVArray with array elements.</p>
<dl>
  <dt style="font-family: courier;">findCDField</dt>
    <dd>Given a pvField find the ChannelField that holds the pvField.</dd>
  <dt style="font-family: courier;">findSourceCDField</dt>
    <dd>Given a pvField find the ChannelField that references the source
      pvField.</dd>
  <dt style="font-family: courier;">getElementCDArrays</dt>
    <dd>Get the CDArray array.</dd>
</dl>

<h3 id="Base">Base CD Classes</h3>

<p>The BaseCD classes provide implementations of the CD interraces. These
provide complete imnplementations and should rarely need to be extended.</p>
<hr />

<h2 style="text-align: center" id="CDGet">CDGet, CDPUT, CDMonitor</h2>
<hr />

<h3 id="CDGet1">CDGet</h3>
<pre>    public interface CDGet {
        void destroy();
        void get(CD cd);
    }
    
    public interface CDGetRequester extends Requester{
        void getDone(RequestResult requestResult);
    }</pre>

<p><span style="font-family: courier;">CDGet</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy the CDGet.</dd>
  <dt style="font-family: courier;">get</dt>
    <dd>Get data and put it into the CD.</dd>
</dl>

<p><span style="font-family: courier;">CDGetRequester</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">getDone</dt>
    <dd>The get has finished. If successful the data is in the CD.</dd>
</dl>

<h3 id="CDPut">CDPut</h3>
<pre>    interface CDPut {
        void destroy();
        void get(CD cd);
        void put(CD cd);
    }
    
    public interface CDPutRequester extends Requester{
        void getDone();
        void putDone(RequestResult requestResult);
    }</pre>

<p>This is a put that uses a CD to hold the data. The caller puts data into
the CD before calling CDPut.put().</p>

<p><span style="font-family: courier;">CDPut</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy the CDGet.</dd>
  <dt style="font-family: courier;">get</dt>
    <dd>Get the latest target data and put it into cd. The target record is
      not processed.</dd>
  <dt style="font-family: courier;">put</dt>
    <dd>Put the data currently residing in cd and put it to the target. If
      process is requested than the record is set active before the data is
      put.</dd>
</dl>

<p><span style="font-family: courier;">CDPutRequester</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">getDone</dt>
    <dd>The get request is done and the data is in cd.</dd>
  <dt style="font-family: courier;">putDone</dt>
    <dd>The put request is finished. The result of record processing, if
      specified, is returned.</dd>
</dl>

<h3 id="CDMonitor">CDMonitor</h3>

<p>This is support for being notified when a put is issued to a field of an
IOC database. The notification includes data.</p>
<pre>    interface CDMonitor {
        void lookForPut(ChannelField channelField, boolean causeMonitor);
        void lookForChange(ChannelField channelField, boolean causeMonitor);
        void lookForAbsoluteChange(ChannelField channelField,double value);
        void lookForPercentageChange(ChannelField channelField,double value);
        void start(int queueSize, String threadName, int threadPriority);
        void stop();
    }
    
    interface CDMonitorRequester extends Requester{
        void monitorCD(CD cD);
        void dataOverrun(int number);
    }
    
    class CDMonitorFactory {
        public static CDMonitor create(Channel channel,
            CDMonitorRequester cdMonitorRequester)
    }</pre>

<p>CDMonitor has the methods:</p>
<dl>
  <dt style="font-family: courier;">lookForPut</dt>
    <dd>Look for a put. If the ChannelField is a structure then look for a
      put to any subfield of the structure.</dd>
  <dt style="font-family: courier;">lookForChange</dt>
    <dd>Look for a change in a data value. This is only valid for a primitive
      field.</dd>
  <dt style="font-family: courier;">lookForAbsoluteChange</dt>
    <dd>Look for an absolute change in the data. The argument value is the
      deadband. This is only valid if ChannelField is a numeric scalar.</dd>
  <dt style="font-family: courier;">lookForPercentageChange</dt>
    <dd>Look for a percentage change in the data. The argument value is the
      deadband. This is only valid if ChannelField is a numeric scalar.</dd>
  <dt style="font-family: courier;">start - MonitorNotify</dt>
    <dd>Notify when a change occurs but do not send data. The caller can
      issue a get request to retrieve the data.</dd>
  <dt style="font-family: courier;">start - Monitor</dt>
    <dd>When data changes send it the the requester.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop monitoring.</dd>
</dl>

<p>CDMonitorRequester has the methods:</p>
<dl>
  <dt style="font-family: courier;">monitorCD</dt>
    <dd>The modified data.</dd>
  <dt style="font-family: courier;">dataOverrun</dt>
    <dd>The number of missed monitors.</dd>
</dl>

<p>CDMonitorRequester has the method:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a CDMonitor</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Example">Example For CD</h2>
<hr />

<h3 id="Discussion">Discussion</h3>

<p>This example creates a CD for a fieldGroup that has the following:</p>
<ul>
  <li>value<br />
  </li>
  <li>alarm - a property of value</li>
  <li>timeStamp - a property of value</li>
</ul>

<p>The definition is:</p>
<pre>    static class ValueData implements ChannelFieldGroupListener{
        ValueData(Channel channel);
        ChannelFieldGroup init();
        void clear();
        boolean nextGetField(Channel channel, ChannelField field, PVField pvField);
        void printResults();
    }</pre>
where 
<dl>
  <dt style="font-family: courier;">ValueData</dt>
    <dd>The constructor</dd>
  <dt style="font-family: courier;">init</dt>
    <dd>creates everthing it needs. Returns null if anything fails.</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Prepares to accept a new set of data for the fieldGroup</dd>
  <dt style="font-family: courier;">nextGetField</dt>
    <dd>Adds the data to the cd list.</dd>
  <dt style="font-family: courier;">printResults</dt>
    <dd>Prints all data received since last clear.</dd>
</dl>

<p>What it provides for later examples is the ability to dump everthing an
example gets from a record after the record is no longer locked.</p>

<h3 id="Implementa">Implementation</h3>
<pre>    class ValueData implements ChannelFieldGroupListener{
        private Channel channel;
        private String fieldName;
        private ChannelFieldGroup channelFieldGroup;
        private ChannelField valueField;
        private ChannelField alarmField = null;
        private ChannelField timeStampField = null;

        ValueData(Channel channel,String fieldName) {
            this.channel = channel;
            this.fieldName = fieldName;
        }

       
        public void accessRightsChange(Channel channel, ChannelField channelField) {
            // TODO Auto-generated method stub

        }

        private ChannelFieldGroup init() {
            channelFieldGroup = channel.createFieldGroup(this);
            valueField = channel.createChannelField(fieldName);
            if(valueField==null) {
                System.out.printf("findField returned %s%n", result.toString());
                return null;
            }
            channelFieldGroup.addChannelField(valueField);
            alarmField =  valueField.findProperty("alarm");
            if(alarmField!=null) channelFieldGroup.addChannelField(alarmField);
            timeStampField = valueField.findProperty("timeStamp");
            if(timeStampField!=null) channelFieldGroup.addChannelField(timeStampField);
            return channelFieldGroup;
        }


       private String printResults(CD cd) {
            StringBuilder builder = new StringBuilder();
            ChannelFieldGroup channelFieldGroup = cd.getChannelFieldGroup();
            List&lt;ChannelField&gt; channelFieldList = channelFieldGroup.getList();
            CDStructure cdStructure = cd.getCDRecord().getCDStructure();
            CDField[] cdbDatas = cdStructure.getCDFields();
            int maxNumPuts = cd.getMaxPutsToField();
            if(maxNumPuts!=1) {
                builder.append(String.format(
                    " maxNumPuts %d ",maxNumPuts));
            }
            for(int i=0;i&lt;cdbDatas.length; i++) {
                CDField cdField = cdbDatas[i];
                maxNumPuts = cdField.getMaxNumPuts();
                if(maxNumPuts&lt;=0) continue;
                if(maxNumPuts!=1) {
                    builder.append(String.format(
                        " maxNumPuts %d ",maxNumPuts));
                }
                PVField pvField = cdField.getPVField();
                ChannelField channelField = channelFieldList.get(i);
                if(channelField==valueField) {
                    builder.append(String.format(
                        "value %s ",
                        pvField.toString(2)));
                } else if(channelField==alarmField) {
                    builder.append(String.format(" alarm %s",
                        pvField.toString()));
                } else if(channelField==timeStampField) {
                    PVTimeStamp pvTimeStamp = PVTimeStamp.create(pvField);
                    TimeStamp timeStamp = new TimeStamp();
                    pvTimeStamp.get(timeStamp);
                    long seconds = timeStamp.secondsPastEpoch;
                    int nano = timeStamp.nanoSeconds;
                    long now = nano/1000000 + seconds*1000;
                    Date date = new Date(now);
                    builder.append(String.format(" time %s",
                        date.toLocaleString()));
                }
                if(cdField.getNumSupportNamePuts()&gt;0) {
                    builder.append(String.format("supportName %s numSupportNamePuts %d%n",
                        pvField.getSupportName(),cdField.getNumSupportNamePuts()));
                }
            }
            return builder.toString();
        }
    }</pre>
<hr />

<h2 style="text-align: center" id="Process">Process Example</h2>
<hr />

<h3 id="Discussion1">Discussion</h3>

<p>This example shows how to implement a process request.</p>

<h3 id="Implementa1">Implementation</h3>
<pre>    static class Process implements ChannelProcessRequester,ChannelListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelProcess channelProcess;

        Process(String pvname) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelProcess = channel.createChannelProcess(this);
           // SHOULD CHECK FOR NULL
        }
        void destroy() {
            channel.destroy();
        }
        void process() {
            allDone = false;
            channelProcess.process();
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException e) {
                return;
            } finally {
                lock.unlock();
            }
        }

        public String getRequesterName() {
            return "Put:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="Example1">Get Example</h2>
<hr />

<h3 id="Discussion2">Discussion</h3>

<p>This example shows how to implement a get request.</p>

<h3 id="Implementa2">Implementation</h3>
<pre>    static class Get implements
    ChannelGetRequester,
    ChannelListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelGet channelGet;
        private ValueData valueData;
        private ChannelFieldGroup getFieldGroup;

        Get(String pvname,boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelGet = channel.createChannelGet(this, process);
        }
        void destroy() {
            channel.destroy();
        }
        boolean connect() {

            valueData = new ValueData(channel);
            getFieldGroup = valueData.init();
            if(getFieldGroup==null) return false;
            return true;
        }

        void get() {
            allDone = false;
            valueData.clear();
            channelGet.get(getFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
            valueData.printResults();
        }

        public boolean nextDelayedGetField(PVField pvField) {
            //nothing to do
        }

        public String getRequesterName() {
            return "PutGet:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextGetField(Channel channel, ChannelField field, PVField pvField) {
            valueData.nextGetField(channel, field, pvField);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="Example2">Put Example</h2>
<hr />

<h3 id="Discussion3">Discussion</h3>

<p>This example shows how to implement a put request.</p>

<h3 id="Implementa3">Implementation</h3>
<pre>    static class Put implements
    ChannelPutRequester,
    ChannelListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelPut channelPut;
        private ChannelFieldGroup putFieldGroup;
        private ChannelField valueField;
        private double value;

        Put(String pvname, boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);

            channelPut = channel.createChannelPut(this, process);
        }

        public boolean nextDelayedPutField(PVField pvField) {
            // nothing to do
            return false;
        }
        void destroy() {
            channel.destroy();
        }
        boolean connect() {
            putFieldGroup = channel.createFieldGroup(this);
            valueField = channel.findField("value");
            if(valueField==null) {
                System.out.println("PutGet:set value not found");
                return false;
            }
            putFieldGroup.addChannelField(valueField);
            return true;
        }

        void put(double value) {
            this.value = value;
            allDone = false;
            channelPut.put(putFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
        }

        public String getRequesterName() {
            return "Put:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextPutField(Channel channel, ChannelField field, PVField pvField) {
            PVDouble pvDouble = (PVDouble)pvField;
            pvDouble.put(value);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="PutGet">PutGet Example</h2>
<hr />

<h3 id="Discussion4">Discussion</h3>

<p>This example shows how to implement a putGet request. When the put method
is called, it puts a double value to a field named value, optionally
processes the record, and retrieves the value, status, severity, and
timeStamp.</p>

<h3 id="Implementa4">Implementation</h3>
<pre>    static class PutGet implements
    ChannelPutGetRequester,
    ChannelListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelPutGet channelPutGet;
        private ChannelFieldGroup putFieldGroup;
        private ValueData valueData;
        private ChannelFieldGroup getFieldGroup;
        private ChannelField valueField;
        private double value;

        PutGet(String pvname,boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelPutGet = channel.createChannelPutGet(this, process);
        }

        public boolean nextDelayedPutField(PVField pvField) {
            // Nothing to do
            return false;
        }

        public boolean nextDelayedGetField(PVField pvField) {
            // Nothing to do
            return false;
        }

        boolean connect() {
            putFieldGroup = channel.createFieldGroup(this);
            valueField = channel.findField("value");
            if(valueField==null) {
                System.out.println("PutGet:set value not found");
                return false;
            }
            putFieldGroup.addChannelField(valueField);
            valueData = new ValueData(channel);
            getFieldGroup = valueData.init();
            if(getFieldGroup==null) return false;
            return true;
        }

        void destroy() {
            channel.destroy();
        }

        void putGet(double value) {
            this.value = value;
            allDone = false;
            valueData.clear();
            channelPutGet.putGet(putFieldGroup, getFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
            valueData.printResults();
        }

        public String getRequesterName() {
            return "PutGet:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextGetField(Channel channel, ChannelField field, PVField pvField) {
            valueData.nextGetField(channel, field, pvField);
            return false;
        }

        public boolean nextPutField(Channel channel, ChannelField field, PVField pvField) {
            PVDouble pvDouble = (PVDouble)pvField;
            pvDouble.put(value);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
</body>
</html>
