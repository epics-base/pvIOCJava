<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: channel Access</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: channel Access<br />
package: org.epics.ioc.ca<br />
2007.02.02</h1>
CONTENTS

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Channel">Channel Definitions</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Channel1">Channel</a></li>
      <li><a href="#ChannelFin">ChannelFindFieldResult</a></li>
      <li><a href="#ChannelSta">ChannelStateListener</a></li>
      <li><a href="#AccessRigh">AccessRights</a></li>
      <li><a href="#ChannelFie">ChannelField</a></li>
      <li><a href="#ChannelFie1">ChannelFieldGroupListener</a></li>
      <li><a href="#ChannelFie2">ChannelFieldGroup</a></li>
      <li><a href="#ChannelFac">ChannelFactory</a></li>
      <li><a href="#ChannelAcc">ChannelAccess</a></li>
    </ul>
  </li>
  <li><a href="#Channel2">Channel Process, Get, Put, PutGet</a>
    <ul>
      <li><a href="#Definition1">Definitions</a></li>
      <li><a href="#ChannelPro">ChannelProcess</a></li>
      <li><a href="#ChannelGet">ChannelGet</a></li>
      <li><a href="#ChannelPut">ChannelPut</a></li>
      <li><a href="#ChannelPut1">ChannelPutGet</a></li>
    </ul>
  </li>
  <li><a href="#ChannelMon">ChannelMonitor</a>
    <ul>
      <li><a href="#Definition2">Definitions</a></li>
      <li><a href="#ChannelMon1">ChannelMonitor</a></li>
    </ul>
  </li>
  <li><a href="#Channel3">Channel Data</a>
    <ul>
      <li><a href="#Definition3">Definitions</a></li>
      <li><a href="#ChannelDat">ChannelDataPV</a></li>
      <li><a href="#ChannelDat1">ChannelData</a></li>
      <li><a href="#ChannelDat2">ChannelDataQueue</a></li>
      <li><a href="#ChannelDat3">ChannelDataFactory</a></li>
    </ul>
  </li>
  <li><a href="#Local">Local Channel Access</a></li>
  <li><a href="#Example">Example For ChannelData</a>
    <ul>
      <li><a href="#Discussion">Discussion</a></li>
      <li><a href="#Implementa">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Process">Process Example</a>
    <ul>
      <li><a href="#Discussion1">Discussion</a></li>
      <li><a href="#Implementa1">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Example1">Get Example</a>
    <ul>
      <li><a href="#Discussion2">Discussion</a></li>
      <li><a href="#Implementa2">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#Example2">Put Example</a>
    <ul>
      <li><a href="#Discussion3">Discussion</a></li>
      <li><a href="#Implementa3">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#PutGet">PutGet Example</a>
    <ul>
      <li><a href="#Discussion4">Discussion</a></li>
      <li><a href="#Implementa4">Implementation</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>This package contains Java definitions for Channel Access clients:</p>
<hr />

<h2 style="text-align: center" id="Channel">Channel Definitions</h2>
<hr />

<p>A channel is a connection to a PVRecord. The channel definitions allow
access to an arbitrary number of fields in a record. A channel allows remote
access to PVRecords.</p>

<p>This section defines the interface and factory classes for connecting to a
channel and creating interfaces for accessing a channel. The interfaces for
accessing a channel are defined in later sections.</p>

<h3 id="Definition">Definitions</h3>
<pre>    public interface Channel {
        String getChannelName();
        public void message(String message, MessageType messageType);
        void destroy();
        boolean isConnected();
        ChannelFindFieldResult findField(String name);
        String getOtherChannel();
        String getOtherField();
        ChannelField getChannelField();
        ChannelFieldGroup createFieldGroup(ChannelFieldGroupListener listener);
        ChannelProcess createChannelProcess(
            ChannelProcessRequestor channelProcessRequestor);
        void destroy(ChannelProcess channelProcess);
        ChannelGet createChannelGet(
            ChannelGetRequestor channelGetRequestor,boolean process);
        void destroy(ChannelGet channelGet);
        ChannelPut createChannelPut(
            ChannelPutRequestor channelPutRequestor,boolean process);
        void destroy(ChannelPut channelPut);
        ChannelPutGet createChannelPutGet(
            ChannelPutGetRequestor channelPutGetRequestor,boolean process);
        void destroy(ChannelPutGet channelPutGet);
        ChannelMonitor createChannelMonitor(boolean onlyWhileProcessing);
        void destroy(ChannelMonitor channelMonitor);
        boolean isLocal();
    }

    public enum ChannelFindFieldResult {
        otherChannel,
        thisChannel,
        notFound,
        failure
    }

    public interface ChannelStateListener {
        void channelStateChange(Channel c,boolean isConnected);
        void disconnect(Channel c);
    }

    public enum AccessRights {
        none,
        read,
        readWrite
    }

    public interface ChannelField {
        Field getField();
        AccessRights getAccessRights();
    }

    public interface ChannelFieldGroupListener {
        void accessRightsChange(Channel channel,ChannelField channelField);
    }

    public interface ChannelFieldGroup {
        void addChannelField(ChannelField channelField);
        void removeChannelField(ChannelField channelField);
        public List&lt;ChannelField&gt; getList();
    }

    public class ChannelFactory {
        public static Channel createChannel(
            String name,ChannelStateListener listener);
        public static void registerLocalChannelAccess(
            ChannelAccess channelAccess);
        public static void registerRemoteChannelAccess(
            ChannelAccess channelAccess);
    }

    public interface ChannelAccess {
        Channel createChannel(String name,ChannelStateListener listener);
    }</pre>

<h3 id="Channel1">Channel</h3>

<p>A channel provides access to a single PVRecord, but to an arbitrary number
of fields in the record. The methods are:</p>
<dl>
  <dt style="font-family: courier;">getChannelName</dt>
    <dd>This is the PVRecord name or closely related to the recordName.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Channel Access code calls this to report errors and/or diagnostic
      information.</dd>
  <dt style="font-family: courier;">destroy</dt>
    <dd>Destroy the channel. Any active requests will still occur but no new
      requests will be accepted for the channel.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>Is the channel connected?</dd>
  <dt style="font-family: courier;">findField</dt>
    <dd>Locate the field, The result of the request is returned. Depending on
      the result the following three methods provide more information.</dd>
  <dt style="font-family: courier;">getOtherChannel</dt>
    <dd>If <span style="font-family: courier;">findField</span> returned
      <span style="font-family: courier;">otherChannel</span>, this returns
      the name of the channel that has the data. In order to access the data
      a new channel must be created</dd>
  <dt style="font-family: courier;">getOtherField</dt>
    <dd>If <span style="font-family: courier;">findField</span> returned
      <span style="font-family: courier;">otherChannel</span>, this returns
      the name of the field that has the data. <span
      style="font-family: courier;">getOtherChannel</span> and <span
      style="font-family: courier;">getOtherField</span> provide all the
      information needed to connect to the other channel.</dd>
  <dt style="font-family: courier;">getChannelField</dt>
    <dd>If <span style="font-family: courier;">findField</span> returned
      <span style="font-family: courier;">thisChannel</span>, this returns a
      <span style="font-family: courier;">channelField</span> that can be
      added to a <span style="font-family: courier;">fieldGroup.</span></dd>
  <dt style="font-family: courier;">createFieldGroup</dt>
    <dd>get, put, putGet, and monitor all use fieldGroup to specify the data
      to get/put from/to a channel.</dd>
  <dt style="font-family: courier;">createChannelProcess</dt>
    <dd>Create a process request. This is used to ask a channel to
    process.</dd>
  <dt><span style="font-family: courier;">destroy</span> - channelProcess</dt>
    <dd>Destroy a channelProcess. This is done automatically when a channel
      is destroyed.</dd>
  <dt style="font-family: courier;">createChannelGet</dt>
    <dd>Create a get request.</dd>
  <dt><span style="font-family: courier;">destroy</span> - channelGet</dt>
    <dd>Destroy a channelGet. This is done automatically when a channel is
      destroyed.</dd>
  <dt style="font-family: courier;">createChannelPut</dt>
    <dd>Create a put request.</dd>
  <dt><span style="font-family: courier;">destroy</span> - channelPut</dt>
    <dd>Destroy a channelPut. This is done automatically when a channel is
      destroyed.</dd>
  <dt style="font-family: courier;">createChannelPutGet</dt>
    <dd>Create a putGet request.</dd>
  <dt><span style="font-family: courier;">destroy</span> - channelPutGet</dt>
    <dd>Destroy a channelPutGet. This is done automatically when a channel is
      destroyed.</dd>
  <dt style="font-family: courier;">createChannelMonitor</dt>
    <dd>Create a channel monitor. This is used to create monitors for the
      channel.</dd>
  <dt><span style="font-family: courier;">destroy</span> - channelMonitor</dt>
    <dd>Destroy a channelMonitor. This is done automatically when a channel
      is destroyed.</dd>
  <dt style="font-family: courier;">isLocal</dt>
    <dd>Is the channel local or remote.</dd>
</dl>

<h3 id="ChannelFin">ChannelFindFieldResult</h3>

<p><span style="font-family: courier;">findField</span> returns <span
style="font-family: courier;">ChannelFindFieldResult</span>. This has the
values:</p>
<dl>
  <dt style="font-family: courier;">otherChannel</dt>
    <dd>The data resides in another channel. <span
      style="font-family: courier;">getOtherChannel</span> and <span
      style="font-family: courier;">getOtherField</span> can be called to get
      the information needed to create and access the other channel.</dd>
  <dt style="font-family: courier;">thisChannel</dt>
    <dd>The data resides in this channel. <span
      style="font-family: courier;">getChannelField</span> can be called to
      get an interface for accessing the field.</dd>
  <dt style="font-family: courier;">notFound</dt>
    <dd>The requested field does not exist in this channel.</dd>
  <dt style="font-family: courier;">failure</dt>
    <dd>The request failed. This will happen if the channel has been
      destroyed or disconnected.</dd>
</dl>

<h3 id="ChannelSta">ChannelStateListener</h3>

<p><span style="font-family: courier;">ChannelStateListener</span> is an
interface that must be implemented by code that creates a channel. It has the
methods:</p>
<dl>
  <dt style="font-family: courier;">channelStateChange</dt>
    <dd>The connection state changed. The listener can call <span
      style="font-family: courier;">channel.isConnected</span> to find the
      connection state.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>The channel is going away. The channel will not accept any further
      requests.</dd>
</dl>

<h3 id="AccessRigh">AccessRights</h3>

<p>AccessRights is an enum specifying access rights to fields of a channel.
Note that access rights are not currently implemented.</p>
<dl>
  <dt style="font-family: courier;">none</dt>
    <dd>The channel can neither read or write the field.</dd>
  <dt style="font-family: courier;">read</dt>
    <dd>The channel can read but not modify the channel.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>The channel can both read and modify the channel</dd>
</dl>

<h3 id="ChannelFie">ChannelField</h3>

<p><span style="font-family: courier;">ChannelField</span> describes a
specific field in a channel.</p>
<dl>
  <dt style="font-family: courier;">getField</dt>
    <dd>Returns the Field that describes the field. See pvAccess for
    details.</dd>
  <dt style="font-family: courier;">getAccessRights</dt>
    <dd>Get the access rights for the field.</dd>
</dl>

<h3 id="ChannelFie1">ChannelFieldGroupListener</h3>

<p><span style="font-family: courier;">ChannelFieldGroupListener</span>
provides a method that is called whenever the access rights change. The
method is:</p>
<dl>
  <dt style="font-family: courier;">accessRightsChange</dt>
    <dd>The listener can call <span
      style="font-family: courier;">channelField.getAccessRights</span> to
      get the current rights.</dd>
</dl>

<h3 id="ChannelFie2">ChannelFieldGroup</h3>

<p><span style="font-family: courier;">ChannelFieldGroup</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">addChannelField</dt>
    <dd>Add a channelField to the group. Note that getChannelField returns a
      channelField.</dd>
  <dt style="font-family: courier;">removeChannelField</dt>
    <dd>Remove a channelField from the group.</dd>
  <dt style="font-family: courier;">getList</dt>
    <dd>Get the list of channelFields in the group.</dd>
</dl>

<h3 id="ChannelFac">ChannelFactory</h3>

<p>A channelFactory creates a channel. A channel is either local, i.e. code
running in an IOC is accessing a field in the local IOC database, or remote,
code is accessing a channel that is available over the network.
Channelfactory also has methods called by support for local access and by
support for remote access.</p>

<p>NOTES:</p>
<ul>
  <li>Currently only local access is implemented.</li>
  <li>ChannelFactory will have to be modified to support multiple remote
    servers. For example servers for both javaIOCs and V3 IOCs should be
    developed and supported.</li>
</ul>

<p>The methods implemented by ChannelFactory are:</p>
<dl>
  <dt style="font-family: courier;">createChannel</dt>
    <dd>A client calls this to create a channel. The channel is created and
      connection managment is started.</dd>
  <dt style="font-family: courier;">registerLocalChannelAccess</dt>
    <dd>This is the registration call for local channel access.</dd>
  <dt style="font-family: courier;">registerRemoteChannelAccess</dt>
    <dd>This is the registration call for remote channel access.</dd>
</dl>

<h3 id="ChannelAcc">ChannelAccess</h3>

<p>This is an interface that must be implemented by code that implements
channel access. It is called by ChannelFactory. It has onl one method</p>
<dl>
  <dt style="font-family: courier;">createChannel</dt>
    <dd>ChannelFactory calls this first for local channel access and if the
      channel is not found then for remote channel access.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Channel2">Channel Process, Get, Put,
PutGet</h2>
<hr />

<h3 id="Definition1">Definitions</h3>
<pre>    public interface ChannelProcess {
        boolean process();
    }

    public interface ChannelProcessRequestor extends Requestor {
            void processDone(RequestResult requestResult);
    }

    public interface ChannelGet {
        boolean get(ChannelFieldGroup fieldGroup);
        void getDelayed(PVData pvData);
    }

    public interface ChannelGetRequestor extends Requestor {
        boolean nextGetData(ChannelField field,PVData data);
        boolean nextDelayedGetData(PVData data);
        void getDone(RequestResult requestResult);
    }

    public interface ChannelPut {
        boolean put(ChannelFieldGroup fieldGroup);
        void putDelayed(PVData pvData);
    }

    public interface ChannelPutRequestor extends Requestor {
        boolean nextPutData(ChannelField field,PVData data);
        boolean nextDelayedPutData(PVData data);
        void putDone(RequestResult requestResult);
    }

    public interface ChannelPutGet {
        boolean putGet(
            ChannelFieldGroup putFieldGroup,ChannelFieldGroup getFieldGroup);
        void putDelayed(PVData pvData);
        void getDelayed(PVData pvData);
    }

    public interface ChannelPutGetRequestor extends
        ChannelPutRequestor,ChannelGetRequestor {}</pre>

<h3 id="ChannelPro">ChannelProcess</h3>

<p>ChannelProcess has the single method:</p>
<dl>
  <dt style="font-family: courier;">process</dt>
    <dd>Process the channel. For example if the channel is a database record,
      process the record. <span style="font-family: courier;">process</span>
      returns (false, true) if the request (can not, can) be done. Normally
      true is returned. A false value probably means that the channel is not
      connected.</dd>
</dl>

<p>ChannelProcessRequestor has the methods:</p>
<dl>
  <dt style="font-family: courier;">getRequestorName</dt>
    <dd>Determined by the requestor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Called for error or informational messages.</dd>
  <dt style="font-family: courier;">processDone</dt>
    <dd>Called when the record associated with the channel completes
      processing.</dd>
</dl>

<p>A ChannelProcess is created via a call:</p>
<pre>    ChannelProcess channelProcess = channel.createChannelProcess(this).</pre>

<p>The requestor must implement interface <span
style="font-family: courier;">ChannelProcessRequestor</span>. <span
style="font-family: courier;">null</span> is returned if the requestor is not
allowed to process the channel. For example the channel is connected to a
record, that already has an assigned record processor.</p>

<p>If <span style="font-family: courier;">createChannelProcess</span> or
<span style="font-family: courier;">process</span> itself fails, <span
style="font-family: courier;">channelProcessRequestor.message</span> is
called. If <span style="font-family: courier;">process</span> returns true,
then <span
style="font-family: courier;">channelProcessRequestor.requestDone</span> is
called when the channel completes processing.</p>

<h3 id="ChannelGet">ChannelGet</h3>

<p><span style="font-family: courier;">ChannelGet</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">get</dt>
    <dd>Get all data for the fieldGroup. The data is returned via calls to
      channelGetRequestor.</dd>
  <dt style="font-family: courier;">getDelayed</dt>
    <dd>If <span
      style="font-family: courier;">channelGetRequestor.nextGetData</span>
      returns true, meaning the requestor is not done retrieving the data,
      then the requestor calls <span
      style="font-family: courier;">getDelayed</span> to retrieve the
    data.</dd>
</dl>

<p><span style="font-family: courier;">ChannelGetRequestor</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">nextGetData</dt>
    <dd>The next pvData in the fieldGroup. The requestor returns false if it
      is done with the data and true otherwise. If true is returned the the
      requestor calls <span
      style="font-family: courier;">channelGet.getDelayed</span> when it is
      ready.</dd>
  <dt style="font-family: courier;">nextDelayedGetData</dt>
    <dd>When the requestor calls <span
      style="font-family: courier;">channelGet.getDelayed</span> the data is
      returned via a call to <span
      style="font-family: courier;">nextDelayedGetData</span></dd>
  <dt style="font-family: courier;">getDone</dt>
    <dd>The request is done.</dd>
</dl>

<p>Delayed gets are provided for channel access servers that need to block
while handling data. Consider a server that needs to send an array over the
network. If it is a very large array, the server has to send the array in
multuple network buffers. In order not to lock a database record while the
array is being sent it can use the delayed methods. It implements something
like:</p>
<pre>    PVArray pvArray;
    int size,offset;

    boolean nextGetData(Channel channel,ChannelField field,PVData data) {
        // recognize that data is actually an array
        pvArray = (PVArray)data;
        size = pvArray.getLength();
        offset = 0;
        return true;
    }
    ...
    while(moreToDo) {
       // get networkBuffer. This may block while waiting
       channelGet.getDelayed(pvArray();
       // send buffer. This might block
       if(offset&gt;=size) break; // all done
    }
    ...
    boolean nextDelayedGetData(PVData data) {
        // transfer data to network buffer
        // update offset
        if(offset&lt;size) return true // getDelayed will again be called
        return false // all done
    }</pre>

<h3 id="ChannelPut">ChannelPut</h3>

<p><span style="font-family: courier;">ChannelPut</span> has the methods:</p>
<dl>
  <dt style="font-family: courier;">put</dt>
    <dd>Put all data for the fieldGroup. The data is fetched via calls to
      <span style="font-family: courier;">channelPutRequestor.</span></dd>
  <dt style="font-family: courier;">putDelayed</dt>
    <dd>If <span
      style="font-family: courier;">channelPutRequestor.nextPutData</span>
      returns true, meaning the requestor has not put the data, then the
      requestor calls <span style="font-family: courier;">putDelayed</span>
      when it is ready to put the data.</dd>
</dl>

<p><span style="font-family: courier;">ChannelPutRequestor</span> has the
methods:</p>
<dl>
  <dt style="font-family: courier;">nextPutData</dt>
    <dd>The next pvData in the fieldGroup. The requestor returns false if it
      is done with that data and true if it is not ready to put the data. If
      true is returned the the requestor calls <span
      style="font-family: courier;">channelPut.putDelayed</span> when it is
      ready.</dd>
  <dt style="font-family: courier;">nextDelayedPutData</dt>
    <dd>When the requestor calls <span
      style="font-family: courier;">channelPut.putDelayed</span> the data is
      put via a call to <span
      style="font-family: courier;">nextDelayedPutData</span></dd>
  <dt style="font-family: courier;">putDone</dt>
    <dd>The put request is complete.</dd>
</dl>

<p>Like delayed gets delayed puts are used by servers that need to block. For
example servers that transfer data from the network to an IOC database.</p>

<h3 id="ChannelPut1">ChannelPutGet</h3>

<p>This is a combination of <span
style="font-family: courier;">ChannelPut</span> and <span
style="font-family: courier;">ChannelGet</span>. A typical example is a
client request to:</p>
<ul>
  <li>Put data to a record.</li>
  <li>Process the record</li>
  <li>Return the status and severity to the client.</li>
</ul>
<hr />

<h2 style="text-align: center" id="ChannelMon">ChannelMonitor</h2>
<hr />

<p>NOTE: ChannelData is described in the next section.</p>

<h3 id="Definition2">Definitions</h3>
<pre>    public interface ChannelMonitor {
        void lookForChange(ChannelField channelField,boolean causeMonitor);
        void lookForAbsoluteChange(ChannelField channelField,double value);
        void lookForPercentageChange(ChannelField channelField,double value);
        boolean start(ChannelMonitorNotifyRequestor channelMonitorNotifyRequestor,
            String threadName, ScanPriority scanPriority);
        boolean start(ChannelMonitorRequestor channelMonitorRequestor,
            int queueSize, String threadName, ScanPriority scanPriority);
        void stop();
    }
    
    public interface ChannelMonitorRequestor extends Requestor{
        void monitorData(ChannelData channelData);
        void dataOverrun(int number);
    }
    
    public interface ChannelMonitorNotifyRequestor extends Requestor {
        void monitorEvent();
    }</pre>

<h3 id="ChannelMon1">ChannelMonitor</h3>

<p>ChannelMonitor has the methods:</p>
<dl>
  <dt style="font-family: courier;">lookForChange</dt>
    <dd>Look for a change. If the ChannelField is a structure then look for a
      change in any subfield of the structure.</dd>
  <dt style="font-family: courier;">lookForAbsoluteChange</dt>
    <dd>Look for an absolute change in the data. The argument value is the
      deadband. This is only valid if ChannelField is a numeric scalar.</dd>
  <dt style="font-family: courier;">lookForPercentageChange</dt>
    <dd>Look for a percentage change in the data. The argument value is the
      deadband. This is only valid if ChannelField is a numeric scalar.</dd>
  <dt style="font-family: courier;">start - MonitorNotify</dt>
    <dd>Notify when a change occurs but do not send data. The caller can
      issue a get request to retrieve the data.</dd>
  <dt style="font-family: courier;">start - Monitor</dt>
    <dd>When data changes send it the the requestor.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop monitoring.</dd>
</dl>

<p>ChannelMonitorRequestor has the methods:</p>
<dl>
  <dt style="font-family: courier;">monitorData</dt>
    <dd>The modified data.</dd>
  <dt style="font-family: courier;">dataOverrun</dt>
    <dd>The number of missed monitors.</dd>
</dl>

<p>ChannelMonitorNotifyRequestor has the methods:</p>
<dl>
  <dt style="font-family: courier;">monitorEvent</dt>
    <dd>Data has been modified.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Channel3">Channel Data</h2>
<hr />

<p>ChannelData helps solve two problems:</p>
<ol>
  <li>Blocking with a record locked.<br />
    An example is a channel access server. Instead of pre allocating network
    buffers for a fieldGroup it can create a channelData, transfer data from
    a record to the channelData, and then transfer the channeldData to a
    network buffer. In the case of a large array multiple network buffers
    will be required.</li>
  <li>Data repository for database monitoring.<br />
    For database monitoring a queue of channelDatas can be created. When a
    monitored record changes, a channelData can be taken from the queue, and
    the data values stored in the channelData. This can be done without
    blocking. When the server is ready it can empty the queue and send the
    channelData over the network.</li>
</ol>

<h3 id="Definition3">Definitions</h3>
<pre>    public interface ChannelDataPV {
        ChannelData getChannelData();
        ChannelField getChannelField();
        PVData getPVData();
        boolean isInitial();
        boolean enumIndexChange();
        boolean enumChoicesChange();
        boolean supportNameChange();
        boolean configurationStructureChange();
    }

    public interface ChannelData {
        ChannelFieldGroup getChannelFieldGroup();
        void clear();
        void initData(ChannelField channelField,PVData pvData);
        void dataPut(PVData pvData);
        void enumIndexPut(PVEnum pvEnum);
        void enumChoicesPut(PVEnum pvEnum);
        void supportNamePut(PVData pvData);
        void configurationStructurePut(PVLink pvLink);
        void beginPut(PVStructure pvStructure);
        void endPut(PVStructure pvStructure);
        void dataPut(PVStructure pvStructure,PVData pvData);
        void enumIndexPut(PVStructure pvStructure,PVEnum pvEnum);
        void enumChoicesPut(PVStructure pvStructure,PVEnum pvEnum);
        void supportNamePut(PVStructure pvStructure,PVData pvData);
        void configurationStructurePut(PVStructure pvStructure,PVLink pvLink);
        List&lt;ChannelDataPV&gt; getChannelDataPVList();
    }

    public interface ChannelDataQueue {
        int getNumberFree();
        int capacity();
        ChannelData getFree(boolean forceFree);
        ChannelData getNext();
        int getNumberMissed();
        void releaseNext(ChannelData channelData);
    }

    public class ChannelDataFactory {
         public static ChannelData createData(
             Channel channel,ChannelFieldGroup channelFieldGroup);
         public static ChannelDataQueue createQueue(
             int queueSize,Channel channel,ChannelFieldGroup channelFieldGroup);
    }</pre>

<h3 id="ChannelDat">ChannelDataPV</h3>

<p>ChannelDataPV has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getChannelData</dt>
    <dd>Get the ChannelData for this monitor.</dd>
  <dt style="font-family: courier;">getChannelField</dt>
    <dd>Get the ChannelField for this monitor.</dd>
  <dt style="font-family: courier;">getPVData</dt>
    <dd>Get the PVData.</dd>
  <dt style="font-family: courier;">isInitial</dt>
    <dd>This is true when a connection is first made. It allows the client to
      get the initial data values.</dd>
  <dt style="font-family: courier;">enumIndexChange</dt>
    <dd>The PVData is an enum or menu and a put was made to the index.</dd>
  <dt style="font-family: courier;">enumChoicesChange</dt>
    <dd>The PVData is an enum put was made to the choices.</dd>
  <dt style="font-family: courier;">supportNameChange</dt>
    <dd>The supportName was changed.</dd>
  <dt style="font-family: courier;">configurationStructureChange</dt>
    <dd>PVData is a link and the configuration structure was changed.</dd>
</dl>

<h3 id="ChannelDat1">ChannelData</h3>

<p>ChannelData has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getChannelFieldGroup</dt>
    <dd>Get the ChannelFieldGroup for this ChannelData.</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Clear the internal list of items that have been added.</dd>
  <dt style="font-family: courier;">initData</dt>
    <dd>When a connection is made this is called for each ChannelField the
      ChannelData contains.</dd>
  <dt style="font-family: courier;">dataPut</dt>
    <dd>The PVData has been modified. Two versions are provided. One is if a
      ChannelField is connected to the PVData itself and the other if the
      PVData is a subfield of the PVStructure to which the ChannelField is
      connected.</dd>
  <dt style="font-family: courier;">enumIndexPut</dt>
    <dd>Like dataPut except for an enum or menu field.</dd>
  <dt style="font-family: courier;">enumChoicesPut</dt>
    <dd>Like dataPut except for a enum field.</dd>
  <dt style="font-family: courier;">supportNamePut</dt>
    <dd>The supportName has been modified.</dd>
  <dt style="font-family: courier;">configurationStructurePut</dt>
    <dd>The PVData is a link and the configuration structure has been
      modified.</dd>
  <dt style="font-family: courier;">beginPut</dt>
    <dd>A set of puts to the fields of a structure is starting.
    </dd>
  <dt style="font-family: courier;">endPut</dt>
    <dd>The set of puts to a structure is done.</dd>
  <dt style="font-family: courier;">getChannelDataPVList</dt>
    <dd>Get the list of all ChannelDataPVs that have been added since the
      last clear request.</dd>
</dl>

<p>A ChannelData is allocated as follows:</p>
<pre>    ChannelData channelData = ChannelDataFactory.createData(
        channel,channelFieldGroup);</pre>

<p>This creates storage for each element of the field group. It can create
storage for all pvTypes. For Array types, the initial size and capacity is 0.
The arrays will grow as data is placed in them but will not be released.</p>

<p>A new set of data is colllected as follows:</p>
<ul>
  <li>The requestor calls channelData.clear</li>
  <li>The data source, which is NOT allowed to block a record, does the
    following:
    <ul>
      <li>Wait until data is not available.</li>
      <li>When one or more pvData items are available, with the data source
        (for example a record) locked, call channelData.add.</li>
      <li>When the last pvData has been copied to channelData notify the
        requestor.</li>
    </ul>
  </li>
  <li>The requestor calls channelData.getPVDataList and
    channelData.getPVDataList. It can block if necessary because the actual
    data source, e.g. a data base record, is not locked.</li>
</ul>

<h3 id="ChannelDat2">ChannelDataQueue</h3>

<p>ChannelDataQueue has the following methods:</p>
<dl>
  <dt style="font-family: courier;">getNumberFree</dt>
    <dd>Get the number of unused channelData elements in the queue.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>Get the number of channelData elements in the queue.</dd>
  <dt style="font-family: courier;">getFree</dt>
    <dd>Get a channelData element from the queue. If there are no more free
      elements numberMissed is incremented. If forceFree is true the oldest
      used element is reused. If no free element is available then null is
      returned.</dd>
  <dt style="font-family: courier;">getNext</dt>
    <dd>Get the next channelData element that has new data in it. Return null
      if there are no more elements.</dd>
  <dt style="font-family: courier;">getNumberMissed</dt>
    <dd>Get the number of times getGree has been called since the last call
      to releaseNext.</dd>
  <dt style="font-family: courier;">releaseNext</dt>
    <dd>Release the element returned by getNext.</dd>
</dl>

<p>A ChannelDataQueue is created as follows:</p>
<pre>    ChannelDataQueue channelDataQueue = ChannelDataFactory.createQueue(
         queueSize,channel,channelFieldGroup);</pre>

<p>This creates <span style="font-family: courier;">queueSize</span> <span
style="font-family: courier;">channelFieldGroup</span>s and a queue to manage
them. As an example of how a queue is used consider a channel access server
monitoring a fieldGroup of an IOC database record.</p>

<h3 id="ChannelDat3">ChannelDataFactory</h3>

<p>ChannelDataFactory has the following methods:</p>
<dl>
  <dt style="font-family: courier;">createData</dt>
    <dd>Create a ChannelData.</dd>
  <dt style="font-family: courier;">createQueue</dt>
    <dd>Create a ChannelDataQueue.</dd>
</dl>
<hr />

<h2 style="text-align: center;" id="Local">Local Channel Access</h2>
<hr />

<p>An implementation of a channel access client for accessing records in the
IOC database is provided. This is created automatically by
ChannelAccessLocalFactory . The factory creates a single instance of an
implementation of a channel access client for accessing local records. This
is used by link support. ChannelAccessLocalFactory has only one public
method.</p>
<pre>    public class ChannelAccessLocalFactory  {
        static public void setIOCDB(IOCDB iocdb);
    }</pre>
<hr />

<h2 style="text-align: center" id="Example">Example For ChannelData</h2>
<hr />

<h3 id="Discussion">Discussion</h3>

<p>This example creates a ChannelData for a fieldGroup that has the
following:</p>
<ul>
  <li>value<br />
  </li>
  <li>status - a property of value</li>
  <li>severity - a property of value</li>
  <li>timeStamp - a property of value</li>
</ul>

<p>The definition is:</p>
<pre>    static class ValueData implements ChannelFieldGroupListener{
        ValueData(Channel channel);
        ChannelFieldGroup init();
        void clear();
            channelData.clear();
        }
        boolean nextGetData(Channel channel, ChannelField field, PVData data);
        void printResults();
    }</pre>
where
<dl>
  <dt style="font-family: courier;">ValueData</dt>
    <dd>The constructor</dd>
  <dt style="font-family: courier;">init</dt>
    <dd>creates everthing it needs. Returns null if anything fails.</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Prepares to accept a new set of data for the fieldGroup</dd>
  <dt style="font-family: courier;">nextGetData</dt>
    <dd>Adds the data to the channelData list.</dd>
  <dt style="font-family: courier;">prinntResults</dt>
    <dd>Prints all data received since last clear.</dd>
</dl>

<p>What it provides for later examples is the ability to dump everthing the
examples gets from a record and displaying the results after the record is no
longer locked.</p>

<h3 id="Implementa">Implementation</h3>
<pre>    class ValueData implements ChannelFieldGroupListener{
        private Channel channel;
        private String fieldName;
        private ChannelFieldGroup channelFieldGroup;
        private ChannelField valueField;
        private ChannelField statusField = null;
        private ChannelField severityField = null;
        private ChannelField timeStampField = null;

        ValueData(Channel channel,String fieldName) {
            this.channel = channel;
            if(fieldName==null) fieldName = "value";
            this.fieldName = fieldName;
        }

        void lookForOther(ChannelMonitor channelMonitor) {
            if(statusField!=null) channelMonitor.lookForChange(statusField, true);
            if(severityField!=null) channelMonitor.lookForChange(severityField, true);
            if(timeStampField!=null) channelMonitor.lookForChange(timeStampField, false);
        }

        void lookForChange(ChannelMonitor channelMonitor) {
            channelMonitor.lookForChange(valueField, true);
            lookForOther(channelMonitor);
        }
        void lookForAbsoluteChange(ChannelMonitor channelMonitor,double deadband) {
            channelMonitor.lookForAbsoluteChange(valueField, deadband);
            lookForOther(channelMonitor);
        }
        void lookForPercentageChange(ChannelMonitor channelMonitor,double deadband) {
            channelMonitor.lookForPercentageChange(valueField, deadband);
            lookForOther(channelMonitor);
        }
       
        public void accessRightsChange(Channel channel, ChannelField channelField) {
            // TODO Auto-generated method stub

        }

        ChannelFieldGroup init() {
            channelFieldGroup = channel.createFieldGroup(this);
            ChannelFindFieldResult result;
            result = channel.findField(fieldName);
            if(result!=ChannelFindFieldResult.thisChannel) {
                System.out.printf("PutGet:set returned %s%n", result.toString());
                return null;
            }
            valueField = channel.getChannelField();
            channelFieldGroup.addChannelField(valueField);
            channel.findField(valueField);
            result = channel.findField("status");
            if(result==ChannelFindFieldResult.thisChannel) {
                statusField = channel.getChannelField();
                channelFieldGroup.addChannelField(statusField);
            }
            channel.findField(valueField);
            result = channel.findField("severity");
            if(result==ChannelFindFieldResult.thisChannel) {
                severityField = channel.getChannelField();
                channelFieldGroup.addChannelField(severityField);
            }
            channel.findField(valueField);
            result = channel.findField("timeStamp");
            if(result==ChannelFindFieldResult.thisChannel) {
                timeStampField = channel.getChannelField();
                channelFieldGroup.addChannelField(timeStampField);
            }
            return channelFieldGroup;
        }

        String printResults(ChannelData channelData) {
            StringBuilder builder = new StringBuilder();
            List&lt;ChannelDataPV&gt; channelDataPVList = channelData.getChannelDataPVList();
            Iterator&lt;ChannelDataPV&gt; iter = channelDataPVList.iterator();
            while(iter.hasNext()) {
                ChannelDataPV channelDataPV = iter.next();
                builder.append(String.format("%n    %s",channelDataPV.toString()));
                PVData data = channelDataPV.getPVData();
                ChannelField field = channelDataPV.getChannelField();
                if(channelDataPV.isInitial()) {
                    builder.append(String.format("%n    initialValue %s%n",
                       data.toString(2)));
                } else if(field==valueField) {
                    builder.append(String.format("value %s", data.toString(2)));
                } else if (field==severityField) {
                    PVEnum pvEnum = (PVEnum)data;
                    int index = pvEnum.getIndex();
                    builder.append(String.format(
                        " severity %s",AlarmSeverity.getSeverity(index).toString()));
                } else if(field==statusField) {
                    PVString pvString = (PVString)data;
                    String value = pvString.get();
                    builder.append(" status " + value);
                } else if(field==timeStampField) {
                    // wait for nanoSecond to change.
                    if(data.getField().getFieldName().equals("nanoSeconds")) {
                        PVTimeStamp pvTimeStamp = PVTimeStamp.create(data.getParent());
                        TimeStamp timeStamp = new TimeStamp();
                        pvTimeStamp.get(timeStamp);
                        long seconds = timeStamp.secondsPastEpoch;
                        int nano = timeStamp.nanoSeconds;
                        long now = nano/1000000 + seconds*1000;
                        Date date = new Date(now);
                        builder.append(String.format(" time %s",date.toLocaleString()));
                    }
                }
            }
            return builder.toString();
        }</pre>
<hr />

<h2 style="text-align: center" id="Process">Process Example</h2>
<hr />

<h3 id="Discussion1">Discussion</h3>

<p>This example shows how to implement a process request.</p>

<h3 id="Implementa1">Implementation</h3>
<pre>    static class Process implements ChannelProcessRequestor,ChannelStateListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelProcess channelProcess;

        Process(String pvname) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelProcess = channel.createChannelProcess(this);
           // SHOULD CHECK FOR NULL
        }
        void destroy() {
            channel.destroy();
        }
        void process() {
            allDone = false;
            channelProcess.process();
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException e) {
                return;
            } finally {
                lock.unlock();
            }
        }

        public String getRequestorName() {
            return "Put:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="Example1">Get Example</h2>
<hr />

<h3 id="Discussion2">Discussion</h3>

<p>This example shows how to implement a get request.</p>

<h3 id="Implementa2">Implementation</h3>
<pre>    static class Get implements
    ChannelGetRequestor,
    ChannelStateListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelGet channelGet;
        private ValueData valueData;
        private ChannelFieldGroup getFieldGroup;

        Get(String pvname,boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelGet = channel.createChannelGet(this, process);
        }
        void destroy() {
            channel.destroy();
        }
        boolean connect() {

            valueData = new ValueData(channel);
            getFieldGroup = valueData.init();
            if(getFieldGroup==null) return false;
            return true;
        }

        void get() {
            allDone = false;
            valueData.clear();
            channelGet.get(getFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
            valueData.printResults();
        }

        public boolean nextDelayedGetData(PVData data) {
            //nothing to do
        }

        public String getRequestorName() {
            return "PutGet:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextGetData(Channel channel, ChannelField field, PVData data) {
            valueData.nextGetData(channel, field, data);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="Example2">Put Example</h2>
<hr />

<h3 id="Discussion3">Discussion</h3>

<p>This example shows how to implement a put request.</p>

<h3 id="Implementa3">Implementation</h3>
<pre>    static class Put implements
    ChannelPutRequestor,
    ChannelStateListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelPut channelPut;
        private ChannelFieldGroup putFieldGroup;
        private ChannelField valueField;
        private double value;

        Put(String pvname, boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);

            channelPut = channel.createChannelPut(this, process);
        }

        public boolean nextDelayedPutData(PVData data) {
            // nothing to do
            return false;
        }
        void destroy() {
            channel.destroy();
        }
        boolean connect() {
            putFieldGroup = channel.createFieldGroup(this);
            ChannelFindFieldResult result;
            result = channel.findField("value");
            if(result!=ChannelFindFieldResult.thisChannel) {
                System.out.printf("PutGet:set returned %s%n", result.toString());
                return false;
            }
            valueField = channel.getChannelField();
            putFieldGroup.addChannelField(valueField);
            return true;
        }

        void put(double value) {
            this.value = value;
            allDone = false;
            channelPut.put(putFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
        }

        public String getRequestorName() {
            return "Put:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextPutData(Channel channel, ChannelField field, PVData data) {
            PVDouble pvDouble = (PVDouble)data;
            pvDouble.put(value);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
<hr />

<h2 style="text-align: center" id="PutGet">PutGet Example</h2>
<hr />

<h3 id="Discussion4">Discussion</h3>

<p>This example shows how to implement a putGet request. When it;s put method
is called, it puts a double value to a field named value, optionally
processes the record, and retrieves the value, status, severity, and
timeStamp.</p>

<h3 id="Implementa4">Implementation</h3>
<pre>    static class PutGet implements
    ChannelPutGetRequestor,
    ChannelStateListener, ChannelFieldGroupListener
    {
        private Lock lock = new ReentrantLock();
        private Condition waitDone = lock.newCondition();
        private boolean allDone = false;
        private String pvname = null;
        private Channel channel;
        private ChannelPutGet channelPutGet;
        private ChannelFieldGroup putFieldGroup;
        private ValueData valueData;
        private ChannelFieldGroup getFieldGroup;
        private ChannelField valueField;
        private double value;

        PutGet(String pvname,boolean process) {
            this.pvname = pvname;
            channel = ChannelFactory.createChannel(pvname, this);
            channelPutGet = channel.createChannelPutGet(this, process);
        }

        public boolean nextDelayedPutData(PVData data) {
            // Nothing to do
            return false;
        }

        public boolean nextDelayedGetData(PVData data) {
            // Nothing to do
            return false;
        }

        boolean connect() {
            putFieldGroup = channel.createFieldGroup(this);
            ChannelFindFieldResult result;
            result = channel.findField("value");
            if(result!=ChannelFindFieldResult.thisChannel) {
                System.out.printf("PutGet:set returned %s%n", result.toString());
                return false;
            }
            valueField = channel.getChannelField();
            putFieldGroup.addChannelField(valueField);
            valueData = new ValueData(channel);
            getFieldGroup = valueData.init();
            if(getFieldGroup==null) return false;
            return true;
        }

        void destroy() {
            channel.destroy();
        }

        void putGet(double value) {
            this.value = value;
            allDone = false;
            valueData.clear();
            channelPutGet.putGet(putFieldGroup, getFieldGroup);
            lock.lock();
            try {
                if(!allDone) {
                    waitDone.await();
                }
            } catch (InterruptedException ie) {
                return;
            } finally {
                lock.unlock();
            }
            valueData.printResults();
        }

        public String getRequestorName() {
            return "PutGet:" + pvname;
        }

        public void message(String message, MessageType messageType) {
            message(channel,message,messageType);
        }

        public boolean nextGetData(Channel channel, ChannelField field, PVData data) {
            valueData.nextGetData(channel, field, data);
            return false;
        }

        public boolean nextPutData(Channel channel, ChannelField field, PVData data) {
            PVDouble pvDouble = (PVDouble)data;
            pvDouble.put(value);
            return false;
        }

        public void message(Channel channel, String message, MessageType messageType) {
            System.out.printf("putGet.massage %s%n", message);
        }

        public void requestDone(Channel channel, RequestResult requestResult) {
            lock.lock();
            try {
                allDone = true;
                    waitDone.signal();
            } finally {
                lock.unlock();
            }
        }

        public void channelStateChange(Channel c, boolean isConnected) { }

        public void disconnect(Channel c) { }

        public void accessRightsChange(Channel channel, ChannelField channelField) { }
    }</pre>
</body>
</html>
