<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIOC: Database Definition</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Definition <br />
package: org.epics.ioc.dbd<br />
2007.09.18</h1>
<hr />
CONTENTS: 

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database Definition Syntax</a> 
    <ul>
      <li><a href="#General">General Statements</a> 
        <ul>
          <li><a href="#namespace">namespace</a></li>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro">Macro Substitution</a></li>
        </ul>
      </li>
      <li><a href="#Structure">Structure and Record Type</a></li>
      <li><a href="#field">field</a> 
        <ul>
          <li><a href="#Primitive">Primitive Types</a></li>
          <li><a href="#string">string</a></li>
          <li><a href="#structure">structure</a></li>
          <li><a href="#array">array</a></li>
        </ul>
      </li>
      <li><a href="#field1">field attribute</a></li>
      <li><a href="#Create">Create</a></li>
      <li><a href="#Support">Support</a></li>
    </ul>
  </li>
  <li><a href="#Overview1">Overview of Java Support For Database
    Definition</a></li>
  <li><a href="#Introspect">Introspection of Database Definitions</a> 
    <ul>
      <li><a href="#Structure1">Structure and RecordType</a></li>
      <li><a href="#Create1">Create and Support</a></li>
      <li><a href="#Support1">Support</a></li>
    </ul>
  </li>
  <li><a href="#Accessing">Accessing Database Definitions</a> 
    <ul>
      <li><a href="#DBD">DBD</a></li>
    </ul>
  </li>
  <li><a href="#Creating">Creating Database Definitions</a> 
    <ul>
      <li><a href="#DBDFactory">DBDFactory</a></li>
      <li><a href="#XMLToDBDFa">XMLToDBDFactory</a></li>
      <li><a href="#Creating1">Creating Database Definitions</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type.</p>

<p>This package describes support for Database Definitions, i.e. support for
the following database components: menu, structure, recordType, create, and
support, Included are factories for creating multiple DBD (Database
Definition) instances. A DBD provides reflection interfaces for all database
components it contains. db, which implements a javaIOC database, uses a DBD
to implement database reflection.</p>

<p>The following is discussed:</p>
<ol>
  <li>Database Definition Syntax<br />
    The XML syntax for defining menus, structures, record types, and
    support.<br />
  </li>
  <li>Java Support for Database Definitions</li>
  <li>Factory support for Database Definitions</li>
  <li>parser support<br />
    This reads an xml file containing menu, structure, record types, and link
    support and adds them to a database definition file.</li>
  <li>Creating and using Database Definitions.<br />
  </li>
</ol>
<hr />

<h2 style="text-align: center" id="Database">Database Definition Syntax</h2>
<hr />
A Database Definition file must be an XML file with a root tag of
DBDDefinition: 
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;?-- valid Database Definition elements --&gt;
&lt;/DBDefinition&gt;</pre>

<h3 id="General">General Statements</h3>

<h4 id="namespace">namespace</h4>
At this time namespaces are not used. 

<h4 id="Include">Include</h4>
An XML file containing Database Definitions can include other files also
containing Database Definitions. An included file must also be a valid XML
Database Definition. Included files can also include other files. The syntax
is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Database Definition file, is processed. If any addPaths
      have been defined the last one specified is prefixed to the
    filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>See package org.epics.ioc.util for details.</p>

<h4 id="Macro">Macro Substitution</h4>

<p>Macro substitution might not be useful for Database Definition but it is
supported just like for Database Instance files. See package org.epics.ioc.db
for details about how macro substitution works.</p>

<h3 id="Structure">Structure and Record Type</h3>

<p>Structure and recordType both define a data structure containing fields.
The main difference is that a structure can't be instanciated except as a
field of a record.</p>

<p>A structure is defined as follows:</p>
<pre>&lt;structure name = "structureName" supportName = "supportName" &gt;
     &lt;field name = "fieldName" supportName = "supportName" type = "fieldType" ... /&gt;
     ...
&lt;/structure&gt;</pre>

<p>A record type is defined as follows:</p>
<pre>&lt;recordType name = "recordtypeName" supportName = "supportName" &gt;
     &lt;field name = "fieldName"  supportName = "supportName" type = "fieldType" ... /&gt;
     ...
&lt;/recordType&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
  <dt><span style="font-family: courier">recordtypeName</span></dt>
    <dd>The structure or record type name.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the structure, record type, or field. A
      support definition, described below, defines the support. When record
      instances are defined, the default can be overridden.</dd>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>Should also have the same syntax as a Java identifier, unique within
      the context of this particular structure.</dd>
  <dt><span style="font-family: courier">fieldType</span></dt>
    <dd>See fieldType below.</dd>
  <dt>...</dt>
    <dd>See field attribute below</dd>
</dl>

<h3 id="field">field</h3>
The syntax for <span style="font-family: courier">fieldType</span> depends on
the field type. 

<h4 id="Primitive">Primitive Types</h4>
Primitive types are the same as the Java primitive types, i.e. <span
style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>. Primitive field types are just
defined as <span style="font-family: courier;">&lt;type /&gt;</span> For
example 
<pre>     
    &lt;field name = "value", type = "double" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;</pre>

<h4 id="string">string</h4>
A <span style="font-family: courier">string</span> is a Java <span
style="font-family: courier;">String</span>. A <span
style="font-family: courier;">string</span> field type is just defined as
<span style="font-family: courier;">string</span>. For example: 
<pre>     &lt;field name = "description" type = "string" /&gt;</pre>

<h4 id="structure">structure</h4>
A structure field is declared as 
<pre>    &lt;field name = "value" type = "structure" structureName = "name" /&gt;</pre>
<span style="font-family: courier;">structureName</span> is the name of a
structure which must have been previously defined. Example: 
<pre>   &lt;structure name = "point"&gt;
       &lt;field name = "x" type = "double" /&gt;
       &lt;field name = "y"&gt; type = "double" /&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "haspoint"&gt;
       ...
       &lt;field name = "point" type = "structure" structureName = "point" /&gt;
       ...</pre>

<p>NOTE: The structureName does not have to be given. In this case the field
instance must define the structureName.</p>

<h4 id="array">array</h4>

<p>NOTE: One dimensional arrays are a supported type. Multidimensional arrays
can be supported via a <span style="font-family: courier;">structure</span>
definition with fields describing the number of dimensions and the attributes
of each dimension.</p>
An array is defined as follows: 
<pre>    &lt;field name = "value" type = "array" elementType = "type" capacity = "capacity" /&gt;</pre>
where 
<dl>
  <dt style="font-family: courier;">elementType</dt>
    <dd>The type must be a valid type, i.e. boolean, byte, short, int, long,
      float, double, string,enum, structure, array or link. This must be
      specified. If the elementType is structure than each element can be a
      different type of structure.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The number of array elements. If not specified the capacity is
      determined at record initialization</dd>
</dl>
Examples: 
<pre>     &lt;field name = "doubleArray" type = "array" elementType = "double" capacity = "3" /&gt;
     &lt;field name = "value" type = "array"  elementType = "double" /&gt;
     &lt;field name = "rectangle" type = "array" elementType = "structure" capacity = "2" /&gt;</pre>

<h3 id="field1">field attribute</h3>

<p>A field can have additional attributes which are specified via xml
attributes. Any xml key,value attribute that is not handled by the
XMLToDBDFactory becomse a field attribute. Two attributes that are recognized
by the javaIOC database are: </p>
<pre>     default = "stringValue"
     readonly = "booleanValue"
 </pre>

<p>The attribute parameter values have the following meanings:</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the fields is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
</dl>
The following examples show how attributes are defined: 
<pre>    &lt;recordType name = "example"&gt;
        ...
        &lt;field name = "status" type = "string" readonly "true" /&gt;
        &lt;field name = "displayLimit" type = "structure"
                structureName = "displayLimit" readonly = "true" /&gt;
        ...
        &lt;field name = "value" type = "double" /&gt;
       ...
    &lt;/recordType&gt;</pre>
<br />


<h3 id="Create">Create</h3>

<p>Create can be associated with any field of a record instance when it is
created. See package org.epics.ioc.db for details. The syntax for a Create
definition is:</p>
<pre>    &lt;create name = "createName" factoryName = "factoryName" /&gt;</pre>
where 
<dl>
  <dt><span style="font-family: courier">create</span></dt>
    <dd>The tag.</dd>
  <dt><span style="font-family: courier">createName</span></dt>
    <dd>string that describes the create</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates create instances. See
      package org.epics.ioc.db for details,</dd>
</dl>

<h3 id="Support">Support</h3>

<p>Support can be associated with any field of a record instance when it is
created. See package org.epics.ioc.db for details. Record types and
structures can have default support as shown above. The syntax for a support
definition is:</p>
<pre>    &lt;support name = "supportName" factoryName = "factoryName" /&gt;</pre>
where 
<dl>
  <dt><span style="font-family: courier">support</span></dt>
    <dd>The tag.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.process for details,</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Overview1">Overview of Java Support For
Database Definition</h2>
<hr />

<p>This following sections describes support for code that accessses Database
Definitions: structure, recordType, create , and support.</p>

<p>The interfaces support reflection for everything created from Database
Definitions. The interfaces can be used by tools such as VDCT or on a running
IOC database. The interfaces are also used by record support, link support,
and the database itself.</p>

<p>Reflection interfaces are available for the following XML definitions</p>
<dl>
  <dt>DBDStructure</dt>
    <dd>This is for introspecting the XML structure definitions.</dd>
  <dt>DBDRecordType</dt>
    <dd>This is for introspecting the XML recordType definitions.</dd>
  <dt>DBDCreate</dt>
    <dd>This is for introspecting the XML create definitions.</dd>
  <dt>DBDSupport</dt>
    <dd>This is for introspecting the XML support definitions.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Introspect">Introspection of Database
Definitions</h2>
<hr />

<p>This section describes interfaces for accessing structure, recordType,
create, and support, i.e. everything defined in Database Definition files
except record instances. Reflection for fields of a structure or recordType
is discussed in the next section.</p>

<h3 id="Structure1">Structure and RecordType</h3>

<p>The interfaces are:</p>
<pre>    interface DBDStructure extends Structure{}

    interface DBDRecordType extends DBDStructure {}</pre>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(DBDStructure structure) {
        Field[] fields = structure.getFields();
        System.out.printf("structure %s {\n",structure.getStructureName();
        for(Field field : fields) {
            Type type = field.getType();
            System.out.printf("field %s type %s",
                field.getName(),type.toString());
        }
    }</pre>

<p>A shorter way is:</p>
<pre>    void dumpStructure(DBDStructure structure) {System.out.println(structure.toString);}</pre>

<h3 id="Create1">Create and Support</h3>

<p>The following interfaces is provided for accessing support.</p>
<pre>    interface DBDCreate {
        String getCreateName();
        String getFactoryName();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getCreateName</dt>
    <dd>Get the create name.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.create for details about create and create factories.</dd>
</dl>

<h3 id="Support1">Support</h3>

<p>The following interfaces is provided for accessing support.</p>
<pre>    interface DBDSupport {
        String getSupportName();
        String getFactoryName();
        String toString();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.dbProcess for details about support and support
    factories.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Accessing">Accessing Database
Definitions</h2>
<hr />

<h3 id="DBD">DBD</h3>

<p>DBD is an interface for accessing a Database containing Database
Definitions. Methods are provided for accessing and inserting components. In
addition a number of "convenience" methods are provided.</p>
<pre>public interface DBD {
    String getName();
    DBD getMasterDBD();
    void mergeIntoMaster();
    DBDStructure createStructure(String name,
        Field[] field,FieldAttribute fieldAttribute);
    DBDRecordType createRecordType(String name,
        Field[] field,FieldAttribute fieldAttribute);
    DBDCreate createCreate(String createName,String factoryName);
    DBDSupport createSupport(String supportName,String factoryName);
    DBDStructure getStructure(String structureName);
    boolean addStructure(DBDStructure structure);
    Map&lt;String,DBDStructure&gt; getStructureMap();
    DBDRecordType getRecordType(String recordTypeName);
    boolean addRecordType(DBDRecordType recordType);
    DBDCreate getCreate(String createName);
    boolean addCreate(DBDCreate create);
    Map&lt;String,DBDCreate&gt; getCreateMap();
    Map&lt;String,DBDRecordType&gt; getRecordTypeMap();
    DBDSupport getSupport(String supportName);
    boolean addSupport(DBDSupport support);
    Map&lt;String,DBDSupport&gt; getSupportMap();
    String[] structureList(String regularExpression);
    String structureToString(String regularExpression);
    String[] recordTypeList(String regularExpression);
    String recordTypeToString(String regularExpression);
    String[] createList(String regularExpression);
    String createToString(String regularExpression);
    String[] supportList(String regularExpression);
    String supportToString(String regularExpression);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The name of this DBD database.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Get the master DBD or null if no master was passed to
      DBDFactory.create. Normally this means that this is the master.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge this DBD into the master DBD. After merging into master the
      compoments are removed from this database.</dd>
  <dt style="font-family: courier;">createStructure</dt>
    <dd>Create a DBDStructure.</dd>
  <dt style="font-family: courier;">createRecordType</dt>
    <dd>Create a DBDRecordType.</dd>
  <dt style="font-family: courier;">createCreate</dt>
    <dd>Create a DBDCreate.</dd>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create a DBDSupport.</dd>
  <dt style="font-family: courier;">getStructure</dt>
    <dd>Get the DBDStructure that describes the structureName</dd>
  <dt style="font-family: courier;">addStructure</dt>
    <dd>Add a structure definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getStructureMap</dt>
    <dd>Get a map of all the structure definitions. A shallow copy of the map
      is returned.</dd>
  <dt style="font-family: courier;">getRecordType</dt>
    <dd>Get the DBDRecordType that describes recordTypeName.</dd>
  <dt style="font-family: courier;">addRecordType</dt>
    <dd>Add a recordType definition and return true. If the definition
      already exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getRecordTypeMap</dt>
    <dd>Get a map of all the recordType definitions. A shallow copy of the
      map is returned.</dd>
  <dt style="font-family: courier;">getCreate</dt>
    <dd>Get the DBDCreate that describes createName.</dd>
  <dt style="font-family: courier;">addCreate</dt>
    <dd>Add a create definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getCreateMap</dt>
    <dd>Get a map of all the create definitions. A shallow copy of the map is
      returned.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the DBDSupport that describes supportName.</dd>
  <dt style="font-family: courier;">addSupport</dt>
    <dd>Add a support definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getSupportMap</dt>
    <dd>Get a map of all the support definitions. A shallow copy of the map
      is returned.</dd>
</dl>
The remaining methods are convenience methods. Each convenience method
produces a string that lists or dumps all components with names that match a
regular expression. The java.util.regex facility is used. Consult it for a
definition of regular expressions. 
<dl>
  <dt style="font-family: courier;">structureList</dt>
    <dd>Return an array of strings that is the list of structure names that
      match a regular expression</dd>
  <dt style="font-family: courier;">structureToString</dt>
    <dd>Get a dump of all the DBDStructure definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">recordTypeList</dt>
    <dd>Return an array of strings that is the list of recordType names that
      match a regular expression</dd>
  <dt style="font-family: courier;">recordTypeToString</dt>
    <dd>Get a dump of all the DBDRecordType definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">createList</dt>
    <dd>Return an array of strings that is the list of create names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">createToString</dt>
    <dd>Get a dump of all the DBDCreate definitions with names that match a
      regular expression.</dd>
  <dt style="font-family: courier;">supportList</dt>
    <dd>Return an array of strings that is the list of support names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">supportToString</dt>
    <dd>Get a dump of all the DBDSupport definitions with names that match a
      regular expression.</dd>
</dl>
An example of using a convience method is: 
<pre>    String[] list = master.menuList(".*[S].*");</pre>
Produces a list of all menu definitions that have an 'S" somewhere in the
menu name. 
<hr />

<h2 style="text-align: center" id="Creating">Creating Database
Definitions</h2>
<hr />
Two classes are provided for creation of DBD Databases: 
<ul>
  <li>DBDFactory<br />
    A factory to create and manage DBD databases.</li>
  <li>XMLToDBDFactory<br />
    A factory that reads xml Database Definitions and puts them into a DBD
    Database.</li>
</ul>

<h3 id="DBDFactory">DBDFactory</h3>

<p>DBDFactory is a class that creates DBD Databases. It provides the
following methods:</p>
<pre>public class DBDFactory {
    public static DBD create(String name);
    public static DBD getMasterDBD();
}
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a new DBD with the specified name. If the name is "master"
      than the master DBD is returned.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Return the master DBD. This is created automatically by
    DBDFactory</dd>
  <dt></dt>
  <dt>All methods of DBDFactory and of the DBD instances it creates are
  thread safe.</dt>
  <dt></dt>
</dl>

<h3 id="XMLToDBDFa">XMLToDBDFactory</h3>

<p>The following reads an xml file containing menu, structure, record type,
and link support definitions and adds the definitions to a database
definition database.</p>
<pre>    public class XMLToDBDFactory {
        public static void convert(DBD dbd, String fileName,
            Requester requester);
        public static DBD create(String dbdName,String fileName,
            Requester requester);
    }</pre>
<dl>
  <dt style="font-family: courier;">convert</dt>
    <dd>Convert the xml DBD definitions in file fileName and put the
      definitions into dbd. When generating definitions for an IOC use
      addToMaster instead of this. The Requester interface is described in
      package org.epics.ioc.util.</dd>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a DBD with the specified name and put the definitions obtained
      by parsing the XML defininitions in fileName into the dbd. The caller
      can, if desired, call DBD.mergeToMaster to put the newly created
      definitions into the master DBD. This can be called either during IOC
      initialization or while an IOC is running, i.e. on-line add of new
      definitions is supported. Definitions will not be created if they
      already appear in master or if they are defined more than once. A
      general rule is that the new definitions should not be added to master
      if any messages with message type greater than info are passed to the
      requester. In any case the caller should remove all references to the
      new DBD after it decides not to merge or after the merge.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">requester</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">dbdName</dt>
    <dd>The name for the DBD field that is created..</dd>
</dl>

<h3 id="Creating1">Creating Database Definitions</h3>

<p>Before record instances can be created all menu, structure, recordType,
and support definitions used by record instances must be created.</p>

<p>A running IOC always uses a DBD Database named "master" and an IOCDB also
named "master". The prefered way to create definitions by calling:</p>
<pre>    maxMessageType = IOCMessageType.iofo;
    DBD add = XMLToDBDFactory.create("add",fileName,this);
    if(maxMessageType!=IOCMessageType.iofo) // failure take appropriate action</pre>

<p>addToMaster will not add any definitions to master if any errors are
detected. It can be called during IOC initialization and also while an IOC is
running. For an IOC this is the only method required for generating Database
Definitions. Other code may decide to use DBDFactory.create instead.</p>

<p>XMLToDBDFactory is thread safe because it only allows one user at a time
to create new definitions. If it is busy and another user calls either
convert or create it call the message Listener with a fatal error and returns
immediately.</p>

<p>All DBD methods are thread safe. In order to prevent race conditions:</p>
<ul>
  <li>DBD has a private readWrite lock that manages all access to its
  methods.</li>
  <li>Database components can be added but not removed from a DBD.</li>
  <li>All getXXXMap methods return shallow copies of the internal map.</li>
</ul>
</body>
</html>
