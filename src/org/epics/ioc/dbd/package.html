<?xml version="1.0" encoding=""?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="" />
  <title>EPICS JavaIOC: Database Definition</title>
</head>

<body>
<hr />

<h1 style="text-align: center">EPICS JavaIoc: Database Definition <br />
package: org.epics.ioc.dbd<br />
2007.01.09</h1>
<hr />
CONTENTS:

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database Definition Syntax</a>
    <ul>
      <li><a href="#General">General Statements</a>
        <ul>
          <li><a href="#namespace">namespace</a></li>
          <li><a href="#Include">Include</a></li>
          <li><a href="#Macro">Macro Substitution</a></li>
        </ul>
      </li>
      <li><a href="#Menu">Menu</a></li>
      <li><a href="#Structure">Structure and Record Type</a></li>
      <li><a href="#field">field</a>
        <ul>
          <li><a href="#Primitive">Primitive Types</a></li>
          <li><a href="#string">string</a></li>
          <li><a href="#enumerated">enumerated</a></li>
          <li><a href="#structure">structure</a></li>
          <li><a href="#array">array</a></li>
          <li><a href="#menu">menu</a></li>
          <li><a href="#link">link</a></li>
        </ul>
      </li>
      <li><a href="#field1">field attribute</a></li>
      <li><a href="#property">property</a></li>
      <li><a href="#Support">Support</a></li>
    </ul>
  </li>
  <li><a href="#Overview1">Overview of Java Support For Database
    Definition</a></li>
  <li><a href="#Introspect">Introspection of Database Definitions</a>
    <ul>
      <li><a href="#Menu1">Menu</a></li>
      <li><a href="#Structure1">Structure and RecordType</a></li>
      <li><a href="#Support1">Support and LinkSupport</a></li>
    </ul>
  </li>
  <li><a href="#Accessing">Accessing Database Definitions</a>
    <ul>
      <li><a href="#DBD">DBD</a></li>
    </ul>
  </li>
  <li><a href="#Creating">Creating Database Definitions</a>
    <ul>
      <li><a href="#DBDFactory">DBDFactory</a></li>
      <li><a href="#XMLToDBDFa">XMLToDBDFactory</a></li>
      <li><a href="#Creating1">Creating Database Definitions</a></li>
    </ul>
  </li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p>An EPICS IOC contains a memory resident real time database. The real time
database has a set of "smart" records. Each record is an instance on a record
of a particular type.</p>

<p>This package describes support for Database Definitions, i.e. support for
the following database components: menu, structure, recordType, support, and
linkSupport. Included are factories for creating multiple DBD (Database
Definition) instances. A DBD provides reflection interfaces for all database
components it contains. db, which implements a javaIOC database, uses a DBD
to implement database reflection.</p>

<p>The following is discussed:</p>
<ol>
  <li>Database Definition Syntax<br />
    The XML syntax for defining menus, structures, record types, and
    support.<br />
  </li>
  <li>Java Support for Database Definitions</li>
  <li>Factory support for Database Definitions</li>
  <li>parser support<br />
    This reads an xml file containing menu, structure, record types, and link
    support and adds them to a database definition file.</li>
  <li>Creating and using Database Definitions.<br />
  </li>
</ol>
<hr />

<h2 style="text-align: center" id="Database">Database Definition Syntax</h2>
<hr />
A Database Definition file must be an XML file with a root tag of
DBDDefinition:
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;?-- valid Database Definition elements --&gt;
&lt;/DBDefinition&gt;</pre>

<h3 id="General">General Statements</h3>

<h4 id="namespace">namespace</h4>
At this time namespaces are not used.

<h4 id="Include">Include</h4>
An XML file containing Database Definitions can include other files also
containing Database Definitions. An included file must also be a valid XML
Database Definition. Included files can also include other files. The syntax
is:
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Database Definition file, is processed. If any addPaths
      have been defined the last one specified is prefixed to the
    filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>See package org.epics.ioc.util for details.</p>

<h4 id="Macro">Macro Substitution</h4>

<p>Macro substitution is not very usefull for Database Definition but it is
support just like for Database Instance files. See package org.epics.ioc.db
for details about how macro substitution works.</p>

<h3 id="Menu">Menu</h3>
A menu is an enumerated type, defined below, where the choice strings are
defined once for each IOC. The syntax is:
<pre>    
&lt;menu name = "name"&gt;
    &lt;choice&gt;choice&lt;/choice&gt;
    ...
&lt;/menu&gt;</pre>
Example:
<pre>    
&lt;menu name = "scan"&gt;
     &lt;choice&gt;passive&lt;/choice&gt;
     &lt;choice&gt;event&lt;/choice&gt;
     &lt;choice&gt;interrupt&lt;/choice&gt;
     &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;</pre>

<h3 id="Structure">Structure and Record Type</h3>

<p>Structure and recordType both define a data structure containing fields.
The main difference is that a structure can't be instanciated except as a
field of a record.</p>

<p>A structure is defined as follows:</p>
<pre>&lt;structure name = "structureName" supportName = "supportName" &gt;
     &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
     ...
     &lt;field name = "fieldName" supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...

    &lt;/field&gt;
     ...
&lt;/structure&gt;</pre>

<p>A record type is defined as follows:</p>
<pre>&lt;recordType name = "recordtypeName" supportName = "supportName" &gt;
    &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
    ...
     &lt;field name = "fieldName"  supportName = "supportName" type = "fieldType" ... &gt;
         &lt;property name = "propertyName" associatedField = "fieldName" /&gt;
         ...
     &lt;/field&gt;
     ...
&lt;/recordType&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
  <dt><span style="font-family: courier">recordtypeName</span></dt>
    <dd>The structure or record type name.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the structure, record type, or field. A
      support definition, described below, defines the support. When record
      instances are defined, the default can be overridden.</dd>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>Should also have the same syntax as a Java identifier, unique within
      the context of this particular structure.</dd>
  <dt><span style="font-family: courier">fieldType</span></dt>
    <dd>See fieldType below.</dd>
  <dt>...</dt>
    <dd>See field attribute below</dd>
  <dt><span style="font-family: courier">propertyName and
  associatedField</span></dt>
    <dd>See property below.</dd>
</dl>

<h3 id="field">field</h3>
The syntax for <span style="font-family: courier">fieldType</span> depends on
the field type.

<h4 id="Primitive">Primitive Types</h4>
Primitive types are the same as the Java primitive types, i.e. <span
style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>. Primitive field types are just
defined as <span style="font-family: courier;">&lt;type /&gt;</span> For
example
<pre>     
    &lt;field name = "value", type = "double" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;</pre>

<h4 id="string">string</h4>
A <span style="font-family: courier">string</span> is a Java <span
style="font-family: courier;">String</span>. A <span
style="font-family: courier;">string</span> field type is just defined as
<span style="font-family: courier;">string</span>. For example:
<pre>     &lt;field name = "description" type = "string" /&gt;</pre>

<h4 id="enumerated">enumerated</h4>

<p>An enumerated field type specified as enum For example:</p>
<pre>    &lt;field name = "value" type = "enum" /&gt;</pre>

<h4 id="structure">structure</h4>
A structure field is declared as
<pre>    &lt;field name = "value" type = "structure" structureName = "name" /&gt;</pre>
<span style="font-family: courier;">structureName</span> is the name of a
structure which must have been previously defined. Example:
<pre>   &lt;structure name = "point"&gt;
       &lt;field name = "x" type = "double" /&gt;
       &lt;field name = "y"&gt; type = "double" /&gt;
   &lt;/structure&gt;
   ...
   &lt;recordType name = "haspoint"&gt;
       ...
       &lt;field name = "point" type = "structure" structureName = "point" /&gt;
       ...</pre>

<p>NOTE: The structureName does not have to be given. In this case the field
instance must define the structureName.</p>

<h4 id="array">array</h4>

<p>NOTE: One dimensional arrays are a supported type. Multidimensional arrays
can be supported via a <span style="font-family: courier;">structure</span>
definition with fields describing the number of dimensions and the attributes
of each dimension.</p>
An array is defined as follows:
<pre>    &lt;field name = "value" type = "array" elementType = "type" capacity = "capacity" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">elementType</dt>
    <dd>The type must be a valid type, i.e. boolean, byte, short, int, long,
      float, double, string,enum, structure, array or link. This must be
      specified. If the elementType is structure than each element can be a
      different type of structure.</dd>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The number of array elements. If not specified the capacity is
      determined at record initialization</dd>
</dl>
Examples:
<pre>     &lt;field name = "doubleArray" type = "array" elementType = "double" capacity = "3" /&gt;
     &lt;field name = "value" type = "array"  elementType = "double" /&gt;
     &lt;field name = "rectangle" type = "array" elementType = "structure" capacity = "2" /&gt;</pre>

<h4 id="menu">menu</h4>
A menu field is defined as:
<pre>     &lt;field name = "name" type = "menu" nameName = "menuName" /&gt;</pre>
where <span style="font-family: courierfont-family: courier;">menuName</span>
is the name of the menu. <br />
Example:
<pre>    &lt;field name = "scan" type = "menu" menuName = "menuScan" /&gt;</pre>

<p>To the database, a menu field is presented just like an enumerated field
with constant choices. The choices are taken from the menu definition.</p>

<h4 id="link">link</h4>
This field type can get/put data from/to a location outside the record. When
a record instance is created, the link choices come from <span
style="font-family: courier;">support</span> definitions which are defined
below. A <span style="font-family: courier;">link</span> can be a link to
another database record, to hardware device support, or something else. The
syntax is:
<pre>     &lt;field name = "name" type = "link" /&gt;</pre>
Examples:
<pre>     &lt;field name = "disableLink" type = "link" /&gt;
     &lt;field name = "input" type = "link" /&gt;</pre>

<h3 id="field1">field attribute</h3>

<p>A field can have additional attributes which are specified via xml
attributes. The additional attributes are:</p>
<pre>     default = "stringValue"
     readonly = "booleanValue"
     design = "booleanValue"
     link = "booleanValue"
     asl = "intValue"</pre>

<p>The attribute parameter values have the following meanings:</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the fields is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>
The following examples show how attributes are defined:
<pre>    &lt;recordType name = "example"&gt;
        ...
        &lt;field name = "status" type = "string" readonly "true" /&gt;
        &lt;field name = "displayLimit" type = "structure"
                structureName = "displayLimit" readonly = "true" /&gt;
        ...
        &lt;field name = "value" type = "double" asl value = "0" /&gt;
       ...
    &lt;/recordType&gt;</pre>
<br />


<h3 id="property">property</h3>
A structure, recordType, and field can have properties. A property is defined
as:
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>The name of the property</dd>
  <dt style="font-family: courier;">associatedField</dt>
    <dd>The name of a field that has the value for the property. It can have
      one of the following forms: "name", "name.name", "/name", or
      "/name.name". See package org.epics.ioc.pv for details.</dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>

<h3 id="Support">Support</h3>

<p>Support can be associated with any field of a record instance when it is
created. See package org.epics.ioc.db for details. Record types and
structures can have default support as shown above. The syntax for a support
definition is:</p>
<pre>    &lt;support name = "supportName" factoryName = "factoryName" /&gt;</pre>
where
<dl>
  <dt><span style="font-family: courier">support</span></dt>
    <dd>Support for a non-link field of a record.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.process for details,</dd>
</dl>

<p>link fields have linkSupport, which is an extension of support that also
supports configuration information. Each link support can optionally have an
associated structure for configuration information.The syntax is:</p>
<pre>    &lt;structure name = "configurationStructureName"&gt;
        ...
    &lt;/structure&gt;
    ...
    &lt;linkSupport name = "supportName"
         configurationStructureName = "configurationStructureName"
         factoryName = "factoryName" /&gt;</pre>
where
<dl>
  <dt><span style="font-family: courier">linkSupport</span></dt>
    <dd>Support for a link field of a record.</dd>
  <dt><span style="font-family: courier">supportName</span></dt>
    <dd>string that describes the choice</dd>
  <dt><span
  style="font-family: courier">configurationStructureName</span></dt>
    <dd>The name of a structure containing configuration information for the
      support. Database configuration tools prompt the user to assign values
      to the structure. This is optional.</dd>
  <dt><span style="font-family: courier">factoryName</span></dt>
    <dd>The name of a Java factory class that creates support instances. See
      package org.epics.ioc.dbProcess for details,</dd>
</dl>

<p>When a record instance is created the supportName selects the support to
attach to a record link field.</p>
<br />
Examples of support:
<pre>     &lt;structure name = "processLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "wait" type = "boolean" /&gt;
         &lt;field name = "timeout" type = "double" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;structure name = "monitorLink"&gt;
         &lt;field name = "pvname" type = "string" link = "true" /&gt;
         &lt;field name = "process" type = "boolean"&gt;
             &lt;!-- process this record when monitor occurs --&gt;
         &lt;/field&gt;
         &lt;field name = "monitorOnly" type = "boolean"&gt;
             &lt;!-- monitor only or data also --&gt;
         &lt;/field&gt;
         &lt;field name = "inheritSeverity" type = "boolean" /&gt;
         &lt;field name = "forceLocal" type = "boolean"&gt;
             &lt;!-- if true pvname must be in local IOC --&gt;
         &lt;/field&gt;
     &lt;/structure&gt;

     &lt;linkSupport name = "processLink" configurationStructureName = "processLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;
     &lt;linkSupport name = "monitorLink" configurationStructureName = "monitorLink"
        factoryName = "org.epics.ioc.support.LinkSupportFactory" /&gt;</pre>
<hr />

<h2 style="text-align: center" id="Overview1">Overview of Java Support For
Database Definition</h2>
<hr />

<p>This following sections describes support for code that accessses Database
Definitions: menu, structure, recordType, support, and, linkSupport..</p>

<p>The interfaces support reflection for everything created from Database
Definitions. The interfaces can be used by tools such as VDCT or on a running
IOC database. The interfaces are also used by record support, link support,
and the database itself.</p>

<p>Reflection interfaces are available for the following XML definitions</p>
<dl>
  <dt>DBDMenu</dt>
    <dd>This is for introspecting the XML menu definitions</dd>
  <dt>DBDStructure</dt>
    <dd>This is for introspecting the XML structure definitions.</dd>
  <dt>DBDRecordType</dt>
    <dd>This is for introspecting the XML recordType definitions.</dd>
  <dt>DBDSupport</dt>
    <dd>This is for introspecting the XML support definitions.</dd>
  <dt>DBDLinkSupport</dt>
    <dd>This is for introspecting the XML linkSupport definitions.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Introspect">Introspection of Database
Definitions</h2>
<hr />

<p>This section describes interfaces for accessing menu, structure,
recordType, support, and linkSupport, i.e. everything defined in Database
Definition files except record instances. Reflection for fields of a
structure or recordType is discussed in the next section.</p>

<h3 id="Menu1">Menu</h3>

<p>The interface is:</p>
<pre>    interface DBDMenu{
        String getName();
        String[] getChoices();
        String toString(int indentLevel);
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The menu name.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>The array of choices for the menu.</dd>
  <dt style="font-family: courier;">toString</dt>
    <dd>Dumps the menu definition.</dd>
</dl>

<p>For example the following dumps a menu</p>
<pre>    void dumpMenu(DBDMenu menu) {
        String[] choices = menu.getChoices();
        System.out.printf("menu %s {\n",menu.getName();
        for(choice: choices) System.out.printf("    %s\n",choice);
        System.out.printf("}\n");
    }</pre>

<p>A shorter way is:</p>
<pre>    void dumpMenu(DBDMenu menu) {System.out.println(menu.toString());}</pre>

<h3 id="Structure1">Structure and RecordType</h3>

<p>The interfaces are:</p>
<pre>    interface DBDStructure extends Structure{}

    interface DBDRecordType extends DBDStructure {}</pre>

<p>For example the following dumps a structure</p>
<pre>    void dumpStructure(DBDStructure structure) {
        Field[] fields = structure.getFields();
        System.out.printf("structure %s {\n",structure.getStructureName();
        for(Field field : fields) {
            Type type = field.getType();
            System.out.printf("field %s type %s",
                field.getName(),type.toString());
        }
    }</pre>

<p>A shorter way is:</p>
<pre>    void dumpStructure(DBDStructure structure) {System.out.println(structure.toString);}</pre>

<h3 id="Support1">Support and LinkSupport</h3>

<p>The following interfaces is provided for accessing support.</p>
<pre>    interface DBDSupport {
        String getSupportName();
        String getFactoryName();
        String toString();
        String toString(int indentLevel);
    }

    interface DBDLinkSupport extends DBDSupport {
        String getConfigurationStructureName();
    }</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getFactoryName</dt>
    <dd>Get the factory name. This must be the complete java package + method
      name of a Factory that creates support for the field. See package
      org.epics.ioc.dbProcess for details about support and support
    factories.</dd>
  <dt style="font-family: courier;">getConfigurationStructureName</dt>
    <dd>Get the configuration structire name. A null is returned if none was
      defined in the linkSupport definition. This means the linkSupport does
      not require configuration information.</dd>
</dl>
<hr />
<hr />

<h2 style="text-align: center" id="Accessing">Accessing Database
Definitions</h2>
<hr />

<h3 id="DBD">DBD</h3>

<p>DBD is an interface for accessing a Database containing Database
Definitions. Methods are provided for accessing and inserting components. In
addition a number of "convenience" methods are provided.</p>
<pre>public interface DBD {
    String getName();
    DBD getMasterDBD();
    void mergeIntoMaster();
    DBDMenu createMenu(String menuName, String[] choices);
    DBDStructure createStructure(String name,
        Field[] field,Property[] property,FieldAttribute fieldAttribute);
    DBDRecordType createRecordType(String name,
        Field[] field,Property[] property,FieldAttribute fieldAttribute);
    DBDSupport createSupport(String supportName,String factoryName);
    DBDLinkSupport createLinkSupport(
        String supportName,String factoryName,String configurationStructureName);
    DBDMenu getMenu(String menuName);
    boolean addMenu(DBDMenu menu);
    Map&lt;String,DBDMenu&gt; getMenuMap();
    DBDStructure getStructure(String structureName);
    boolean addStructure(DBDStructure structure);
    Map&lt;String,DBDStructure&gt; getStructureMap();
    DBDRecordType getRecordType(String recordTypeName);
    boolean addRecordType(DBDRecordType recordType);
    Map&lt;String,DBDRecordType&gt; getRecordTypeMap();
    DBDSupport getSupport(String supportName);
    boolean addSupport(DBDSupport support);
    Map&lt;String,DBDSupport&gt; getSupportMap();
    DBDLinkSupport getLinkSupport(String supportName);
    boolean addLinkSupport(DBDLinkSupport support);
    Map&lt;String,DBDLinkSupport&gt; getLinkSupportMap();
    String[] menuList(String regularExpression);
    String menuToString(String regularExpression);
    String[] structureList(String regularExpression);
    String structureToString(String regularExpression);
    String[] recordTypeList(String regularExpression);
    String recordTypeToString(String regularExpression);
    String[] supportList(String regularExpression);
    String supportToString(String regularExpression);
    String[] linkSupportList(String regularExpression);
    String linkSupportToString(String regularExpression);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getName</dt>
    <dd>The name of this DBD database.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Get the master DBD or null if no master was passed to
      DBDFactory.create. Normally this means that this is the master.</dd>
  <dt style="font-family: courier;">mergeIntoMaster</dt>
    <dd>Merge this DBD into the master DBD. After merging into master the
      compoments are removed from this database.</dd>
  <dt style="font-family: courier;">createMenu</dt>
    <dd>Create a DBDMenu.</dd>
  <dt style="font-family: courier;">createStructure</dt>
    <dd>Create a DBDStructure.</dd>
  <dt style="font-family: courier;">createRecordType</dt>
    <dd>Create a DBDRecordType.</dd>
  <dt style="font-family: courier;">createSupport</dt>
    <dd>Create a DBDSupport.</dd>
  <dt style="font-family: courier;">createLinkSupport</dt>
    <dd>Create a DBDLinkSupport.</dd>
  <dt style="font-family: courier;">getMenu</dt>
    <dd>Get the DBDMenu that describes menuName.</dd>
  <dt style="font-family: courier;">addMenu</dt>
    <dd>Add a menu definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getMenuMap</dt>
    <dd>Get a map of all the menu definitions. A shallow copy of the map is
      returned.</dd>
  <dt style="font-family: courier;">getStructure</dt>
    <dd>Get the DBDStructure that describes the structureName</dd>
  <dt style="font-family: courier;">addStructure</dt>
    <dd>Add a structure definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getStructureMap</dt>
    <dd>Get a map of all the structure definitions. A shallow copy of the map
      is returned.</dd>
  <dt style="font-family: courier;">getRecordType</dt>
    <dd>Get the DBDRecordType that describes recordTypeName.</dd>
  <dt style="font-family: courier;">addRecordType</dt>
    <dd>Add a recordType definition and return true. If the definition
      already exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getRecordTypeMap</dt>
    <dd>Get a map of all the recordType definitions. A shallow copy of the
      map is returned.</dd>
  <dt style="font-family: courier;">getSupport</dt>
    <dd>Get the DBDSupport that describes supportName.</dd>
  <dt style="font-family: courier;">addSupport</dt>
    <dd>Add a support definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getSupportMap</dt>
    <dd>Get a map of all the support definitions. A shallow copy of the map
      is returned.</dd>
  <dt style="font-family: courier;">getLinkSupport</dt>
    <dd>Get the DBDLinkSupport that describes supportName.</dd>
  <dt style="font-family: courier;">addLinkSupport</dt>
    <dd>Add a support definition and return true. If the definition already
      exists the request fails and false is returned.</dd>
  <dt style="font-family: courier;">getLinkSupportMap</dt>
    <dd>Get a map of all the support definitions. A shallow copy of the map
      is returned.</dd>
</dl>
The remaining methods are convenience methods. Each convenience method
produces a string that lists or dumps all components with names that match a
regular expression. The java.util.regex facility is used. Consult it for a
definition of regular expressions.
<dl>
  <dt style="font-family: courier;">menuList</dt>
    <dd>Return an array of strings that is the list of menu names that match
      a regular expression</dd>
  <dt style="font-family: courier;">menuToString</dt>
    <dd>Get a dump of all the DBDMenu definitions with names that match a
      regular expression.</dd>
  <dt style="font-family: courier;">structureList</dt>
    <dd>Return an array of strings that is the list of structure names that
      match a regular expression</dd>
  <dt style="font-family: courier;">structureToString</dt>
    <dd>Get a dump of all the DBDStructure definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">recordTypeList</dt>
    <dd>Return an array of strings that is the list of recordType names that
      match a regular expression</dd>
  <dt style="font-family: courier;">recordTypeToString</dt>
    <dd>Get a dump of all the DBDRecordType definitions with names that match
      a regular expression.</dd>
  <dt style="font-family: courier;">supportList</dt>
    <dd>Return an array of strings that is the list of support names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">supportToString</dt>
    <dd>Get a dump of all the DBDSupport definitions with names that match a
      regular expression.</dd>
  <dt style="font-family: courier;">linkSupportList</dt>
    <dd>Return an array of strings that is the list of linkSupport names that
      match a regular expression.</dd>
  <dt style="font-family: courier;">linkSupportToString</dt>
    <dd>Get a dump of all the DBDLinkSupport definitions with names that
      match a regular expression.</dd>
</dl>
An example of using a convience method is:
<pre>    String[] list = master.menuList(".*[S].*");</pre>
Produces a list of all menu definitions that have an 'S" somewhere in the
menu name.
<hr />

<h2 style="text-align: center" id="Creating">Creating Database
Definitions</h2>
<hr />
Two classes are provided for creation of DBD Databases:
<ul>
  <li>DBDFactory<br />
    A factory to create and manage DBD databases.</li>
  <li>XMLToDBDFactory<br />
    A factory that reads xml Database Definitions and puts them into a DBD
    Database.</li>
</ul>

<h3 id="DBDFactory">DBDFactory</h3>

<p>DBDFactory is a class that creates DBD Databases. It provides the
following methods:</p>
<pre>public class DBDFactory {
    public static DBD create(String name);
    public static DBD getMasterDBD();
}
 </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a new DBD with the specified name. If the name is "master"
      than the master DBD is returned.</dd>
  <dt style="font-family: courier;">getMasterDBD</dt>
    <dd>Return the master DBD. This is created automatically by
    DBDFactory</dd>
  <dt></dt>
  <dt>All methods of DBDFactory and of the DBD instances it creates are
  thread safe.</dt>
  <dt></dt>
</dl>

<h3 id="XMLToDBDFa">XMLToDBDFactory</h3>

<p>The following reads an xml file containing menu, structure, record type,
and link support definitions and adds the definitions to a database
definition database.</p>
<pre>    public class XMLToDBDFactory {
        public static void convert(DBD dbd, String fileName,
            Requestor requestor);
        public static DBD create(String dbdName,String fileName,
            Requestor requestor);
    }</pre>
<dl>
  <dt style="font-family: courier;">convert</dt>
    <dd>Convert the xml DBD definitions in file fileName and put the
      definitions into dbd. When generating definitions for an IOC use
      addToMaster instead of this. The Requestor interface is described in
      package org.epics.ioc.util.</dd>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a DBD with the specified name and put the definitions obtained
      by parsing the XML defininitions in fileName into the dbd. The caller
      can, if desired, call DBD.mergeToMaster to put the newly created
      definitions into the master DBD. This can be called either during IOC
      initialization or while an IOC is running, i.e. on-line add of new
      definitions is supported. Definitions will not be created if they
      already appear in master or if they are defined more than once. A
      general rule is that the new definitions should not be added to master
      if any messages with message type greater than info are passed to the
      requestor. In any case the caller should remove all references to the
      new DBD after it decides not to merge or after the merge.</dd>
</dl>

<p>The method arguments are:</p>
<dl>
  <dt style="font-family: courier;">dbd</dt>
    <dd>The Database Definition Database.</dd>
  <dt style="font-family: courier;">fileName</dt>
    <dd>The filename relative to the current working directory that contains
      the Database Definitions.</dd>
  <dt style="font-family: courier;">requestor</dt>
    <dd>A listener for all messages generated while the method is
    execuiting.</dd>
  <dt style="font-family: courier;">dbdName</dt>
    <dd>The name for the DBD field that is created..</dd>
</dl>

<h3 id="Creating1">Creating Database Definitions</h3>

<p>Before record instances can be created all menu, structure, recordType,
and support definitions used by record instances must be created.</p>

<p>A running IOC always uses a DBD Database named "master" and an IOCDB also
named "master". The prefered way to create definitions by calling:</p>
<pre>    maxMessageType = IOCMessageType.iofo;
    DBD add = XMLToDBDFactory.create("add",fileName,this);
    if(maxMessageType!=IOCMessageType.iofo) // failure take appropriate action</pre>

<p>addToMaster will not add any definitions to master if any errors are
detected. It can be called during IOC initialization and also while an IOC is
running. For an IOC this is the only method required for generating Database
Definitions. Other code may decide to use DBDFactory.create instead.</p>

<p>XMLToDBDFactory is thread safe because it only allows one user at a time
to create new definitions. If it is busy and another user calls either
convert or create it call the message Listener with a fatal error and returns
immediately.</p>

<p>All DBD methods are thread safe. In order to prevent race conditions:</p>
<ul>
  <li>DBD has a private readWrite lock that manages all access to its
  methods.</li>
  <li>Database components can be added but not removed from a DBD.</li>
  <li>All getXXXMap methods return shallow copies of the internal map.</li>
</ul>
<hr />
</body>
</html>
