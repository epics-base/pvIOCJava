<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br
/>
2006.06.20</h1>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Database">Database Definition Syntax</a>
    <ul>
      <li><a href="#Database1">Database Definition Types</a></li>
      <li><a href="#field">field definition</a></li>
      <li><a href="#property">property</a></li>
      <li><a href="#Example">Example Structure, Menu, and linkSupport
        Definitions</a></li>
    </ul>
  </li>
  <li><a href="#Database2">Database Definition Examples</a>
    <ul>
      <li><a href="#Analog">Analog Input Record</a></li>
      <li><a href="#Analog1">Analog Imput Embeded Record</a></li>
      <li><a href="#Power">Power Supply Linked</a></li>
      <li><a href="#Power1">Power Supply Embeded</a></li>
      <li><a href="#Power2">Power Supply Array</a></li>
    </ul>
  </li>
  <li><a href="#Record">Record Instance Syntax</a></li>
  <li><a href="#Record1">Record Instance Examples</a>
    <ul>
      <li><a href="#aiRecord">analogInputRecord Instance</a></li>
      <li><a href="#aiEmbededR">aiRecord Instance</a></li>
      <li><a href="#powerSuppl">powerSupplyLinkedRecord Instance</a></li>
      <li><a href="#powerSuppl1">powerSupplyEmbededRecord Instance</a></li>
      <li><a href="#Power3">Power Supply Array Instance</a></li>
    </ul>
  </li>
  <li><a href="#Field">Field Access and Property Definitions</a></li>
  <li><a href="#Database3">Database Interface Definitions</a>
    <ul>
      <li><a href="#Field1">Field Types</a></li>
      <li><a href="#Data">Data Access Interfaces</a></li>
    </ul>
  </li>
  <li><a href="#Database4">Database Reflection</a>
    <ul>
      <li><a href="#pvAccess">pvAccess reflection</a></li>
      <li><a href="#dbAccess">dbAccess reflection</a></li>
    </ul>
  </li>
  <li><a href="#Example1">Example: Database Access via Reflection</a></li>
  <li><a href="#Database5">Database Access</a>
    <ul>
      <li><a href="#Interface">Interface DBAccess</a></li>
    </ul>
  </li>
  <li><a href="#Examples">Examples of Accessing Fields via DBAccess</a>
    <ul>
      <li><a href="#exampleAiE">exampleAiEmbeded</a></li>
      <li><a href="#exampleAi">exampleAi</a></li>
      <li><a href="#examplePow">examplePowerSupplyLinked or
        examplePowerSupplyEmbeded</a></li>
    </ul>
  </li>
  <li><a href="#License">License Agreement</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node
that controls and/or monitors a collection of devices. An IOC contains a
memory resident real time database. The real time database has a set of
"smart" records. Each record is an instance on a record of a particular
type.</p>

<p>JavaIOC is a JAVA implementation of an EPICS IOC. It has many similarities
to a Version 3 ( the 3.13 and 3.14 releases of EPICS base) but extends the
data types to support structures and arrays. This document assumes that the
reader is familiar with EPICS Version 3.</p>

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>
<ul>
  <li>default<br />
    This package contains the overview you are now reading. It also contains
    the main program XMLToDatabase.</li>
  <li>org.epics.ioc.pvAccess<br />
    A description of the basic data types. The basic data types are for data
    that is passed in or out of record instances, i.e. these are the data
    types used by channel access:
    <ul>
      <li>All Java primitive types except char<br />
        boolean, byte, short, int, long, float, double.</li>
      <li>string<br />
        A Java String.</li>
      <li>structure<br />
        A structure can contain fields with any of the supported types
        including structure and array fields.</li>
      <li>array<br />
        The array element type can be any of the supported types including
        structure and array.</li>
      <li>enum<br />
        A enum is a set of choices and an index that selects a choice.</li>
    </ul>
    pvAccess implements the reflection interfaces and defines the data
    interfaces for these types.<br />
  </li>
  <li>org.epics.ioc.dbDefinition<br />
    dbDefinition provides the following:
    <ul>
      <li>Adds the following types to the basic types.
        <ul>
          <li>menu<br />
            A menu is an enum with immutable choices.</li>
          <li>structure<br />
            sructure is extended to allow fields that have an extended
          type.</li>
          <li>array<br />
            array is extended to allow fields that have an extended type.</li>
          <li>link<br />
            A link is a special kind of structure.</li>
        </ul>
      </li>
      <li>Implements the reflection interfaces for the extended types.</li>
      <li>Provides an xml to database converter for database definitions,
        i.e. definitions of the following:
        <ul>
          <li>menu</li>
          <li>structure</li>
          <li>recordType</li>
          <li>linkSupport</li>
        </ul>
      </li>
      <li>Implements one or more DBDs which provides access to database
        definitions.</li>
    </ul>
  </li>
  <li>org.epics.ioc.dbAccess<br />
    dbAccess provides the following:
    <ul>
      <li>Provides an xml to database converter for record instancess</li>
      <li>Defines interfaces for data types defined by dbDefinition.</li>
      <li>Provides a factory that implements the data interfaces for a field
        of any of the supported types.</li>
      <li>Implements one or more IOCDBs ( IOC DataBase).</li>
      <li>Implements DBAccess, which is an interface for accessing an
      IOCDB.</li>
    </ul>
  </li>
  <li>org.epics.ioc.channelAccess<br />
    Work on this package is just beginning.</li>
  <li>org.epics.ioc.dbProcess<br />
    Work on this package is just beginning.</li>
  <li>org.epics.ioc.support<br />
    Work on this package is just beginning. It will contain the record,
    structure, and link support provided by the javaIOC.</li>
</ul>

<p>In package default there is a Java main program that reads Database
Definition and Record Instance files and dumps the resulting database. This
program can be executed as follows:</p>

<p>Make sure class path is properly defined. For example if your shell is
bash:</p>
<pre>    export CLASSPATH=pathToJavaIOC/bin</pre>

<p>Then execute:</p>
<pre>    java XMLToDatabase ...</pre>
The arguments can be any combination of:
<ul>
  <li>- dbd <br />
    the following filenames are database definition files</li>
  <li>- db <br />
    the following filenames are record instance files</li>
  <li>fileName <br />
    a database definition or record instance file</li>
  <li>-dumpDBD<br />
    dump all that database definitions read so far</li>
  <li>-dumpDB<br />
    dump all the record instances read so far</li>
</ul>

<p>For example:</p>
<pre>java XMLToDatabase menuStructureSupportDBD.xml aiDBD.xml \
    -db exampleAiLinearDB.xml -dumpDBD -dumpDB &gt; temp  `</pre>

<p>Will read two database definition files, one record instance file, dump
the database definitions and dump the record instance. The output will be
written to file temp. This example will actually work if you have unziped the
javaIOC distribution file. Just cd to directory
src.org/epics/dbAccess/example and execute the above command.</p>

<p>The remainder of this document gives an overview of what is currently
implemented:</p>
<ul>
  <li>The xml syntax for database definitions</li>
  <li>The xml syntax for record instances.</li>
  <li>The syntax for accessing fields of a record instance.</li>
  <li>A brief overview of what each package provides.</li>
</ul>

<p>Before a beta release of JavaIOC can be announced the following must also
be defined and implemented:</p>
<ul>
  <li>Channel Access<br />
    This will be based on the ideas described in the EPICS core developer
    wikis. The following varieties of CA are required.
    <ul>
      <li>Local Access - Links between record instances.</li>
      <li>Remote Access</li>
      <li>Gateway to V3 Channel Access
        <ul>
          <li>Client - database links to V3 IOCs</li>
          <li>Server - V3 client access to a JavaIOC</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Record Processing<br />
    This will be based on the record processing semantics described in the
    EPICS core developer wikis.</li>
  <li>include and macro substitution for xml files.</li>
  <li>A shell - Jython?</li>
  <li>iocInit<br />
    This will be designed so that on-line add is available.</li>
  <li>Design and implement a core set of:
    <ul>
      <li>menu, structure, linkSupport, and recordType database
      definitions</li>
      <li>record/structure support modules</li>
      <li>link support modules for channel access links</li>
    </ul>
  </li>
  <li>Design and implement hardware device support based on asynDriver.</li>
</ul>

<p>When these are ready a JavaIOC is a viable product. However several other
things are desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool.</li>
  <li>Access Security - Based on V3 Access Security.</li>
  <li>Remore Error Logging.</li>
  <li>Monitoring of database modification from outside IOC</li>
  <li>Channel Access Clients that implement the JavaIOC Channel Access
    Semantics.</li>
  <li>...</li>
</ul>

<p>Thus lots of work remains.</p>
<hr />

<h2 style="text-align: center" id="Database">Database Definition Syntax</h2>
<hr />

<p>This section provides a brief description of database definitions. See
package org.epics.ioc.dbDefinition for complete details.</p>

<h3 id="Database1">Database Definition Types</h3>

<p>Database definitions consist of the following definition types: menu,
structure, linkSupport, and recordType.</p>

<p>An example menu definition is:</p>
<pre>    &lt;menu name = "menuAlarmSevr"&gt;
        &lt;choice&gt;none&lt;/choice&gt;
        &lt;choice&gt;minor&lt;/choice&gt;
        &lt;choice&gt;major&lt;/choice&gt;
        &lt;choice&gt;invalid&lt;/choice&gt;
    &lt;/menu&gt;</pre>

<p>A menu definition consists of a name and a set of choices.</p>

<p>An example structure definition is:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low" type = "double" /&gt;
        &lt;field name = "high" type = "double" /&gt;
    &lt;/structure&gt;</pre>

<p>A structure definition consists of a name and a set of field definitions.
More details about field definitions are provided below. A structure
definitions can also optionally define associated support as follows:</p>
<pre>    &lt;struucture name = "name" structureSupportName = "supportName" &gt;
       ...
    &lt;/structure&gt;</pre>

<p>The supportName must be the name of a Java Class. For example
"org.epics.ioc.support.SomeSupport"</p>

<p>An example linkSupport definition is:</p>
<pre>    &lt;linkSupport name = "org.epics.ioc.support.MonitorLink" configStructureName = "monitorLink" /&gt;</pre>

<p>A linkSupport definition consists of a name, which must be the name of a
Java Class, and the name of a structure for configuration information.</p>

<p>An example recordType definition is:</p>
<pre>&lt;recordType name = "example" recordSupportName = "supportName" /&gt;
    &lt;field name = "value" type = "double"&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
&lt;/recordType&gt;</pre>

<p>A recordtype definition consists of a name, optional default record
support, and a set of field definitions. A recordType is imlemented so that
it extends a structure definition. The supportName must be the name of a Java
Class. For example "org.epics.ioc.support.SomeSupport"</p>

<h3 id="field">field definition</h3>

<p>Both structure and recordType definitions define a set of field
definitions. A field definition has the format:</p>
<pre>    &lt;field name = "value" type = "double ... "&gt;</pre>
where "..." represents other attributes. The complete set of attributes are:
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>the field name.</dd>
  <dt style="font-family: courier;">type</dt>
    <dd>The field type which must be one of:<br />
      boolean byte short int long float double string enum menu array
      structure link</dd>
  <dt style="font-family: courier;">menuName</dt>
    <dd>must be given if the type is menu.</dd>
  <dt style="font-family: courier;">structureName</dt>
    <dd>can be given if the type is structure. If not given the structure
      must be specified when a field instance is created.</dd>
  <dt style="font-family: courier;">elementType</dt>
    <dd>must be specified if the type is array. It can be any of the
      supported types.</dd>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the field is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>

<h3 id="property">property</h3>
A structure, recordType, and field can have properties. A property is defined
as:
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where
<dl>
  <dt>name</dt>
    <dd>The name of the property</dd>
  <dt>associatedField</dt>
    <dd>The name of a field that has the value for the property. Examples are
      given later in this document. An associatedField must be one of the
      following:
      <dl>
        <dt>/name</dt>
          <dd>If the associatedField value starts with '/' then the search
            will start at the record not with the field that has the
          property.</dd>
        <dt>name</dt>
          <dd>The name of a structure field.</dd>
        <dt>name1.name2</dt>
          <dd>name1 must be the name of a structure field. name2 must be a
            property or field in the structure field.</dd>
      </dl>
    </dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>
<hr />

<h3 id="Example">Example Structure, Menu, and linkSupport Definitions</h3>
<hr />

<p>The following are examples of menu and structure definitions. For now they
are just examples but similar definitions will be part of base.</p>
<pre>&lt;menu name = "menuPriority"&gt;
    &lt;choice&gt;low&lt;/choice&gt;
    &lt;choice&gt;medium&lt;/choice&gt;
    &lt;choice&gt;high&lt;/choice&gt;
&lt;/menu&gt;</pre>
<pre>&lt;menu name = "menuAlarmSevr"&gt;
    &lt;choice&gt;none&lt;/choice&gt;
    &lt;choice&gt;minor&lt;/choice&gt;
    &lt;choice&gt;major&lt;/choice&gt;
    &lt;choice&gt;invalid&lt;/choice&gt;
&lt;/menu&gt;</pre>

<p>menuPriority and menuAlarmSever are just like the V3 versions.</p>
<pre>&lt;structure name = "displayLimit"&gt;
    &lt;field name = "low" type = "double" /&gt;
    &lt;field name = "high" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>Whenever a field has a property "displayLimit" then the associatedField
for the property must be a displayLimit structure field.</p>
<pre>&lt;structure name = "linearConvert"&gt;
    &lt;field name = "engUnitsLow" type = "double" /&gt;
    &lt;field name = "engUnitsHigh" type = "double" /&gt;
    &lt;field name = "slope" type = "double" /&gt;
    &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>This is for use by records that perform linear conversions.</p>
<pre>&lt;structure name = "timeStamp"&gt;
    &lt;field name = "secondsPastEpoch" type = "long" /&gt;
    &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<p>This may be the way time stamps are defined. Some thought should be given
to see if another way is desired.</p>
<pre>&lt;menu name = "menuScan"&gt;
    &lt;choice&gt;passive&lt;/choice&gt;
    &lt;choice&gt;event&lt;/choice&gt;
    &lt;choice&gt;interrupt&lt;/choice&gt;
    &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;

&lt;structure name = "scan"&gt;
    &lt;field name = "scan" type = "menu" menuName = "menuScan" /&gt;
    &lt;field name = "rate" type = "double" /&gt;
    &lt;field name = "phase" type = "int" /&gt;
&lt;/structure&gt;</pre>

<p>This is similar to V3 except, instead of having predefined scan rates
defined in menuScan, the rate is specfied via a separate field.</p>
<pre>&lt;structure name = "processLink" structureSupportName = "org.epics.ioc.support.ProcessLink" &gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "wait" type = "boolean" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
    &lt;field name = "forceLocal" type = "boolean"&gt;
        &lt;!-- if true pvname must be in local IOC --&gt;
    &lt;/field&gt;
&lt;/structure&gt;
A processLink is the replacement for the V3 forward links,
i.e. a request to process a linked record.
A new feature is that the record making the request will wait, which
actually means to go asynchronous, until the linked record completes
its processing.
&lt;structure name = "monitorLink" structureSupportName = "org.epics.ioc.support.MonitorLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean"&gt;
        &lt;!-- process this record when monitor occurs --&gt;
    &lt;/field&gt;
    &lt;field name = "monitorOnly" type = "boolean"&gt;
        &lt;!-- monitor only or data also --&gt;
    &lt;/field&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
    &lt;field name = "forceLocal" type = "boolean"&gt;
        &lt;!-- if true pvname must be in local IOC --&gt;
    &lt;/field&gt;
&lt;/structure&gt;
This is a replacement for the V3 CP/CPP input links,
this is a request to set a monitor on the linked field.
&lt;structure name = "inputLink" structureSupportName = "org.epics.ioc.support.InputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "wait" type = "boolean" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
    &lt;field name = "forceLocal" type = "boolean" &gt;
        &lt;!-- if true pvname must be in local IOC --&gt;
    &lt;/field&gt;
&lt;/structure&gt;
This is a replacement for V3 input links.
New features are that if a request is made to process the linked
record the record making the request can wait until the linked
record completes processing before getting the input data.
&lt;structure name = "outputLink" structureSupportName = "org.epics.ioc.support.OutputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "wait" type = "boolean" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
    &lt;field name = "forceLocal" type = "boolean" &gt;
        &lt;!-- if true pvname must be in local IOC --&gt;
        &lt;boolean /&gt;
    &lt;/field&gt;
&lt;/structure&gt;</pre>

<p>This is the replacement for V3 output links. A new feature is that the
record making the request can wait for the linked record to complete
processing, it implements putCallback.</p>
<pre>&lt;linkSupport name = "processLink" configStructureName = "processLink" /&gt;
&lt;linkSupport name = "monitorLink" configStructureName = "monitorLink" /&gt;
&lt;linkSupport name = "inputLink" configStructureName = "inputLink" /&gt;
&lt;linkSupport name = "outputLink" configStructureName = "outputLink" /&gt;</pre>

<p>These define the "soft" link support that will be implemented for the
javaIOC, i.e. the support for links to other records.</p>
<pre>&lt;structure name = "disableLink" structureSupportName = "org.epics.ioc.support.DisableLink"&gt;
    &lt;field name = "disabled" type = "boolean" /&gt;
    &lt;field name = "value" type = "short" default = "1" /&gt;
    &lt;field name = "input" type = "short" /&gt;
    &lt;field name = "link" type = "link" /&gt;
    &lt;field name = "disableAlarmSeverity"
           type = "menu" menuName = "menuAlarmSevr" /&gt;
&lt;/structure&gt;</pre>

<p>These describe the equivalent or the disable fields in V3 dbCommon.</p>
<pre>&lt;structure name = "asynLink" structureSupportName = "org.epics.ioc.support.AsynLink"&gt;
    &lt;field name = "portName" type = "string" /&gt;
    &lt;field name = "addr" type = "int" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
&lt;/structure&gt;
&lt;linkSupport name = "asynLink" configStructureName = "asynLink" /&gt;</pre>

<p>For interfacing to hardware, V4 will provide support for asynDriver style
interfaces. The record support provided with the base javaIOC will use these
as well as the soft link support interfaces.</p>
<hr />

<h2 id="Database2">Database Definition Examples</h2>
<hr />

<p>This section provides some examples of record type definitions. The
examples demonstrate that record types can be designed in several ways. The
examples are:</p>
<dl>
  <dt>analogInputRecord</dt>
    <dd>This is a record type that is similar to the V3 aiRecord but will
      only allow linear or no conversion.</dd>
  <dt>aiRecord</dt>
    <dd>This is a record type that has the same capabilities as
      analogInputRecord but is created by using embeded components which can
      also be reused for other record types.</dd>
  <dt>powerSupplyLinkedRecord</dt>
    <dd>This is an example of how a "device" abstraction record type can be
      created by using links to other records</dd>
  <dt>powerSupplyEmbededRecord</dt>
    <dd>This is an example that has the same capability as the
      powerSupplyLinkedRecord but is created by using embeded components.</dd>
  <dt>powerSupplyArrayRecord</dt>
    <dd>This is an example that shows how arrays of other "devices" can be
      supported.</dd>
  <dt>The examples are chosen to demonstrate the capabilities of the javaIOC
  rather than to say how record types should be created.</dt>
</dl>

<h3 id="Analog">Analog Input Record</h3>

<p>The following is one way of defining an analog input record:</p>
<pre>&lt;recordType name = "analogInputRecord" 
         recordSupportName = "org.epics.ioc.support.AnalogInputSupport" &gt;
    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert"
        type = "structure" structureName = "linearConvert" /&gt;
&lt;/recordType&gt;</pre>

<p>This definition is similar to the V3 aiRecord except that it does not
support breakpoint conversions.</p>

<p>Breakpoint conversions could also be provided but instead on adding fields
to menuConvert, whichV3 does, a separate field should holds the breakpoint
information.</p>

<p>A disadvantage of this way of defining an analog input record is that if
additional features are desired the record can not easily be reused. Either a
new record type and associated record support must be created or a set of
linked records has to be defined.</p>

<h3 id="Analog1">Analog Imput Embeded Record</h3>

<p>The following defines an analog input record type with maximum reuse of
components.</p>

<p>First define a structure for raw input.</p>
<pre>&lt;structure name = "aiRaw" structureSupportName = "org.epics.ioc.support.AiRaw" &gt;
    &lt;field name = "value" type = "int" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;</pre>
This defines a structure appropriate for holding the raw value obtained from
an ADC. Device support for an ADC can be attached to the input field. The
value field has three propertys. The status and severity reside in the
structure itself. The timeStamp will be obtained from a parent structure or
record type. Note that the structure also has associated support.

<p>Next define:</p>
<pre>&lt;structure name = "aiLinear" structureSupportName = "org.epics.ioc.support.AiLinear" &gt;
    &lt;property name = "rawValue" associatedField = "aiRaw.value" /&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "aiRaw" type = "structure" structureName = "aiRaw"/&gt;
    &lt;field name = "linearConvert"
        type = "structure" structureName = "linearConvert" /&gt;
&lt;/structure&gt;</pre>

<p>This defines a structure appropriate for holding a value that is obtained
by performing a linear conversion on a raw value obtained from other support.
Similar structures could be defined for other types of conversion, e.g.
breakpoint conversions.</p>

<p>Finally define a record type</p>
<pre>&lt;recordType name = "aiRecord" recordSupportName = "org.epics.ioc.support.Ai" &gt;
    &lt;property name = "value" associatedField = "aiLinear.value" /&gt;
    &lt;property name = "rawValue" associatedField = "aiLinear.rawValue" /&gt;
    &lt;property name = "status" associatedField = "aiLinear.status" /&gt;
    &lt;property name = "severity" associatedField = "aiLinear.severity" /&gt;
    &lt;field name = "aiLinear" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>

<p>The associated record support could be written so that it could also be
used for other similar record types. For example an aiBreakPointRecord. As
long as the new record type has fields required by the record support, the
existing record support can be used by the new record type.</p>

<h3 id="Power">Power Supply Linked</h3>

<p>The following shows how a simple power supply record type can be created
via links to other record types. To make the example simple the power supply
provides access only to power, current, and voltage. The current and voltage
will be read via some hardware device such as an ADC. The power is just
current*voltage.</p>
<pre>&lt;recordType name = "powerSupplyLinkedRecord"
         recordSupportName = "org.epics.ioc.support.PowerSupplyLinked"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;property name = "voltage" associatedField = "voltageInput.value" /&gt;
    &lt;field name = "power" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;

    &lt;field name = "currentInput" type = "link" /&gt;
    &lt;field name = "voltageInput" type = "link" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
&lt;/recordType&gt;</pre>

<h3 id="Power1">Power Supply Embeded</h3>

<p>The following is one way of creating the simple power supply using embeded
structures.</p>

<p>First define:</p>
<pre>&lt;structure name = "powerSupply" structureSupportName = "org.epics.ioc.support.PowerSupply" &gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;property name = "voltage" associatedField = "voltageInput.value" /&gt;
    &lt;field name = "power" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "voltageInput" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
&lt;/structure&gt;</pre>

<p>This defines a single power supply. The power is a field of the power
supply structure. The current and voltage are defined via an aiLinear
structure, which was defined in the previous example. The support available
via the aiLinear structure will also work with the powerSupply.</p>

<p>Next define:</p>
<pre>&lt;recordType name = "powerSupplyEmbededRecord"
        recordSupportName = "org.epics.ioc.support.PowerSupply"&gt;
    &lt;property name = "power" associatedField = "powerSupply.power" /&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;property name = "voltage" associatedField = "powerSupply.voltage" /&gt;
    &lt;field name = "powerSupply"
         type = "structure" structureName = "powerSupply" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>

<h3 id="Power2">Power Supply Array</h3>

<p>An array of power supplies could be defined as follows:</p>
<pre>&lt;recordType name = "powerSupplyArrayRecord"
        recordSupportName = "org.epics.ioc.support.PowerSupplyArray" &gt;
    &lt;field name = "powerSupply" type = "array" elementType = "structure" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>
<hr />

<h2 style="text-align: center" id="Record">Record Instance Syntax</h2>
<hr />

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" recordSupportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p>If the recordSupport name is not specified then the record support
specified in the recordType definition is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>
<hr />

<h2 id="Record1">Record Instance Examples</h2>
<hr />

<h3 id="aiRecord">analogInputRecord Instance</h3>
<pre>&lt;record name = "exampleAnalogInput" type = "analogInputRecord"&gt;
    &lt;input linkSupportName = "opg.epics.ioc.support.AsynInt" configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h3 id="aiEmbededR">aiRecord Instance</h3>
<pre>&lt;record name = "exampleAi" type = "aiRecord"&gt;
    &lt;aiLinear&gt;
        &lt;aiRaw&gt;
            &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                     configStructureName = "asynLink"&gt;
                &lt;portName&gt;somePort&lt;/portName&gt;
                &lt;addr&gt;1&lt;/addr&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiLinear&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h3 id="powerSuppl">powerSupplyLinkedRecord Instance</h3>
<pre>&lt;record name = "current" type = "aiRecord"&gt;
    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
             configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;

&lt;record name = "voltage" type = "aiRecord"&gt;
    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
            configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;

&lt;record name = "examplePowerSupplyLinked" type = "powerSupplyLinkedRecord"&gt;
    &lt;units&gt;watts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;100.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;currentInput linkSupportName = "org.epics.ioc.support.InputLink"
            configStructureName = "inputLink"&gt;
         &lt;pvname&gt;current.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/currentInput&gt;
    &lt;voltageInput linkSupportName = "org.epics.ioc.support.AsynInt"
              configStructureName = "inputLink"&gt;
         &lt;pvname&gt;voltage.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/voltageInput&gt;
&lt;/record&gt;</pre>

<h3 id="powerSuppl1">powerSupplyEmbededRecord Instance</h3>
<pre>&lt;record name = "examplePowerSupply" type = "powerSupplyEmbededRecord"&gt;
    &lt;powerSupply&gt;
        &lt;units&gt;watts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;100.0&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;currentInput&gt;
            &lt;aiRaw&gt;
                &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                         configStructureName = "asynLink"&gt;
                    &lt;portName&gt;somePort&lt;/portNname&gt;
                    &lt;addr&gt;2&lt;/addr&gt;
                &lt;/input&gt;
            &lt;/aiRaw&gt;
            &lt;units&gt;amps&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;10.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;linearConvert&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
        &lt;/currentInput&gt;
        &lt;voltageInput&gt;
            &lt;aiRaw&gt;
                &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                         configStructureName = "asynLink"&gt;
                    &lt;portName&gt;somePort&lt;/portName&gt;
                    &lt;addr&gt;2&lt;/addr&gt;
                &lt;/input&gt;
            &lt;/aiRaw&gt;
            &lt;units&gt;volts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;2.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;linearConvert&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;2.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
        &lt;/voltageInput&gt;
    &lt;/powerSupply&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h3 id="Power3">Power Supply Array Instance</h3>
<pre>&lt;record name = "examplePowerSupplyArray" type = "powerSupplyArrayRecord"&gt;
    &lt;powerSupply capacity = "2"&gt;
        &lt;value     structureName = "powerSupply"&gt;
            &lt;units&gt;watts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;100.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;currentInput&gt;
                &lt;aiRaw&gt;
                    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;4&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;amps&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;10.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/currentInput&gt;
            &lt;voltageInput&gt;
                &lt;aiRaw&gt;
                    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;5&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;volts&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;2.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;2.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/voltageInput&gt;
        &lt;/value&gt;
        &lt;value     structureName = "powerSupply"&gt;
            &lt;units&gt;watts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;1000.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;currentInput&gt;
                &lt;aiRaw&gt;
                    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;6&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;amps&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;10.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/currentInput&gt;
            &lt;voltageInput&gt;
                &lt;aiRaw&gt;
                    &lt;input linkSupportName = "org.epics.ioc.support.AsynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;7&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;volts&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;100.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;100.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/voltageInput&gt;
        &lt;/value&gt;
    &lt;/powerSupply&gt;
    &lt;priority&gt;low&lt;/priority&gt;
&lt;/record&gt;</pre>
<hr />

<h2 style="text-align: center" id="Field">Field Access and Property
Definitions</h2>
<hr />

<p>Because a JavaIOC allows structures, there has to be a way to refer to
each field of each structure. A field is specified via a string that has the
form: <pre>    &lt;recordName&gt;.name.name ...</pre>
The first "." ends the record name and each "." locates a field. For the
following examples the recordName and first "." will be assumed. Thus when
the example gives a field name as "powerSupply.power" it actually means
"&lt;recordName&gt;.powerSupply.power"</p>

<p>Properties can be assigned to a field, a structure, and a recordType.
Properties provide two features: <ol>
  <li>related fields<br />
    When given for a field a property specifies a field that has information
    associated with the field. For example a value field can have properties
    defined for display limits, control limits, units, etc.</li>
  <li>look elsewhere<br />
    When assigned to a structure it is a way of saying look elsewhere for a
    field that holds the desired data. Since a recordType is also a structure
    properties can also be assigned to a recordType. Elsewhere can be a field
    in the same record or a field in another record.</li>
</ol>
</p>

<p>Lets discuss the first case. The aiRaw structure includes the definitions: <pre>&lt;structure name = "aiRaw"&gt;
    &lt;field name = "value" type = "int" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
&lt;/structure&gt;</pre>
These defininitions state that value has the following properties: <dl>
  <dt>status</dt>
    <dd>The associatedField is the status field of the aiRaw structure.</dd>
  <dt>severity</dt>
    <dd>The associatedField is the severity field of the aiRaw structure.</dd>
  <dt>timeStamp</dt>
    <dd>The associatedField "/timeStamp" says to start looking at the top of
      the record hierarchy for the timeStamp.</dd>
</dl>
When a client has access to aiRaw.value then the client can ask for any of
the properties status, severity, and timeStamp and will get an interface that
allows access to the appropriate field.</p>

<p>Now lets consider properties assigned to a structure or record type. The
aiLinear structure includes the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;property name = "rawValue" associatedField = "aiRaw.value" /&gt;
    &lt;field name = "aiRaw" type = "structure" structureName = "aiRaw"/&gt;
&lt;/structure&gt;</pre>
This property definition says that to find rawValue look at the aiRaw field
of structure aiLinear and then look for value. In this example value is a
field of structure aiRaw so it is the actual field. In more complicated
examples like the powerSupply, value could be a property rather than a field
and a further search is required.</p>

<p>This use of property is especially usefull for "device" oriented records,
e.g. the powerSupply. A client that understands what a power supply is just
wants to ask for power, current, and voltage. The client should not be
responsible for knowing exactly where the current is located but can just ask
for the current and be told where it is located.</p>

<p>Now consider the powerSupplyEmbeded example.</p>

<p>The power supply record has the structure: <pre>    powerSupplyEmbededRecord
        powerSupply
            power
            currentInput
                value
                status
                severity
                units
                displayLimit
                aiRaw
                    value
                    status
                    severity
                    input
                linearConvert
            voltageInput
                value
                status
                severity
                units
                displayLimit
                aiRaw
                    value
                    status
                    severity
                    input
                linearConvert
            status
            severity
            units
            displayLimit
        status
        severity
        timeStamp
        priority
        scan</pre>
where the detail of many of the structure fields is not shown.</p>

<p>Without properties the only way to get the power, current, and voltage it
to specify the fields as: <pre>    powerSupply.power
    powerSupply.currentInput.value
    powerSupply.voltageInput.value</pre>
</p>

<p>But with the way the properties are defined they can be specified as: <pre>    power
    current
    voltage</pre>
</p>

<p>Lets consider power first. The powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyEmbededRecord"&gt;
    &lt;property name = "power" associatedField = "powerSupply.power" /&gt;
    &lt;field name = "powerSupply" type = "structure" structureName = "powerSupply" /&gt;
&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;field name = "power" type = "double" &gt;
&lt;/structure&gt;</pre>
</p>

<p>Thus field "power" results in the following: <ol>
  <li>In powerSupplyRecord property power is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>field power is located in the powerSupply structure.</li>
  <li>Thus the actual field is powerSupplyRecord.powerSupply.power.</li>
</ol>
</p>

<p>Now for current. The powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyRecord"&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;field name = "powerSupply" type = "structure" structureName = "powerSupply" /&gt;
&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>Structure aiLinear has the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;field name = "value" type = "double" &gt;
&lt;/structure&gt;</pre>
</p>

<p>Thus field "current" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Thus the actual field is
  powerSupplyRecord.powerSupply.aiLinear.value</li>
</ol>
</p>

<p>Now consider "current.status" and "current.timeStamp" The
powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyRecord"&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;field name = "powerSupply"
         type = "structure" structureName = "powerSupply" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;

&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>Structure aiLinear has the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;field name = "value" type = "double" &gt;
      &lt;property name = "status" associatedField = "status" /&gt;
      &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>"current.status" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Field value of structure aiLinear has property status.</li>
  <li>The aiLinear structure has a field status.</li>
  <li>Thus the actual field is
  powerSupplyRecord.powerSupply.aiLinear.status</li>
</ol>
"current.timeStamp" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Field value of structure aiLinear has property timeStamp.</li>
  <li>The associatedField for timeStamp is "/timeStamp". This results in
    searching from the top of the record looking for a field named
    "timeStamp". It is found in powerSupplyRecord.</li>
  <li>Thus the actual field is powerSupplyRecord.timeStamp</li>
</ol>
</p>

<p>Thus for the powerSupply: <ol>
  <li>power is powerSupplyRecord.powerSupply.power</li>
  <li>power.status is powerSupplyRecord.powerSupply.status</li>
  <li>power.timeStamp is powerSupplyRecord.timeStamp</li>
  <li>current is powerSupplyRecord.powerSupply.aiLinear.value</li>
  <li>current.status is powerSupplyRecord.powerSupply.aiLinear.status</li>
  <li>current.timeStamp is powerSupplyRecord.timeStamp</li>
  <li>current.rawValue is
  powerSupplyRecord.powerSupply.aiLinear.aiRaw.value</li>
  <li>current.rawValue.status is
    powerSupplyRecord.powerSupply.aiLinear.aiRaw.status</li>
  <li>current.rawValue.timeStamp is powerSupplyRecord.timeStamp</li>
</ol>
</p>

<p>Properties for structures can also be used for "device" records that are
implemented via links. For example the powerSupplyLinkedRecord has the
definitions:</p>
<pre>&lt;recordType name = "powerSupplyLinkedRecord"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "link" /&gt;</pre>

<p>And the example record instance defined:</p>
<pre>&lt;record name = "examplePowerSupplyLinked" type = "powerSupplyLinkedRecord"&gt;
    &lt;currentInput linkSupportName = "inputLink" configStructureName = "inputLink"&gt;
         &lt;pvname&gt;current.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/currentInput&gt;
 </pre>

<p>NOTE: current in <span
style="font-family: courier;">&lt;pvname&gt;current.value&lt;/pvname&gt;</span>
is the name of the record that has the current.</p>

<p>When a request is made for field current the following happens.</p>
<ol>
  <li>The property current is located in record examplePowerSupplyLinked.</li>
  <li>The field currentInput is located in examplePowerSupplyLinked.</li>
  <li>The fact that the field is a link indicates that the current is located
    in another record. The remainder of the associatedField is saved. Call
    this the remoteField which in this example has the value "value"</li>
  <li>The data structure that holds the inputLink information is located.</li>
  <li>The inputLink fields are searched for the first field that has the
    attribute "link".</li>
  <li>This field must be a string. The beginning of the string up to the
    first "." is the name of the remote record. Call this remoteRecord. In
    this example it has the value "current".</li>
  <li>The requester is told the the current can be located by asking for
    remoteRecord.remoteField which is this case has the value
  "current.value".</li>
  <li>The requester must make a separate request to get the current
    information.</li>
</ol>
<pre></pre>
<hr />

<h2 style="text-align: center" id="Database3">Database Interface
Definitions</h2>
<hr />

<p>A JavaIOC implements interfaces for accessing fields of database records.
The interfaces are a combination of reflection ( what is a field) and data
(what does a field contain) interfaces.</p>

<h3 id="Field1">Field Types</h3>

<p>Two Java enums define the supported types.</p>

<p>The first enum is:</p>
<pre>    public enum Type {
        pvUnknown,
        pvBoolean,
        pvByte,
        pvShort,
        pvInt,
        pvLong,
        pvFloat,
        pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray;
    }</pre>

<p>Access to database fields from outside a record, i.e. Channel Access,
always uses only the pv types.</p>

<p>The IOC database adds the types:</p>
<pre>    public enum DBType {
        dbPvType,
        dbMenu,
        dbStructure,
        dbArray,
        dbLink;
    }
    </pre>

<h3 id="Data">Data Access Interfaces</h3>

<p>The following describe the interfaces for accessing the data a field
contains.</p>

<p>The data interfaces for accessing Type data are:</p>
<pre>    interface PVData {
         Field getField(); // get the reflection interface
         String toString();
         String toString(int indentLevel);
    }
    interface PVBoolean extends PVData{
        boolean get();
        void put(boolean value);
    }
    //   similar interfaces for other primitve types
    interface PVString extends PVData{
        String get();
        void put(String value);
    }
    interface PVEnum extends PVData{
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }
    interface PVStructure extends PVData {
        PVData[] getFieldPVDatas();
    }
    interface PVArray extends PVData{
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
    }
    interface PVBooleanArray extends PVArray{
        int get(int offset, int len, boolean[]to, int toOffset);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }
    // ... for arrays of other pv Types</pre>

<p>The following interfaces extend the PVData interfaces for DBType data:</p>
<pre>    interface DBData extends PVData {
        DBDField getDBDField(); // get the reflection interface
        DBStructure getParent();
        DBRecord getRecord();
        void addListener(DBListener listener);
        void removeListener(DBListener listener);
        void postPut();
        void postPut(DBData dbData);
    }
    interface DBBoolean extends DBData, PVBoolean{}
    // ... similar interfaces for all other PVData interfaces
    interface DBStructure extends DBData, PVStructure {
        DBData[] getFieldDBDatas();
        int getFieldDBDataIndex(String fieldName);
        DBStructure getParent();
    }
    interface DBLink extends DBStructure {
        String getConfigStructureName();
        void putConfigStructureName(String name);
        String getLinkSupportName();
        void putLinkSupportName(String name);
        DBStructure getConfigStructure();
        void putConfigStructure(DBStructure dbStructure);
    }
    interface DBRecord extends DBStructure {
        String getRecordName();
    }</pre>
<hr />

<h2 style="text-align: center" id="Database4">Database Reflection</h2>
<hr />

<p>The previous section listed the interfaces for accessing data. The
interfaces also provided methods (PVData.getField and DBData.get DBDField)
which provide access to the reflection interfaces described in this section.
The reflection interfaces provide access to the type, attributes, and
properties of each field of each record instance.</p>

<h3 id="pvAccess">pvAccess reflection</h3>

<p>The reflection interfaces for pvAccess data are:</p>
<pre>    interface Property {
        String getName();
        String getFieldName();
    }
    interface Field {
        String getName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
    }
    interface Enum extends Field {
        boolean isChoicesMutable();
    }
    interface Array extends Field{
        Type getElementType();
    }
    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }</pre>

<h3 id="dbAccess">dbAccess reflection</h3>

<p>For DBType reflection the following are added:</p>
<pre>interface DBDAttribute {
    String getName();
    DBType getDBType();
    Type getType();
    String getDefault();
    boolean isReadOnly();
    boolean isDesign();
    boolean isLink();
    int getAsl();
    DBDMenu getMenu();
    DBDStructure getStructure();
    DBType getElementDBType();
    Type getElementType();
}
interface DBDField extends Field {
    DBType getDBType();
    DBDAttribute getAttribute();
}
public interface DBDArrayField extends DBDField, Array {}
public interface DBDEnumField extends DBDField, Enum { }
public interface DBDLinkField extends DBDStructureField { }
public interface DBDMenuField extends DBDField, Enum { }
public interface DBDStructureField extends DBDField,Structure { }</pre>
<hr />

<h2 id="Example1">Example: Database Access via Reflection</h2>
<hr />
An interface IOCDB, not described in this overview, provides a method that
locates the interface for a record instance. For example, to locate the
aiAnalogExample record the call is:
<pre>    DBRecord dbRecord = iocdb.findRecord("exampleAiLinear");</pre>

<p>Starting with this the data in the value field can be read as follows:</p>
<pre>    DBData[] dbData = dbRecord.getFieldDBDatas();
    int index = dbRecord.getFieldDBDataIndex("value");
    assert(dbData[index].getField().getType==Type.dbDouble);
    DBDouble valueData= (DBDouble)dbData[index];
    double value = valueData.get();</pre>

<p>The data for exampleAiLinear.aiLinear.aiRaw.value can also be located and
read via reflection as follows:</p>
<pre>    DBData[] dbData = dbRecord.getFieldDBDatas();
    int index = dbRecord.getFieldDBDataIndex("aiLinear");
    assert(dbData[index].getField().getType()==Type.pvStructure);
    DBStructure dbStructure = (DBStructure)dbData[index];
    index = dbStructure.getFieldDBDataIndex("aiRaw");
    dbData = dbStructure.getFieldDBDatas();
    assert(dbData[index].getField().getType()==Type.pvStructure);
    dbStructure = (DBStructure)dbData[index];
    index = dbStructure.getFieldDBDataIndex("value");
    dbData = dbStructure.getFieldDBDatas();
    assert(dbData[index].getField().getType==Type.dbInt);
    DBInt valueData = (DBInt)dbData[index];
    int value = valueData.get();</pre>

<p>Obviously this is not a very plesent way to access an IOC database. The
next section provides a much easier way to find the data interfaces for a
field.</p>
<hr />

<h2 style="text-align: center" id="Database5">Database Access</h2>
<hr />

<h3 id="Interface">Interface DBAccess</h3>

<p>DBAccess is the interface for accessing a record instance. A DBAccess can
be created via:</p>
<pre>    DBAccess dbAccess = iocdb.createAccess(instanceName);</pre>
Where instanceName is a Java String. For example:
<pre>    DBAccess dbAccess = iocdb.createAccess("exampleAiLinear");</pre>

<p>DBAccess provides the following methods:</p>
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    public interface DBAccess {
        DBRecord getDbRecord();
        AccessSetResult setField(String name);
        String getOtherRecord();
        String getOtherField();
        void setField(DBData dbData);
        DBData getField();
        DBData getPropertyField(Property property);
        DBData getPropertyField(String propertyName);
        void replaceField(DBData oldField, DBData newField);
    }</pre>
where
<dl>
  <dt>getDBRecord</dt>
    <dd>Returns the interface for the record instance.</dd>
  <dt>setField</dt>
    <dd>Locates a field. It returns one of the following:
      <dl>
        <dt>otherRecord</dt>
          <dd>The data is located in another record. The other record name
            can be obtained by calling getOtherRecord and the field by
            calling getOtherField.</dd>
        <dt>thisRecord</dt>
          <dd>The field is located in this record. It sets the field that
            will be used for future calls to setField(name) and for calls to
            getField and getPropertyField.</dd>
        <dt>notFound</dt>
          <dd>The field was not found.</dd>
      </dl>
    </dd>
  <dt>setField(DBData dbData)</dt>
    <dd>sets the field that will be used as the base for future calls to
      setField(name) and for calls to getField and getPropertyField.</dd>
  <dt>getField</dt>
    <dd>Returns the interface for the field located via the call to
    setField</dd>
  <dt>getPropertyField</dt>
    <dd>Returns the interface for the property field associated with the
      field located via the call to setField.</dd>
</dl>

<p>The argument to setField(name) has the form:</p>
<pre>    name.name...</pre>
Each <span style="font-family: courier;">name</span> is the name of a
property or a field. For example:
<pre>    DBAccess dbAccess = IOCDB.createAccess("exampleAiLinear");
    boolean found = dbAccess.setField("aiLinear.aiRaw.value");</pre>

<p>Locates the value field of the aiRaw structure of the aiLinear structure
in the aiLinearRecord.</p>

<p>But because the way propertys are defined, the same field can be located
via the call:</p>
<pre>      found = dbAccess.setField("rawValue");</pre>
<hr />

<h2 id="Examples">Examples of Accessing Fields via DBAccess</h2>
<hr />

<p>DBAccess is an interface that allows "device"oriented access. DBAccess
uses the structure property definitions that are designed fot this purpose.
It also is usefull for obtaining the properties associated with a field
without using the reflection interfaces.</p>

<h3 id="exampleAiE">exampleAiEmbeded</h3>
<pre>    DBAccess dbAccess = IOCDB.createAccess("exampleAiEmbeded");

    // get the value field and make sure its type is double
    assert(dbAccess.setField("value")==AccessSetResult.thisRecord);
    DBData valueData = dbAccess.getField();
    Field field = valueData.getField();
    assert(field.getType()==Type.pvDouble);
    double value = ((DBDouble)valueData).get();

    // now get the status for field value
    DBData valueStatusData = dbAccess.getPropertyField("status");
    assert(valueStatusData!=null);
    assert(field.getType()==Type.pvString);
    String status = ((DBString)valueStatusData).get();

    // now get rawData and rawData status
    assert(dbAccess.setField("rawData")==AccessSetResult.thisRecord));
    DBData rawValueData = dbAccess.getField();
    Field field = rawValueData.getField();
    assert(field.getType()==Type.pvInt);
    int rawValue = ((DBInt)rawValueData).get();
    DBData rawValueStatusData = dbAccess.getPropertyField("status");
    assert(rawValueStatusData!=null);
    assert(field.getType()==Type.pvString);
    String status = ((DBString)valueStatusData).get();</pre>

<h3 id="exampleAi">exampleAi</h3>

<p>Accessing exampleAi is exactly the same as for exampleAiEmbeded except
that the record name is different.</p>

<h3 id="examplePow">examplePowerSupplyLinked or examplePowerSupplyEmbeded</h3>

<p>The following example shows how to access device records which are created
either via links or by embeding. The example is for the linked instance but
will also work for the embeded instance. The following is an example of code
to access the power, current, and voltage.</p>
<pre>    DBAccess powerSupply = IOCDB.createAccess("examplePowerSupplyLinked")
    DBAccess powerAccess;
    DBAccess currentAccess;
    DBAcess voltageAccess;
    DBData power;
    DBData current;
    DBData voltage;
    AccessSetResult setResult;
    
    // get access to power
    setResult = powerSupply.setField("power");
    switch(setResult) {
    case notFound: throw new Exception("power not found");
    case thisRecord: 
        powerAccess = powerSupply; break;
    case otherRecord:
        powerAccess = IOCDB.createAccess(powerSupply.getOtherRecord());
        if(powerAccess==null) throw new Exception("power not found");
        setResult = powerAccess.setField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("power not found");
        break;
    }
    power = powerAccess.getField();

    // get access to current
    setResult = powerSupply.setField("current");
    switch(setResult) {
    case notFound: throw new Exception("current not found");
    case thisRecord: 
        currentAccess = powerSupply; break;
    case otherRecord:
        currentAccess = IOCDB.createAccess(powerSupply.getOtherRecord());
        if(currentAccess==null) throw new Exception("current not found");
        setResult = currentAccess.setField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("current not found");
        break;
    }
    current = current.getField();

    // get access to voltage
    setResult = powerSupply.setField("voltage");
    switch(setResult) {
    case notFound: throw new Exception("voltage not found");
    case thisRecord: 
        voltageAccess = powerSupply; break;
    case otherRecord:
        voltageAccess = IOCDB.createAccess(powerSupply.getOtherRecord());
        if(voltageAccess==null) throw new Exception("voltage not found");
        setResult = voltageAccess.setField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("voltage not found");
        break;
    }
    voltage = voltage.getField();

    // can now get data as well as properties for power, current, voltage</pre>

<p>NOTE: The example is not correct because of calls like</p>
<pre>    DBAccess access = IOCDB.createAccess(powerSupply.getOtherRecord());</pre>

<p>This assumes the records are located in the same IOC as record
examplePowerSupplyLinked. In a real example channel access, not database
access, must be used. However channel access is not yet defined.</p>

<h2 style="text-align: center;text-align: center;" id="License"><a
name="LicenseAgreement"></a>License Agreement</h2>
<pre>Copyright (c) 2006 All rights reserved 
The University of Chicago, as Operator of Argonne National Laboratory,
    (UofC) Chicago Ilinois, USA,
Deutsches Elektronen-Synchroton, Member of the Helmholtz Association,
    (DESY), HAMBURG, GERMANY,
BERLINER SPEICHERRING GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H.
    (BESSY), BERLIN, GERMANY.

EPICS JavaIOC is distributed subject to the following license conditions:

 SOFTWARE LICENSE AGREEMENT
 Software: EPICS JavaIOC
 Versions: All

 1. The "Software", below, refers to EPICS JavaIOC (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.


________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
