<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br
/>
2008.08.19</h1>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<p>This document has three parts:</p>
<ul>
  <li>Part I is a brief description of the javaIOC.</li>
  <li>Part II describes the javaIOC Data Model. The model 1) supports general
    purpose tools and 2) is used by the javaIOC support code.</li>
  <li>Part III is a description of the Database Definitions that come with
    javaIOC.</li>
</ul>

<p>CONTENTS</p>
<hr />
<hr />

<h2 style="text-align: center">Part I: javaIOC - Brief Description</h2>
<hr />
<hr />

<p>Part I describes the javaIOC. Detailed descriptions of the javaIOC
packages are provided with each package.</p>
<hr />

<h3 style="text-align: center">Overview Of Part I</h3>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node
that controls and/or monitors a collection of devices. An IOC contains a
memory resident real time database. The real time database has a set of
"smart" records. Each record is an instance on a record of a particular
type.</p>

<p>JavaIOC is a JAVA implementation of an IOC. It has many similarities to a
EPICS V3 ( the 3.13 and 3.14 releases of EPICS base) but extends the data
types to support structures and arrays. This document assumes that the reader
is familiar with EPICS V3.</p>

<p><span style="font-weight:bold;">WARNING</span>: No hardware support is
supplied with the javaIOC itself. It is, however, ready for softIOC
applications. Also it needs more testing.</p>

<h4>Getting Started</h4>

<p>JavaIOC is developed as an eclipse project. The following assumes that you
have eclipse installed and have imported JavaIOC into a project named
"javaIOC".</p>

<p>In order to use the examples in the javaIOC, the environment variable
JAVAIOC must be defined so that it references the javaIOC project. For
example on my linux system I define</p>
<pre>export JAVAIOC=${HOME}/workspace/javaIOC</pre>

<p>In package default ( <span
style="font-family: courier;">javaIOC/src</span> ) there is a Java main
program, <span style="font-family: courier;">XMLToDatabase</span>, that:</p>
<ul>
  <li>Reads Database Definition and Record Instance files</li>
  <li>Dumps the resulting DBD and DB definitions</li>
  <li>Starts servers.</li>
  <li>Starts an ioc.</li>
  <li>Invokes swtshell, which is a GUI shell for a running JavaIOC.</li>
</ul>

<p>Run <span style="font-family: courier;">javaIOC/src/XMLToDatabase</span>
as an <span style="font-weight:bold;">eclipse SWT application.</span></p>

<p>The arguments to XMLToDatabase can be any combination of:</p>
<ul>
  <li>-dbd <br />
    followed by filenames of database definition files</li>
  <li>-db <br />
    followed by filenames of record instance files <br />
  </li>
  <li>-dumpDBD<br />
    dump all the database definitions read so far</li>
  <li>-dumpDB<br />
    dump all the record instances read so far</li>
  <li>-server 
    <p>followed by a filenames. Each field is a list of servers to start.</p>
  </li>
  <li>-startIOC<br />
    Starts a javaIOC.</li>
  <li>-swtshell<br />
    Start swtshell.</li>
</ul>

<p>For example:</p>
<pre>    -dbd "example/exampleDBD.xml" -db "example/exampleDB.xml" -dumpDBD -dumpDB</pre>

<p>Reads a set of database definition and record instance files and then
dumps the database definitions and record instances.</p>

<p>As a beginning example specify the arguments as:</p>
<pre>    -dbd example/exampleDBD.xml -db example/exampleDB.xml \
    -server server/beforeStartIOC.txt \
    -startIOC \
    -server server/afterStartIOC.txt \
    -swtshell</pre>

<p>This:</p>
<ul>
  <li>Loads some DBD and DB files.</li>
  <li>Starts a ChannelAccess Client that communicates with V3 IOCs.</li>
  <li>Starts the javaIOC</li>
  <li>starts a Channel Access server for V3 clients.</li>
  <li>Starts the swtshell.</li>
</ul>

<p>Just try it</p>
<ul>
  <li>click the monitor button and a new window appears 
    <ul>
      <li>click the selectLocalChannel button and select "counter"
        <p>In the pvname text window counter appears. Add ".value". Then
        click the enter key</p>
      </li>
      <li>click property button. a window offering choices appears 
        <p>select alarm and timeStamp choices and click the done button</p>
      </li>
      <li>click startMonitor button 
        <p>after awhile click "stopMonitor" and "disconnect" buttons</p>
      </li>
    </ul>
  </li>
  <li>on swtshell window click introspectDatabase button and a new window
    appears 
    <ul>
      <li>The menu bar at the top provides access to Database Definitions for
        menu, structure, recordType, create, and support. 
        <ul>
          <li>select and look at the various definitions.</li>
        </ul>
      </li>
      <li>the recordName row provides access to record instances. Click the
        select button and select record "counter" and then click dump. 
        <ul>
          <li>The current value of all fields in record ai are shown</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>You are on your own.</li>
</ul>

<p>The remainder of this document gives an overview of javaIOC:</p>
<ul>
  <li>The xml syntax for database definitions and record instances.</li>
  <li>Java interfaces for accessing records and fields.</li>
  <li>Record processing<br />
    A javaIOC has a "smart" real time database. A record instance can be
    Records have associated support code. In addition each field can
    optionally have support. </li>
  <li>Example database definitions and record instances.</li>
</ul>

<h4>Status and Remaining Tasks</h4>

<p>The javaIOC provides database definitions (javaIOC/dbd) and support for
creating a wide variety on record types. This should provided most of the
functionality provided by EPICS V3 base.</p>

<p>The javaIOC has both client and server support for V3 Channel Access. This
means that an existing EPICS channel accesss client can access any primitive
field (or an array of primitives) of a javaIOC record.</p>

<p>The above means that the javaIOC is now ready for use at least as a soft
IOC.</p>

<p>The javaIOC implements portDriver which provides the same functionality as
the asynDriver module for EPICS V3. However no hardware drivers are
implemented.</p>

<p>The following JavaIOC components are desirable.</p>
<ul>
  <li>JavaIOC Remote Channel Access<br />
    A remote ChannelAccess that fully supports the javaIOC structured
    data.This requires both client and server. </li>
  <li>Message Server<br />
    JavaIOC interfaces provide methods for sending messages to requesters.
    Currently the requesters just write the messages to System.out or to a
    swtshell text window. A message server facility similar to the V3
    logMessage facility needs to be implemented. Once in place it will be
    easy to modify the existing code to use the message server.</li>
  <li>portDriver<br />
    Hardware drivers and STREAMS.</li>
</ul>

<p>Additional components are also desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a JavaIOC.</li>
  <li>Channel Access Clients that implement the JavaIOC Channel Access
    Semantics.</li>
  <li>A javaIOC replacement for calcPerform that comes with EPICS V3 base and
    for the sCalc and arrayCalc that come with synAPPS.</li>
  <li>etc, etc.</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>
<hr />

<h3 style="text-align: center">Package Summary</h3>
<hr />

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>

<h4>default - javaIOC/src</h4>

<p>This package contains:</p>
<ul>
  <li>The overview package.html document you are now reading.</li>
  <li>XMLToDatabase, which is the example program which was discussed in the
    getting started section.</li>
</ul>

<h4>
<a href = "org/epics/ioc/swtshell/package-summary.html">
org.epics.ioc.swtshell</a>
</h4>

<p>This is a GUI shell for an ioc. It is implemented via the Standard Widget
Toolkit. Getting Started explains how to invoke it. See the package overview
for a description of swtshell.</p>

<h4>javaIOC/dbd</h4>

<p>This directory and it's sub-directories, provides database definition
files for the recordTypes and support supplied with the javaIOC.
part III describes these files.</p>

<h4>javaIOC/example</h4>

<p>This directory contains example xml files..</p>

<h4>
<a href = "org/epics/ioc/pv/package-summary.html">
org.epics.ioc.pv</a>
</h4>

<p>A JavaIOC has a Process Variable (PV) Database, which is a "smart" real
time database. It is smart because each record instance has processing
code.</p>

<p>This package defines definitions for the data that javaIOC supports. This
is a combination of data and reflection interfaces. Read the package overview
for details. A brief description appears below.</p>

<h4>javaIOC/test</h4>
<p>This directory contains sub-directorys, each of which tests some
part of the JavaIOC code. They are also a good example of how to create
record instances.</p>

<h4>
<a href = "org/epics/ioc/dbd/package-summary.html">
org.epics.ioc.dbd</a>
</h4>
<p>This package implements the DBD (Database Definition Database).
A DBD defines structures, record types, support factorys, and create factorys.
</p>
<h4>
<a href = "org/epics/ioc/db/package-summary.html">
org.epics.ioc.db</a>
</h4>

<p>This package provides a factory for creating javaIOC databases. It defines
a set data interfaces that contain references to PV Data and provides methods
so that:</p>
<ul>
  <li>Support can be attached to records and fields.</li>
  <li>Record instances can be locked.</li>
  <li>Fields of records can be monitored for changes.</li>
</ul>

<p>This package implements an XML parser that creates record instances and
puts them into an IOC Database (IOCDB).</p>

<h4>
<a href = "org/epics/ioc/support/package-summary.html">
org.epics.ioc.support</a>
</h4>

<p>This package provides the framework for processing IOC database records.
The subpackages of this package provide support that uses the framework.
Each record instance must have associated support and each field of a record
instance can optionally have support.
</p>

<h4>
<a href = "org/epics/ioc/support/basic/package-summary.html">
org.epics.ioc.support.basic</a>
</h4>
<p>This provides basic support such as noop, generic, etc.</p>
<h4>
<a href = "org/epics/ioc/support/alarm/package-summary.html">
org.epics.ioc.support.alarm</a>
</h4>
<p>This provides support for alarms.</p>
<h4>
<a href = "org/epics/ioc/support/ca/package-summary.html">
org.epics.ioc.support.ca</a>
</h4>
<p>This provides for channel access links, i.e. it allows records
to get/put/monitor data in other records.</p>
<h4>
<a href = "org/epics/ioc/support/calc/package-summary.html">
org.epics.ioc.support.calc</a>
</h4>
<p>The provides support for calculations. A calcaulator is support that
produces a result that is assigned to a value field.</p>
<h4>
<a href = "org/epics/ioc/support/device/package-summary.html">
org.epics.ioc.support.device</a>
</h4>
<p>This contains examples of support for "device" abstractions.</p>


<h4>
<a href = "org/epics/ioc/ca/package-summary.html">
org.epics.ioc.ca</a>
</h4>

<p>This package is Channel Access for a javaIOC. Currently only local access
is implemented.</p>

<h4>
<a href = "org/epics/ioc/caV3/package-summary.html">
org.epics.ioc.caV3</a>
</h4>

<p>This package is Channel Access V3, e.g. channel access Version 3. Server
support has been implemented by Matej Sekoranja (COSYLAB). Client support is
under development. Both thew client and server require JCA/CAJ.</p>

<h4>
<a href = "org/epics/ioc/util/package-summary.html">
org.epics.ioc.util</a>
</h4>
This package provides utility code for a javaIOC: 
<dl>
  <dt>Message Support</dt>
    <dd>This is an interface for passing messages to a requester of many
      services.</dd>
  <dt>Time Stamp support</dt>
    <dd>Support is provided to make it easier to work with time stamps.</dd>
  <dt>Scan Field Support</dt>
    <dd>Support that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
  <dt>IOCXML Reader</dt>
    <dd>Support for reading XML Database Definition and Record Instance
      files. It is an abstraction above Java SAX (Simple API for XML). It
      implements macro substitution and include.</dd>
</dl>


<h4>
<a href = "org/epics/ioc/create/package-summary.html">
org.epics.ioc.create</a>
</h4>

<p>This package defines Create, which is an interface that is called if a
field is declared to have a createName. Support that implements Create
normally replaces the data interface for the field at the time the field is
created.</p>

<h4>
<a href = "org/epics/ioc/pdrv/package-summary.html">
org.epics.ioc.pdrv</a>
</h4>

<p>These packages implement portDriver, which is support for accessing and
controlling hardware. It is modeled after the EPICS asynDriver and thus
provides support for synchronous and asynchronous devices. Each device is
accessed via a port. Each port provides access to one or more devices.</p>
<h4>
<a href = "org/epics/ioc/pdrv/interfaces/package-summary.html">
org.epics.ioc.pdrv.interfaces</a>
</h4>
<p>This directory defines the interfaces for portDriver.</p>
<h4>
<a href = "org/epics/ioc/pdrv/testDriver/package-summary.html">
org.epics.ioc.pdrv.testDriver</a>
</h4>
<p>This directory contains test port drivers.</p>
<hr />

<h3 style="text-align: center">Database Syntax</h3>
<hr />

<p>The syntax for both Database Definitions (menu, structure, recordType,
etc) and Record Instance Definitions is XML based. In addition XML based
macro substitution and include is supported. Package org.epics.ioc.util
provides XML support with the following features:</p>
<ul>
  <li>Include and Macro Substitution are handled automatically.<br />
    NOTE: include and substitute are reserved words.</li>
  <li>xml namespaces are not support.</li>
  <li>Although the implementation uses SAX, the user code only implements
    IOCXMLListener and uses IOCXMLReader.</li>
  <li>The support is used by XMLToDBDFactory and by XMLToIOCDBFactory and can
    be used by other code.</li>
</ul>

<h4 style="text-align: center">Include and Macro Substitution</h4>

<h5>Syntax</h5>

<p>An xml file can include other xml files. All files must be valid xml files
and must have the same root element name. An include statement has the
format:</p>
<pre>&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h5>Example</h5>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "double"&gt;
    &lt;input structureName = "linearConvertInput" &gt;
        &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;${pvname}&lt;/pvname&gt;
            &lt;wait&gt;true&lt;/wait&gt;
        &lt;/input&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/input&gt;
    &lt;doubleDisplayCharacteristics&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/doubleDisplayCharacteristics&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/pvAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h4 style="text-align: center">Database Definition</h4>

<p>This section provides a brief description of database definitions. See
package org.epics.ioc.dbd for complete details.</p>

<h5>Basic Syntax</h5>

<p>Database definitions consist of the following definition types: <span
style="font-family: courier;"></span> <span
style="font-family: courier;">structure</span>,create, <span
style="font-family: courier;">recordType.</span><span
style="font-family: courier;">create</span>, and <span
style="font-family: courier;">support</span></p>

<p>An example structure definition is:</p>
<pre>    &lt;structure name = "doubleLimit"&gt;
        &lt;field name = "low" type = "double" /&gt;
        &lt;field name = "high" type = "double" /&gt;
    &lt;/structure&gt;</pre>

<p>An example recordType definition is:</p>
<pre>&lt;recordType name = "example" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure" structureName = "alarm"
      supportName = "alarm" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "doubleAlarm" supportName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "display" --&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "doubleHistory" supportName = "history" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/recordType&gt;</pre>

<p>A recordType is just the top level structure for a record instance.</p>

<h5>Field Syntax</h5>

<p>Both structure and recordType definitions define a set of field
definitions. A field definition has the format:</p>
<pre>    &lt;field name = "value" type = "type"  ...&gt;</pre>
where supportName is optional and "..." represents other attributes. The
complete set of attributes are: 
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>the field name. This must be defined.</dd>
  <dt style="font-family: courier;">type</dt>
    <dd>The field type which must be defined and must be one of:<br />
      boolean,byte,short,int,long,float,double,string,enum,menu,link,structure,array</dd>
  <dt style="font-family: courier;">createName</dt>
    <dd>The name of a create. A create is called at the time a field is being
      created. Normally it will replave the default data implementation.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the field. A matching support definition must
      be available during IOC initialization.</dd>
  <dt style="font-family: courier;">structureName</dt>
    <dd>can be given if the type is structure. If not given the structure
      must be specified when a field instance is created.</dd>
  <dt style="font-family: courier;">elementType</dt>
    <dd>must be specified if the type is array. It can be any of the
      supported types.</dd>
</dl>

<p>Additional name/value pairs will be saved by the parser as PVAttributes
for the field. The following are recognized by the javaIOC database.</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the field is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
</dl>

<h5>Example Structure, recordType, create, and Support Definitions</h5>

<p>The second part of this document provides the definition supported by the
javaIOC. Look at it for example.</p>

<h4 style="text-align: center">Record Instance Definition</h4>

<h5>Syntax</h5>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p>If the recordSupport name is not specified then the record support
specified in the recordType definition is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<h5>Example</h5>
<pre>&lt;record name = "double01" type = "double"&gt;
    &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
        &lt;pvname&gt;counterCounter&lt;/pvname&gt;
        &lt;process&gt;false&lt;/process&gt;
    &lt;/input&gt;
    &lt;valueAlarm structureName = "doubleAlarm"&gt;
          &lt;active&gt;true&lt;/active&gt;
          &lt;interval&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;2.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;major&lt;/choice&gt;&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;4.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;minor&lt;/choice&gt;&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;6.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;none&lt;/choice&gt;&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;8.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;minor&lt;/choice&gt;&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;10.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;major&lt;/choice&gt;&lt;/severity&gt;
              &lt;/element&gt;
          &lt;/interval&gt;
          &lt;outOfRange&gt;&lt;choice&gt;invalid&lt;/choice&gt;&lt;/outOfRange&gt;
          &lt;hystersis&gt;0.1&lt;/hystersis&gt;
    &lt;/valueAlarm&gt;
    &lt;display structureName = "display" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/displayCharacteristics&gt;

&lt;/record&gt;</pre>
<hr />

<h3 style="text-align: center">PVData</h3>
<hr />

<p>JavaIOC data is stored in a PVData (Process Variable) Database, which is a
collection of record instances. A record instance is a structured set of
fields. A JavaIOC implements interfaces for accessing fields of database
records. The interfaces are a combination of reflection ( what is a field)
and data (what does a field contain) interfaces. Each field has a type as
defined in the next section. See the package overview for org.epics.ioc.pv
for more information. This section just gives a brief summary.</p>

<h4>Field Types</h4>

<p>A Java enum defines the supported types.</p>
<pre>    public enum Type {
        pvBoolean,
        pvByte,
        pvShort,
        pvInt,
        pvLong,
        pvFloat,
        pvDouble,
        pvString,
        pvStructure,
        pvArray;
    }</pre>

<h4>PVData Reflection</h4>

<p>The reflection interfaces for PVData are:</p>
<pre>    
    public interface FieldAttribute {
        void setAttributes(Map&lt;String,String&gt; attributes,String[] exclude);
        String setAttribute(String key,String value);
        Map&lt;String,String&gt; getAttributes();
        String getAttribute(String key);
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<h4>PVData Interfaces</h4>

<p>The following describe the interfaces for accessing the data a field
contains.</p>

<p>The interfaces for accessing data are:</p>
<pre>    interface PVField {
         String getFullFieldName();
         Field getField(); // get the reflection interface
         PVField getParent();
         PVRecord getPVRecord();
         PVField getSubField(String fieldName);
         PVField findProperty(String fieldName);
         PVField findPropertyViaParent(String propertyName);
         String[] getPropertyNames();
         void replacePVField(PVField newPVField);
         String getSupportName();
         String setSupportName(String name);
         void asynAccessListenerAdd(AsynAccessListener asynAccessListener);
         void asynAccessListenerRemove(AsynAccessListener asynAccessListener);
         void asynAccessCallListeners(boolean begin);
         boolean asynModifyStart(Object asynModifier);
         void asynModifyEnd(Object asynModifier);
         boolean isAsynModifyActive();
         String toString();
         String toString(int indentLevel);
    }
    interface PVBoolean extends PVField{
        boolean get();
        void put(boolean value);
    }
    //   similar interfaces for other primitve types
    interface PVString extends PVField{
        String get();
        void put(String value);
    }
    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getFieldPVFields();
    }
    interface PVArray extends PVField{
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
    }
    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray{
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }
    // ... for arrays of other pv Types
    public interface PVRecord extends PVStructure {
        String getRecordName();
        void message(String message, MessageType messageType);
    }</pre>

<h4>Example: Database Access via Reflection</h4>
An interface IOCDB provides a method that locates the interface for a record
instance. For example, to locate the ai record the call is: 
<pre>    DBRecord dbRecord = iocdb.findRecord("ai");</pre>

<p>Starting with this the data in the value field can be read as follows:</p>
<pre>    PVRecord pvRecord = dbRecord.getPVRecord();
    PVField[] pvField = pvRecord.getPVStructure().getFieldPVFields();
    Structure structure = (Structure)pvRecord.getField();
    int index = structure.getFieldIndex("value");
    assert(pvField[index].getField().getType==Type.dbDouble);
    PVDouble valueData= (PVDouble)pvField[index];
    double value = valueData.get();</pre>

<h3 style="text-align: center">DBData</h3>

<p>See package org.epics.ioc.db for details about the interfaces shown in
this section, which just shows the interfaces.</p>

<p>The DBData interfaces provide:</p>
<ul>
  <li>Access to the PV interfaces</li>
  <li>Access to Support interfaces</li>
  <li>Record locking</li>
  <li>Record monitoring</li>
</ul>

<p>The interfaces are:</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Create getCreate();
        void setCreate(Create create);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        void addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        String toString();
        String toString(int indentLevel);
    }

    public interface DBListener {
        void dataPut(DBField dbField);
        void supportNamePut(DBField dbField);
        void dataPut(DBField requested,DBField dbField);
        void supportNamePut(DBField requested,DBField dbField);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }

    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        void replacePVStructure();
        DBField[] getFieldDBFields();
        void beginPut();
        void endPut();
    }

    public interface DBArray extends DBField{
        PVArray getPVArray();PVArray getPVArray();
    }

    public interface DBStructureArray extends DBArray{
        PVStructureArray getPVStructureArray();
        DBStructure[] getElementDBStructures();
    }

    public interface DBArrayArray extends DBArray{
        PVArrayArray getPVArrayArray();
        DBArray[] getElementDBArrays();
    }

    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void addListenerSource(BaseDBField dbField);
    }</pre>
<hr />

<h3 style="text-align: center">Channel Access</h3>
<hr />

<p>Package org.epics.ioc.ca describes Channel Access for a JavaIOC. See it
for details. Some features are:</p>
<ul>
  <li>Local Channel Access is implemented.</li>
  <li>A V3 Channel Access server is available. Thus Channel Access clients
    can access a javaIOC database.</li>
  <li>V3 Channel Access client code is implemented. This allows the javaIOC
    to communicate with an EPICS IOC.</li>
  <li>Link support is implemented. 
    <ul>
      <li>Get, Put, and PutGet are all supported. Each can optionally process
        the record. Each can access a group of fields in a record instance.
        Structure and Array fields can be accessed. Each provides an option
        to process the record</li>
      <li>MonitorNotify is supported. In this case the client is notified of
        changes but must issue a get to retrieve the data</li>
      <li>Monitor is supported. A monitor includes the data which has
        changed. Any group of fields within a record instance can be
        monitored. Structure and Array fields can be monitored including an
        entire record instance. For appropriate field types onPut, onChange,
        absoluteChange, and percentChange are all supported.</li>
    </ul>
  </li>
</ul>
<hr />

<h3 style="text-align: center">Record Processing</h3>
<hr />

<p>Package org.epics.ioc.process describes and implements code directly
related to record processing. The package overview has a section "Record
Processing: Theory of Operation" that provides a description of record
processing.</p>

<p>Package org.epics.ioc.support describes and implements all the support
code that comes with javaIOC. Applications can, of course, add additional
support.</p>

<p>When a set of javaIOC record instances are created and initialized, a
recordProcess object is created for each record instance. The primary
function of recordProcess is to call record support code, which may in turn
call field support code. RecordProcess has methods for the following: </p>
<ul>
  <li>Lifetime Management: initialize, start, stop, uninitialize<br />
    recordProcess just calls the support methods with the same name.</li>
  <li>Processing</li>
  <li>timeStamp support:<br />
    Get/Set methods for a timeStamp.</li>
  <li>trace<br />
    A record instance can generate diagnostic message while processing.</li>
</ul>

<p>The primary purpose of recordProcess is to be the "gatekeeper" for record
processing. Only one object can process a record. Methods are available to
request being the record processor and methods involved with processing. A
process can be synchronous or asynchronous. An asynchronous operation is an
operation that blocks, e.g. file I/O. recordProcess provides methods that
allow asynchronous support but that only lock a record instance when blocking
can not occur. </p>

<p>Whenever any field of a record is being accessed or whenever anything is
done that can modify the state of a record, the record must be locked. In
most cases recordProcess takes care of locking and unlocking.</p>

<p>Each record instance must have associated support and each field of a
record can optionally have support.</p>

<p>Support must implement interface Support:</p>

<p></p>
<pre>    public interface Support extends Requester {
        SupportState getSupportState();
        DBField getDBField();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void allSupportStarted();
        void process(SupportProcessRequester supportProcessRequester);
    }</pre>

<p>where</p>
<dl>
  <dt>Requestor, getSupportState, getDBField</dt>
    <dd>See package org.epics.ioc.support for details.</dd>
  <dt>initialize</dt>
    <dd>Initialization related to the record itself. Support must not connect
      to other records or to hardware.</dd>
  <dt>start</dt>
    <dd>Support can connect to other records or top hardware.</dd>
  <dt>stop</dt>
    <dd>Disconnect from other records or hardware.</dd>
  <dt>uninitialize</dt>
    <dd>Remove any connection to the record.</dd>
  <dt>process</dt>
    <dd>Do whatever the support should do for record processing.</dd>
</dl>

<p>The primary purpose of a support module is to help with record processing.
Most support does something with a "value" field. For example the support for
a channel access input link will get a value and put it in the "value"
field.</p>

<p>Typical support code does the following core functions:</p>
<ul>
  <li>initialize<br />
    Determine the "value" field. Most support modules look for a field named
    "value".<br />
    Many support modules also provide support for other fields, which are
    identified by name. For example if a support module supports alarms it
    looks for a field "alarm".</li>
  <li>process<br />
    This is the core of record processing. What happens is up to the support
    module. For example it can interact with hardware. The channel access
    support reads or write other records.</li>
</ul>

<p>There is no separate concept of record support. Record support just
happens to be the support called by recordProcess, i.e. it is the highest
level support for a record instance. The record support that comes with
javaIOC is also designed to also be structure support, i.e. support for a
structure field embeded within a recordType.</p>

<p>Support code should not be aware of recordTypes and in most cases specific
structure types. A support modules works with some set of fields that it
locates at initialization. While processing it uses the PV and DB interfaces
to access the fields. Thus support is generic. If a recordType or structure
has the fields required by the support then the support can be used to help
support that recordType or structure.</p>

<p>An extreme example is generic support. This is used for most of the
recordTypes that come with the javaIOC. It can also be used with the
structure associated with each recordType. All that it does is look at all
the fields in the recordType or structure that is passed to it's initalizer.
For each field that has support it calls the support. The supports are called
in the order the fields are defined in the recordType or structure. It waits
for each support to finish before the next support is called. </p>
<hr />

<h3 style="text-align: center">Database Examples</h3>
<hr />

<p>javaIOC/dbd and it's subdirectories has the database definitions for all
the recordTypes and support supplied with thew javaIOC. Applications can add
new database definitions and support. This section just gives a few example
of using these database definitions. The complete set of definitions are
described in the second part of this document.</p>

<h4 style="text-align: center">Database Definitions</h4>

<p>The example uses the following database definitions:</p>
<dl>
  <dt>doubleCommon</dt>
    <dd>Defines fields common to structure "double" and recordType
    "double"</dd>
  <dt>doubleRecord</dt>
    <dd>Defines structure "double" and recordType "double"</dd>
  <dt>powerSupplyCommon</dt>
    <dd>Defines fields common to structure "powerSupply" and recordType
      "powerSupply"</dd>
  <dt>powerSupplyRecord</dt>
    <dd>Defines structure "powerSupply" and recordType "powerSupply"</dd>
</dl>

<h5>doubleCommon</h5>

<p>The following defines the fields that are common to both recordType double
and structure double.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5>doubleRecord</h5>

<p>The following defines both a recordType and a structure named "double". It
also defines a support named "doubleRecord". The same support is the default
support for both the structure and for the recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "double" supportName = "generic" &gt;
  &lt;include href = "doubleCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "doubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;/DBDefinition&gt;</pre>

<h5>powerSupplyCommon</h5>

<p>The following defines both a recordType and a structure named "double". It
also defines a support named "doubleRecord". The same support is the default
support for both the structure and for the recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;support name = "powerSupplyCurrent"
   factoryName = "org.epics.ioc.support.PowerSupplyFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5>powerSupplyRecord</h5>

<p>The following defines the fields that are common to both recordType double
and structure double.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "power" type = "structure" structureName = "double" /&gt;
  &lt;field name = "voltage" type = "structure" structureName = "double" /&gt;
  &lt;field name = "current" type = "structure" structureName = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 style="text-align: center">Support Implementation</h4>

<p>The example uses the following support</p>
<ul>
  <li>generic</li>
</ul>
<ul>
  <li>powerSupply</li>
</ul>
<dl>
    <dd>Requires fields power, voltage, and current. If a field named
      "voltageInput" has support it is called. If a field names
      "currentOutput" has support it is called. When it processes it computes
      current from power and voltage.</dd>
</dl>
<ul>
  <li>linearConvertInput</li>
</ul>
<dl>
    <dd>Implements linear conversion from a rawValue to engineering
    units.</dd>
</dl>
<ul>
  <li>linearConvertOutput</li>
</ul>
<dl>
    <dd>Implements linear conversion from engineering units to a
    rawValue.</dd>
</dl>
<ul>
  <li>CALink</li>
</ul>
<dl>
    <dd>JaveIOC implements channel access links between records.</dd>
</dl>
<ul>
  <li>portDriver Support</li>
</ul>
<dl>
    <dd>portDriver provides access to hardware.</dd>
</dl>

<h4 style="text-align: center">Record Instance Examples</h4>

<h5>doubleInput</h5>

<p>The following creates a record instance of type double. It is an input
record because input is initialized to a Channel Access inputLink.</p>
<pre>&lt;record name = "doubleInput" type = "double"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
&lt;/record&gt;</pre>

<h5>doubleOutput</h5>

<p>The following creates a record instance of type double. It is an output
record because output is initialized to a Channel Access outputLink.</p>
<pre>&lt;record name = "doubleOutput" type = "double"&gt;
    &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h5>ai</h5>

<p>The following creates an instance of an aiRecord. The raw ADC value is
read via portDriver support and converted via linearConvertInput support.</p>
<pre>&lt;record name = "ai" type = "double" &gt;
    &lt;input structureName = "linearConvertInput"&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;input supportName = "pdrvInt32Input" structureName = "pdrvSupport"&gt;
            &lt;portName&gt;syncInt32Driver&lt;/portName&gt;
            &lt;addr&gt;0&lt;/addr&gt;
            &lt;timeout&gt;.2&lt;/timeout&gt;
        &lt;/input&gt;
    &lt;/input&gt;
    &lt;valueAlarm structureName = "doubleAlarm"&gt;
          &lt;active&gt;true&lt;/active&gt;
          &lt;interval&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;2.0&lt;/value&gt;
                  &lt;severity&gt;major&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;4.0&lt;/value&gt;
                  &lt;severity&gt;minor&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;6.0&lt;/value&gt;
                  &lt;severity&gt;none&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;8.0&lt;/value&gt;
                  &lt;severity&gt;minor&lt;/severity&gt;
              &lt;/element&gt;
              &lt;element structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;10.0&lt;/value&gt;
                  &lt;severity&gt;major&lt;/severity&gt;
              &lt;/element&gt;
          &lt;/interval&gt;
          &lt;outOfRange&gt;invalid&lt;/outOfRange&gt;
          &lt;hystersis&gt;0.1&lt;/hystersis&gt;
    &lt;/valueAlarm&gt;
    &lt;displayCharacteristics structureName = "doubleDisplayCharacteristics" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/displayCharacteristics&gt;

&lt;/record&gt;</pre>

<h5>ao</h5>

<p>The following creates an instance of an aoRecord. The value is converted
via linearConvertOutput support to a rawValue which is written via portDriver
support.</p>
<pre>&lt;record name = "ao" type = "double" &gt;
    &lt;output structureName = "linearConvertOutput"&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;output supportName = "pdrvInt32Output" structureName = "pdrvSupport"&gt;
            &lt;portName&gt;syncInt32Driver&lt;/portName&gt;
            &lt;addr&gt;0&lt;/addr&gt;
            &lt;timeout&gt;.2&lt;/timeout&gt;
        &lt;/output&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h5>psSimple</h5>

<p>The following creates a powerSupply instance that does no input or output.
The voltage and power must be written via channel access.</p>
<pre>&lt;record name = "psSimple" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;&lt;value&gt;10.0&lt;/value&gt;&lt;/voltage&gt;
    &lt;current&gt;
        &lt;input supportName = "powerSupplyCurrent" /&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>

<h5>psLinked</h5>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via channel access.</p>
<pre>&lt;record name = "psLinked" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;
        &lt;input  supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;voltage&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/input&gt;
    &lt;/voltage&gt;
    &lt;current&gt;
       &lt;input supportName = "powerSupplyCurrent" /&gt;
       &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
          &lt;pvname&gt;current&lt;/pvname&gt;
          &lt;process&gt;true&lt;/process&gt;
       &lt;/output&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>

<h5>psEmbeded</h5>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via embeded support.</p>
<pre>&lt;record name = "psEmbeded" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;
        &lt;input structureName = "linearConvertInput"&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
                    &lt;pvname&gt;adcVoltageEmbeded&lt;/pvname&gt;
                    &lt;process&gt;false&lt;/process&gt;
            &lt;/input&gt;
        &lt;/input&gt;
    &lt;/voltage&gt;
    &lt;current&gt;
        &lt;alarm structureName = "alarm" /&gt;
        &lt;input supportName = "powerSupplyCurrent" /&gt;
        &lt;output structureName = "linearConvertOutput"&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
                &lt;pvname&gt;dacCurrentEmbeded&lt;/pvname&gt;
                &lt;process&gt;true&lt;/process&gt;
            &lt;/output&gt;
        &lt;/output&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>
<hr />
<hr />

<h2 style="text-align: center">Part II: javaIOC Data Model</h2>
<hr />
<hr />
<hr />

<h3 style="text-align: center">Summary</h3>
<hr />

<p>The Data Model supports general purpose client tools. A set of structures
are defined that support the data model. A recordType supports the data model
if it follows a few simple guidelines.</p>

<p>The model can briefly be described as follows: Clients access fields in a
structure. A field meant for general purpose clients is considered a property
and the field name is the property name. The structure normally has a field
named "value". It is usually a data field, i.e. a scalar type or an array
with the elementType being scalar. All other fields of the structure support
the value. Typical property fields are timeStamp, alarm, display, control,
and history.</p>
<hr />

<h3 style="text-align: center">JavaIOC Data Model</h3>
<hr />

<h4>Basic Concept</h4>

<p>A javaIOC structure follows the javaIOC Data Model if it has a set of
fields that have names and types that support the data model. It can have
additional fields, that can also be considered properties. The following
field names have special meaning, i.e. are properties for general purpose
clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients expect
      this property. All other fields in the structure support or describe
      the value field. The type can any supported type but is usually one of
      the following: 
      <dl>
        <dt>scalar</dt>
          <dd>One of boolean, byte, short, int, long, float, double, or
          string</dd>
        <dt>scalar array</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index, choice, and
            choices. index is an int that selects a choice. choice is the
            currently selected choice. choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients
            and support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      javaIOC structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>A history structure as described below. It provides a history buffer
      for the value field.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition the javaIOC structure can have additional fields that support
the value field but are not recognized by most general purpose client tools.
Typical examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
      value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link.
      It can write a value to hardware. Etc.</dd>
</dl>

<p>The model allows for device records. A device record has fields that are
structures that support the javaIOC data model. For example a powerSupport
record can have fields power, voltage, current that each support the javaIOC
data model. </p>

<h4>structure null</h4>

<p>A null structure, by definition, is a structure that has no fields and no
support. It allows general purpose structures and record types to be defined.
For example:</p>
<pre>&lt;structure name = "example" &gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;</pre>

<p>In the above definition Al fields except value are by default a null
structure. If a record instance does not override the default than code must
act as if the field does not exist. If a record instance does override the
field than it must replace the structure with a structure that supports the
data model.</p>

<h4>getPropety</h4>

<p>Interface PVField has two methods that make it easy to locate fields of
interest:</p>
<pre>     PVField PVField.getProperty(String fieldName);
     PVField[] PVField.getPropertys;</pre>

<p>where</p>
<dl>
  <dt>getProperty</dt>
    <dd>Locates a "property" associated with the PVField.</dd>
  <dt>getPropertys</dt>
    <dd>PVField is a value field than the value field itself will not be in
      the PVField[].</dd>
</dl>

<p>getProperty locates a field relative to the PVField. It can search down
the structure hierarchy and handles value and timeStamp as a special case.
getProperty does the following:</p>
<ul>
  <li>The fieldName is of the form item.item... where item is a "name" or a
    "name[index]". (Note multiple levels of index are allowed)</li>
  <li>getPropertry locates each item starting from the left. If any item is
    not found it returns null. It it finds all inems it returns the interface
    to the last item. </li>
  <li>For each item it locates name as follows: 
    <ul>
      <li>If the current item is a field is named "value" the current item
        becomes the parent of value..</li>
      <li>If the current item is a structure and the structure has a field
        named "name" and the field is anything except a null structure it is
        selected</li>
      <li>If a field has not been found but "name" is timeStamp than a search
        up the parent tree is made to locate a field named timeStamp.</li>
      <li>If no field is found than getProperty returns null.</li>
    </ul>
  </li>
  <li>If [index] is specified than the field found for name must be an array
    with elementType array or structure. If the array has an element
    corresponding to the index than that element becomes the current item. In
    all other cases getProperty returns null.</li>
</ul>

<p>The following example assume that pvField is set to a structure or
record.</p>
<pre>    PVField valuePVField = pvField.getProperty("value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>

<p>The following example assume that pvField is set to a powerSupply
structure or record.</p>
<pre>    PVField valuePVField = pvField.getProperty("power.value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>

<p>The following example assume that pvField is a structure with a field
named supply that is an array of powerSupply structures.</p>
<pre>    PVField valuePVField = pvField.getProperty("supply[2].power.value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>
<hr />

<h3 style="text-align: center">Definitions for Standard Properties</h3>
<hr />

<p>The following are the proposed set of structures for standard properties
for general purpose client tools. </p>

<h4>timeStamp</h4>
<pre>&lt;structure name = "timeStamp"&gt;
  &lt;field name = "secondsPastEpoch" type = "long" /&gt;
  &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<h4>alarm</h4>
<pre>&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "ackTransient" type = "boolean" /&gt;
  &lt;field name = "ackSeverity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "typeCode" type = "structure" /&gt;
&lt;/structure&gt;</pre>

<h4>display</h4>
<pre>&lt;structure name = "display"&gt;
    &lt;field name = "description" type = "string" /&gt;
    &lt;field name = "format" type = "string" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "resolution" type = "int" /&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>

<h4>control</h4>
<pre>&lt;structure name = "control"&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "minStep" type = "double" /&gt;
&lt;/structure&gt;</pre>

<h4>history</h4>

<p>The following describes the structure for history for a double value
field. Definitions will also appear for booleanHistory, byteHistory, ...,
stringHistory.</p>
<pre>&lt;structure name = "doubleHistory" &gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "alarm" type = "structure"
         structureName = "alarm" supportName = "null" /&gt;
&lt;/structure&gt;

&lt;structure name = "history" supportName = "doubleHistory" &gt;
    &lt;field name = "size" type = "int" /&gt;
    &lt;!-- other fields are needed. TODO --&gt;
    &lt;!-- support will make this an array of doubleHistory structures --&gt;
    &lt;field name = "data" type = "array" elementType = "structure" /&gt;
&lt;/structure&gt;</pre>
<hr />
<hr />

<h2 style="text-align: center">Part III: javaIOC - Database Definition</h2>
<hr />
<hr />

<p>Part III describes the Database Definitions provided with the javaIOC.</p>
<hr />

<h3 style="text-align: center">Overview Of Part III</h3>
<hr />

<p>The menu, structure, and support definitions required by the support
implemented by javaIOC are defined. In addition an extensive set of
recordType/structure definitions that use the support are provided. A brief
summary is:</p>
<dl>
  <dt style="font-family: courier;">javaIOC/dbd</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt style="font-family: courier;">common.xml</dt>
          <dd>Defines fields scan, and timeStamp. These are fields that are
            in most recordType definitions. Note that this is not a valid
            structure definition. It can only be used by including this file
            within a recordType definition. </dd>
        <dt style="font-family: courier;">structure.xml</dt>
          <dd>Includes all the support definitions from dbd/structure.</dd>
        <dt style="font-family: courier;">recordType.xml</dt>
          <dd>Includes all the support definitions from dbd/recordType except
            powerSupply.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">javaIOC/dbd/structure</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt style="font-family: courier;">commonFields.xml</dt>
          <dd>Contains definitions for the fields that appear in
            dbd/common.xml.</dd>
        <dt style="font-family: courier;">limit.xml</dt>
          <dd>Contains a structure definition for each numeric type. Each
            structure contains two fields: low and high.</dd>
        <dt style="font-family: courier;">display.xml</dt>
          <dd>Defines display characteristics.</dd>
        <dt style="font-family: courier;">control.xml</dt>
          <dd>Defines control characteristics.</dd>
        <dt style="font-family: courier;">alarm.xml</dt>
          <dd>Contains definitions related to alarms.</dd>
        <dt style="font-family: courier;">booleanHistory.xml</dt>
          <dd>Defines history for boolean data..</dd>
        <dt style="font-family: courier;">byteHistory.xml</dt>
          <dd>Defines history for byte data..</dd>
        <dt style="font-family: courier;">shortHistory.xml</dt>
          <dd>Defines history for short data..</dd>
        <dt style="font-family: courier;">intHistory.xml</dt>
          <dd>Defines history for int data..</dd>
        <dt style="font-family: courier;">longHistory.xml</dt>
          <dd>Defines history for long data..</dd>
        <dt style="font-family: courier;">floatHistory.xml</dt>
          <dd>Defines history for float data..</dd>
        <dt style="font-family: courier;">doubleHistory.xml</dt>
          <dd>Defines history for double data..</dd>
        <dt style="font-family: courier;">stringHistory.xml</dt>
          <dd>Defines history for string data..</dd>
        <dt style="font-family: courier;">booleanState.xml</dt>
          <dd>A structure for setting a boolean value.</dd>
        <dt style="font-family: courier;">intState.xml</dt>
          <dd>A structure for setting a integer value.</dd>
        <dt style="font-family: courier;">stringState.xml</dt>
          <dd>A structure for setting a string value.</dd>
        <dt style="font-family: courier;">supportState.xml</dt>
          <dd>Defines the current state of support for a record or field.</dd>
        <dt style="font-family: courier;">analog.xml</dt>
          <dd>Support for analog I/O.</dd>
        <dt style="font-family: courier;">digital.xml</dt>
          <dd>Support for digital I/O.</dd>
        <dt style="font-family: courier;">calc.xml</dt>
          <dd>Support for calculations. No generic calculation support is
            implemented but something similar to the EPICS calcPerform will
            be implemented in the future. For now a calculation support
            modules must be implemented similar to the EPICS subroutine
            record.</dd>
        <dt style="font-family: courier;">channelAccess.xml</dt>
          <dd>Support for links to other records.</dd>
        <dt style="font-family: courier;">delay.xml</dt>
          <dd>Support that implements an asynchronous delay when the process
            method is called. It is normally only used for testing.</dd>
        <dt style="font-family: courier;">disable.xml</dt>
          <dd>Not implemented but it will provide features like the EPICS
            disable fields.</dd>
        <dt style="font-family: courier;">enumerated.xml</dt>
          <dd>Defines an enumerated structure and create for enumerated</dd>
        <dt style="font-family: courier;">event.xml</dt>
          <dd>Support that announces an event when the process method is
            called.</dd>
        <dt style="font-family: courier;">generic.xml</dt>
          <dd>Support code that can be used to support many recordTypes and
            or structures. It just looks for fields that have associated
            support and calls the support.</dd>
        <dt style="font-family: courier;">noop.xml</dt>
          <dd>Defines noop support, which is support that does nothing except
            complete all support methods successfully and synchronously.</dd>
        <dt style="font-family: courier;">portDriver.xml</dt>
          <dd>Definitions for portDriver support for the javaIOC</dd>
        <dt style="font-family: courier;">supportArray.xml</dt>
          <dd>Support for an array of structures that have support. It is
            used with many record types.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">javaIOC/dbd/recordType</dt>
    <dd>This defines record types. Most of the definitions define both a
      recordType and a structure. The associated support will work for
      either. Thus the associated support can be used like an embeded record
      by using the structure rather than the recordType definition. 
      <dl>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/portDriver</dt>
          <dd>This defines ink support that connects to portDriver. In
            addition two record types are defined. portRecord initializes a
            port. portDeviceControl provides access to the connection
            management and trace facilities of a portDriver port or
          device.</dd>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/processControl</dt>
          <dd>A record type that can change the support state of another
            record and also set trace and enable state for a record.</dd>
      </dl>
    </dd>
</dl>

<p>An application can include all the support defined in this package by
using the following xml file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "dbd" /&gt;
&lt;include href = "structure.xml" /&gt;
&lt;include href = "recordType.xml" /&gt;
&lt;include removePath = "dbd" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>This package overview does not discuss the algorithms implemented by the
support implementations. See package org.epics.ioc.support and sub-packages
for details.</p>
<hr />

<h3 style="text-align: center;">javaIOC/dbd</h3>
<hr />

<h4>structure.xml</h4>

<p>This file includes all definitions needed for the support provided by
javaIOC.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "${JAVAIOC}/dbd/structure" /&gt;
&lt;include href = "limit.xml" /&gt;
&lt;include href = "display.xml" /&gt;
&lt;include href = "control.xml" /&gt;
&lt;include href = "enumerated.xml" /&gt;
&lt;include href = "commonFields.xml" /&gt;
&lt;include href = "alarm.xml" /&gt;
&lt;include href = "byteHistory.xml" /&gt;
&lt;include href = "shortHistory.xml" /&gt;
&lt;include href = "intHistory.xml" /&gt;
&lt;include href = "longHistory.xml" /&gt;
&lt;include href = "floatHistory.xml" /&gt;
&lt;include href = "doubleHistory.xml" /&gt;
&lt;include href = "stringHistory.xml" /&gt;
&lt;include href = "noop.xml" /&gt;
&lt;include href = "generic.xml" /&gt;
&lt;include href = "supportArray.xml" /&gt;
&lt;include href = "supportState.xml" /&gt;
&lt;include href = "booleanState.xml" /&gt;
&lt;include href = "intState.xml" /&gt;
&lt;include href = "stringState.xml" /&gt;
&lt;include href = "channelAccess.xml" /&gt;
&lt;include href = "analog.xml" /&gt;
&lt;include href = "digital.xml" /&gt;
&lt;include href = "event.xml" /&gt;
&lt;include href = "calc.xml" /&gt;
&lt;include href = "disable.xml" /&gt;
&lt;include href = "delay.xml" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/dbd/structure" /&gt;
&lt;include addPath = "${JAVAIOC}/src/org/epics/ioc/support/calc/example" /&gt;
&lt;include href = "exampleCalculatorSupport.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/src/org/epics/ioc/support/calc/example" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4>recordType.xml</h4>

<p>This file defines recordType generic and then includes recordType
definitions provided by javaIOC.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;recordType name = "generic" supportName = "generic" /&gt;
&lt;include addPath = "${JAVAIOC}/dbd/recordType" /&gt;
&lt;include href = "processControl.xml" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/dbd/recordType" /&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structure/alarm.xml</h3>
<hr />

<p>This file contains database definitions related to alarms.</p>

<p>See package org.epics.ioc.support for a description of the algorithm for
raising alarms.</p>

<p>After defining the alarm severities, it defines a structure alarm. This is
the structure for a field, usually named alarm, that provides the alarm
severity and a message describing why an alarm was raised. A recordType can
have an alarm field and each structure field in a recordType can optionally
have an alarm field, i.e. a hierarachy of alarms is supported. If a structure
has an alarm field then when it's support is called to raise an alarm, the
support looks up the parent tree for the first alarm field it finds and
raises an alarm equal to it's own alarm severity. Thus the alarm field for
the recordType always has an alarm severity greater than or equal to all
lower level alarms.</p>

<p>The remaining definitions are for checking alarms for value fields.
Definitions and support are available for the numeric types, boolean, and
enumerated. </p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "alarmSeverity" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
    default = "none minor major invalid" /&gt;
&lt;/structure&gt;

&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "ackTransient" type = "boolean" /&gt;
  &lt;field name = "ackSeverity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "typeCode" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "byteAlarmInterval"&gt;
  &lt;field name = "value" type = "byte" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "byteAlarm" supportName = "byteAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "byte" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortAlarmInterval"&gt;
  &lt;field name = "value" type = "short" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "shortAlarm" supportName = "shortAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "short" /&gt;
&lt;/structure&gt;

&lt;structure name = "intAlarmInterval"&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "intAlarm" supportName = "intAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "longAlarmInterval"&gt;
  &lt;field name = "value" type = "long" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "longAlarm" supportName = "longAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "long" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatAlarmInterval"&gt;
  &lt;field name = "value" type = "float" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "floatAlarm" supportName = "floatAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleAlarmInterval"&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm" supportName = "doubleAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "booleanAlarm"  supportName = "booleanAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "falseAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "trueAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "changeStateAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "enumeratedAlarm"  supportName = "enumeratedAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
   &lt;!-- each array element must have structureName  alarmSeverity --&gt;
  &lt;field name = "stateAlarm" type = "array" elementType = "structure" design = "false" /&gt;
  &lt;field name = "changeStateAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;support name = "alarm"
  factoryName = "org.epics.ioc.support.AlarmFactory" /&gt;
&lt;support name = "booleanAlarm"
  factoryName = "org.epics.ioc.support.BooleanAlarmFactory" /&gt;
&lt;support name = "byteAlarm"
  factoryName = "org.epics.ioc.support.ByteAlarmFactory" /&gt;
&lt;support name = "shortAlarm"
  factoryName = "org.epics.ioc.support.ShortAlarmFactory" /&gt;
&lt;support name = "intAlarm"
  factoryName = "org.epics.ioc.support.IntAlarmFactory" /&gt;
&lt;support name = "longAlarm"
  factoryName = "org.epics.ioc.support.LongAlarmFactory" /&gt;
&lt;support name = "floatAlarm"
  factoryName = "org.epics.ioc.support.FloatAlarmFactory" /&gt;
&lt;support name = "doubleAlarm"
  factoryName = "org.epics.ioc.support.DoubleAlarmFactory" /&gt;
&lt;support name = "enumeratedAlarm"
  factoryName = "org.epics.ioc.support.EnumeratedAlarmFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4>numeric alarms</h4>

<p>The definitions for byte, short, int, long, float, and double are all the
same except for the data type. The following describes the fields for double.
Except for the data type it also is valid for the other types.</p>

<p>Structure doubleAlarmInterval has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The upper limit for the interval. If a data value is &gt; the
      previous interval value and &lt;= value than this interval determines
      the alarm severity.</dd>
  <dt>severity</dt>
    <dd>The alarm severity if the data value falls into this interval.</dd>
</dl>

<p>Structure doubleAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>interval</dt>
    <dd>An array of doubleAlarmIntervals. These must be defined in increasing
      order.</dd>
  <dt>outOfRange</dt>
    <dd>The alarm severity if a data value does not fall into any
    interval.</dd>
  <dt>hystersis</dt>
    <dd>A hystersis value for changing the alarm severity. It prevents alarm
      "chatter".</dd>
</dl>

<h4>boolean alarms</h4>

<p>Structure booleanAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>falseAlarm</dt>
    <dd>alarm severity if the data value is false.</dd>
  <dt>trueAlarm</dt>
    <dd>alarm severity if the data value is true.</dd>
  <dt>changeStateAlarm</dt>
    <dd>alarm severity if the data value has changed since the last
    process.</dd>
</dl>

<h4>enumerated alarms</h4>

<p>Enumerated alarms are for a data type that is an enumerated structure.</p>

<p>Structure enumeratedAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>stateSeverity</dt>
    <dd>An array of menuSeverity structures.</dd>
  <dt>changeStateAlarm</dt>
    <dd>A severity for change of state.</dd>
</dl>
<hr />

<h3 style="text-align: center">dbd/structure/analog.xml</h3>
<hr />

<p>This is the support for analog I/O. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "linearConvert" &gt;
  &lt;field name = "engUnitsLow" type = "double" /&gt;
  &lt;field name = "engUnitsHigh" type = "double" /&gt;
  &lt;field name = "deviceHigh" type = "int" /&gt;
  &lt;field name = "deviceLow" type = "int" /&gt;
  &lt;field name = "slope" type = "double" /&gt;
  &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertInput" supportName = "generic"&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "linearConvert" type = "structure"
     structureName = "linearConvert" supportName = "linearConvertInput" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertOutput" supportName = "generic"&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "linearConvert" type = "structure"
     structureName = "linearConvert" supportName = "linearConvertOutput" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "incrementalDouble" supportName = "generic" &gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "input" type = "structure" structureName = "null" /&gt;
  &lt;field name = "incremental" type = "boolean" supportName = "incremental"/&gt;
  &lt;field name = "rateOfChange" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
&lt;/structure&gt;
&lt;support name = "linearConvertInput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "linearConvertOutput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "incremental"
   factoryName = "org.epics.ioc.support.IncrementalFactory" /&gt;&lt;support name = "linearConvertInput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "linearConvertOutput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "incremental"
   factoryName = "org.epics.ioc.support.IncrementalFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4>linearConvert</h4>

<p>Structure linearConvert is for linear conversions. The slope and intercept
can be specified directly or can be computed from the other four fields.
Normally the record instance defines engUnitsLow and engUnitsHigh and support
code provides values for deviceHigh and deviceLow but other combinations are
also permitted. Structure linearConvert has the fields:</p>
<dl>
  <dt>engUnitsLow</dt>
    <dd>Engineering units value for deviceLow.</dd>
  <dt>engUnitsHigh</dt>
    <dd>Engineering units value for deviceHigh.</dd>
  <dt>deviceHigh</dt>
    <dd>Highest possible raw value.</dd>
  <dt>deviceLow</dt>
    <dd>Lowest possible raw value.</dd>
  <dt>slope</dt>
    <dd>Slope for converting raw value to engineering units.</dd>
  <dt>intercept</dt>
    <dd>Intrercept for converting raw value to engineering units.</dd>
</dl>

<h4>linearConvertInput</h4>

<p>Structure linearConvertInput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to get the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that inputs the raw value.</dd>
</dl>

<h4>linearConvertOutput</h4>

<p>Structure linearConvertOutput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to put the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that outputs the raw value.</dd>
</dl>

<h4>incrementalDouble</h4>

<p>This is for rate limited output. The output value incrementally reaches
the desired value. The structure has the fields:</p>
<dl>
  <dt>desiredValue</dt>
    <dd>The desired value.</dd>
  <dt>input</dt>
    <dd>A structure for reading the desired value.</dd>
  <dt>incrementalOutput</dt>
    <dd>If false the output is set to the desired value if it falls within
      the control limits.</dd>
  <dt>rateOfChange</dt>
    <dd>Rate of change per process if incrementalInput is true.</dd>
  <dt>units</dt>
    <dd>units.</dd>
  <dt>controlLimit</dt>
    <dd>control limits. The output value is forced to be within the control
      limits.</dd>
</dl>
<hr />

<h3 style="text-align: center">dbd/structure/limit.xml</h3>
<hr />

<p>This contains structure definitions for limits for each of the numeric
types. No default support is provided. Each structure has just two fields:
low and high.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "byteLimit"&gt;
    &lt;field name = "low" type = "byte" /&gt;
    &lt;field name = "high" type = "byte" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortLimit"&gt;
    &lt;field name = "low" type = "short" /&gt;
    &lt;field name = "high" type = "short" /&gt;
&lt;/structure&gt;

&lt;structure name = "intLimit"&gt;
    &lt;field name = "low" type = "int" /&gt;
    &lt;field name = "high" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "longLimit"&gt;
    &lt;field name = "low" type = "long" /&gt;
    &lt;field name = "high" type = "long" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatLimit"&gt;
    &lt;field name = "low" type = "float" /&gt;
    &lt;field name = "high" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleLimit"&gt;
    &lt;field name = "low" type = "double" /&gt;
    &lt;field name = "high" type = "double" /&gt;
&lt;/structure&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structures/display.xml</h3>
<hr />

<p>This section defines the history characteristics for display.</p>
<pre>&lt;structure name = "display"&gt;
    &lt;field name = "description" type = "string" /&gt;
    &lt;field name = "format" type = "string" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "resolution" type = "int" /&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structures1">dbd/structures/doubleHistory.xml</h3>
<hr />

<p>This section defines the history characteristics for a double field.
Similar definitions exist for boolean, byte, short, int, long, float, and
string.</p>
<pre>&lt;structure name = "doubleHistory" supportName = "history" &gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "alarm" type = "structure"
         structureName = "alarm" supportName = "null" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structures2">dbd/structures/commonFields.xml</h3>
<hr />

<p>This file contains database definitions for fields in common.xml, i.e.
fields alarm, scan, and timeStamp, which are present in most recordTypes.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "scanPriority" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int"/&gt;
  &lt;field name = "choice" type = "string" default = "low"/&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
      default = "lowest lower low middle high higher highest" /&gt;
&lt;/structure&gt;
&lt;structure name = "scanType"  createName = "enumerated" &gt;
  &lt;field name = "index"  type = "int"/&gt;
  &lt;field name = "choice" type = "string"/&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
      default = "passive event periodic" /&gt;
&lt;/structure&gt;
&lt;structure name = "timeStamp"&gt;
  &lt;field name = "secondsPastEpoch" type = "long" /&gt;
  &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;
&lt;structure name = "scan" supportName = "scan"&gt;
  &lt;field name = "priority" type = "structure" structureName = "scanPriority" /&gt;
  &lt;field name = "type" type =  "structure" structureName = "scanType" /&gt;
  &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
  &lt;field name = "eventName" type = "string" /&gt;
  &lt;field name = "processSelf" type = "boolean" /&gt;
  &lt;field name = "processAfterStart" type = "boolean" default = "false" /&gt;
  &lt;field name = "maxConsecutiveActive" type = "int" default = "1" /&gt;
&lt;/structure&gt;
&lt;support name = "scan"
  factoryName = "org.epics.ioc.support.basic.ScanFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>Definitions for the following structuress:</p>
<dl>
  <dt>priority</dt>
    <dd>The scan priorities: lowest,...,highest</dd>
  <dt>scanType</dt>
    <dd>An enumerated structure that defines the scan types: 
      <dl>
        <dt>passive</dt>
          <dd>A record that is neither periodically or event scanned.
            Something elase can make it process. For example another record
            with a process link.</dd>
        <dt>event</dt>
          <dd>An event scanned record. In this case an eventName is also
            assigned to the record.</dd>
        <dt>periodioc</dt>
          <dd>A periodically scanned record. In this case a rate is also
            assigned to the record.</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt>timeStamp</dt>
    <dd><dl>
        <dt>secondsPastEpoch</dt>
          <dd>Seconds past the epoch which is Jan 1, 1970 UTC. This is
            compatible with Java and POSIX.</dd>
        <dt>nanoSeconds</dt>
          <dd>nanoseconds within the second.</dd>
      </dl>
    </dd>
  <dt>scan</dt>
    <dd><dl>
        <dt>priority</dt>
          <dd>The thread priority for a periodic and event scanning.</dd>
        <dt>scan</dt>
          <dd>Scan type, i.e. passive, event, or periodic</dd>
        <dt>rate</dt>
          <dd>Periodic scan rate in seconds</dd>
        <dt>eventName</dt>
          <dd>The event name for event scanned records.</dd>
        <dt>processSelf</dt>
          <dd>Should the record process itself?</dd>
        <dt>processAfterStart</dt>
          <dd>determines if the record instance should be processed one time
            after the record enters the ready state. If the value is true
            than recordProcess attempts to process the record immeriately
            after it becomes ready. The attempt is only successfull if no
            record processor is registered of if the record has been
            initialized to be processSelf.</dd>
        <dt>maxConsecutiveActive</dt>
          <dd>The periodic and event scanners will generate a message if they
            find the record active maxConsecutiveActive times.</dd>
      </dl>
    </dd>
</dl>
<hr />

<h3 style="text-align: center">dbd/structure/noop.xml</h3>
<hr />

<p>noop is support that implements each of the support methods by just
completing successfully. One use is for a record that just holds data.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;!-- structure null is created automatically --&gt;

&lt;support name = "noop"
    factoryName = "org.epics.ioc.support.NoopFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structure/generic.xml</h3>
<hr />

<p>Generic is the default support for many record types. It just calls the
support for any fields that have support. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "generic" supportName = "generic" /&gt;
&lt;support name = "generic"
   factoryName = "org.epics.ioc.support.basic.GenericFactory" /&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure6">dbd/structure/supportArray.xml</h3>
<hr />

<p>This is the support for an array of links, which is part of many record
types. See org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "supportArrayElement"&gt;
  &lt;field name = "wait" type = "boolean" /&gt;
  &lt;field name = "link" type = "structure" structureName = "null" /&gt;
&lt;/structure&gt;

&lt;support name = "supportArray"
  factoryName = "org.epics.ioc.support.SupportArrayFactory" /&gt;
&lt;/DBDefinition&gt;</pre>
<dl>
  <dt>supportArrayElement</dt>
    <dd><dl>
        <dt>wait</dt>
          <dd>After this link is started should supportArraySupport wait for
            completion of all links currently started before starting the
            next link.</dd>
        <dt>link</dt>
          <dd>A database link</dd>
        <dt>name</dt>
          <dd>A name that can be used is desired. For example a calculation
            record (not implemented) could use it.</dd>
      </dl>
    </dd>
</dl>
<hr />

<h3 style="text-align: center"
id="support6">dbd/structure/channelAccess.xml</h3>
<hr />

<p>This is the support for a links to other records. See
org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "monitorType" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
     default = "put change absoluteChange percentageChange" /&gt; 
&lt;/structure&gt;

&lt;structure name = "processSupport" supportName = "processSupport" &gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
&lt;/structure&gt;

&lt;structure name = "monitorSupport" supportName = "monitorSupport" &gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "type" type = "structure" structureName = "monitorType"
     default = "put" /&gt;
  &lt;field name = "deadband" type = "double" /&gt;
  &lt;field name = "queueSize" type = "int"  default = "3" /&gt;
  &lt;field name = "reportOverrun" type = "boolean" /&gt;
  &lt;field name = "process" type = "boolean"&gt;
      &lt;!-- process this record when monitor occurs --&gt;
  &lt;/field&gt;
  &lt;field name = "propertyNames" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "monitorNotifySupport" supportName = "monitorNotifySupport" &gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
&lt;/structure&gt;

&lt;structure name = "inputSupport" supportName = "inputSupport" &gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "process" type = "boolean" /&gt;
  &lt;field name = "propertyNames" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "outputSupport" supportName = "outputSupport" &gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "process" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;support name = "processSupport"
  factoryName = "org.epics.ioc.support.ca.LinkSupportFactory" /&gt;
&lt;support name = "monitorSupport"
  factoryName = "org.epics.ioc.support.ca.LinkSupportFactory" /&gt;
&lt;support name = "monitorNotifySupport"
  factoryName = "org.epics.ioc.support.ca.LinkSupportFactory" /&gt;
&lt;support name = "inputSupport"
  factoryName = "org.epics.ioc.support.ca.LinkSupportFactory" /&gt;
&lt;support name = "outputSupport"
  factoryName = "org.epics.ioc.support.ca.LinkSupportFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4>processSupport</h4>

<p>Structure processSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
</dl>

<h4>monitorSupport</h4>

<p>Structure monitorSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
  <dt>queueSize</dt>
    <dd>Must be greater than 1. The default is 2.</dd>
  <dt>reportOverrun</dt>
    <dd>If the data queue is overrun should it be reported by setting status
      and severity?</dd>
  <dt>process</dt>
    <dd>Should the record containing the link be processed after the
      monotered data is read.</dd>
  <dt>propertyNames</dt>
    <dd>A set of propertyNames. If a name is alarm than this record inherits
      the alarm from the linked record.</dd>
</dl>

<h4>monitorNotifySupport</h4>

<p>Structure monitorNotifySupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
</dl>

<h4>inputSupport</h4>

<p>Structure inputSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>process</dt>
    <dd>Should the linked record be processed before getting data?</dd>
  <dt>propertyNames</dt>
    <dd>A set of propertyNames. If a name is alarm than this record inherits
      the alarm from the linked record.</dd>
</dl>

<h4>outputSupport</h4>

<p>Structure outputSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>process</dt>
    <dd>Should the linked record be processed after putting data?</dd>
</dl>
<hr />

<h3 style="text-align: center">dbd/structure/digital.xml</h3>
<hr />

<p>This is the support for digital I/O. See org.epics.ioc.support for
details. It reads a registerValue. The raw value is the low order
numberOfBits of the registerValue. This value deterrmines the digitalState.
</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "digitalState"&gt;
  &lt;field name = "name" type = "string" /&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "digital" supportName = "generic" &gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- each structureName must be digitalState --&gt;
  &lt;!-- supportName can be digitalInput or digitalOutput --&gt;
  &lt;field name = "states" type = "array" elementType = "structure" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;support name = "digitalInput"
   factoryName = "org.epics.ioc.support.DigitalFactory" /&gt;

&lt;support name = "digitalOutput"
   factoryName = "org.epics.ioc.support.DigitalFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4>digitalState</h4>

<p>This provides a name, value, and severity for a single digital state.</p>
<dl>
  <dt>name</dt>
    <dd>The name for this state.</dd>
  <dt>value</dt>
    <dd>The raw value for this state.</dd>
  <dt>severity</dt>
    <dd>Alarm severity for this state.</dd>
</dl>

<h4>digital</h4>

<p>This is the structure required by the digital support. The field states,
which must be an array of digitalState structures, is the field that is
supported by digitalInput or digitalOutput.</p>
<hr />

<h3 style="text-align: center">dbd/structure/event.xml</h3>
<hr />

<p>This is the support for announcing events. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;support name = "event"
   factoryName = "org.epics.ioc.support.EventFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structure/calc.xml</h3>
<hr />

<p>This is the support for calculations. See org.epics.ioc.support for
details. Note that at the present time there is no support equivalent to
EPICS calcPerform. </p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "calcArg" supportName = "generic" &gt;
  &lt;!-- instance must define value --&gt;
  &lt;field name = "name" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "expressionCalculator" supportName = "expressionCalculator" &gt;
  &lt;field name = "expression" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "calculation" supportName = "generic" &gt;
  &lt;field name = "calcArgArray" type = "array"
     elementType = "structure" supportName = "calcArgArray" /&gt;
  &lt;field name = "calculator" type = "structure" 
     structureName = "expressionCalculator" /&gt;
  &lt;field name = "alarm" type = "structure" structureName = "alarm" /&gt;
&lt;/structure&gt;

&lt;support name = "calcArgArray"
 factoryName = "org.epics.ioc.support.calc.CalcArgArrayFactory" /&gt;

&lt;support name = "expressionCalculator"
 factoryName = "org.epics.ioc.support.calc.ExpressionCalculatorFactory" /&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structure/disable.xml</h3>
<hr />

<p>This is the support for disabling a record. NOT IMPLEMENTED.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "disableLink"&gt;
    &lt;field name = "disabled" type = "boolean" /&gt;
    &lt;field name = "value" type = "short" default = "1" /&gt;
    &lt;field name = "input" type = "short" /&gt;
    &lt;field name = "link" type = "link" /&gt;
    &lt;field name = "disableAlarmSeverity"
           type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;!-- support not implemented --&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure11">dbd/structure/booleanState.xml</h3>
<hr />

<p>The following describes the structure for setting the state of a boolean
value. Similar structures are available for other primitive types.</p>
<pre>&lt;structure name = "booleanState" &gt;
  &lt;field name = "value" type = "boolean" /&gt;
  &lt;field name = "desiredValue" type = "boolean" /&gt;
  &lt;field name = "setValue" type = "boolean" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/structure/delay.xml</h3>
<hr />

<p>This is the support that delays before completing. It is used for testing.
See org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "delay"&gt;
    &lt;!-- min, max, inc are delay in milliseconds --&gt;
    &lt;field name = "min" type = "long" /&gt;
    &lt;field name = "max" type = "long" /&gt;
    &lt;field name = "inc" type = "long" /&gt;
&lt;/structure&gt;

&lt;support name = "delay"
    factoryName = "org.epics.ioc.support.DelayFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure12">dbd/structure/enumerated.xml</h3>
<hr />
<pre>&lt;structure name = "enumerated" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string" /&gt;
&lt;/structure&gt;

&lt;create name = "enumerated"
  factoryName = "org.epics.ioc.create.EnumeratedFactory" /&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure12">dbd/structure/supportState.xml</h3>
<hr />
<pre>&lt;DBDefinition&gt;
&lt;structure name = "supportState" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
    default = "readyForInitialize readyForStart ready zombie" /&gt;
&lt;/structure&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure13">dbd/structure/portDriver.xml</h3>
<hr />

<p>This is the support for portDriver. See org.epics.ioc.support and
org.epics.ioc.portDriver for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "pdrvSupport"&gt;
  &lt;field name = "portName" type = "string" /&gt;
  &lt;field name = "addr" type = "int" /&gt;
  &lt;field name = "timeout" type = "double" /&gt;
  &lt;field name = "mask" type = "int" /&gt;
  &lt;field name = "size" type = "int" /&gt;
  &lt;field name = "process" type = "boolean" default = "false" /&gt;
  &lt;field name = "drvParams" type = "structure" /&gt;
&lt;/structure&gt;

&lt;support name = "pdrvOctetInput"
  factoryName = "org.epics.ioc.support.PDRVSuppowerSupplyCurrentportFactory" /&gt;
&lt;support name = "pdrvOctetInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvOctetOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvInt32Input"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32InterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32AverageInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32Output"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvFloat64Input"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64InterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64AverageInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64Output"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvFloat64ArrayInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64ArrayInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64ArrayOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvUInt32DigitalInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvUInt32DigitalInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvUInt32DigitalOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4>pdrvSupport</h4>

<p>This structure has fields for connecting to a port.</p>
<dl>
  <dt>portName</dt>
    <dd>The name of the port.</dd>
  <dt>addr</dt>
    <dd>The device address.</dd>
  <dt>timeout</dt>
    <dd>The timeout for low level I/O operations.</dd>
  <dt>mask</dt>
    <dd>Only for digital I/O. It is the mask.</dd>
  <dt>size</dt>
    <dd>Only for octet support. It is the size of the buffer for I/O.</dd>
  <dt>process</dt>
    <dd>For interrupt support. Shouls an interrupt cause the record to
      process.</dd>
  <dt>drvParams</dt>
    <dd>Driver parameters. Driver specific.</dd>
</dl>
<hr />

<h3 style="text-align: center"
id="recordType7">dbd/recordType/processControl.xml</h3>
<hr />

<p>This is support for the processControl recordType. It provides the
following features:</p>
<dl>
  <dt>trace</dt>
    <dd>Trace can be turned on or off for a record instance.</dd>
  <dt>enable</dt>
    <dd>Processing of a record instance can be enabled or disabled.</dd>
  <dt>Support State</dt>
    <dd>The process state of the support for a record or a field within a
      record can be set. This involves calling one of the following methods:
      initialize, start, stop, uninitialize.</dd>
  <dt>Support</dt>
    <dd>The support for a field can be changed. In order to make this change,
      the record instance must be in the readyForInitialize state. It is not
      possible to change the support for the record itself. </dd>
  <dt>Structure</dt>
    <dd>If a field is a structure, then the structure itself can be changed.
      In order to make this change, the record instance must be in the
      readyForInitialize state. It is not possible to change the structure
      for the record itself.</dd>
  <dt>Reporting</dt>
    <dd>All problems are reported via field message. Other fields show the
      current values for trace, enable, record support state, field support
      state, name of the field support, and the name of the structure for a
      field.</dd>
</dl>

<p>See package org.epics.ioc.support for more details.</p>

<p>processControl.xml describes the fields contained in a processControl
record. It has the definitions:</p>
<pre>&lt;structure name = "supportStateCommand" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
    default = "idle initialize start stop uninitialize" /&gt;
&lt;/structure&gt;

&lt;recordType name = "processControl" supportName = "processControl" &gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "recordName" type = "string" /&gt;
  &lt;field name = "trace" type = "structure" structureName = "booleanState" /&gt;
  &lt;field name = "enable" type = "structure" structureName = "booleanState" /&gt;
  &lt;field name = "supportStateRecord" type = "structure" structureName = "supportState" /&gt;
  &lt;field name = "supportStateCommandRecord" type = "structure" structureName = "supportStateCommand" /&gt;
  &lt;!-- remaining fields refer to a field of the record --&gt;
  &lt;field name = "fieldName" type = "structure" structureName = "stringState"  /&gt;
  &lt;field name = "supportState" type = "structure" structureName = "supportState" /&gt;
  &lt;field name = "supportStateCommand" type = "structure" structureName = "supportStateCommand" /&gt;
  &lt;field name = "supportName" type = "structure" structureName = "stringState" /&gt;
  &lt;field name = "structureName" type = "structure" structureName = "stringState" /&gt;
&lt;/recordType&gt;


&lt;support name = "processControl"
   factoryName = "org.epics.ioc.support.ProcessControlFactory" /&gt;</pre>
<hr />

<h3 style="text-align: center">dbd/recordType/portDriver.xml</h3>
<hr />

<h4>Overview</h4>

<p>This defines everything required for performing I/O via portDriver. See
portDriver for details.</p>

<p>In addition two record types are defined: portCreate and
portDeviceControl. portCreate is a recordType for creating a port.
portDeviceControl is a recordType for accessing the connect and trace
features of portDriver.</p>

<h4>portDriver.xml</h4>
<pre>&lt;DBDefinition&gt;
&lt;recordType name = "portCreate" supportName = "portCreate" &gt;
  &lt;field name = "factoryName" type = "string" /&gt;
  &lt;field name = "portName" type = "string" /&gt;
  &lt;field name = "autoConnect" type = "boolean" default = "true" /&gt;
  &lt;field name = "priority" type = "structure" structureName = "scanPriority" /&gt;
  &lt;field name = "driverParameters" type = "structure" structureName = "null"/&gt;
&lt;/recordType&gt;


&lt;recordType name = "portDeviceControl" supportName = "portDeviceControl" &gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "portDevice" type = "string" /&gt;
  &lt;field name = "connect" type = "structure" structureName = "booleanState"  /&gt;
  &lt;field name = "enable" type = "structure" structureName = "booleanState"   /&gt;
  &lt;field name = "autoConnect" type = "structure" structureName = "booleanState" /&gt;
  &lt;field name = "traceMask" type = "structure" structureName = "intState"  /&gt;
  &lt;field name = "traceIOMask" type = "structure" structureName = "intState" /&gt;
  &lt;field name = "traceIOTruncateSize" type = "structure" structureName = "intState" /&gt;
  &lt;field name = "report" type = "boolean" /&gt;
  &lt;field name = "reportDetails" type = "int" /&gt;
&lt;/recordType&gt;

&lt;support name = "portCreate"
   factoryName = "org.epics.ioc.support.PDRVPortCreateFactory" /&gt;

&lt;support name = "portDeviceControl"
   factoryName = "org.epics.ioc.support.PDRVPortDeviceControlFactory" /&gt;


&lt;include addPath = "src/org/epics/ioc/pdrv/testDriver" /&gt;
&lt;include href = "octetDriver.xml" /&gt;
&lt;include href = "int32Driver.xml" /&gt;
&lt;include href = "float64Driver.xml" /&gt;
&lt;include href = "uint32DigitalDriver.xml" /&gt;
&lt;include href = "int32ArrayDriver.xml" /&gt;
&lt;include href = "float64ArrayDriver.xml" /&gt;
&lt;include removePath = "src/org/epics/ioc/pdrv/testDriver" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h2 style="text-align: center">License Agreement</h2>
<pre>Copyright (c) 2006 All rights reserved 
The University of Chicago, as Operator of Argonne National Laboratory,
    (UofC) Chicago Ilinois, USA,
Deutsches Elektronen-Synchroton, Member of the Helmholtz Association,
    (DESY), HAMBURG, GERMANY,
BERLINER SPEICHERRING GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H.
    (BESSY), BERLIN, GERMANY.

EPICS JavaIOC is distributed subject to the following license conditions:

 SOFTWARE LICENSE AGREEMENT
 Software: EPICS JavaIOC
 Versions: All

 1. The "Software", below, refers to EPICS JavaIOC (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.


________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
