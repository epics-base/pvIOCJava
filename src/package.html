<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br
/>
2007.02.02</h1>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<p>CONTENTS</p>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a>
    <ul>
      <li><a href="#default">default</a></li>
      <li><a href="#org.epics.">org.epics.ioc.pv</a></li>
      <li><a href="#org.epics.1">org.epics.ioc.dbd</a></li>
      <li><a href="#org.epics.2">org.epics.ioc.db</a></li>
      <li><a href="#org.epics.3">org.epics.ioc.ca</a></li>
      <li><a href="#org.epics.4">org.epics.ioc.util</a></li>
      <li><a href="#org.epics.5">org.epics.ioc.support</a></li>
      <li><a href="#org.epics.6">org.epics.ioc.process</a></li>
      <li><a href="#org.epics.7">org.epics.ioc.swtshell</a></li>
      <li><a href="#javaIOC">javaIOC/dbd</a></li>
      <li><a href="#Getting">Getting Started</a></li>
      <li><a href="#Status">Status and Remaining Tasks</a></li>
    </ul>
  </li>
  <li><a href="#Database">Database Syntax</a>
    <ul>
      <li><a href="#Include">Include and Macro Substitution</a>
        <ul>
          <li><a href="#Syntax">Syntax</a></li>
          <li><a href="#Example">Example</a></li>
        </ul>
      </li>
      <li><a href="#Database1">Database Definition</a>
        <ul>
          <li><a href="#Basic">Basic Syntax</a></li>
          <li><a href="#Field">Field Syntax</a></li>
          <li><a href="#Property">Property Syntax</a></li>
          <li><a href="#Example1">Example Structure, Menu, and Support
            Definitions</a></li>
          <li><a href="#Record">Record Type Examples</a></li>
        </ul>
      </li>
      <li><a href="#Record1">Record Instance Definition</a>
        <ul>
          <li><a href="#Syntax1">Syntax</a></li>
          <li><a href="#Example2">Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Java">Java Database Definitions</a>
    <ul>
      <li><a href="#Field1">Field Types</a></li>
      <li><a href="#Data">Data Interfaces</a></li>
    </ul>
  </li>
  <li><a href="#Database2">Database Reflection</a>
    <ul>
      <li><a href="#pvAccess">pvAccess reflection</a></li>
      <li><a href="#Example3">Example: Database Access via Reflection</a></li>
    </ul>
    <ul>
      <li><a href="#PVAccess">PVAccess</a></li>
    </ul>
  </li>
  <li><a href="#Record2">Record Processing: Brief Theory of Operation</a>
    <ul>
      <li><a href="#Definition">Definitions</a></li>
      <li><a href="#Requestor">Requestor Examples</a></li>
    </ul>
  </li>
  <li><a href="#Support">Support</a></li>
  <li><a href="#Generic">Generic Device Support</a>
    <ul>
      <li><a href="#Database3">Database Definitions</a>
        <ul>
          <li><a href="#Analog">Analog Input Record</a></li>
          <li><a href="#Analog1">Analog Imput Embeded Record</a></li>
          <li><a href="#Power">Power Supply Linked</a></li>
          <li><a href="#Power1">Power Supply Embeded</a></li>
          <li><a href="#Power2">Power Supply Array</a></li>
        </ul>
      </li>
      <li><a href="#Record3">Record Instance Examples</a>
        <ul>
          <li><a href="#analogInpu">analogInputRecord Instance</a></li>
          <li><a href="#aiRecord">aiRecord Instance</a></li>
          <li><a href="#powerSuppl">powerSupplyLinkedRecord Instance</a></li>
          <li><a href="#powerSuppl1">powerSupplyEmbededRecord
          Instance</a></li>
          <li><a href="#Power3">Power Supply Array Instance</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Field2">Field Access and Property Definitions</a></li>
  <li><a href="#Examples">Examples of Accessing Fields via PVAccess</a>
    <ul>
      <li><a href="#exampleAiE">exampleAiEmbeded</a></li>
      <li><a href="#exampleAi">exampleAi</a></li>
      <li><a href="#examplePow">examplePowerSupplyLinked or
        examplePowerSupplyEmbeded</a></li>
    </ul>
  </li>
  <li><a href="#License">License Agreement</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node
that controls and/or monitors a collection of devices. An IOC contains a
memory resident real time database. The real time database has a set of
"smart" records. Each record is an instance on a record of a particular
type.</p>

<p>JavaIOC is a JAVA implementation of an EPICS IOC. It has many similarities
to a Version 3 ( the 3.13 and 3.14 releases of EPICS base) but extends the
data types to support structures and arrays. This document assumes that the
reader is familiar with EPICS Version 3.</p>

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>

<h3 id="default">default</h3>

<p>This package contains the overview you are now reading. It also contains
XMLToDatabase, which is the example program discussed below.</p>

<h3 id="org.epics.">org.epics.ioc.pv</h3>

<p>This package defines definitions for the data that javaIOC supports. This
is a combination of data and reflection interfaces. Read the package overview
for details. Read it, at least quickly, before continuing with this
document.</p>

<h3 id="org.epics.1">org.epics.ioc.dbd</h3>

<p>This package provides support for a Database Definition Database (DBD). A
DBD holds definitions of the following:</p>
<dl>
  <dt>menu</dt>
  <dt>structure</dt>
  <dt>support</dt>
  <dt>recordType</dt>
</dl>

<p>An XML parser is provided that reads xml descriptions of the above and
creates a DBD. Examples of the xml files are presented below.</p>

<h3 id="org.epics.2">org.epics.ioc.db</h3>

<p>Package org.epics.ioc.pv provides a factory for creating the reflection
interfaces but not for data. This package provides a factory for creating the
data required by javaIOC. It also extends the data interfaces defined in
org.epics.ioc.pv so that:</p>
<ul>
  <li>Support can be attached to records and fields.</li>
  <li>Record instances can be locked.</li>
  <li>Fields of records can be monitored for changes.</li>
</ul>

<p>This package implements an XML parser that creates record instances and
puts them into an IOC Database (IOCCB).</p>

<h3 id="org.epics.3">org.epics.ioc.ca</h3>

<p>This package is Channel Access for a javaIOC.</p>

<h3 id="org.epics.4">org.epics.ioc.util</h3>
This package provides utility code for a javaIOC:
<dl>
  <dt>Message Support</dt>
    <dd>This is an interface for passing messages to a requestor of many
      services.</dd>
  <dt>Time Stamp support</dt>
    <dd>Support is provided to make it easier to work with time stamps.</dd>
  <dt>Scan Field Support</dt>
    <dd>Support that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
  <dt>XML Reader</dt>
    <dd>Support for reading XML Database Definition and Record Instance
      files. It is an abstraction above Java SAX (Simple API for XML). It
      implements macro substitution and include.</dd>
</dl>

<h3 id="org.epics.5">org.epics.ioc.support</h3>
<dl>
  <dt>LinkSupportFactory</dt>
    <dd>Support for the following link types: processLink, inputLink,
      outputLink, and monitorLink.</dd>
  <dt>LinkArraySupportFactory</dt>
    <dd>Support for an array of links. This can be used by most record
    types</dd>
  <dt>ScanSupportFactory</dt>
    <dd>Support for the scan field.</dd>
  <dt>LinearConvertInputFactory</dt>
    <dd>Support for converting a raw value to engineering units. NOT
      IMPLEMENTED.</dd>
</dl>

<h3 id="org.epics.6">org.epics.ioc.process</h3>

<p>This package provides support for processing IOC database records.</p>

<h3 id="org.epics.7">org.epics.ioc.swtshell</h3>

<p>This is a GUI shell for an ioc. It is implemented via the Standard Widget
Toolkit. Getting Started explains how to invoke it.</p>

<h3 id="javaIOC">javaIOC/dbd</h3>

<p>In javaIOC there is a directory dbd, which has database Definitions for
everything implemented by javaIOC.</p>

<h3 id="Getting">Getting Started</h3>

<p>In package default there is a Java main program that: <ul>
  <li>reads Database Definition and Record Instance files</li>
  <li>dumps the resulting DBD and DB definitions</li>
  <li>Starts an IOC with an swtshell</li>
</ul>
This program can be executed as follows:</p>

<p>Make sure class path is properly defined. In addition the SWT load
libraries for your platform must be defined. For example if your shell is
bash: <pre>    export CLASSPATH=${CLASSPATH}:pathToJavaIOC/bin
    export CLASSPATH=${CLASSPATH}:/usr/local/swt/swt.jar
    export LD_LIBRARY_PATH=/usr/local/swt</pre>
Then execute:</p>
<pre>    java XMLToDatabase ...</pre>
The arguments can be any combination of:
<ul>
  <li>-dbd <br />
    the following filenames are database definition files</li>
  <li>-db <br />
    the following filenames are record instance files</li>
  <li>fileName <br />
    a database definition or record instance file</li>
  <li>-dumpDBD<br />
    dump all that database definitions read so far</li>
  <li>-dumpDB<br />
    dump all the record instances read so far</li>
  <li>-swtshell<br />
    Start swtshell and initialize the ioc.</li>
</ul>

<p>For example:</p>
<pre>cd javaIOC
java XMLToDatabase -dbd "src/exampleDBD.xml" -db "src/exampleDB.xml" -dumpDBD -dumpDB &gt; temp  </pre>

<p>Will read a set of database definition and record instance files and then
dump the database definitions record instances. The output will be written to
file temp. This example will actually work if you have unziped the javaIOC
distribution file. Just cd javaIOC and execute the above command. NOTE that
this produces a lot of output since the example has lots of different menu,
structure, support, and recordType definitions.</p>

<p>The javaIOC distribution has an example that starts swtshell. On Linux do
the following:</p>
<pre>    cd javaIOC
    . exampleCommand</pre>

<p>The remainder of this document gives an overview of what is currently
implemented:</p>
<ul>
  <li>The xml syntax for database definitions and record instances.</li>
  <li>Java interraces for accessing fields of a record instance.</li>
  <li>A brief overview of record processing.</li>
  <li>A discussion of "device" support, i.e. how support for simple devices
    like an ADC and complex devices like a power supply can be defined.</li>
</ul>

<h3 id="Status">Status and Remaining Tasks</h3>

<p>With the exception of remote Channel Access, the basic functionality
required for a javaIOC is now implemented. It is possible to create a running
javaIOC but since it can not comminicate with the outside world it can not do
anything usefull.</p>

<p>The following JavaIOC components, which are not yet defined or
implemented, are required before a usable javaIOC exists.</p>
<ul>
  <li>Remote Channel Access<br />
    This requires both client and server. This could wait until after a beta
    release of javaIOC is announced.</li>
  <li>V3 Channel Access<br />
    Two things are required:
    <ul>
      <li>javaIOC to V3 server<br />
        This allows javaIOC records to have links to V3 IOCs.</li>
      <li>V3 client to javaIOC<br />
        This allows V3 channel access clients to access javaIOC records.</li>
    </ul>
    Both of these are required before javaIOC is ready for serious use.</li>
  <li>A shell<br />
    What to do? Two things come to mind. Perhaps both have their place.
    <ul>
      <li>Jython<br />
        Provide Jython support for javaIOC. Interfacing Jython to a javaIOC
        is easy but providing full featured support will take thought.</li>
      <li>A GUI based shell<br />
        Instead of a command line shell like EPICS V3 a GUI based interface
        may be prefereable. In order to minimize the memory and cpu impact on
        a javaIOC, the GUI should be remote and have a javaIOC server that
        communicates with the GUI. It should provide on-line add, database
        introspection, database tracing, etc.</li>
    </ul>
  </li>
  <li>messageServer<br />
    JavaIOC interfaces provide methods for sending messages to requestors.
    Currently the requestors just write the messages to System.out. A message
    server facility similar to the V3 logMessage facility needs to be
    implemented. Once in place it will be easy to modify the existing code to
    use the message server.</li>
  <li>Design and implement a core set of recordType DatabaseDefinitions and
    support. This is required before a beta release can be announced.</li>
  <li>Design and implement hardware device support based on asynDriver.</li>
</ul>

<p>When these are ready a JavaIOC is a viable product. However several other
things are desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a javaIOC.</li>
  <li>Channel Access Clients that implement the JavaIOC Channel Access
    Semantics.</li>
  <li>...</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>

<p>Marty Kraimer's next priorities are the GUI based shell and a core set of
recordTypes.</p>
<hr />

<h2 style="text-align: center" id="Database">Database Syntax</h2>
<hr />

<p>The syntax for both Database Definitions (menu, structure, recordType,
etc) and Record Instance Definitions is XML based. In addition XML based
macro substitution and include is supported. Package org.epics.ioc.util
provides XML support with the following features:</p>
<ul>
  <li>Include and Macro Substitution are handled automatically.<br />
    NOTE: include and substitute are reserved words.</li>
  <li>xml namespaces are not support.</li>
  <li>Although the implementation uses SAX, the user code only implements
    IOCXMLListener and uses IOCXMLReader.</li>
  <li>The support is used by XMLToDBDFactory and by XMLToIOCDBFactory and can
    be used by other code.</li>
</ul>

<h3 style="text-align: center" id="Include">Include and Macro
Substitution</h3>

<h4 id="Syntax">Syntax</h4>

<p>An xml file can include other xml files. All files must be valid xml files
and must have the same root element name. An include statement has the
format:</p>
<pre>&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4 id="Example">Example</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "aiRecord"&gt;
    &lt;aiInput structureName = "aiLinear" &gt;
        &lt;aiRaw&gt;
            &lt;input supportName = "inputLink"&gt;
                &lt;configure structureName = "inputLink"&gt;
                    &lt;pvname&gt;${pvname}&lt;/pvname&gt;
                    &lt;wait&gt;true&lt;/wait&gt;
                &lt;/configure&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiInput&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/pvAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h3 style="text-align: center" id="Database1">Database Definition</h3>

<p>This section provides a brief description of database definitions. See
package org.epics.ioc.dbd for complete details.</p>

<h4 id="Basic">Basic Syntax</h4>

<p>Database definitions consist of the following definition types: <span
style="font-family: courier;">menu</span>, <span
style="font-family: courier;">structure</span>, <span
style="font-family: courier;">support</span>, and <span
style="font-family: courier;">recordType.</span></p>

<p>An example menu definition is:</p>
<pre>    &lt;menu name = "menuAlarmSevr"&gt;
        &lt;choice&gt;none&lt;/choice&gt;
        &lt;choice&gt;minor&lt;/choice&gt;
        &lt;choice&gt;major&lt;/choice&gt;
        &lt;choice&gt;invalid&lt;/choice&gt;
    &lt;/menu&gt;</pre>

<p>A menu definition consists of a name and a set of choices.</p>

<p>An example structure definition is:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low" type = "double" /&gt;
        &lt;field name = "high" type = "double" /&gt;
    &lt;/structure&gt;</pre>

<p>A structure definition consists of a name and a set of field definitions.
More details about field definitions are provided below. A structure
definition can also optionally define associated support as follows:</p>
<pre>    &lt;struucture name = "name" supportName = "supportName" &gt;
       ...
    &lt;/structure&gt;</pre>

<p>The supportName must be the same as a name in a support definition.</p>

<p>An example support definition is:</p>
<pre>    &lt;support name = "org.epics.ioc.support.processLink"
         configStructureName = "processLink" 
         factoryName = "org.epics.ioc.support.LinkSupportFactory"/&gt;</pre>

<p>A support definition consists of:</p>
<ul>
  <li>name
    <p>Provides a way to match support to a structure, recordType, or a field
    of a structure.</p>
  </li>
  <li>configStructureName
    <p>The name of a structure definition. The structure provides
    configuration information for the support.</p>
  </li>
  <li>factoryName
    <p>The name of a factory that creates support instances.</p>
  </li>
</ul>

<p>An example recordType definition is:</p>
<pre>&lt;recordType name = "doubleRecord" supportName = "doubleRecord" &gt;
    &lt;include href = "commonDBD.xml" /&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;

&lt;/recordType&gt;</pre>

<p>A recordtype definition consists of a name, optional default record
support, and a set of field definitions. A recordType is impemented so that
it extends a structure definition.</p>

<h4 id="Field">Field Syntax</h4>

<p>Both structure and recordType definitions define a set of field
definitions. A field definition has the format:</p>
<pre>    &lt;field name = "value" type = "type"  ...&gt;</pre>
where supportName is optional and "..." represents other attributes. The
complete set of attributes are:
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>the field name. This must be defined.</dd>
  <dt style="font-family: courier;">type</dt>
    <dd>The field type which must be defined and must be one of:<br />
      boolean,byte,short,int,long,float,double,string,enum,structure,array</dd>
  <dt>supportName</dt>
    <dd>The name of support for the field. A matching support definition must
      be available during IOC initialization.</dd>
  <dt style="font-family: courier;">menuName</dt>
    <dd>must be given if the type is menu.</dd>
  <dt style="font-family: courier;">structureName</dt>
    <dd>can be given if the type is structure. If not given the structure
      must be specified when a field instance is created.</dd>
  <dt style="font-family: courier;">elementType</dt>
    <dd>must be specified if the type is array. It can be any of the
      supported types.</dd>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the field is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>

<h4 id="Property">Property Syntax</h4>
A structure, recordType, and field can have properties. A property is defined
as:
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where
<dl>
  <dt>name</dt>
    <dd>The name of the property</dd>
  <dt>associatedField</dt>
    <dd>The name of a field that has the value for the property. Examples are
      given later in this document. An associatedField must be one of the
      following:
      <dl>
        <dt>/name</dt>
          <dd>If the associatedField value starts with '/' then the search
            will start at the record not with the field that has the
          property.</dd>
        <dt>name</dt>
          <dd>The name of a structure field.</dd>
        <dt>name1.name2</dt>
          <dd>name1 must be the name of a structure field. name2 must be a
            property or field in the structure field.</dd>
      </dl>
    </dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>

<h4 id="Example1">Example Structure, Menu, and Support Definitions</h4>

<p>The following are examples of menu and structure definitions. These are
taken from menuStructureSupport.xml which resides in javaIOC/dbd:</p>
<pre>&lt;menu name = "menuPriority"&gt;
    &lt;choice&gt;lowest&lt;/choice&gt;
    &lt;choice&gt;lower&lt;/choice&gt;
    &lt;choice&gt;low&lt;/choice&gt;
    &lt;choice&gt;middle&lt;/choice&gt;
    &lt;choice&gt;high&lt;/choice&gt;
    &lt;choice&gt;higher&lt;/choice&gt;
    &lt;choice&gt;highest&lt;/choice&gt;
&lt;/menu&gt;</pre>
<pre>&lt;menu name = "menuAlarmSevr"&gt;
    &lt;choice&gt;none&lt;/choice&gt;
    &lt;choice&gt;minor&lt;/choice&gt;
    &lt;choice&gt;major&lt;/choice&gt;
    &lt;choice&gt;invalid&lt;/choice&gt;
&lt;/menu&gt;</pre>

<p>menuPriority and menuAlarmSever are just like the V3 versions.</p>
<pre>&lt;structure name = "displayLimit"&gt;
    &lt;field name = "low" type = "double" /&gt;
    &lt;field name = "high" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>Whenever a field has a property "displayLimit" then the associatedField
for the property must be a displayLimit structure field.</p>
<pre>&lt;structure name = "linearConvert"&gt;
    &lt;field name = "engUnitsLow" type = "double" /&gt;
    &lt;field name = "engUnitsHigh" type = "double" /&gt;
    &lt;field name = "slope" type = "double" /&gt;
    &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;</pre>

<p>This is for use by records that perform linear conversions.</p>
<pre>&lt;structure name = "timeStamp"&gt;
    &lt;field name = "secondsPastEpoch" type = "long" /&gt;
    &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<p>This may be the way time stamps are defined. Some thought should be given
to see if another way is desired.</p>
<pre>&lt;menu name = "menuScan"&gt;
    &lt;choice&gt;passive&lt;/choice&gt;
    &lt;choice&gt;event&lt;/choice&gt;
    &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;

&lt;structure name = "scan"&gt;
    &lt;field name = "priority" type = "menu" menuName = "priority" default = "middle" /&gt;
    &lt;field name = "scan" type = "menu" menuName = "scan" default = "passive" /&gt;
    &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
    &lt;field name = "eventName" type = "string" /&gt;
&lt;/structure&gt;</pre>

<p>This is similar to V3 except, instead of having predefined scan rates
defined in menuScan, the rate is specfied via a separate field.</p>

<p>The following define configuration structures for link fields for database
and channel access links:</p>
<pre>&lt;structure name = "processLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "inputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "outputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "monitorLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "queueCapacity" type = "int"&gt;
        &lt;!-- 0 means monitor only &gt;0 means data also --&gt;
    &lt;/field&gt;
    &lt;field name = "reportOverrun" type = "boolean" &gt;
        &lt;!-- only applicable if queueCapacity&gt;=0 --&gt;
     &lt;/field&gt;
    &lt;field name = "process" type = "boolean"&gt;
        &lt;!-- process this record when monitor occurs --&gt;
    &lt;/field&gt;
    &lt;field name = "inheritSeverity" type = "boolean" &gt;
        &lt;!-- only applicable if process is true --&gt;
    &lt;/field&gt;
&lt;/structure&gt;</pre>

<p>The following, which is not currently supported, defines fields for a V3
style disable link:</p>
<pre>&lt;structure name = "disableLink"&gt;
    &lt;field name = "disabled" type = "boolean" /&gt;
    &lt;field name = "value" type = "short" default = "1" /&gt;
    &lt;field name = "input" type = "short" /&gt;
    &lt;field name = "link" type = "link" /&gt;
    &lt;field name = "disableAlarmSeverity"
           type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<p>The following is for interfacing to hardware, V4 will provide support for
asynDriver style interfaces. The record support provided with the base
javaIOC will use these as well as the soft link support interfaces.</p>
<pre>&lt;structure name = "asynLink" structureSupportName = "org.epics.ioc.support.AsynLink"&gt;
    &lt;field name = "portName" type = "string" /&gt;
    &lt;field name = "addr" type = "int" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
&lt;/structure&gt;
&lt;linkSupport name = "asynLink" configStructureName = "asynLink" /&gt;</pre>

<h4 id="Record">Record Type Examples</h4>

<p>A sample record type definition was presented above. The last section
discusses some possibilities for defining complex devices.</p>

<h3 style="text-align: center" id="Record1">Record Instance Definition</h3>

<h4 id="Syntax1">Syntax</h4>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p>If the recordSupport name is not specified then the record support
specified in the recordType definition is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<h4 id="Example2">Example</h4>
<pre>&lt;record name = "double01" type = "doubleRecord"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;counter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
&lt;/record&gt;</pre>
<hr />

<h2 style="text-align: center" id="Java">Java Database Definitions</h2>
<hr />

<p>A JavaIOC implements interfaces for accessing fields of database records.
The interfaces are a combination of reflection ( what is a field) and data
(what does a field contain) interfaces.</p>

<h3 style="text-align: center" id="Field1">Field Types</h3>

<p>Two Java enums define the supported types.</p>

<p>The first enum is:</p>
<pre>    public enum Type {
        pvUnknown,
        pvBoolean,
        pvByte,
        pvShort,
        pvInt,
        pvLong,
        pvFloat,
        pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray,
        pvMenu,
        pvLink;
    }</pre>
<pre>    </pre>

<h3 style="text-align: center" id="Data">Data Interfaces</h3>

<p>The following describe the interfaces for accessing the data a field
contains.</p>

<p>The data interfaces for accessing Type data are:</p>
<pre>    interface PVData {
         String getFullFieldName();
         Field getField(); // get the reflection interface
         PVData getParent();
         PVRecord getPVRecord();
         void replacePVData(PVData newPVData);
         String getSupportName();
         String setSupportName(String name);
         String toString();
         String toString(int indentLevel);
    }
    interface PVBoolean extends PVData{
        boolean get();
        void put(boolean value);
    }
    //   similar interfaces for other primitve types
    interface PVString extends PVData{
        String get();
        void put(String value);
    }
    interface PVEnum extends PVData{
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }
    interface PVStructure extends PVData {
        PVData[] getFieldPVDatas();
    }
    public interface PVMenu extends PVEnum {}
    public interface PVLink extends PVData {
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }
    interface PVArray extends PVData{
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
    }
    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray{
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }
    // ... for arrays of other pv Types
    public interface PVRecord extends PVStructure {
        String getRecordName();
        void message(String message, MessageType messageType);
    }</pre>

<p>The following interfaces extend the PVData interfaces for DBType data:</p>
<pre>    interface DBData extends PVData {
        DBRecord getDBRecord();
        void addListener(DBListener listener);
        void removeListener(DBListener listener);
        void postPut();
        Support getSupport();
        void setSupport(Support support);
    }

    interface DBRecord extends DBData, PVRecord {
        void lock();
        void unlock();
        ...
    }</pre>

<h2 style="text-align: center" id="Database2">Database Reflection</h2>

<p>The previous section listed the interfaces for accessing data. The
interfaces also provided methods (PVData.getField and DBData.get DBDField)
which provide access to the reflection interfaces described in this section.
The reflection interfaces provide access to the type, attributes, and
properties of each field of each record instance.</p>

<h4 id="pvAccess">pvAccess reflection</h4>

<p>The reflection interfaces for pvAccess data are:</p>
<pre>    interface Property {
        String getPropertyName();
        String getAssociatedFieldName();
        String toString();
        String toString(int indentLevel);
    }

    public interface FieldAttribute {
        String getDefault();
        boolean isReadOnly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    }

    interface Enum extends Field {
        boolean isChoicesMutable();
    }

    interface Menu extends Enum {
        String getMenuName();
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<h4 id="Example3">Example: Database Access via Reflection</h4>
An interface IOCDB provides a method that locates the interface for a record
instance. For example, to locate the aiAnalogExample record the call is:
<pre>    DBRecord dbRecord = iocdb.findRecord("exampleAiLinear");</pre>

<p>Starting with this the data in the value field can be read as follows:</p>
<pre>    PVData[] pvData = dbRecord.getFieldPVdatas();
    Structure structure = (Structure)dbRecord.getField();
    int index = structure.getFieldIndex("value");
    assert(pvData[index].getField().getType==Type.dbDouble);
    PVDouble valueData= (PVDouble)pvData[index];
    double value = valueData.get();</pre>

<p>The data for exampleAiLinear.aiLinear.aiRaw.value can also be located and
read via reflection as follows:</p>
<pre>    PVData[] pvData = dbRecord.getFieldPVdatas();
    Structure structure = (Structure)dbRecord.getField();
    int index = structure.getFieldIndex("aiLinear");
    assert(pvData[index].getField().getType()==Type.pvStructure);
    PVStructure pvStructure = (PVStructure)pvData[index];
    Structure aiLinearStructure = (Structure)pvStructure.getField();
    index = aiLinearStructure.getFieldIndex("aiRaw");
    pvData = pvStructure.getFieldPVdatas();
    assert(pvData[index].getField().getType()==Type.pvStructure);
    pvStructure = (PVStructure)pvData[index];
    Structure aiRawStructure = (Structure)pvStructure.getField();
    index = aiRawStructure.getFieldIndex("value");
    pvData = pvStructure.getFieldPVdatas();
    assert(pvData[index].getField().getType==Type.pvInt);
    PVInt valueData = (PVInt)pvData[index];
    int value = valueData.get();</pre>

<p>The next section provides a much easier way to find the data interfaces
for a field.</p>

<h3 style="text-align: center" id="PVAccess">PVAccess</h3>

<p>PVAccess is an interface for accessing a record instance. A PVAccess can
be created via:</p>
<pre>    PVAccess pvAccess = PVAccessFactory.create(instanceName);</pre>
Where instanceName is a Java String. For example:
<pre>    PVAccess pvAccess = PVAccessFactory.create("exampleAiLinear");</pre>

<p>PVAccess provides the following methods:</p>
<pre>    public enum AccessSetResult {
        otherRecord,
        thisRecord,
        notFound
    }

    interface PVAccess {
        PVRecord getPVRecord();
        AccessSetResult findField(String name);
        String getOtherRecord();
        String getOtherField();
        void setPVField(PVData pvData);
        PVData getField();
    }

    public class PVAccessFactory {
        public static PVAccess createPVAccess(PVRecord pvRecord);
    }</pre>

<p>The argument to findField(name) has the form:</p>
<pre>    name.name...</pre>
Each <span style="font-family: courier;">name</span> is the name of a
property or a field. For example:
<pre>    PVAccess pvAccess = PVAccessFactory.create("exampleAiLinear");
    boolean found = pvAccess.findField("aiLinear.aiRaw.value");</pre>

<p>Locates the value field of the aiRaw structure of the aiLinear structure
in the aiLinearRecord.</p>

<p>But because the way properties are defined, the same field can be located
via the call:</p>
<pre>      found = pvAccess.findField("rawValue");</pre>

<p>A later section provides more examples of PVAccess.</p>
<hr />

<h2 style="text-align: center" id="Record2">Record Processing: Brief Theory
of Operation</h2>
<hr />

<p>Package org.epics.ioc.process describes and implements code directly
related to record processing. This section gives a brief introduction to
record processing.</p>

<h3 id="Definition">Definitions</h3>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete. It is permissible to take locks that that are
      shared by other synchronous code.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke
      other support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance.</dd>
  <dt>recordProcess</dt>
    <dd>Every record instance has an implementation of an object that
      coordinates record processing. RecordProcess is the name of the
      interface implemented by record processing.</dd>
  <dt>process requestor</dt>
    <dd>Code that asks recordProcess to process a record. Code must register
      to be the requestor and only one requestor is allow to request
      processing. Thus a registration request fails if a requestor is already
      attached to a record. If code that is not the requestor attempts to
      process a record an exception is thrown.</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h3 id="Requestor">Requestor Examples</h3>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests:
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status,
            severity, and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be
      done with as few lock/unlock cycles and context switches as possible.
      In particular the only asynchronous support should cause a context
      switch. <br />
      Typical requests are:
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or
          severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>
<hr />

<h2 style="text-align: center" id="Support">Support</h2>
<hr />

<p>Package org.epics.ioc.support provides basic support for processing
javaIOC records. It provides standard support for the following:</p>
<dl>
  <dt>LinkSupportFactory</dt>
    <dd>Support for the following link types: processLink, inputLink,
      outputLink, and monitorLink.</dd>
  <dt>LinkArraySupportFactory</dt>
    <dd>Support for an array of links. This can be used by most record
    types</dd>
  <dt>ScanSupportFactory</dt>
    <dd>Support for the scan field.</dd>
  <dt>LinearConvertInputFactory</dt>
    <dd>Support for converting a raw value to engineering units. NOT
      IMPLEMENTED.</dd>
</dl>

<p>In addition a file that does not have an implementation is present.
Something like this will be part of the standard set of record types provided
by javaIOC. It will most likely be moved to a different package perhaps:
<span style="font-family: courier;">org.epics.ioc.recordType.</span></p>
<dl>
  <dt>AnalogInputFactory</dt>
    <dd>A record type that has an input link which provides a raw value,
      converts the raw value to engineering units, and uses linkArray support
      that can have processLink and/or outputLink elements. It will use
      LinearConvertInput to do the conversion.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="Generic">Generic Device Support</h2>
<hr />

<p>This section discusses how record types (Database Definitions and Support)
can be defined to implement generic device support. It starts with simple ADC
(Analog to Digital Converter) device and ends with an array of power supply
controllers. The examples demonstrate that record types can be designed in
several ways. The examples are:</p>
<dl>
  <dt>analogInputRecord</dt>
    <dd>This is a record type that is similar to the V3 aiRecord but will
      only allow linear or no conversion.</dd>
  <dt>aiRecord</dt>
    <dd>This is a record type that has the same capabilities as
      analogInputRecord but is created by using embeded components which can
      also be reused for other record types.</dd>
  <dt>powerSupplyLinkedRecord</dt>
    <dd>This is an example of how a "device" abstraction record type can be
      created by using links to other records</dd>
  <dt>powerSupplyEmbededRecord</dt>
    <dd>This is an example that has the same capability as the
      powerSupplyLinkedRecord but is created by using embeded components.</dd>
  <dt>powerSupplyArrayRecord</dt>
    <dd>This is an example that shows how arrays of other "devices" can be
      supported.</dd>
  <dt>The examples are chosen to demonstrate the capabilities of the javaIOC
  rather than to say how record types should be created.</dt>
</dl>

<h3 style="text-align: center" id="Database3">Database Definitions</h3>

<h4 id="Analog">Analog Input Record</h4>

<p>The following is one way of defining an analog input record:</p>
<pre>&lt;recordType name = "analogInputRecord" 
         supportName = "analogInput" &gt;
    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "/timeStamp" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "rawValue" type = "int" /&gt;
    &lt;field name = "linearConvert"
        type = "structure" structureName = "linearConvert" /&gt;
&lt;/recordType&gt;</pre>

<p>This definition is similar to the V3 aiRecord except that it does not
support breakpoint conversions.</p>

<p>Breakpoint conversions could also be provided but instead on adding fields
to menuConvert, whichV3 does, a separate field should holds the breakpoint
information.</p>

<p>A disadvantage of this way of defining an analog input record is that if
additional features are desired the record can not easily be reused. Either a
new record type and associated record support must be created or a set of
linked records has to be defined.</p>

<h4 id="Analog1">Analog Imput Embeded Record</h4>

<p>The following defines an analog input record type with maximum reuse of
components.</p>

<p>First define a structure for raw input.</p>
<pre>&lt;structure name = "aiRaw" supportName = "aiRaw" &gt;
    &lt;field name = "value" type = "int" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "input" type = "link" /&gt;
&lt;/structure&gt;</pre>
This defines a structure appropriate for holding the raw value obtained from
an ADC. Device support for an ADC can be attached to the input field. The
value field has three properties. The status and severity reside in the
structure itself. The timeStamp will be obtained from a parent structure or
record type. Note that the structure also has associated support.

<p>Next define:</p>
<pre>&lt;structure name = "aiLinear" supportName = "aiLinear" &gt;
    &lt;property name = "rawValue" associatedField = "aiRaw.value" /&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = ".." /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "aiRaw" type = "structure" structureName = "aiRaw"/&gt;
    &lt;field name = "linearConvert"
        type = "structure" structureName = "linearConvert" /&gt;
&lt;/structure&gt;</pre>

<p>This defines a structure appropriate for holding a value that is obtained
by performing a linear conversion on a raw value obtained from other support.
Similar structures could be defined for other types of conversion, e.g.
breakpoint conversions.</p>

<p>Finally define a record type</p>
<pre>&lt;recordType name = "aiRecord" supportName = "ai" &gt;
    &lt;property name = "value" associatedField = "aiLinear.value" /&gt;
    &lt;property name = "rawValue" associatedField = "aiLinear.rawValue" /&gt;
    &lt;property name = "status" associatedField = "aiLinear.status" /&gt;
    &lt;property name = "severity" associatedField = "aiLinear.severity" /&gt;
    &lt;field name = "aiLinear" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>

<p>The associated record support could be written so that it could also be
used for other similar record types. For example an aiBreakPointRecord. As
long as the new record type has fields required by the record support, the
existing record support can be used by the new record type.</p>

<h4 id="Power">Power Supply Linked</h4>

<p>The following shows how a simple power supply record type can be created
via links to other record types. To make the example simple the power supply
provides access only to power, current, and voltage. The current and voltage
will be read via some hardware device such as an ADC. The power is just
current*voltage.</p>
<pre>&lt;recordType name = "powerSupplyLinkedRecord" supportName = "powerSupplyLinked"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;property name = "voltage" associatedField = "voltageInput.value" /&gt;
    &lt;field name = "power" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;

    &lt;field name = "currentInput" type = "link" /&gt;
    &lt;field name = "voltageInput" type = "link" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
&lt;/recordType&gt;</pre>

<h4 id="Power1">Power Supply Embeded</h4>

<p>The following is one way of creating the simple power supply using embeded
structures.</p>

<p>First define:</p>
<pre>&lt;structure name = "powerSupply" supportName = "powerSupply" &gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;property name = "voltage" associatedField = "voltageInput.value" /&gt;
    &lt;field name = "power" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "voltageInput" type = "structure" structureName = "aiLinear" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
&lt;/structure&gt;</pre>

<p>This defines a single power supply. The power is a field of the power
supply structure. The current and voltage are defined via an aiLinear
structure, which was defined in the previous example. The support available
via the aiLinear structure will also work with the powerSupply.</p>

<p>Next define:</p>
<pre>&lt;recordType name = "powerSupplyEmbededRecord" supportName = "powerSupply"&gt;
    &lt;property name = "power" associatedField = "powerSupply.power" /&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;property name = "voltage" associatedField = "powerSupply.voltage" /&gt;
    &lt;field name = "powerSupply"
         type = "structure" structureName = "powerSupply" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>

<h4 id="Power2">Power Supply Array</h4>

<p>An array of power supplies could be defined as follows:</p>
<pre>&lt;recordType name = "powerSupplyArrayRecord" supportName = "powerSupplyArray" &gt;
    &lt;field name = "powerSupply" type = "array" elementType = "structure" /&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "priority" type = "menu" menuName = "menuPriority" /&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"/&gt;
&lt;/recordType&gt;</pre>

<h3 style="text-align: center" id="Record3">Record Instance Examples</h3>

<h4 id="analogInpu">analogInputRecord Instance</h4>
<pre>&lt;record name = "exampleAnalogInput" type = "analogInputRecord"&gt;
    &lt;input supportName = "asynInt" configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h4 id="aiRecord">aiRecord Instance</h4>
<pre>&lt;record name = "exampleAi" type = "aiRecord"&gt;
    &lt;aiLinear&gt;
        &lt;aiRaw&gt;
            &lt;input supportName = "asynInt"
                     configStructureName = "asynLink"&gt;
                &lt;portName&gt;somePort&lt;/portName&gt;
                &lt;addr&gt;1&lt;/addr&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiLinear&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h4 id="powerSuppl">powerSupplyLinkedRecord Instance</h4>
<pre>&lt;record name = "current" type = "aiRecord"&gt;
    &lt;input supportName = "asynInt"
             configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;

&lt;record name = "voltage" type = "aiRecord"&gt;
    &lt;input supportName = "asynInt"
            configStructureName = "asynLink"&gt;
        &lt;portName&gt;somePort&lt;/portName&gt;
        &lt;addr&gt;1&lt;/addr&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;linearConvert&gt;
        &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
        &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
    &lt;/linearConvert&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;

&lt;record name = "examplePowerSupplyLinked" type = "powerSupplyLinkedRecord"&gt;
    &lt;units&gt;watts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;100.0&lt;/high&gt;
    &lt;/displayLimit&gt;
    &lt;currentInput supportName = "inputLink"
            configStructureName = "inputLink"&gt;
         &lt;pvname&gt;current.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/currentInput&gt;
    &lt;voltageInput supportName = "asynInt"
              configStructureName = "asynLink"&gt;
         &lt;pvname&gt;voltage.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/voltageInput&gt;
&lt;/record&gt;</pre>

<h4 id="powerSuppl1">powerSupplyEmbededRecord Instance</h4>
<pre>&lt;record name = "examplePowerSupply" type = "powerSupplyEmbededRecord"&gt;
    &lt;powerSupply&gt;
        &lt;units&gt;watts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;100.0&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;currentInput&gt;
            &lt;aiRaw&gt;
                &lt;input supportName = "asynInt"
                         configStructureName = "asynLink"&gt;
                    &lt;portName&gt;somePort&lt;/portNname&gt;
                    &lt;addr&gt;2&lt;/addr&gt;
                &lt;/input&gt;
            &lt;/aiRaw&gt;
            &lt;units&gt;amps&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;10.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;linearConvert&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
        &lt;/currentInput&gt;
        &lt;voltageInput&gt;
            &lt;aiRaw&gt;
                &lt;input supportName = "asynInt"
                         configStructureName = "asynLink"&gt;
                    &lt;portName&gt;somePort&lt;/portName&gt;
                    &lt;addr&gt;2&lt;/addr&gt;
                &lt;/input&gt;
            &lt;/aiRaw&gt;
            &lt;units&gt;volts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;2.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;linearConvert&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;2.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
        &lt;/voltageInput&gt;
    &lt;/powerSupply&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;</pre>

<h4 id="Power3">Power Supply Array Instance</h4>
<pre>&lt;record name = "examplePowerSupplyArray" type = "powerSupplyArrayRecord"&gt;
    &lt;powerSupply capacity = "2"&gt;
        &lt;value     structureName = "powerSupply"&gt;
            &lt;units&gt;watts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;100.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;currentInput&gt;
                &lt;aiRaw&gt;
                    &lt;input supportName = "asynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;4&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;amps&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;10.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/currentInput&gt;
            &lt;voltageInput&gt;
                &lt;aiRaw&gt;
                    &lt;input supportName = "asynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;5&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;volts&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;2.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;2.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/voltageInput&gt;
        &lt;/value&gt;
        &lt;value     structureName = "powerSupply"&gt;
            &lt;units&gt;watts&lt;/units&gt;
            &lt;displayLimit&gt;
                &lt;low&gt;0.0&lt;/low&gt;
                &lt;high&gt;1000.0&lt;/high&gt;
            &lt;/displayLimit&gt;
            &lt;currentInput&gt;
                &lt;aiRaw&gt;
                    &lt;input supportName = "asynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;6&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;amps&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;10.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/currentInput&gt;
            &lt;voltageInput&gt;
                &lt;aiRaw&gt;
                    &lt;input supportName = "asynInt"
                            configStructureName = "asynLink"&gt;
                        &lt;pvname&gt;somePort&lt;/pvname&gt;
                        &lt;addr&gt;7&lt;/addr&gt;
                    &lt;/input&gt;
                &lt;/aiRaw&gt;
                &lt;units&gt;volts&lt;/units&gt;
                &lt;displayLimit&gt;
                    &lt;low&gt;0.0&lt;/low&gt;
                    &lt;high&gt;100.0&lt;/high&gt;
                &lt;/displayLimit&gt;
                &lt;linearConvert&gt;
                    &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                    &lt;engUnitsHigh&gt;100.0&lt;/engUnitsHigh&gt;
                &lt;/linearConvert&gt;
            &lt;/voltageInput&gt;
        &lt;/value&gt;
    &lt;/powerSupply&gt;
    &lt;priority&gt;low&lt;/priority&gt;
&lt;/record&gt;</pre>
<hr />

<h2 style="text-align: center" id="Field2">Field Access and Property
Definitions</h2>
<hr />

<p>Because a JavaIOC allows structures, there has to be a way to refer to
each field of each structure. A field is specified via a string that has the
form: <pre>    &lt;recordName&gt;.name.name ...</pre>
The first "." ends the record name and each "." locates a field. For the
following examples the recordName and first "." will be assumed. Thus when
the example gives a field name as "powerSupply.power" it actually means
"&lt;recordName&gt;.powerSupply.power"</p>

<p>Properties can be assigned to a field, a structure, and a recordType.
Properties provide two features: <ol>
  <li>related fields<br />
    When given for a field a property specifies a field that has information
    associated with the field. For example a value field can have properties
    defined for display limits, control limits, units, etc.</li>
  <li>look elsewhere<br />
    When assigned to a structure it is a way of saying look elsewhere for a
    field that holds the desired data. Since a recordType is also a structure
    properties can also be assigned to a recordType. Elsewhere can be a field
    in the same record or a field in another record.</li>
</ol>
</p>

<p>Lets discuss the first case. The aiRaw structure includes the definitions: <pre>&lt;structure name = "aiRaw"&gt;
    &lt;field name = "value" type = "int" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
    &lt;field name = "severity" type = "menu" menuName = "menuAlarmSevr" /&gt;
&lt;/structure&gt;</pre>
These defininitions state that value has the following properties: <dl>
  <dt>status</dt>
    <dd>The associatedField is the status field of the aiRaw structure.</dd>
  <dt>severity</dt>
    <dd>The associatedField is the severity field of the aiRaw structure.</dd>
  <dt>timeStamp</dt>
    <dd>The associatedField "/timeStamp" says to start looking at the top of
      the record hierarchy for the timeStamp.</dd>
</dl>
When a client has access to aiRaw.value then the client can ask for any of
the properties status, severity, and timeStamp and will get an interface that
allows access to the appropriate field.</p>

<p>Now lets consider properties assigned to a structure or record type. The
aiLinear structure includes the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;property name = "rawValue" associatedField = "aiRaw.value" /&gt;
    &lt;field name = "aiRaw" type = "structure" structureName = "aiRaw"/&gt;
&lt;/structure&gt;</pre>
This property definition says that to find rawValue look at the aiRaw field
of structure aiLinear and then look for value. In this example value is a
field of structure aiRaw so it is the actual field. In more complicated
examples like the powerSupply, value could be a property rather than a field
and a further search is required.</p>

<p>This use of property is especially usefull for "device" oriented records,
e.g. the powerSupply. A client that understands what a power supply is just
wants to ask for power, current, and voltage. The client should not be
responsible for knowing exactly where the current is located but can just ask
for the current and be told where it is located.</p>

<p>Now consider the powerSupplyEmbeded example.</p>

<p>The power supply record has the structure: <pre>    powerSupplyEmbededRecord
        powerSupply
            power
            currentInput
                value
                status
                severity
                units
                displayLimit
                aiRaw
                    value
                    status
                    severity
                    input
                linearConvert
            voltageInput
                value
                status
                severity
                units
                displayLimit
                aiRaw
                    value
                    status
                    severity
                    input
                linearConvert
            status
            severity
            units
            displayLimit
        status
        severity
        timeStamp
        priority
        scan</pre>
where the detail of many of the structure fields is not shown.</p>

<p>Without properties the only way to get the power, current, and voltage it
to specify the fields as: <pre>    powerSupply.power
    powerSupply.currentInput.value
    powerSupply.voltageInput.value</pre>
</p>

<p>But with the way the properties are defined they can be specified as: <pre>    power
    current
    voltage</pre>
</p>

<p>Lets consider power first. The powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyEmbededRecord"&gt;
    &lt;property name = "power" associatedField = "powerSupply.power" /&gt;
    &lt;field name = "powerSupply" type = "structure" structureName = "powerSupply" /&gt;
&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;field name = "power" type = "double" &gt;
&lt;/structure&gt;</pre>
</p>

<p>Thus field "power" results in the following: <ol>
  <li>In powerSupplyRecord property power is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>field power is located in the powerSupply structure.</li>
  <li>Thus the actual field is powerSupplyRecord.powerSupply.power.</li>
</ol>
</p>

<p>Now for current. The powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyRecord"&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;field name = "powerSupply" type = "structure" structureName = "powerSupply" /&gt;
&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>Structure aiLinear has the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;field name = "value" type = "double" &gt;
&lt;/structure&gt;</pre>
</p>

<p>Thus field "current" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Thus the actual field is
  powerSupplyRecord.powerSupply.aiLinear.value</li>
</ol>
</p>

<p>Now consider "current.status" and "current.timeStamp" The
powerSupplyRecord has the definitions: <pre>&lt;recordType name = "powerSupplyRecord"&gt;
    &lt;property name = "current" associatedField = "powerSupply.current" /&gt;
    &lt;field name = "powerSupply"
         type = "structure" structureName = "powerSupply" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;

&lt;/recordType&gt;</pre>
</p>

<p>The powerSupply has the definitions: <pre>&lt;structure name = "powerSupply"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "structure" structureName = "aiLinear" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>Structure aiLinear has the definitions: <pre>&lt;structure name = "aiLinear"&gt;
    &lt;field name = "value" type = "double" &gt;
      &lt;property name = "status" associatedField = "status" /&gt;
      &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "status" type = "string" /&gt;
&lt;/structure&gt;</pre>
</p>

<p>"current.status" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Field value of structure aiLinear has property status.</li>
  <li>The aiLinear structure has a field status.</li>
  <li>Thus the actual field is
  powerSupplyRecord.powerSupply.aiLinear.status</li>
</ol>
"current.timeStamp" results in the following: <ol>
  <li>In powerSupplyRecord property current is found.</li>
  <li>Field powerSupply is located in the powerSupplyRecord.</li>
  <li>The powerSupply structure has property current</li>
  <li>Field currentInput is located in the powerSupply structure.</li>
  <li>field value is located in the aiLinear structure of field
  currentInput.</li>
  <li>Field value of structure aiLinear has property timeStamp.</li>
  <li>The associatedField for timeStamp is "/timeStamp". This results in
    searching from the top of the record looking for a field named
    "timeStamp". It is found in powerSupplyRecord.</li>
  <li>Thus the actual field is powerSupplyRecord.timeStamp</li>
</ol>
</p>

<p>Thus for the powerSupply: <ol>
  <li>power is powerSupplyRecord.powerSupply.power</li>
  <li>power.status is powerSupplyRecord.powerSupply.status</li>
  <li>power.timeStamp is powerSupplyRecord.timeStamp</li>
  <li>current is powerSupplyRecord.powerSupply.aiLinear.value</li>
  <li>current.status is powerSupplyRecord.powerSupply.aiLinear.status</li>
  <li>current.timeStamp is powerSupplyRecord.timeStamp</li>
  <li>current.rawValue is
  powerSupplyRecord.powerSupply.aiLinear.aiRaw.value</li>
  <li>current.rawValue.status is
    powerSupplyRecord.powerSupply.aiLinear.aiRaw.status</li>
  <li>current.rawValue.timeStamp is powerSupplyRecord.timeStamp</li>
</ol>
</p>

<p>Properties for structures can also be used for "device" records that are
implemented via links. For example the powerSupplyLinkedRecord has the
definitions:</p>
<pre>&lt;recordType name = "powerSupplyLinkedRecord"&gt;
    &lt;property name = "current" associatedField = "currentInput.value" /&gt;
    &lt;field name = "currentInput" type = "link" /&gt;</pre>

<p>And the example record instance defined:</p>
<pre>&lt;record name = "examplePowerSupplyLinked" type = "powerSupplyLinkedRecord"&gt;
    &lt;currentInput linkSupportName = "inputLink" configStructureName = "inputLink"&gt;
         &lt;pvname&gt;current.value&lt;/pvname&gt;
         &lt;process&gt;true&lt;/process&gt;
         &lt;wait&gt;true&lt;/wait&gt;
    &lt;/currentInput&gt;
 </pre>

<p>NOTE: current in <span
style="font-family: courier;">&lt;pvname&gt;current.value&lt;/pvname&gt;</span>
is the name of the record that has the current.</p>

<p>When a request is made for field current the following happens.</p>
<ol>
  <li>The property current is located in record examplePowerSupplyLinked.</li>
  <li>The field currentInput is located in examplePowerSupplyLinked.</li>
  <li>The fact that the field is a link indicates that the current is located
    in another record. The remainder of the associatedField is saved. Call
    this the remoteField which in this example has the value "value"</li>
  <li>The data structure that holds the inputLink information is located.</li>
  <li>The inputLink fields are searched for the first field that has the
    attribute "link".</li>
  <li>This field must be a string. The beginning of the string up to the
    first "." is the name of the remote record. Call this remoteRecord. In
    this example it has the value "current".</li>
  <li>The requester is told the the current can be located by asking for
    remoteRecord.remoteField which is this case has the value
  "current.value".</li>
  <li>The requester must make a separate request to get the current
    information.</li>
</ol>
<hr />

<h2 id="Examples">Examples of Accessing Fields via PVAccess</h2>
<hr />

<p>PVAccess is an interface that allows "device"oriented access. PVAccess
uses the structure property definitions that are designed fot this purpose.
It also is usefull for obtaining the properties associated with a field
without using the reflection interfaces.</p>

<h3 id="exampleAiE">exampleAiEmbeded</h3>
<pre>    PVAccess pvAccess = PVAccessFactory.create("exampleAiEmbeded");

    // get the value field and make sure its type is double
    assert(pvAccess.findField("value")==AccessSetResult.thisRecord);
    PVData valueData = pvAccess.getField();
    Field field = valueData.getField();
    assert(field.getType()==Type.pvDouble);
    double value = ((PVDouble)valueData).get();

    // now get the status for field value
    pvAccess.findField(valueData);
    assert(pvAccess.findField("status")==AccessSetResult.thisRecord);
    PVData valueStatusData = pvAccess.getField();
    assert(field.getType()==Type.pvString);
    String status = ((PVString)valueStatusData).get();
    // now get rawData and rawData status
    pvAccess.findField(valueData);
    assert(pvAccess.findField("rawData")==AccessSetResult.thisRecord));
    PVData rawValueData = pvAccess.getField();
    Field field = rawValueData.getField();
    assert(field.getType()==Type.pvInt);
    int rawValue = ((PVInt)rawValueData).get();
    assert(pvAccess.findField("status")==AccessSetResult.thisRecord));
    PVData rawValueStatusData = pvAccess.getField();
    field = rawValueStatusData.getField();
    assert(field.getType()==Type.pvString);
    String status = ((PVString)rawValueStatusData).get();</pre>

<h3 id="exampleAi">exampleAi</h3>

<p>Accessing exampleAi is exactly the same as for exampleAiEmbeded except
that the record name is different.</p>

<h3 id="examplePow">examplePowerSupplyLinked or examplePowerSupplyEmbeded</h3>

<p>The following example shows how to access device records which are created
either via links or by embeding. The example is for the linked instance but
will also work for the embeded instance. The following is an example of code
to access the power, current, and voltage.</p>
<pre>    PVAccess powerSupply = PVAccessFactory.create("examplePowerSupplyLinked")
    PVAccess powerAccess;
    PVAccess currentAccess;
    PVAcess voltageAccess;
    PVData power;
    PVData current;
    PVData voltage;
    AccessSetResult setResult;
    
    // get access to power
    setResult = powerSupply.findField("power");
    switch(setResult) {
    case notFound: throw new Exception("power not found");
    case thisRecord: 
        powerAccess = powerSupply; break;
    case otherRecord:
        powerAccess = PVAccessFactory.create(powerSupply.getOtherRecord());
        if(powerAccess==null) throw new Exception("power not found");
        setResult = powerAccess.findField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("power not found");
        break;
    }
    power = powerAccess.getField();

    // get access to current
    setResult = powerSupply.findField("current");
    switch(setResult) {
    case notFound: throw new Exception("current not found");
    case thisRecord: 
        currentAccess = powerSupply; break;
    case otherRecord:
        currentAccess = PVAccessFactory.create(powerSupply.getOtherRecord());
        if(currentAccess==null) throw new Exception("current not found");
        setResult = currentAccess.findField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("current not found");
        break;
    }
    current = current.getField();

    // get access to voltage
    setResult = powerSupply.findField("voltage");
    switch(setResult) {
    case notFound: throw new Exception("voltage not found");
    case thisRecord: 
        voltageAccess = powerSupply; break;
    case otherRecord:
        voltageAccess = PVAccessFactory.create(powerSupply.getOtherRecord());
        if(voltageAccess==null) throw new Exception("voltage not found");
        setResult = voltageAccess.findField(powerSupply.getOtherField());
        if(setResult!=AccessSetResult.thisRecord) throw new Exception("voltage not found");
        break;
    }
    voltage = voltage.getField();

    // can now get data as well as properties for power, current, voltage</pre>

<p>NOTE: The example is not correct because of calls like</p>
<pre>    PVAccess access = PVAccessFactory.create(powerSupply.getOtherRecord());</pre>

<p>This assumes the records are located in the same IOC as record
examplePowerSupplyLinked. In a real example channel access, not database
access, must be used. However channel access is not yet defined.</p>
<hr />

<h2 style="text-align: center;text-align: center;" id="License">License
Agreement</h2>
<pre>Copyright (c) 2006 All rights reserved 
The University of Chicago, as Operator of Argonne National Laboratory,
    (UofC) Chicago Ilinois, USA,
Deutsches Elektronen-Synchroton, Member of the Helmholtz Association,
    (DESY), HAMBURG, GERMANY,
BERLINER SPEICHERRING GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H.
    (BESSY), BERLIN, GERMANY.

EPICS JavaIOC is distributed subject to the following license conditions:

 SOFTWARE LICENSE AGREEMENT
 Software: EPICS JavaIOC
 Versions: All

 1. The "Software", below, refers to EPICS JavaIOC (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.


________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
