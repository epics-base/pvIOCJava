<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br
/>
2007.04.30</h1>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<p>CONTENTS</p>

<div class="toc">
<ul>
  <li><a href="#Overview">Overview</a> 
    <ul>
      <li><a href="#Getting">Getting Started</a></li>
      <li><a href="#Status">Status and Remaining Tasks</a></li>
    </ul>
  </li>
  <li><a href="#Package">Package Summary</a> 
    <ul>
      <li><a href="#default">default</a></li>
      <li><a href="#org.epics.">org.epics.ioc.pv</a></li>
      <li><a href="#org.epics.1">org.epics.ioc.dbd</a></li>
      <li><a href="#org.epics.2">org.epics.ioc.db</a></li>
      <li><a href="#org.epics.3">org.epics.ioc.ca</a></li>
      <li><a href="#org.epics.4">org.epics.ioc.util</a></li>
      <li><a href="#org.epics.5">org.epics.ioc.support</a></li>
      <li><a href="#org.epics.6">org.epics.ioc.recordSupport</a></li>
      <li><a href="#org.epics.7">org.epics.ioc.process</a></li>
      <li><a href="#org.epics.8">org.epics.ioc.swtshell</a></li>
      <li><a href="#javaIOC">javaIOC/dbd</a></li>
    </ul>
  </li>
  <li><a href="#Database">Database Syntax</a> 
    <ul>
      <li><a href="#Include">Include and Macro Substitution</a> 
        <ul>
          <li><a href="#Syntax">Syntax</a></li>
          <li><a href="#Example">Example</a></li>
        </ul>
      </li>
      <li><a href="#Database1">Database Definition</a> 
        <ul>
          <li><a href="#Basic">Basic Syntax</a></li>
          <li><a href="#Field">Field Syntax</a></li>
          <li><a href="#Property">Property Syntax</a></li>
          <li><a href="#Example1">Example Structure, Menu, and Support
            Definitions</a></li>
          <li><a href="#Record">Record Type Examples</a></li>
        </ul>
      </li>
      <li><a href="#Record1">Record Instance Definition</a> 
        <ul>
          <li><a href="#Syntax1">Syntax</a></li>
          <li><a href="#Example2">Example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#PVData">PVData</a> 
    <ul>
      <li><a href="#Field1">Field Types</a></li>
      <li><a href="#PVData1">PVData Reflection</a></li>
      <li><a href="#PVData2">PVData Interfaces</a></li>
      <li><a href="#Example3">Example: Database Access via Reflection</a></li>
      <li><a href="#PVAccess">PVAccess</a></li>
    </ul>
  </li>
  <li><a href="#DBData">DBData Interfaces</a></li>
  <li><a href="#Record2">Record Processing</a></li>
  <li><a href="#Channel">Channel Access</a></li>
  <li><a href="#Generic">Generic Device Support</a> 
    <ul>
      <li><a href="#Database2">Database Definitions</a> 
        <ul>
          <li><a href="#doubleComm">doubleCommon</a></li>
          <li><a href="#doubleReco">doubleRecord</a></li>
          <li><a href="#aiDoubleCo">aiDoubleCommon</a></li>
          <li><a href="#aiDoubleRe">aiDoubleRecord</a></li>
          <li><a href="#aoDoubleCo">aoDoubleCommon</a></li>
          <li><a href="#aoDoubleRe">aoDoubleRecord</a></li>
          <li><a href="#powerSuppl">powerSupply</a></li>
        </ul>
      </li>
      <li><a href="#Support">Support Implementation</a></li>
      <li><a href="#Record3">Record Instance Examples</a> 
        <ul>
          <li><a href="#doubleInpu">doubleInput</a></li>
          <li><a href="#doubleOutp">doubleOutput</a></li>
          <li><a href="#ai">ai</a></li>
          <li><a href="#ao">ao</a></li>
          <li><a href="#psSimple">psSimple</a></li>
          <li><a href="#psLinked">psLinked</a></li>
          <li><a href="#psEmbeded">psEmbeded</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#License">License Agreement</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="Overview">Overview</h2>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node
that controls and/or monitors a collection of devices. An IOC contains a
memory resident real time database. The real time database has a set of
"smart" records. Each record is an instance on a record of a particular
type.</p>

<p>JavaIOC is a JAVA implementation of an EPICS IOC. It has many similarities
to a Version 3 ( the 3.13 and 3.14 releases of EPICS base) but extends the
data types to support structures and arrays. This document assumes that the
reader is familiar with EPICS Version 3.</p>

<p><span style="font-weight:bold;">WARNING</span>: JavaIOC is currently
pre-alpha:</p>
<ul>
  <li>It does not have sufficient functionality to be used for real
    appplications.</li>
  <li>It has not been seriously tested and thus may have many bugs.</li>
</ul>

<h3 id="Getting">Getting Started</h3>

<p>JavaIOC is developed as an eclipse project. The following assumes that you
have eclipse installed and have imported JavaIOC into a project named
"javaIOC".</p>

<p>In package default ( <span
style="font-family: courier;">javaIOC/src</span> ) there is a Java main
program, <span style="font-family: courier;">XMLToDatabase</span>, that:</p>
<ul>
  <li>Reads Database Definition and Record Instance files</li>
  <li>Dumps the resulting DBD and DB definitions</li>
  <li>Invokes swtshell, which is a GUI shell for a running JavaIOC.</li>
</ul>

<p>Run <span style="font-family: courier;">javaIOC/src/XMLToDatabase</span>
as an <span style="font-weight:bold;">eclipse SWT application.</span></p>

<p>The arguments to XMLToDatabase can be any combination of:</p>
<ul>
  <li>-dbd <br />
    followed by filenames of database definition files</li>
  <li>-db <br />
    followed by filenames of record instance files <br />
  </li>
  <li>-dumpDBD<br />
    dump all the database definitions read so far</li>
  <li>-dumpDB<br />
    dump all the record instances read so far</li>
  <li>-swtshell<br />
    Start swtshell, which also starts a javaIOC.</li>
</ul>

<p>For example:</p>
<pre>    -dbd "src/exampleDBD.xml" -db "src/exampleDB.xml" -dumpDBD -dumpDB</pre>

<p>Reads a set of database definition and record instance files and then
dumps the database definitions and record instances.</p>

<p>As a beginning example specify the arguments as:</p>
<pre>    -dbd src/exampleDBD.xml -db src/exampleDB.xml -swtshell</pre>

<p>This will load the DBD and DB files and start swtshell, which is a SWT
(Standard Widget Toolkit) shell running an ioc. Just try it. After swshell
starts do the following:</p>
<ul>
  <li>click the monitor button and a new window appears 
    <ul>
      <li>click connect button and a small window "getChannel" appears 
        <ul>
          <li>click select and choose channel "ai". A small window
            "getChannelField" appears 
            <ul>
              <li>enter "value" and press enter</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>click property button. a window offering choices appears 
        <ul>
          <li>select all choices and click done button</li>
        </ul>
      </li>
      <li>click startMonitor button 
        <ul>
          <li>after awhile click "stopMonitor" and "disconnect" buttons</li>
        </ul>
      </li>
    </ul>
    <p></p>
  </li>
  <li>on swtshell window click introspectDatabase button and a new window
    appears 
    <ul>
      <li>The menu bar at the top provides access to Database Definitions for
        menu, structure, recordType, support, and linkSupport 
        <ul>
          <li>select and look at the various definitions.</li>
        </ul>
      </li>
      <li>the recordName row provides access to record instances. Click the
        select button and select record "ai" 
        <ul>
          <li>The current value of all fields in record ai are shown</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>on swtshell window click on loadDatabase button and a new window
    appears. Now on-line add powerSupply records 
    <ul>
      <li>click find button and select dbd/powerSupplyRecordDBD.xml</li>
      <li>click show button and the file contents are displayed</li>
      <li>clock loadDBD button and the database definition is added to the
        IOC database definitions.</li>
      <li>click find button and select src/powerSupplyAllDB.xml</li>
      <li>click show button and the file contents are displayed</li>
      <li>click loadDB button and the record instance is added to the IOC
        database.</li>
    </ul>
  </li>
  <li>on monitor window 
    <ul>
      <li>monitor record "psEmbeded" field "power" and all properties. 
        <ul>
          <li>The initial vale timeStamp shows that the record was never
            processed.</li>
          <li>Just leave the window monitoring psEmbeded.power</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>on swtshell window click probe button. A new window appears 
    <ul>
      <li>In Put control 
        <ul>
          <li>set process choice to selected</li>
          <li>click connect button and choose record "psEmbeded" and field
            "power"</li>
          <li>click put button 
            <ul>
              <li>enter "1.0" and press enter key</li>
            </ul>
          </li>
          <li>Look at monitor window. The record has processed and the
            updated values are shown</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>You are on your own.</li>
</ul>

<p>The remainder of this document gives an overview of what is currently
implemented:</p>
<ul>
  <li>The xml syntax for database definitions and record instances.</li>
  <li>Java interfaces for accessing records and fields.</li>
  <li>A brief overview of record processing.</li>
  <li>A discussion of "device" support, i.e. how support for simple devices
    like an ADC and complex devices like a power supply can be defined.</li>
</ul>

<h3 id="Status">Status and Remaining Tasks</h3>

<p>With the exception of remote Channel Access, the basic functionality
required for a javaIOC is now implemented. It is possible to create a running
javaIOC but since it can not comminicate with the outside world it can not do
anything usefull.</p>

<p>The following JavaIOC components, which are not yet defined or
implemented, are required before a usable javaIOC exists.</p>
<ul>
  <li>Remote Channel Access<br />
    This requires both client and server. This could wait until after a beta
    release of JavaIOC is announced.</li>
  <li>V3 Channel Access<br />
    Two things are required: 
    <ul>
      <li>JavaIOC to V3 server<br />
        This allows javaIOC records to have links to V3 IOCs.</li>
      <li>V3 client to javaIOC<br />
        This allows V3 channel access clients to access javaIOC records.</li>
    </ul>
    Both of these are required before JavaIOC is ready for serious use.</li>
  <li>Message Server<br />
    JavaIOC interfaces provide methods for sending messages to requesters.
    Currently the requesters just write the messages to System.out or to a
    swtshell text window. A message server facility similar to the V3
    logMessage facility needs to be implemented. Once in place it will be
    easy to modify the existing code to use the message server.</li>
  <li>Design and implement a more complete core set of recordType Database
    Definitions and support. This release provides only a small amount of
    support. More is required before a beta release can be announced.</li>
  <li>Design and implement hardware device support based on asynDriver.</li>
</ul>

<p>When the above is implemented JavaIOC is a viable product. However several
other things are desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a JavaIOC.</li>
  <li>Channel Access Clients that implement the JavaIOC Channel Access
    Semantics.</li>
  <li>etc, etc.</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>

<p>Marty Kraimer's next priorities are:</p>
<ul>
  <li>More testing</li>
  <li>Remote Channel Access</li>
  <li>A more complete set of standard support</li>
</ul>
<hr />

<h2 style="text-align: center" id="Package">Package Summary</h2>
<hr />

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>

<h3 id="default">default</h3>

<p>This package, which resides in javaIOC/src, contains:</p>
<ul>
  <li>The overview package.html document you are now reading.</li>
  <li>XMLToDatabase, which is the example program which was discussed in the
    getting started section.</li>
  <li>A number of xml files containing example and test record instance
  files.</li>
</ul>

<h3 id="org.epics.">org.epics.ioc.pv</h3>

<p>A JavaIOC has a Process Variable (PV) Database, which is a "smart" real
time database. It is smart because each record instance has processing code.
Package <span style="font-family: courier;">pv</span> contains support for
the data and package <span style="font-family: courier;">db</span> contains
support for processing.</p>

<p>This package defines definitions for the data that javaIOC supports. This
is a combination of data and reflection interfaces. Read the package overview
for details. A brief description appears below.</p>

<h3 id="org.epics.1">org.epics.ioc.dbd</h3>

<p>This package provides support for a Database Definition Database (DBD). A
DBD holds definitions of the following:</p>
<dl>
  <dt>menu</dt>
  <dt>structure</dt>
  <dt>recordType</dt>
  <dt>support</dt>
  <dt>linkSupport</dt>
</dl>

<p>An XML parser is provided that reads xml descriptions of the above and
creates a DBD. Examples of the xml files are presented below.</p>

<h3 id="org.epics.2">org.epics.ioc.db</h3>

<p>This package provides a factory for creating javaIOC databases. It defines
a set data interfaces that contain references to PV Data and provides methods
so that:</p>
<ul>
  <li>Support can be attached to records and fields.</li>
  <li>Record instances can be locked.</li>
  <li>Fields of records can be monitored for changes.</li>
</ul>

<p>This package implements an XML parser that creates record instances and
puts them into an IOC Database (IOCDB).</p>

<h3 id="org.epics.3">org.epics.ioc.ca</h3>

<p>This package is Channel Access for a javaIOC.</p>

<h3 id="org.epics.4">org.epics.ioc.util</h3>
This package provides utility code for a javaIOC: 
<dl>
  <dt>Message Support</dt>
    <dd>This is an interface for passing messages to a requester of many
      services.</dd>
  <dt>Time Stamp support</dt>
    <dd>Support is provided to make it easier to work with time stamps.</dd>
  <dt>Scan Field Support</dt>
    <dd>Support that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
  <dt>XML Reader</dt>
    <dd>Support for reading XML Database Definition and Record Instance
      files. It is an abstraction above Java SAX (Simple API for XML). It
      implements macro substitution and include.</dd>
</dl>

<h3 id="org.epics.5">org.epics.ioc.support</h3>

<p>Each field of a javaIOC record can optionally have processing support.
This package provides interfaces and classes for processing fields of IOC
database records. It defines the following interfaces:</p>
<dl>
  <dt>Support</dt>
    <dd>The interfaces and classes that provide the core for support.</dd>
  <dt>ScanSupport</dt>
    <dd>An extension of Support for field scan.</dd>
  <dt>AlarmSupport</dt>
    <dd>An extension of Support for field alarm and for calculation
    alarms.</dd>
  <dt>Linear Conversion</dt>
    <dd>An extension of Support for Linear conversions.</dd>
  <dt>Noop Support</dt>
    <dd>Support that does nothing except complete normally.</dd>
  <dt>CalculationSupport</dt>
    <dd>An extension of Support for field calculation of a calc record or
      structure.</dd>
  <dt>CALinkFactory</dt>
    <dd>Support for links to other records.</dd>
  <dt>LinkArrayFactory</dt>
    <dd>Support for an array of links.</dd>
  <dt>LinkFactory</dt>
    <dd>Support for a structure that has a single field which is a link</dd>
  <dt>DelayLinkFactory</dt>
    <dd>Support that simulates asynchronous support</dd>
</dl>

<p>In addition the following classes are provided:</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>A base class that is extended by most support code. It implements all
      of the Support methods.</dd>
  <dt>AbstractLinkSupport</dt>
    <dd>A base class that extends AbstractSupport to also implement
      LinkSupport.</dd>
</dl>

<h3 id="org.epics.6">org.epics.ioc.recordSupport</h3>

<p>This package provides the following support factories:</p>
<dl>
  <dt style="font-family: courier;">DoubleFactory</dt>
    <dd>Supports structure and recordType double. It can also be used for
      other structure or recordTypes that have some combination of the
      supported fields.</dd>
  <dt style="font-family: courier;">IncrementalDoubleFactory</dt>
    <dd>In addition to what DoubleFactory provides this support provides
      support for incremental output and limits.</dd>
  <dt style="font-family: courier;">IntFactory</dt>
    <dd>Supports structure and recordType int. It can also be used for other
      structure or recordTypes that have some combination of the supported
      fields.</dd>
  <dt style="font-family: courier;">EventFactory</dt>
    <dd>Supports recordType event. It can also be used by other structure or
      recordTypes that have the required fields.</dd>
  <dt style="font-family: courier;">CalcFactory</dt>
    <dd>Supports structure or recordTypes that have fields appropriate for
      perform calculations.</dd>
  <dt style="font-family: courier;">PowerSupplyFactory</dt>
    <dd>An example of support for a complex device.</dd>
</dl>

<h3 id="org.epics.7">org.epics.ioc.process</h3>

<p>This package provides support for processing IOC database records. It
defines the following interfaces:</p>
<dl>
  <dt>RecordProcess</dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt>SupportCreation</dt>
    <dd>An interface for creating and initializing all support for a set of
      record instances.</dd>
</dl>

<p>It also has a number of interfaces implement by code that requests to be
notified about process or support events:</p>
<dl>
  <dt>RecordProcessRequester.</dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt>SupportProcessRequester</dt>
    <dd>Implemented by code that calls support.process.</dd>
  <dt>ProcessCallbackRequester</dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt>ProcessContinueRequester</dt>
    <dd>Implemented by code that call recordProcess.processContinue.</dd>
</dl>

<p>The following enum defines the support state:</p>
<dl>
  <dt>SupportState</dt>
    <dd>Specifies the current status of the support. For example is it ready
      for processing.</dd>
</dl>

<p>In addition the following classes are provided:</p>
<dl>
  <dt>RecordProcessFactory</dt>
    <dd>Implements RecordProcess.</dd>
  <dt>SupportCreationFactory</dt>
    <dd>Creates a process Database.</dd>
</dl>

<h3 id="org.epics.8">org.epics.ioc.swtshell</h3>

<p>This is a GUI shell for an ioc. It is implemented via the Standard Widget
Toolkit. Getting Started explains how to invoke it.</p>

<h3 id="javaIOC">javaIOC/dbd</h3>

<p>In javaIOC there is a directory dbd, which has database Definitions for
everything implemented by javaIOC.</p>
<hr />

<h2 style="text-align: center" id="Database">Database Syntax</h2>
<hr />

<p>The syntax for both Database Definitions (menu, structure, recordType,
etc) and Record Instance Definitions is XML based. In addition XML based
macro substitution and include is supported. Package org.epics.ioc.util
provides XML support with the following features:</p>
<ul>
  <li>Include and Macro Substitution are handled automatically.<br />
    NOTE: include and substitute are reserved words.</li>
  <li>xml namespaces are not support.</li>
  <li>Although the implementation uses SAX, the user code only implements
    IOCXMLListener and uses IOCXMLReader.</li>
  <li>The support is used by XMLToDBDFactory and by XMLToIOCDBFactory and can
    be used by other code.</li>
</ul>

<h3 style="text-align: center" id="Include">Include and Macro
Substitution</h3>

<h4 id="Syntax">Syntax</h4>

<p>An xml file can include other xml files. All files must be valid xml files
and must have the same root element name. An include statement has the
format:</p>
<pre>&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h4 id="Example">Example</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "aiRecord"&gt;
    &lt;aiInput structureName = "aiLinear" &gt;
        &lt;aiRaw&gt;
            &lt;input supportName = "inputLink"&gt;
                &lt;configure structureName = "inputLink"&gt;
                    &lt;pvname&gt;${pvname}&lt;/pvname&gt;
                    &lt;wait&gt;true&lt;/wait&gt;
                &lt;/configure&gt;
            &lt;/input&gt;
        &lt;/aiRaw&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;displayLimit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/displayLimit&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/aiInput&gt;
    &lt;priority&gt;medium&lt;/priority&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/pvAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h3 style="text-align: center" id="Database1">Database Definition</h3>

<p>This section provides a brief description of database definitions. See
package org.epics.ioc.dbd for complete details.</p>

<h4 id="Basic">Basic Syntax</h4>

<p>Database definitions consist of the following definition types: <span
style="font-family: courier;">menu</span>, <span
style="font-family: courier;">structure</span>, <span
style="font-family: courier;">support</span>, and <span
style="font-family: courier;">recordType.</span></p>

<p>An example menu definition is:</p>
<pre>    &lt;menu name = "menuAlarmSevr"&gt;
        &lt;choice&gt;none&lt;/choice&gt;
        &lt;choice&gt;minor&lt;/choice&gt;
        &lt;choice&gt;major&lt;/choice&gt;
        &lt;choice&gt;invalid&lt;/choice&gt;
    &lt;/menu&gt;</pre>

<p>A menu definition consists of a name and a set of choices.</p>

<p>An example structure definition is:</p>
<pre>    &lt;structure name = "displayLimit"&gt;
        &lt;field name = "low" type = "double" /&gt;
        &lt;field name = "high" type = "double" /&gt;
    &lt;/structure&gt;</pre>

<p>A structure definition consists of a name and a set of field definitions.
More details about field definitions are provided below. A structure
definition can also optionally define associated support as follows:</p>
<pre>    &lt;struucture name = "name" supportName = "supportName" &gt;
       ...
    &lt;/structure&gt;</pre>

<p>The supportName must be the same as a name in a support definition.</p>

<p>A support or linkSupport definition associates a Java Factory class with a
support name. A linkSupport can also specify a configuration structure. An
example linkSupport definition is:</p>
<pre>    &lt;linkSupport name = "processLink"
         configurationStructureName = "processLink" 
         factoryName = "org.epics.ioc.support.CALinkFactory"/&gt;</pre>

<p>A support definition consists of:</p>
<ul>
  <li>name 
    <p>Provides a way to match support to a structure, recordType, or a field
    of a structure.</p>
  </li>
  <li>configurationStructureName 
    <p>linkSupport only. The name of a structure definition. The structure
    provides configuration information for the support.</p>
  </li>
  <li>factoryName 
    <p>The name of a factory that creates support instances.</p>
  </li>
</ul>

<p>An example recordType definition is:</p>
<pre>&lt;recordType name = "example" supportName = "doubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "displayLimit" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;

&lt;/recordType&gt;</pre>

<p>A recordtype definition consists of a name, default record support, and a
set of field definitions. A recordType is just the top level structure for a
record instance.</p>

<h4 id="Field">Field Syntax</h4>

<p>Both structure and recordType definitions define a set of field
definitions. A field definition has the format:</p>
<pre>    &lt;field name = "value" type = "type"  ...&gt;</pre>
where supportName is optional and "..." represents other attributes. The
complete set of attributes are: 
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>the field name. This must be defined.</dd>
  <dt style="font-family: courier;">type</dt>
    <dd>The field type which must be defined and must be one of:<br />
      boolean,byte,short,int,long,float,double,string,enum,menu,link,structure,array</dd>
  <dt>supportName</dt>
    <dd>The name of support for the field. A matching support definition must
      be available during IOC initialization.</dd>
  <dt style="font-family: courier;">menuName</dt>
    <dd>must be given if the type is menu.</dd>
  <dt style="font-family: courier;">structureName</dt>
    <dd>can be given if the type is structure. If not given the structure
      must be specified when a field instance is created.</dd>
  <dt style="font-family: courier;">elementType</dt>
    <dd>must be specified if the type is array. It can be any of the
      supported types.</dd>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the field is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
  <dt><span style="font-family: courier">design</span></dt>
    <dd>Should a Database Configuration Tool allow the field to be configured
      at design time? Takes the value true if not specified.</dd>
  <dt><span style="font-family: courier">link</span></dt>
    <dd>This is only valid for string fields. If true the field is the name
      of a channel, i.e. a link to record. This is for use by Database
      Configuration Tools. Takes the value false if not specified.</dd>
  <dt><span style="font-family: courier">asl</span></dt>
    <dd>Channel Access security level for this field, 0 or 1. Takes the value
      1 if not specified.</dd>
</dl>

<h4 id="Property">Property Syntax</h4>
A structure, recordType, and field can have properties. A property is defined
as: 
<pre>    &lt;property name = "name" associatedField = "field name" /&gt;</pre>
where 
<dl>
  <dt>name</dt>
    <dd>The name of the property</dd>
  <dt>associatedField</dt>
    <dd>The name of a field that has the value for the property. Examples are
      given later in this document. An associatedField must be one of the
      following: 
      <dl>
        <dt>/name</dt>
          <dd>If the associatedField value starts with '/' then the search
            will start at the record not with the field that has the
          property.</dd>
        <dt>name</dt>
          <dd>The name of a structure field.</dd>
        <dt>name1.name2</dt>
          <dd>name1 must be the name of a structure field. name2 must be a
            property or field in the structure field.</dd>
      </dl>
    </dd>
</dl>

<p>For example:</p>
<pre>    &lt;field name = "value" type = "double"&gt;
        &lt;property name = "status" associatedField = "status" /&gt;
        &lt;property name = "severity" associatedField = "severity" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
    &lt;/field&gt;</pre>

<h4 id="Example1">Example Structure, Menu, and Support Definitions</h4>

<p>The following are examples of menu and structure definitions. These are
taken from menuStructureSupport.xml which resides in javaIOC/dbd:</p>
<pre>&lt;menu name = "priority"&gt;
    &lt;choice&gt;lowest&lt;/choice&gt;
    &lt;choice&gt;lower&lt;/choice&gt;
    &lt;choice&gt;low&lt;/choice&gt;
    &lt;choice&gt;middle&lt;/choice&gt;
    &lt;choice&gt;high&lt;/choice&gt;
    &lt;choice&gt;higher&lt;/choice&gt;
    &lt;choice&gt;highest&lt;/choice&gt;
&lt;/menu&gt;</pre>
<pre>&lt;menu name = "alarmSeverity"&gt;
    &lt;choice&gt;none&lt;/choice&gt;
    &lt;choice&gt;minor&lt;/choice&gt;
    &lt;choice&gt;major&lt;/choice&gt;
    &lt;choice&gt;invalid&lt;/choice&gt;
&lt;/menu&gt;</pre>

<p>The following are some example structure definitiond.</p>
<pre>&lt;structure name = "doubleLimit"&gt;
    &lt;field name = "low" type = "double" /&gt;
    &lt;field name = "high" type = "double" /&gt;
&lt;/structure&gt;</pre>
<pre>&lt;structure name = "linearConvert"&gt;
    &lt;field name = "engUnitsLow" type = "double" /&gt;
    &lt;field name = "engUnitsHigh" type = "double" /&gt;
    &lt;field name = "deviceHigh" type = "int" /&gt;
    &lt;field name = "deviceLow" type = "int" /&gt;
    &lt;field name = "slope" type = "double" /&gt;
    &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;</pre>
<pre>&lt;structure name = "timeStamp"&gt;
    &lt;field name = "secondsPastEpoch" type = "long" /&gt;
    &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<p>The following are definitions for the scan field.</p>
<pre>&lt;menu name = "scan"&gt;
    &lt;choice&gt;passive&lt;/choice&gt;
    &lt;choice&gt;event&lt;/choice&gt;
    &lt;choice&gt;periodic&lt;/choice&gt;
&lt;/menu&gt;

&lt;structure name = "scan"&gt;
    &lt;field name = "priority" type = "menu" menuName = "priority" default = "middle" /&gt;
    &lt;field name = "scan" type = "menu" menuName = "scan" default = "passive" /&gt;
    &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
    &lt;field name = "eventName" type = "string" /&gt;
    &lt;field name = "processSelf" type = "boolean" /&gt;
&lt;/structure&gt;</pre>

<p>The following define configuration structures for link fields for database
and channel access links:</p>
<pre>&lt;structure name = "processLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "inputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "outputLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "process" type = "boolean" /&gt;
    &lt;field name = "inheritSeverity" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "monitorLink"&gt;
    &lt;field name = "pvname" type = "string" link = "true" /&gt;
    &lt;field name = "type" type = "menu" menuName = "monitorType" default = "change" /&gt;
    &lt;field name = "deadband" type = "double" /&gt;
    &lt;field name = "onlyWhileProcessing" type = "boolean" /&gt;
    &lt;field name = "queueSize" type = "int"  default = "3" /&gt;
    &lt;field name = "reportOverrun" type = "boolean" /&gt;
    &lt;field name = "process" type = "boolean"&gt;
        &lt;!-- process this record when monitor occurs --&gt;
    &lt;/field&gt;
    &lt;field name = "inheritSeverity" type = "boolean" &gt;
        &lt;!-- only applicable if process is true --&gt;
    &lt;/field&gt;
&lt;/structure&gt;</pre>

<p>The following, which is not currently supported, defines fields for a V3
style disable link:</p>
<pre>&lt;structure name = "disableLink"&gt;
    &lt;field name = "disabled" type = "boolean" /&gt;
    &lt;field name = "value" type = "short" default = "1" /&gt;
    &lt;field name = "input" type = "short" /&gt;
    &lt;field name = "link" type = "link" /&gt;
    &lt;field name = "disableAlarmSeverity"
           type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<p>The following is for interfacing to hardware, V4 will provide support for
asynDriver style interfaces. The record support provided with the base
javaIOC will use these as well as the soft link support interfaces.</p>
<pre>&lt;structure name = "asynLink" structureSupportName = "org.epics.ioc.support.AsynLink"&gt;
    &lt;field name = "portName" type = "string" /&gt;
    &lt;field name = "addr" type = "int" /&gt;
    &lt;field name = "timeout" type = "double" /&gt;
&lt;/structure&gt;
&lt;linkSupport name = "asynLink" configStructureName = "asynLink" /&gt;</pre>

<h4 id="Record">Record Type Examples</h4>

<p>A sample record type definition was presented above. The last section
discusses some possibilities for defining complex devices.</p>

<h3 style="text-align: center" id="Record1">Record Instance Definition</h3>

<h4 id="Syntax1">Syntax</h4>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p>If the recordSupport name is not specified then the record support
specified in the recordType definition is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<h4 id="Example2">Example</h4>
<pre>&lt;record name = "double01" type = "doubleRecord"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;counter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
    &lt;units&gt;volts&lt;/units&gt;
    &lt;displayLimit&gt;
        &lt;low&gt;0.0&lt;/low&gt;
        &lt;high&gt;10.0&lt;/high&gt;
    &lt;/displayLimit&gt;
&lt;/record&gt;</pre>
<hr />

<h2 style="text-align: center" id="PVData">PVData</h2>
<hr />

<p>JavaIOC data is stored in a PVData (Process Variable) Database, which is a
collection of record instances. A record instance is a structured set of
fields. A JavaIOC implements interfaces for accessing fields of database
records. The interfaces are a combination of reflection ( what is a field)
and data (what does a field contain) interfaces. Each field has a type as
defined in the next section. See the package overview for org.epics.ioc.pv
for more information. This section just gives a brief summary.</p>

<h3 id="Field1">Field Types</h3>

<p>A Java enum defines the supported types.</p>
<pre>    public enum Type {
        pvUnknown,
        pvBoolean,
        pvByte,
        pvShort,
        pvInt,
        pvLong,
        pvFloat,
        pvDouble,
        pvString,
        pvEnum,
        pvStructure,
        pvArray,
        pvMenu,
        pvLink;
    }</pre>

<h3 id="PVData1">PVData Reflection</h3>

<p>The reflection interfaces for PVData are:</p>
<pre>    interface Property {
        String getPropertyName();
        String getAssociatedFieldName();
        String toString();
        String toString(int indentLevel);
    }

    public interface FieldAttribute {
        String getDefault();
        boolean isReadOnly();
        boolean isDesign();
        boolean isLink();
        int getAsl();
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    }

    interface Enum extends Field {
        boolean isChoicesMutable();
    }

    interface Menu extends Enum {
        String getMenuName();
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<h3 id="PVData2">PVData Interfaces</h3>

<p>The following describe the interfaces for accessing the data a field
contains.</p>

<p>The interfaces for accessing data are:</p>
<pre>    interface PVField {
         String getFullFieldName();
         Field getField(); // get the reflection interface
         PVField getParent();
         PVRecord getPVRecord();
         void replacePVField(PVField newPVField);
         String getSupportName();
         String setSupportName(String name);
         void asynAccessListenerAdd(AsynAccessListener asynAccessListener);
         void asynAccessListenerRemove(AsynAccessListener asynAccessListener);
         void asynAccessCallListeners(boolean begin);
         boolean asynModifyStart(Object asynModifier);
         void asynModifyEnd(Object asynModifier);
         boolean isAsynModifyActive();
         String toString();
         String toString(int indentLevel);
    }
    interface PVBoolean extends PVField{
        boolean get();
        void put(boolean value);
    }
    //   similar interfaces for other primitve types
    interface PVString extends PVField{
        String get();
        void put(String value);
    }
    interface PVEnum extends PVField{
        Enum getEnum();
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }
    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getFieldPVFields();
    }
    public interface PVMenu extends PVEnum {
        Menu getMenu();
    }
    public interface PVLink extends PVField {
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }
    interface PVArray extends PVField{
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
    }
    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray{
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }
    // ... for arrays of other pv Types
    public interface PVRecord extends PVStructure {
        String getRecordName();
        void message(String message, MessageType messageType);
    }</pre>

<h3 id="Example3">Example: Database Access via Reflection</h3>
An interface IOCDB provides a method that locates the interface for a record
instance. For example, to locate the ai record the call is: 
<pre>    DBRecord dbRecord = iocdb.findRecord("ai");</pre>

<p>Starting with this the data in the value field can be read as follows:</p>
<pre>    PVRecord pvRecord = dbRecord.getPVRecord();
    PVField[] pvField = pvRecord.getPVStructure().getFieldPVFields();
    Structure structure = (Structure)pvRecord.getField();
    int index = structure.getFieldIndex("value");
    assert(pvField[index].getField().getType==Type.dbDouble);
    PVDouble valueData= (PVDouble)pvField[index];
    double value = valueData.get();</pre>

<p>The data for ai.input.rawValue can also be located and read via reflection
as follows:</p>
<pre>    PVRecord pvRecord = dbRecord.getPVRecord();
    PVField[] pvField = pvRecord.getPVStructure().getFieldPVFields();
    Structure structure = (Structure)pvRecord.getField();
    int index = structure.getFieldIndex("input");
    assert(pvField[index].getField().getType()==Type.pvStructure);
    PVStructure pvStructure = (PVStructure)pvField[index];
    Structure aiLinearStructure = (Structure)pvStructure.getField();
    index = aiLinearStructure.getFieldIndex("rawValue");
    pvField = pvStructure.getFieldPVdatas();
    assert(pvField[index].getField().getType==Type.pvInt);
    PVInt valueData = (PVInt)pvField[index];
    int value = valueData.get();</pre>

<p>The next section provides an easier way to find the data interfaces for a
field.</p>

<h3 id="PVAccess">PVAccess</h3>

<p>PVAccess is an interface for locating PVField interfaces. A PVAccess can
be created via:</p>
<pre>    PVAccess pvAccess = PVAccessFactory.create(instanceName);</pre>
Where instanceName is a Java String. For example: 
<pre>    PVAccess pvAccess = PVAccessFactory.create("ai");</pre>

<p>PVAccess provides the following methods:</p>
<pre>    interface PVAccess {
        PVRecord getPVRecord();
        PVField findField(String name);
        void setPVField(PVField pvField);
    }

    public class PVAccessFactory {
        public static PVAccess createPVAccess(PVRecord pvRecord);
    }</pre>

<p>The argument to findField(name) has the form:</p>
<pre>    name.name...</pre>
Each <span style="font-family: courier;">name</span> is the name of a
property or a field. For example: 
<pre>    PVAccess pvAccess = PVAccessFactory.create("ai");
    ChannelField channelField = pvAccess.findField("value.status");</pre>

<p>Locates the status property of the value field in record ai.</p>

<h2 style="text-align: center" id="DBData">DBData Interfaces</h2>

<p>See package org.epics.ioc.db for details about the interfaces shown in
this section, which just shows the interfaces.</p>

<p>The DBData interfaces provide:</p>
<ul>
  <li>Access to the PV interfaces</li>
  <li>Access to Support interfaces</li>
  <li>Record locking</li>
  <li>Record monitoring</li>
</ul>

<p>The interfaces are:</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        void addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        List&lt;RecordListener&gt; getRecordListenerList();
        String toString();
        String toString(int indentLevel);
    }

    public class BaseDBField implements DBField{ ... }

    public interface DBListener {
        void dataPut(DBField dbField);
        void enumIndexPut(DBEnum dbEnum);
        void enumChoicesPut(DBEnum dbEnum);
        void supportNamePut(DBField dbField);
        void configurationStructurePut(DBLink dbLink);
        void beginPut(DBStructure dbStructure);
        void endPut(DBStructure dbStructure);
        void dataPut(DBField requested,DBField dbField);
        void enumIndexPut(DBField requested,DBEnum dbEnum);
        void enumChoicesPut(DBField requested,DBEnum dbEnum);
        void supportNamePut(DBField requested,DBField dbField);
        void configurationStructurePut(DBField requested,DBLink dbLink);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }

    public interface DBEnum extends DBField {
        PVEnum getPVEnum();
        void replacePVEnum();
        int getIndex();
        void setIndex(int index);
        String[] getChoices();
        boolean setChoices(String[] choice);
    }

    public class BaseDBEnum extends BaseDBField implements DBEnum {...}

    public interface DBMenu extends DBEnum {
        PVMenu getPVMenu();
        void replacePVMenu();
    }

    public class BaseDBMenu extends BaseDBEnum implements DBMenu{ ... }

    public interface DBLink extends DBField{
        PVLink getPVLink();
        void replacePVLink();
        PVStructure getConfigurationStructure();
        boolean setConfigurationStructure(PVStructure pvStructure);
    }

    public class BaseDBLink extends BaseDBField implements DBLink { ... }

    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        void replacePVStructure();
        DBField[] getFieldDBFields();
        void beginPut();
        void endPut();
    }

    public class BaseDBStructure extends BaseDBField implements DBStructure{ ... }

    public interface DBNonScalarArray extends DBField{
        void replacePVArray();
        DBField[] getElementDBFields();
    }

    public class BaseDBNonScalarArray extends BaseDBField
    implements DBNonScalarArray{...}

    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void removeRecordListeners();
        void addListenerSource(BaseDBField dbField);
        DBD getDBD();
        void setDBD(DBD dbd);
        IOCDB getIOCDB();
        void setIOCDB(IOCDB iocdb);
    }</pre>
<hr />

<h2 style="text-align: center" id="Record2">Record Processing</h2>
<hr />

<p>Package org.epics.ioc.process describes and implements code directly
related to record processing. The package overview has a section "Record
Processing: Theory of Operation" that provides a description of record
processing.</p>
<hr />

<h2 style="text-align: center" id="Channel">Channel Access</h2>
<hr />

<p>Package org.epics.ioc.ca describes Channel Access for a JavaIOC. See it
for details. Some features are:</p>
<ul>
  <li>Local Channel Access is implemented. Remote is not implemented.</li>
  <li>Channel Access Database Link support is implemented.</li>
  <li>Get, Put, and PutGet are all supported. Each can optionally process the
    record. Each can access a group of fields in a record instance. Structure
    and Array fields can be accessed. Each provides an option to process the
    record.</li>
  <li>MonitorNotify is supported. In this case the client is notified of
    changes but must issue a get to retrieve the data.</li>
  <li>Monitor is supported. A monitor includes the data which has changed.
    Any group of fields within a record instance can be monitored. Structure
    and Array fields can be monitored including an entire record instance.
    For numeric scalar fields onChange, absoluteChange, and percentChange are
    all supported.</li>
</ul>
<hr />

<h2 style="text-align: center" id="Generic">Generic Device Support</h2>
<hr />

<p>This section shows how record types and support can be defined to
implement generic device support. It</p>
<ul>
  <li>starts with a recordType, structure, and support for a double.</li>
  <li>Extends this to support ADC (Analog to Digital Converter) input and DAC
    (Digital to Analog Converter) output.</li>
  <li>Extends this to support a power supply controller</li>
</ul>

<h3 style="text-align: center" id="Database2">Database Definitions</h3>

<p>XML definitions are provided for:</p>
<dl>
  <dt>doubleCommon</dt>
    <dd>Defines fields common to structure "double" and recordType
    "double"</dd>
  <dt>doubleRecord</dt>
    <dd>Defines structure "double" and recordType "double" and support
      "doubleRecord"</dd>
  <dt>aiDoubleCommon</dt>
    <dd>Defines fields common to structure "aiDouble" and recordType
      "aiDouble"</dd>
  <dt>aiDoubleRecord</dt>
    <dd>Defines structure "aiDouble" and recordType "aiDouble"</dd>
  <dt>aoDoubleCommon</dt>
    <dd>Defines fields common to structure "aoDouble" and recordType
      "aoDouble"</dd>
  <dt>aoDoubleRecord</dt>
    <dd>Defines structure "aoDouble" and recordType "aoDouble"</dd>
  <dt>powerSupplyRecord</dt>
    <dd>Defines recordType "powerSupply" and support "powerSupplyRecord"</dd>
</dl>

<h4 id="doubleComm">doubleCommon</h4>

<p>The following defines the fields that are common to both recordType double
and structure double.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "doubleAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "output" type = "link" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="doubleReco">doubleRecord</h4>

<p>The following defines both a recordType and a structure named "double". It
also defines a support named "doubleRecord". The same support is the default
support for both the structure and for the recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "double" supportName = "doubleRecord" &gt;
    &lt;include href = "doubleCommon.xml" /&gt;
&lt;/structure&gt;
&lt;recordType name = "double" supportName = "doubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;include href = "doubleCommon.xml" /&gt;
&lt;/recordType&gt;

&lt;support name = "doubleRecord"
   factoryName = "org.epics.ioc.recordSupport.DoubleFactory" /&gt;</pre>

<h4 id="aiDoubleCo">aiDoubleCommon</h4>

<p>The following defines the fields that are common to both recordType
aiDouble and structure aiDouble.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "structure" structureName = "linearConvertInput"/&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "doubleAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="aiDoubleRe">aiDoubleRecord</h4>

<p>The following defines both a recordType and a structure named "aiDouble".
doubleRecord is the default support for both the structure and for the
recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "aiDouble" supportName = "doubleRecord" &gt;
    &lt;include href = "aiDoubleCommon.xml" /&gt;
&lt;/structure&gt;
&lt;recordType name = "aiDouble" supportName = "doubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;include href = "aiDoubleCommon.xml" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="aoDoubleCo">aoDoubleCommon</h4>

<p>The following defines the fields that are common to both recordType
aoDouble and structure aoDouble.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "value" type = "double" &gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "controlLimit" associatedField = "controlLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "output" type = "structure" structureName = "linearConvertOutput"/&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "doubleAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="aoDoubleRe">aoDoubleRecord</h4>

<p>The following defines both a recordType and a structure named "aoDouble".
doubleRecord is the default support for both the structure and for the
recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "aoDouble" supportName = "doubleRecord" &gt;
    &lt;include href = "aoDoubleCommon.xml" /&gt;
&lt;/structure&gt;
&lt;recordType name = "aoDouble" supportName = "doubleRecord" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;include href = "aoDoubleCommon.xml" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="powerSuppl">powerSupply</h4>

<p>The followig are definitions for a recordType named "powerSupply" and for
support "powerSupplyRecord".</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "dbd" /&gt;
&lt;recordType name = "powerSupply" supportName = "powerSupplyRecord" &gt;
    &lt;property name = "value" associatedField = "power" /&gt;
    &lt;include href = "common.xml" /&gt;
    &lt;field name = "power" type = "double" &gt;
        &lt;property name = "voltage" associatedField = "voltage" /&gt;
        &lt;property name = "current" associatedField = "current" /&gt;
        &lt;property name = "alarm" associatedField = "alarm" /&gt;
        &lt;property name = "units" associatedField = "units" /&gt;
        &lt;property name = "displayLimit" associatedField = "displayLimit" /&gt;
        &lt;property name = "timeStamp" associatedField = "/timeStamp" /&gt;
    &lt;/field&gt;
    &lt;field name = "input" type = "link" /&gt;
    &lt;field name = "doubleAlarm" type = "link" supportName = "doubleAlarm" /&gt;
    &lt;field name = "voltage" type = "double" /&gt;
    &lt;field name = "voltageInput" type = "structure" structureName = "link" /&gt;
    &lt;field name = "current" type = "double" /&gt;
    &lt;field name = "currentOutput" type = "structure" structureName = "link" /&gt;
    &lt;field name = "output" type = "link" /&gt;
    &lt;field name = "linkArray" type = "array"
         elementType = "structure" supportName = "linkArray" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "displayLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
&lt;/recordType&gt;

&lt;support name = "powerSupplyRecord"
   factoryName = "org.epics.ioc.recordSupport.PowerSupplyFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h3 style="text-align: center" id="Support">Support Implementation</h3>

<p>The example uses the following support</p>
<ul>
  <li>doubleRecord</li>
  This is used by record types double, aiDouble, and aoDouble. It is also
  used by the embeded powerSupply example for voltageInput and currentOutput.
  It works for all these types because the only thing it does is: 
  <li>Have access to a value field. It can have access either by some other
    support calling it's setField method or by locating a field named
  "value"</li>
  <li>looks for support for fields named "input", "doubleAlarm", "output",
    and "linkArray". If a field does not exist or does not have support the
    field is ignored. If it does exist and has support, the support is
    called. Thus doubleRecord is generic.</li>
</ul>
<ul>
  <li>powerSupplyRecord</li>
</ul>
<dl>
    <dd>Requires fields power, voltage, and current. If a field named
      "voltageInput" has support it is called. If a field names
      "currentOutput" has support it is called. When it processes it computes
      current from power and voltage.</dd>
</dl>
<ul>
  <li>linearConvertInput</li>
</ul>
<dl>
    <dd>Implements linear conversion from a rawValue to engineering
    units.</dd>
</dl>
<ul>
  <li>linearConvertOutput</li>
</ul>
<dl>
    <dd>Implements linear conversion from engineering units to a
    rawValue.</dd>
</dl>
<ul>
  <li>CALinkSupport</li>
</ul>
<dl>
    <dd>JaveIOC implements channel access links between records.</dd>
</dl>
<ul>
  <li>asyn Support</li>
</ul>
<dl>
    <dd>This is not implemented but will be asynDriver converted to the
      JavaIOC.</dd>
</dl>

<h3 style="text-align: center" id="Record3">Record Instance Examples</h3>

<h4 id="doubleInpu">doubleInput</h4>

<p>The following creates a record instance of type double. It is an input
record because input is initialized to a Channel Access inputLink.</p>
<pre>&lt;record name = "doubleInput" type = "double"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
&lt;/record&gt;</pre>

<h4 id="doubleOutp">doubleOutput</h4>

<p>The following creates a record instance of type double. It is an output
record because input is initialized to a Channel Access outputLink.</p>
<pre>&lt;record name = "doubleOutput" type = "double"&gt;
    &lt;output supportName = "outputLink" &gt;
        &lt;configure structureName = "outputLink"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h4 id="ai">ai</h4>

<p>The following creates an instance of an aiRecord. The raw ADC value is
read via asyn support and converted via linearConvertInput support.</p>
<pre>&lt;record name = "ai" type = "aiDouble" &gt;
    &lt;input&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;input supportName = "asynLink" &gt;
            &lt;configure structureName = "asynLink"&gt;
                &lt;portName&gt;somePort&lt;/portName&gt;
                &lt;addr&gt;0&lt;/addr&gt;
            &lt;/configure&gt;
        &lt;/input&gt;

    &lt;/input&gt;
&lt;/record&gt;</pre>

<h4 id="ao">ao</h4>

<p>The following creates an instance of an aoRecord. The value is converted
via linearConvertInput support to a rawValue which is written via asyn
support.</p>
<pre>&lt;record name = "ao" type = "aoDouble" &gt;
    &lt;output&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;output supportName = "asynLink" &gt;
            &lt;configure structureName = "asynLink"&gt;
                &lt;portName&gt;somePort&lt;/portName&gt;
                &lt;addr&gt;0&lt;/addr&gt;
            &lt;/configure&gt;
        &lt;/output&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h4 id="psSimple">psSimple</h4>

<p>The following creates a powerSupply instance that does no input or output.
The voltage and power must be written via channel access.</p>
<pre>&lt;record name = "psSimple" type = "powerSupply" &gt;
    &lt;voltage&gt;10.0&lt;/voltage&gt;
&lt;/record</pre>

<h4 id="psLinked">psLinked</h4>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via channel access.</p>
<pre>&lt;record name = "psLinked" type = "powerSupply" &gt;
    &lt;voltageInput&gt;
        &lt;link supportName = "inputLink"&gt;
            &lt;configure structureName = "inputLink"&gt;
                &lt;pvname&gt;voltage&lt;/pvname&gt;
                &lt;process&gt;false&lt;/process&gt;
            &lt;/configure&gt;
        &lt;/link&gt;
    &lt;/voltageInput&gt;
    &lt;currentOutput&gt;
        &lt;link supportName = "outputLink"&gt;
            &lt;configure structureName = "outputLink"&gt;
                &lt;pvname&gt;current&lt;/pvname&gt;
                &lt;process&gt;true&lt;/process&gt;
            &lt;/configure&gt;
        &lt;/link&gt;
    &lt;/currentOutput&gt;
&lt;/record&gt;</pre>

<h4 id="psEmbeded">psEmbeded</h4>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via embeded support.</p>
<pre>&lt;record name = "psEmbeded" type = "powerSupply" &gt;
    &lt;voltageInput structureName = "aiDouble" &gt;
        &lt;input&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;input supportName = "asynLink" &gt;
                &lt;configure structureName = "asynLink"&gt;
                    &lt;portName&gt;inputPort&lt;/portName&gt;
                &lt;/configure&gt;
            &lt;/input&gt;

        &lt;/input&gt;
    &lt;/voltageInput&gt;
    &lt;currentOutput structureName = "aoDouble" &gt;
        &lt;output&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;output supportName = "asynLink" &gt;
                &lt;configure structureName = "asynLink"&gt;
                    &lt;portName&gt;outputPort&lt;/portName&gt;
                &lt;/configure&gt;
            &lt;/output&gt;

        &lt;/output&gt;
    &lt;/currentOutput&gt;
&lt;/record&gt;</pre>
<hr />

<h2 style="text-align: center;text-align: center;" id="License">License
Agreement</h2>
<pre>Copyright (c) 2006 All rights reserved 
The University of Chicago, as Operator of Argonne National Laboratory,
    (UofC) Chicago Ilinois, USA,
Deutsches Elektronen-Synchroton, Member of the Helmholtz Association,
    (DESY), HAMBURG, GERMANY,
BERLINER SPEICHERRING GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H.
    (BESSY), BERLIN, GERMANY.

EPICS JavaIOC is distributed subject to the following license conditions:

 SOFTWARE LICENSE AGREEMENT
 Software: EPICS JavaIOC
 Versions: All

 1. The "Software", below, refers to EPICS JavaIOC (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.


________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
