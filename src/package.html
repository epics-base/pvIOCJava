<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br
/>
2008.02.08</h1>

<p>This product is available via the <a href="#LicenseAgreement">open source
license</a> described at the end of this document.</p>

<p>This document has three parts:</p>
<ul>
  <li>Part I is a brief description of the javaIOC.</li>
  <li>Part II describes the javaIOC Data Model. The model 1) supports general
    purpose tools and 2) is used by the javaIOC support code.</li>
  <li>Part III is a description of the Database Definitions that come with
    javaIOC.</li>
</ul>

<p>CONTENTS</p>

<div class="toc">
<ul>
  <li><a href="#Part">Part I: javaIOC - Brief Description</a> 
    <ul>
      <li><a href="#Overview">Overview Of Part I</a> 
        <ul>
          <li><a href="#Getting">Getting Started</a></li>
          <li><a href="#Status">Status and Remaining Tasks</a></li>
        </ul>
      </li>
      <li><a href="#Package">Package Summary</a> 
        <ul>
          <li><a href="#default">default - javaIOC/src</a></li>
          <li><a href="#javaIOC">javaIOC/dbd</a></li>
          <li><a href="#javaIOC1">javaIOC/example</a></li>
          <li><a href="#org.epics.">org.epics.ioc.pv</a></li>
          <li><a href="#org.epics.1">org.epics.ioc.dbd</a></li>
          <li><a href="#org.epics.2">org.epics.ioc.db</a></li>
          <li><a href="#org.epics.3">org.epics.ioc.ca</a></li>
          <li><a href="#org.epics.4">org.epics.ioc.util</a></li>
          <li><a href="#org.epics.5">org.epics.ioc.process</a></li>
          <li><a href="#org.epics.6">org.epics.ioc.create</a></li>
          <li><a href="#org.epics.7">org.epics.ioc.support</a></li>
          <li><a href="#org.epics.8">org.epics.ioc.pdrv<br />
            org.epics.ioc.pdrv/interfaces<br />
            org.epics.ioc.pdrv/testDriver<br />
            </a></li>
          <li><a href="#org.epics.9">org.epics.ioc.swtshell</a></li>
        </ul>
      </li>
      <li><a href="#Database">Database Syntax</a> 
        <ul>
          <li><a href="#Include">Include and Macro Substitution</a> 
            <ul>
              <li><a href="#Syntax">Syntax</a></li>
              <li><a href="#Example">Example</a></li>
            </ul>
          </li>
          <li><a href="#Database1">Database Definition</a> 
            <ul>
              <li><a href="#Basic">Basic Syntax</a></li>
              <li><a href="#Field">Field Syntax</a></li>
              <li><a href="#Example1">Example Structure, recordType, create,
                and Support Definitions</a></li>
            </ul>
          </li>
          <li><a href="#Record">Record Instance Definition</a> 
            <ul>
              <li><a href="#Syntax1">Syntax</a></li>
              <li><a href="#Example2">Example</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#PVData">PVData</a> 
        <ul>
          <li><a href="#Field1">Field Types</a></li>
          <li><a href="#PVData1">PVData Reflection</a></li>
          <li><a href="#PVData2">PVData Interfaces</a></li>
          <li><a href="#Example3">Example: Database Access via
          Reflection</a></li>
        </ul>
      </li>
      <li><a href="#DBData">DBData</a></li>
      <li><a href="#Channel">Channel Access</a></li>
      <li><a href="#Record1">Record Processing</a></li>
      <li><a href="#Database2">Database Examples</a> 
        <ul>
          <li><a href="#Database3">Database Definitions</a> 
            <ul>
              <li><a href="#doubleComm">doubleCommon</a></li>
              <li><a href="#doubleReco">doubleRecord</a></li>
              <li><a href="#powerSuppl">powerSupplyCommon</a></li>
              <li><a href="#powerSuppl1">powerSupplyRecord</a></li>
            </ul>
          </li>
          <li><a href="#Support">Support Implementation</a></li>
          <li><a href="#Record2">Record Instance Examples</a> 
            <ul>
              <li><a href="#doubleInpu">doubleInput</a></li>
              <li><a href="#doubleOutp">doubleOutput</a></li>
              <li><a href="#ai">ai</a></li>
              <li><a href="#ao">ao</a></li>
              <li><a href="#psSimple">psSimple</a></li>
              <li><a href="#psLinked">psLinked</a></li>
              <li><a href="#psEmbeded">psEmbeded</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Part1">Part II: javaIOC Data Model</a> 
    <ul>
      <li><a href="#Summary">Summary</a></li>
      <li><a href="#JavaIOC">JavaIOC Data Model</a> 
        <ul>
          <li><a href="#Basic1">Basic Concept</a></li>
          <li><a href="#structure">structure null</a></li>
          <li><a href="#getPropety">getPropety</a></li>
        </ul>
      </li>
      <li><a href="#Definition">Definitions for Standard Properties</a> 
        <ul>
          <li><a href="#timeStamp">timeStamp</a></li>
          <li><a href="#alarm">alarm</a></li>
          <li><a href="#display">display</a></li>
          <li><a href="#control">control</a></li>
          <li><a href="#history">history</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Part2">Part III: javaIOC - Database Definition</a> 
    <ul>
      <li><a href="#Overview1">Overview Of Part III</a></li>
      <li><a href="#javaIOC2">javaIOC/dbd</a> 
        <ul>
          <li><a href="#common.xml">common.xml</a></li>
          <li><a href="#structure.">structure.xml</a></li>
          <li><a href="#recordType">recordType.xml</a></li>
        </ul>
      </li>
      <li><a href="#structure1">dbd/structure/alarm.xml</a> 
        <ul>
          <li><a href="#numeric">numeric alarms</a></li>
          <li><a href="#boolean">boolean alarms</a></li>
          <li><a href="#enumerated">enumerated alarms</a></li>
        </ul>
      </li>
      <li><a href="#structure2">dbd/structure/analog.xml</a> 
        <ul>
          <li><a href="#linearConv">linearConvert</a></li>
          <li><a href="#linearConv1">linearConvertInput</a></li>
          <li><a href="#linearConv2">linearConvertOutput</a></li>
          <li><a href="#incrementa">incrementalDouble</a></li>
        </ul>
      </li>
      <li><a href="#structure3">dbd/structure/limit.xml</a></li>
      <li><a href="#structures">dbd/structures/display.xml</a></li>
      <li><a href="#structures1">dbd/structures/doubleHistory.xml</a></li>
      <li><a href="#structures2">dbd/structures/commonFields.xml</a></li>
      <li><a href="#structure4">dbd/structure/noop.xml</a></li>
      <li><a href="#structure5">dbd/structure/generic.xml</a></li>
      <li><a href="#structure6">dbd/structure/supportArray.xml</a></li>
      <li><a href="#support6">dbd/structure/channelAccess.xml</a> 
        <ul>
          <li><a href="#processSup">processSupport</a></li>
          <li><a href="#monitorSup">monitorSupport</a></li>
          <li><a href="#monitorNot">monitorNotifySupport</a></li>
          <li><a href="#inputSuppo">inputSupport</a></li>
          <li><a href="#outputSupp">outputSupport</a></li>
        </ul>
      </li>
      <li><a href="#structure7">dbd/structure/digital.xml</a> 
        <ul>
          <li><a href="#digitalSta">digitalState</a></li>
          <li><a href="#digital">digital</a></li>
        </ul>
      </li>
      <li><a href="#structure8">dbd/structure/event.xml</a></li>
      <li><a href="#structure9">dbd/structure/calc.xml</a></li>
      <li><a href="#structure10">dbd/structure/disable.xml</a></li>
      <li><a href="#structure11">dbd/structure/delay.xml</a></li>
      <li><a href="#structure12">dbd/structure/enumerated.xml</a></li>
      <li><a href="#structure13">dbd/structure/portDriver.xml</a> 
        <ul>
          <li><a href="#pdrvSuppor">pdrvSupport</a></li>
        </ul>
      </li>
      <li><a href="#recordType1">dbd/recordType/primitive</a> 
        <ul>
          <li><a href="#Overview2">Overview</a></li>
          <li><a href="#boolean1">boolean</a> 
            <ul>
              <li><a href="#booleanCom">booleanCommon.xml</a></li>
              <li><a href="#booleanRec">booleanRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#byte">byte</a> 
            <ul>
              <li><a href="#byteCommon">byteCommon.xml</a></li>
              <li><a href="#byteRecord">byteRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#short">short</a> 
            <ul>
              <li><a href="#shortCommo">shortCommon.xml</a></li>
              <li><a href="#shortRecor">shortRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#int">int</a> 
            <ul>
              <li><a href="#intCommon.">intCommon.xml</a></li>
              <li><a href="#intRecord.">intRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#long">long</a> 
            <ul>
              <li><a href="#longCommon">longCommon.xml</a></li>
              <li><a href="#longRecord">longRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#float">float</a> 
            <ul>
              <li><a href="#floatCommo">floatCommon.xml</a></li>
              <li><a href="#floatRecor">floatRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#double">double</a> 
            <ul>
              <li><a href="#doubleComm1">doubleCommon.xml</a></li>
              <li><a href="#doubleReco1">doubleRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#string">string</a> 
            <ul>
              <li><a href="#stringComm">stringCommon.xml</a></li>
              <li><a href="#stringReco">stringRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType2">dbd/recordType/primitiveArray</a> 
        <ul>
          <li><a href="#Overview3">Overview</a></li>
          <li><a href="#booleanArr">booleanArray</a> 
            <ul>
              <li><a href="#booleanArr1">booleanArrayCommon.xml</a></li>
              <li><a href="#booleanArr2">booleanArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#byteArray">byteArray</a> 
            <ul>
              <li><a href="#byteArrayC">byteArrayCommon.xml</a></li>
              <li><a href="#byteArrayR">byteArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#shortArray">shortArray</a> 
            <ul>
              <li><a href="#shortArray1">shortArrayCommon.xml</a></li>
              <li><a href="#shortArray2">shortArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#intArray">intArray</a> 
            <ul>
              <li><a href="#intArrayCo">intArrayCommon.xml</a></li>
              <li><a href="#intArrayRe">intArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#longArray">longArray</a> 
            <ul>
              <li><a href="#longArrayC">longArrayCommon.xml</a></li>
              <li><a href="#longArrayR">longArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#floatArray">floatArray</a> 
            <ul>
              <li><a href="#floatArray1">floatArrayCommon.xml</a></li>
              <li><a href="#floatArray2">floatArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#doubleArra">doubleArray</a> 
            <ul>
              <li><a href="#doubleArra1">doubleArrayCommon.xml</a></li>
              <li><a href="#doubleArra2">doubleArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#stringArra">stringArray</a> 
            <ul>
              <li><a href="#stringArra1">stringArrayCommon.xml</a></li>
              <li><a href="#stringArra2">stringArrayRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType3">dbd/recordType/analog</a> 
        <ul>
          <li><a href="#Overview4">Overview</a></li>
          <li><a href="#aoIncremen">aoIncrementalDouble</a> 
            <ul>
              <li><a
              href="#aoIncremen1">aoIncrementalDoubleCommon.xml</a></li>
              <li><a
              href="#aoIncremen2">aoIncrementalDoubleRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType4">dbd/recordType/enumerated</a> 
        <ul>
          <li><a href="#Overview5">Overview</a></li>
          <li><a href="#enumerated1">enumerated</a> 
            <ul>
              <li><a href="#enumerated2">enumeratedCommon.xml</a></li>
              <li><a href="#enumerated3">enumeratedRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType5">dbd/recordType/event</a> 
        <ul>
          <li><a href="#Overview6">Overview</a></li>
          <li><a href="#event">event</a> 
            <ul>
              <li><a href="#eventCommo">eventCommon.xml</a></li>
              <li><a href="#eventRecor">eventRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType6">dbd/recordType/calc</a> 
        <ul>
          <li><a href="#Overview7">Overview</a></li>
          <li><a href="#calcDouble">calcDouble</a> 
            <ul>
              <li><a href="#calcDouble1">calcDoubleCommon.xml</a></li>
              <li><a href="#calcDouble2">calcDoubleRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#calcDouble3">calcDoubleArray</a> 
            <ul>
              <li><a href="#calcDouble4">calcDoubleArrayCommon.xml</a></li>
              <li><a href="#calcDouble5">calcDoubleArrayRecord.xml</a></li>
            </ul>
          </li>
          <li><a href="#calcBoolea">calcBooleanArray</a> 
            <ul>
              <li><a href="#calcBoolea1">calcBooleanArrayCommon.xml</a></li>
              <li><a href="#calcBoolea2">calcBooleanArrayRecord.xml</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#recordType7">dbd/recordType/portDriver</a> 
        <ul>
          <li><a href="#Overview8">Overview</a></li>
          <li><a href="#portDriver">portDriver.xml</a></li>
        </ul>
      </li>
      <li><a href="#recordType8">dbd/recordType/powerSupply</a> 
        <ul>
          <li><a href="#Overview9">Overview</a></li>
          <li><a href="#powerSuppl2">powerSupplyCommon.xml</a></li>
          <li><a href="#powerSuppl3">powerSupplyRecord.xml</a></li>
          <li><a href="#powerSuppl4">powerSupplyArrayCommon.xml</a></li>
          <li><a href="#powerSuppl5">powerSupplyArrayRecord.xml</a></li>
        </ul>
      </li>
      <li><a href="#recordType9">dbd/recordType/allTypes</a> 
        <ul>
          <li><a href="#Overview10">Overview</a></li>
          <li><a href="#allTypesCo">allTypesCommon.xml</a></li>
          <li><a href="#allTypesRe">allTypesRecord.xml</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#License">License Agreement</a></li>
</ul>
</div>
<hr />
<hr />

<h2 style="text-align: center" id="Part">Part I: javaIOC - Brief
Description</h2>
<hr />
<hr />

<p>Part I describes the javaIOC. Detailed descriptions of the javaIOC
packages are provided with each package.</p>
<hr />

<h3 style="text-align: center" id="Overview">Overview Of Part I</h3>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for scientific
instruments such as a particle accelerators, telescopes and other large
scientific experiments. An IOC (Input/Output Controller) is a network node
that controls and/or monitors a collection of devices. An IOC contains a
memory resident real time database. The real time database has a set of
"smart" records. Each record is an instance on a record of a particular
type.</p>

<p>JavaIOC is a JAVA implementation of an IOC. It has many similarities to a
EPICS V3 ( the 3.13 and 3.14 releases of EPICS base) but extends the data
types to support structures and arrays. This document assumes that the reader
is familiar with EPICS V3.</p>

<p><span style="font-weight:bold;">WARNING</span>: JavaIOC is currently
pre-alpha:</p>
<ul>
  <li>It does not have sufficient functionality to be used for real
    appplications.</li>
  <li>It has not been seriously tested and thus may have many bugs.</li>
</ul>

<h4 id="Getting">Getting Started</h4>

<p>JavaIOC is developed as an eclipse project. The following assumes that you
have eclipse installed and have imported JavaIOC into a project named
"javaIOC".</p>

<p>In order to use the examples in the javaIOC, the environment variable
JAVAIOC must be defined so that it references the javaIOC project. For
example on my linux system I define</p>
<pre>export JAVAIOC=${HOME}/workspace/javaIOC</pre>

<p>In package default ( <span
style="font-family: courier;">javaIOC/src</span> ) there is a Java main
program, <span style="font-family: courier;">XMLToDatabase</span>, that:</p>
<ul>
  <li>Reads Database Definition and Record Instance files</li>
  <li>Dumps the resulting DBD and DB definitions</li>
  <li>Stárts servers.</li>
  <li>Starts an ioc.</li>
  <li>Invokes swtshell, which is a GUI shell for a running JavaIOC.</li>
</ul>

<p>Run <span style="font-family: courier;">javaIOC/src/XMLToDatabase</span>
as an <span style="font-weight:bold;">eclipse SWT application.</span></p>

<p>The arguments to XMLToDatabase can be any combination of:</p>
<ul>
  <li>-dbd <br />
    followed by filenames of database definition files</li>
  <li>-db <br />
    followed by filenames of record instance files <br />
  </li>
  <li>-dumpDBD<br />
    dump all the database definitions read so far</li>
  <li>-dumpDB<br />
    dump all the record instances read so far</li>
  <li>-server 
    <p>followed by a filenames. Each field is a list of servers to start.</p>
  </li>
  <li>-startIOC<br />
    Starts a javaIOC.</li>
  <li>-swtshell<br />
    Start swtshell.</li>
</ul>

<p>For example:</p>
<pre>    -dbd "example/exampleDBD.xml" -db "example/exampleDB.xml" -dumpDBD -dumpDB</pre>

<p>Reads a set of database definition and record instance files and then
dumps the database definitions and record instances.</p>

<p>As a beginning example specify the arguments as:</p>
<pre>    -dbd example/exampleDBD.xml -db example/exampleDB.xml \
    -server server/afterStartIOC.txt \
    -startIOC \
    -server server/afterStartIOC.txt \
    -swtshell</pre>

<p>This:</p>
<ul>
  <li>Loads some DBD and DB files.</li>
  <li>Starts a ChannelAccess Client that commnicates with V3 IOCs.</li>
  <li>Starts the javaIOC</li>
  <li>starts a Channel Access server for V3 clients.</li>
  <li>Starts the swtshell.</li>
</ul>

<p>Just try it</p>
<ul>
  <li>click the monitor button and a new window appears 
    <ul>
      <li>click connect button and a small window "getChannel" appears 
        <ul>
          <li>click select and choose channel "ai". A small window
            "getChannelField" appears 
            <ul>
              <li>enter "value" and press enter</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>click property button. a window offering choices appears 
        <ul>
          <li>select alarm and timeStamp choices and click done button</li>
        </ul>
      </li>
      <li>click startMonitor button 
        <ul>
          <li>after awhile click "stopMonitor" and "disconnect" buttons</li>
        </ul>
      </li>
    </ul>
    <p></p>
  </li>
  <li>on swtshell window click introspectDatabase button and a new window
    appears 
    <ul>
      <li>The menu bar at the top provides access to Database Definitions for
        menu, structure, recordType, create, and support. 
        <ul>
          <li>select and look at the various definitions.</li>
        </ul>
      </li>
      <li>the recordName row provides access to record instances. Click the
        select button and select record "ai" 
        <ul>
          <li>The current value of all fields in record ai are shown</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>on swtshell window click on loadDatabase button and a new window
    appears. Now on-line add powerSupply records 
    <ul>
      <li>click find button and select
        dbd/recordType/powerSupply/powerSupplyRecordDBD.xml</li>
      <li>click show button and the file contents are displayed</li>
      <li>clock loadDBD button and the database definition is added to the
        IOC database definitions.</li>
      <li>click find button and select src/powerSupplyAllDB.xml</li>
      <li>click show button and the file contents are displayed</li>
      <li>click loadDB button and the record instance is added to the IOC
        database.</li>
    </ul>
  </li>
  <li>on monitor window 
    <ul>
      <li>monitor record "psEmbeded" field "power" and select alarm and
        timeStamp properties.. 
        <ul>
          <li>The initial vale timeStamp shows that the record was never
            processed.</li>
          <li>Just leave the window monitoring psEmbeded.power</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>on swtshell window click put button. A new window appears 
    <ul>
      <li>set process selected</li>
      <li>click connect button and choose record "psEmbeded" and field
      "power"</li>
      <li>click put button 
        <ul>
          <li>enter "1.0" and press enter key</li>
        </ul>
      </li>
      <li>Look at monitor window. The record has processed and the updated
        values are shown</li>
    </ul>
  </li>
  <li>You are on your own.</li>
</ul>

<p>The remainder of this document gives an overview of javaIOC:</p>
<ul>
  <li>The xml syntax for database definitions and record instances.</li>
  <li>Java interfaces for accessing records and fields.</li>
  <li>Record processing<br />
    A javaIOC has a "smart" real time database. A record instance can be
    Records have associated support code. In addition each field can
    optionally have support. </li>
  <li>Example database definitions and record instances.</li>
</ul>

<h4 id="Status">Status and Remaining Tasks</h4>

<p>With the exception of remote Channel Access, the basic functionality
required for a javaIOC is now implemented. It is possible to create a running
javaIOC but since it can not comminicate with the outside world it can not do
anything useful.</p>

<p>The javaIOC provides database definitions (javaIOC/dbd) and support for a
core set of recordTypes. This should provided most of the functionality
provided by EPICS V3 base.</p>

<p>The javaIOC implements portDriver which provides the same functionality as
the asynDriver module for EPICS V3</p>

<p>The following JavaIOC components are required before a usable javaIOC
exists.</p>
<ul>
  <li>Remote Channel Access<br />
    This requires both client and server. This could wait until after a beta
    release of JavaIOC is announced.</li>
  <li>V3 Channel Access<br />
    Two things are required: 
    <ul>
      <li>JavaIOC to V3 server<br />
        This allows javaIOC records to have links to V3 IOCs.</li>
      <li>V3 client to javaIOC<br />
        This allows V3 channel access clients to access javaIOC records.o
        This is currently being implemented by Matej fron cosyLAB. </li>
    </ul>
    Both of these are required before JavaIOC is ready for serious use.</li>
  <li>Message Server<br />
    JavaIOC interfaces provide methods for sending messages to requesters.
    Currently the requesters just write the messages to System.out or to a
    swtshell text window. A message server facility similar to the V3
    logMessage facility needs to be implemented. Once in place it will be
    easy to modify the existing code to use the message server.</li>
  <li>portDriver<br />
    Hardware drivers and STREAMS.</li>
</ul>

<p>When the above is implemented JavaIOC is a viable product. However several
other things are desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a JavaIOC.</li>
  <li>Channel Access Clients that implement the JavaIOC Channel Access
    Semantics.</li>
  <li>A javaIOC replacement for calcPerform that comes with EPICS V3 base and
    for the sCalc and arrayCalc that come with synAPPS.</li>
  <li>etc, etc.</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>

<p>Marty Kraimer's next priorities are:</p>
<ul>
  <li>Some proof of concept support for BACnet.</li>
  <li>A example device that has multiple motors.</li>
  <li>More testing</li>
  <li>Hardware drivers for portDriver.</li>
</ul>
<hr />

<h3 style="text-align: center" id="Package">Package Summary</h3>
<hr />

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>

<h4 id="default">default - javaIOC/src</h4>

<p>This package contains:</p>
<ul>
  <li>The overview package.html document you are now reading.</li>
  <li>XMLToDatabase, which is the example program which was discussed in the
    getting started section.</li>
</ul>

<h4 id="javaIOC">javaIOC/dbd</h4>

<p>This directory and it's sub-directories, provides database definition
files for the recordTypes and support supplied with the javaIOC. </p>

<h4 id="javaIOC1">javaIOC/example</h4>

<p>This directory contains number of xml files that define instances of most
of the record/structure types supported byn the javaIOC.</p>

<h4 id="org.epics.">org.epics.ioc.pv</h4>

<p>A JavaIOC has a Process Variable (PV) Database, which is a "smart" real
time database. It is smart because each record instance has processing
code.</p>

<p>This package defines definitions for the data that javaIOC supports. This
is a combination of data and reflection interfaces. Read the package overview
for details. A brief description appears below.</p>

<h4 id="org.epics.1">org.epics.ioc.dbd</h4>

<p>This directory an it's subdirectories have database definitions for all
the support provided by the javaIOC. It is described in the second part of
this document.</p>

<h4 id="org.epics.2">org.epics.ioc.db</h4>

<p>This package provides a factory for creating javaIOC databases. It defines
a set data interfaces that contain references to PV Data and provides methods
so that:</p>
<ul>
  <li>Support can be attached to records and fields.</li>
  <li>Record instances can be locked.</li>
  <li>Fields of records can be monitored for changes.</li>
</ul>

<p>This package implements an XML parser that creates record instances and
puts them into an IOC Database (IOCDB).</p>

<h4 id="org.epics.3">org.epics.ioc.ca</h4>

<p>This package is Channel Access for a javaIOC. Currently only local access
is implemented.</p>

<h4 id="org.epics.3">org.epics.ioc.caV3</h4>

<p>This package is Channel Access V3, e.g. channel access Version 3. Server
support has been implemented by Matej Sekoranja (COSYLAB). Client support is
under development. Both thew client and server require JCA/CAJ.</p>

<h4 id="org.epics.4">org.epics.ioc.util</h4>
This package provides utility code for a javaIOC: 
<dl>
  <dt>Message Support</dt>
    <dd>This is an interface for passing messages to a requester of many
      services.</dd>
  <dt>Time Stamp support</dt>
    <dd>Support is provided to make it easier to work with time stamps.</dd>
  <dt>Scan Field Support</dt>
    <dd>Support that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
  <dt>IOCXML Reader</dt>
    <dd>Support for reading XML Database Definition and Record Instance
      files. It is an abstraction above Java SAX (Simple API for XML). It
      implements macro substitution and include.</dd>
</dl>

<h4 id="org.epics.5">org.epics.ioc.process</h4>

<p>This package provides support for processing IOC database records.</p>

<h4 id="org.epics.6">org.epics.ioc.create</h4>

<p>This package defines Create, which is an interface that is called if a
field is declared to have a createName. Support that implements Create
normally replaces the data interface for the field at the time the field is
created.</p>

<h4 id="org.epics.7">org.epics.ioc.support</h4>

<p>Each record instance must have associated support and each field of a
record instance can optionally have support.</p>

<h4 id="org.epics.8">org.epics.ioc.pdrv<br />
org.epics.ioc.pdrv/interfaces<br />
org.epics.ioc.pdrv/testDriver<br />
</h4>

<p>These packages implement portDriver, which is support for accessing and
controlling hardware. It is modeled after the EPICS asynDriver and thus
provides support for synchronous and asynchronous devices. Each device is
accessed via a port. Each port provides access to one or more devices.</p>

<h4 id="org.epics.9">org.epics.ioc.swtshell</h4>

<p>This is a GUI shell for an ioc. It is implemented via the Standard Widget
Toolkit. Getting Started explains how to invoke it.</p>
<hr />

<h3 style="text-align: center" id="Database">Database Syntax</h3>
<hr />

<p>The syntax for both Database Definitions (menu, structure, recordType,
etc) and Record Instance Definitions is XML based. In addition XML based
macro substitution and include is supported. Package org.epics.ioc.util
provides XML support with the following features:</p>
<ul>
  <li>Include and Macro Substitution are handled automatically.<br />
    NOTE: include and substitute are reserved words.</li>
  <li>xml namespaces are not support.</li>
  <li>Although the implementation uses SAX, the user code only implements
    IOCXMLListener and uses IOCXMLReader.</li>
  <li>The support is used by XMLToDBDFactory and by XMLToIOCDBFactory and can
    be used by other code.</li>
</ul>

<h4 style="text-align: center" id="Include">Include and Macro
Substitution</h4>

<h5 id="Syntax">Syntax</h5>

<p>An xml file can include other xml files. All files must be valid xml files
and must have the same root element name. An include statement has the
format:</p>
<pre>&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must
      be a valid XML Record Instance file, is processed. If any addPaths have
      been defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
      commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<h5 id="Example">Example</h5>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;record name = "ai${recordExtension}Record" type = "double"&gt;
    &lt;input structureName = "linearConvertInput" &gt;
        &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;${pvname}&lt;/pvname&gt;
            &lt;wait&gt;true&lt;/wait&gt;
        &lt;/input&gt;
        &lt;linearConvert&gt;
            &lt;engUnitsLow&gt;${engUnitsLow}&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;${engUnitsHigh}&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
    &lt;/input&gt;
    &lt;doubleDisplayCharacteristics&gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;${displayLow}&lt;/low&gt;
            &lt;high&gt;${displayHigh}&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/doubleDisplayCharacteristics&gt;
&lt;/record&gt;
&lt;/IOCDatabase&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;IOCDatabase&gt;
&lt;include addPath = "src/org/epics/ioc/pvAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/IOCDatabase&gt;</pre>

<h4 style="text-align: center" id="Database1">Database Definition</h4>

<p>This section provides a brief description of database definitions. See
package org.epics.ioc.dbd for complete details.</p>

<h5 id="Basic">Basic Syntax</h5>

<p>Database definitions consist of the following definition types: <span
style="font-family: courier;"></span> <span
style="font-family: courier;">structure</span>,create, <span
style="font-family: courier;">recordType.</span><span
style="font-family: courier;">create</span>, and <span
style="font-family: courier;">support</span></p>

<p>An example structure definition is:</p>
<pre>    &lt;structure name = "doubleLimit"&gt;
        &lt;field name = "low" type = "double" /&gt;
        &lt;field name = "high" type = "double" /&gt;
    &lt;/structure&gt;</pre>

<p>An example recordType definition is:</p>
<pre>&lt;recordType name = "example" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure" structureName = "alarm"
      supportName = "alarm" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "doubleAlarm" supportName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "display" --&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set
     structureName = "doubleHistory" supportName = "history" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/recordType&gt;</pre>

<p>A recordType is just the top level structure for a record instance.</p>

<h5 id="Field">Field Syntax</h5>

<p>Both structure and recordType definitions define a set of field
definitions. A field definition has the format:</p>
<pre>    &lt;field name = "value" type = "type"  ...&gt;</pre>
where supportName is optional and "..." represents other attributes. The
complete set of attributes are: 
<dl>
  <dt style="font-family: courier;">name</dt>
    <dd>the field name. This must be defined.</dd>
  <dt style="font-family: courier;">type</dt>
    <dd>The field type which must be defined and must be one of:<br />
      boolean,byte,short,int,long,float,double,string,enum,menu,link,structure,array</dd>
  <dt style="font-family: courier;">createName</dt>
    <dd>The name of a create. A create is called at the time a field is being
      created. Normally it will replave the default data implementation.</dd>
  <dt style="font-family: courier;">supportName</dt>
    <dd>The name of support for the field. A matching support definition must
      be available during IOC initialization.</dd>
  <dt style="font-family: courier;">structureName</dt>
    <dd>can be given if the type is structure. If not given the structure
      must be specified when a field instance is created.</dd>
  <dt style="font-family: courier;">elementType</dt>
    <dd>must be specified if the type is array. It can be any of the
      supported types.</dd>
</dl>

<p>Additional name/value pairs will be saved by the parser as PVAttributes
for the field. The following are recognized by the javaIOC database.</p>
<dl>
  <dt><span style="font-family: courier">default</span></dt>
    <dd>Default value for an instance of this field, using the Record
      Instance Syntax. A default can only be specified if the field type is
      primitive or string. If a default is not specified, the field will
      initialize to all zero bits.</dd>
  <dt><span style="font-family: courier">readonly</span></dt>
    <dd>Can this field be modified via channel access? If not the field is
      not modifable at run time or is handled by database access. Takes the
      value false if not specified.</dd>
</dl>

<h5 id="Example1">Example Structure, recordType, create, and Support
Definitions</h5>

<p>The second part of this document provides the definition supported by the
javaIOC. Look at it for example.</p>

<h4 style="text-align: center" id="Record">Record Instance Definition</h4>

<h5 id="Syntax1">Syntax</h5>

<p>The syntax for a record instance is:</p>
<pre>&lt;record type = "recordType" name = "recordName" supportName = "supportName"&gt;
    fieldAssignment
&lt;/record&gt;</pre>

<p>If the recordSupport name is not specified then the record support
specified in the recordType definition is used.</p>

<p>A <span style="font-family: courier">fieldAssignment</span> has the
format:</p>
<pre>    &lt;fieldName&gt;
        &lt;!-- initializer --&gt;
    &lt;/fieldName&gt;</pre>

<h5 id="Example2">Example</h5>
<pre>&lt;record name = "double01" type = "double"&gt;
    &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
        &lt;pvname&gt;counterCounter&lt;/pvname&gt;
        &lt;process&gt;false&lt;/process&gt;
    &lt;/input&gt;
    &lt;valueAlarm structureName = "doubleAlarm"&gt;
          &lt;active&gt;true&lt;/active&gt;
          &lt;interval&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;2.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;major&lt;/choice&gt;&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;4.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;minor&lt;/choice&gt;&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;6.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;none&lt;/choice&gt;&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;8.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;minor&lt;/choice&gt;&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;10.0&lt;/value&gt;
                  &lt;severity&gt;&lt;choice&gt;major&lt;/choice&gt;&lt;/severity&gt;
              &lt;/value&gt;
          &lt;/interval&gt;
          &lt;outOfRange&gt;&lt;choice&gt;invalid&lt;/choice&gt;&lt;/outOfRange&gt;
          &lt;hystersis&gt;0.1&lt;/hystersis&gt;
    &lt;/valueAlarm&gt;
    &lt;display structureName = "display" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/displayCharacteristics&gt;

&lt;/record&gt;</pre>
<hr />

<h3 style="text-align: center" id="PVData">PVData</h3>
<hr />

<p>JavaIOC data is stored in a PVData (Process Variable) Database, which is a
collection of record instances. A record instance is a structured set of
fields. A JavaIOC implements interfaces for accessing fields of database
records. The interfaces are a combination of reflection ( what is a field)
and data (what does a field contain) interfaces. Each field has a type as
defined in the next section. See the package overview for org.epics.ioc.pv
for more information. This section just gives a brief summary.</p>

<h4 id="Field1">Field Types</h4>

<p>A Java enum defines the supported types.</p>
<pre>    public enum Type {
        pvBoolean,
        pvByte,
        pvShort,
        pvInt,
        pvLong,
        pvFloat,
        pvDouble,
        pvString,
        pvStructure,
        pvArray;
    }</pre>

<h4 id="PVData1">PVData Reflection</h4>

<p>The reflection interfaces for PVData are:</p>
<pre>    
    public interface FieldAttribute {
        void setAttributes(Map&lt;String,String&gt; attributes,String[] exclude);
        String setAttribute(String key,String value);
        Map&lt;String,String&gt; getAttributes();
        String getAttribute(String key);
        String toString();
        String toString(int indentLevel);
    }


    interface Field{
        String getFieldName();
        Property[] getPropertys();
        Property getProperty(String propertyName);
        Type getType();
        String getSupportName();
        void setSupportName(String name);
        boolean isMutable();
        void setMutable();
        FieldAttribute getFieldAttribute();
        String toString();
        String toString(int indentLevel);
    }

    interface Structure extends Field{
        String getStructureName();
        String[] getFieldNames();
        Field getField(String fieldName);
        int getFieldIndex(String fieldName);
        Field[] getFields();
    }

    interface Array extends Field{
        Type getElementType();
    }</pre>

<h4 id="PVData2">PVData Interfaces</h4>

<p>The following describe the interfaces for accessing the data a field
contains.</p>

<p>The interfaces for accessing data are:</p>
<pre>    interface PVField {
         String getFullFieldName();
         Field getField(); // get the reflection interface
         PVField getParent();
         PVRecord getPVRecord();
         PVField getSubField(String fieldName);
         PVField findProperty(String fieldName);
         PVField findPropertyViaParent(String propertyName);
         String[] getPropertyNames();
         void replacePVField(PVField newPVField);
         String getSupportName();
         String setSupportName(String name);
         void asynAccessListenerAdd(AsynAccessListener asynAccessListener);
         void asynAccessListenerRemove(AsynAccessListener asynAccessListener);
         void asynAccessCallListeners(boolean begin);
         boolean asynModifyStart(Object asynModifier);
         void asynModifyEnd(Object asynModifier);
         boolean isAsynModifyActive();
         String toString();
         String toString(int indentLevel);
    }
    interface PVBoolean extends PVField{
        boolean get();
        void put(boolean value);
    }
    //   similar interfaces for other primitve types
    interface PVString extends PVField{
        String get();
        void put(String value);
    }
    interface PVStructure extends PVField {
        Structure getStructure();
        PVField[] getFieldPVFields();
    }
    interface PVArray extends PVField{
        Array getArray();
        int getLength();
        void setLength(int len);
        int getCapacity();
        void setCapacity(int len);
    }
    public class BooleanArrayData {
        public boolean[] data;
        public int offset;
    }
    interface PVBooleanArray extends PVArray{
        int get(int offset, int len, BooleanArrayData data);
        int put(int offset, int len, boolean[]from, int fromOffset);
    }
    // ... for arrays of other pv Types
    public interface PVRecord extends PVStructure {
        String getRecordName();
        void message(String message, MessageType messageType);
    }</pre>

<h4 id="Example3">Example: Database Access via Reflection</h4>
An interface IOCDB provides a method that locates the interface for a record
instance. For example, to locate the ai record the call is: 
<pre>    DBRecord dbRecord = iocdb.findRecord("ai");</pre>

<p>Starting with this the data in the value field can be read as follows:</p>
<pre>    PVRecord pvRecord = dbRecord.getPVRecord();
    PVField[] pvField = pvRecord.getPVStructure().getFieldPVFields();
    Structure structure = (Structure)pvRecord.getField();
    int index = structure.getFieldIndex("value");
    assert(pvField[index].getField().getType==Type.dbDouble);
    PVDouble valueData= (PVDouble)pvField[index];
    double value = valueData.get();</pre>

<h3 style="text-align: center" id="DBData">DBData</h3>

<p>See package org.epics.ioc.db for details about the interfaces shown in
this section, which just shows the interfaces.</p>

<p>The DBData interfaces provide:</p>
<ul>
  <li>Access to the PV interfaces</li>
  <li>Access to Support interfaces</li>
  <li>Record locking</li>
  <li>Record monitoring</li>
</ul>

<p>The interfaces are:</p>
<pre>    public interface DBField {
        DBRecord getDBRecord();
        DBField getParent();
        PVField getPVField();
        void replacePVField(PVField newPVField);
        String getSupportName();
        String setSupportName(String name);
        Create getCreate();
        void setCreate(Create create);
        Support getSupport();
        void setSupport(Support support);
        void postPut();
        void addListener(RecordListener recordListener);
        void removeListener(RecordListener recordListener);
        List&lt;RecordListener&gt; getRecordListenerList();
        String toString();
        String toString(int indentLevel);
    }
    public class BaseDBField implements DBField{ ... }

    public interface DBListener {
        void dataPut(DBField dbField);
        void supportNamePut(DBField dbField);
        void beginPut(DBStructure dbStructure);
        void endPut(DBStructure dbStructure);
        void dataPut(DBField requested,DBField dbField);
        void supportNamePut(DBField requested,DBField dbField);
        void beginProcess();
        void endProcess();
        void unlisten(RecordListener listener);
    }

    public interface DBStructure extends DBField {
        PVStructure getPVStructure();
        void replacePVStructure();
        DBField[] getFieldDBFields();
        void beginPut();
        void endPut();
    }
    public class BaseDBStructure extends BaseDBField implements DBStructure{ ... }

    public interface DBArray extends DBField{
        PVArray getPVArray();PVArray getPVArray();
    }
    public class BaseDBArray extends BaseDBField implements DBArray { ... }

    public interface DBStructureArray extends DBArray{
        PVStructureArray getPVStructureArray();
        DBStructure[] getElementDBStructures();
        void replacePVArray();
    }
    public class BaseDBStructureArray
        extends BaseDBArray implements DBStructureArray { ... }

    public interface DBArrayArray extends DBArray{
        PVArrayArray getPVArrayArray();
        DBArray[] getElementDBArrays();
        void replacePVArray();
    }
    public class BaseDBArrayArray
        extends BaseDBArray implements DBArrayArray { ... }

    interface DBRecord {
        DBField findDBField(PVField pvField);
        PVRecord getPVRecord();
        DBStructure getDBStructure();
        void lock();
        void unlock();
        void lockOtherRecord(DBRecord otherRecord);
        RecordProcess getRecordProcess();
        boolean setRecordProcess(RecordProcess recordProcess);
        int getRecordID();
        void beginProcess();
        void endProcess();
        RecordListener createRecordListener(DBListener listener);
        void removeRecordListener(RecordListener listener);
        void removeRecordListeners();
        void addListenerSource(BaseDBField dbField);
        DBD getDBD();
        void setDBD(DBD dbd);
        IOCDB getIOCDB();
        void setIOCDB(IOCDB iocdb);
    }</pre>
<hr />

<h3 style="text-align: center" id="Channel">Channel Access</h3>
<hr />

<p>Package org.epics.ioc.ca describes Channel Access for a JavaIOC. See it
for details. Some features are:</p>
<ul>
  <li>Local Channel Access is implemented. Remote is not implemented.</li>
  <li>Link support is implemented. 
    <ul>
      <li>Get, Put, and PutGet are all supported. Each can optionally process
        the record. Each can access a group of fields in a record instance.
        Structure and Array fields can be accessed. Each provides an option
        to process the record</li>
      <li>MonitorNotify is supported. In this case the client is notified of
        changes but must issue a get to retrieve the data</li>
      <li>Monitor is supported. A monitor includes the data which has
        changed. Any group of fields within a record instance can be
        monitored. Structure and Array fields can be monitored including an
        entire record instance. For appropriate field types onPut, onChange,
        absoluteChange, and percentChange are all supported.</li>
    </ul>
  </li>
</ul>
<hr />

<h3 style="text-align: center" id="Record1">Record Processing</h3>
<hr />

<p>Package org.epics.ioc.process describes and implements code directly
related to record processing. The package overview has a section "Record
Processing: Theory of Operation" that provides a description of record
processing.</p>

<p>Package org.epics.ioc.support describes and implements all the support
code that comes with javaIOC. Applications can, of course, add additional
support.</p>

<p>When a set of javaIOC record instances are created and initialized, a
recordProcess object is created for each record instance. The primary
function of recordProcess is to call record support code, which may in turn
call field support code. RecordProcess has methods for the following: </p>
<ul>
  <li>Lifetime Management: initialize, start, stop, uninitialize<br />
    recordProcess just calls the support methods with the same name.</li>
  <li>Processing</li>
  <li>timeStamp support:<br />
    Get/Set methods for a timeStamp.</li>
  <li>trace<br />
    A record instance can generate diagnostic message while processing.</li>
</ul>

<p>The primary purpose of recordProcess is to be the "gatekeeper" for record
processing. Only one object can process a record. Methods are available to
request being the record processor and methods involved with processing. A
process can be synchronous or asynchronous. An asynchronous operation is an
operation that blocks, e.g. file I/O. recordProcess provides methods that
allow asynchronous support but that only lock a record instance when blocking
can not occur. </p>

<p>Whenever any field of a record is being accessed or whenever anything is
done that can modify the state of a record, the record must be locked. In
most cases recordProcess takes care of locking and unlocking.</p>

<p>Each record instance must have associated support and each field of a
record can optionally have support.</p>

<p>Support must implement interface Support:</p>

<p></p>
<pre>    public interface Support extends Requester {
        SupportState getSupportState();
        DBField getDBField();
        void initialize();
        void start();
        void stop();
        void uninitialize();
        void allSupportStarted();
        void process(SupportProcessRequester supportProcessRequester);
    }</pre>

<p>where</p>
<dl>
  <dt>Requestor, getSupportState, getDBField</dt>
    <dd>See package org.epics.ioc.support for details.</dd>
  <dt>initialize</dt>
    <dd>Initialization related to the record itself. Support must not connect
      to other records or to hardware.</dd>
  <dt>start</dt>
    <dd>Support can connect to other records or top hardware.</dd>
  <dt>stop</dt>
    <dd>Disconnect from other records or hardware.</dd>
  <dt>uninitialize</dt>
    <dd>Remove any connection to the record.</dd>
  <dt>process</dt>
    <dd>Do whatever the support should do for record processing.</dd>
</dl>

<p>The primary purpose of a support module is to help with record processing.
Most support does something with a "value" field. For example the support for
a channel access input link will get a value and put it in the "value"
field.</p>

<p>Typical support code does the following core functions:</p>
<ul>
  <li>initialize<br />
    Determine the "value" field. Most support modules look for a field named
    "value".<br />
    Many support modules also provide support for other fields, which are
    identified by name. For example if a support module supports alarms it
    looks for a field "alarm".</li>
  <li>process<br />
    This is the core of record processing. What happens is up to the support
    module. For example it can interact with hardware. The channel access
    support reads or write other records.</li>
</ul>

<p>There is no separate concept of record support. Record support just
happens to be the support called by recordProcess, i.e. it is the highest
level support for a record instance. The record support that comes with
javaIOC is also designed to also be structure support, i.e. support for a
structure field embeded within a recordType.</p>

<p>Support code should not be aware of recordTypes and in most cases specific
structure types. A support modules works with some set of fields that it
locates at initialization. While processing it uses the PV and DB interfaces
to access the fields. Thus support is generic. If a recordType or structure
has the fields required by the support then the support can be used to help
support that recordType or structure.</p>

<p>An extreme example is generic support. This is used for most of the
recordTypes that come with the javaIOC. It can also be used with the
structure associated with each recordType. All that it does is look at all
the fields in the recordType or structure that is passed to it's initalizer.
For each field that has support it calls the support. The supports are called
in the order the fields are defined in the recordType or structure. It waits
for each support to finish before the next support is called. </p>
<hr />

<h3 style="text-align: center" id="Database2">Database Examples</h3>
<hr />

<p>javaIOC/dbd and it's subdirectories has the database definitions for all
the recordTypes and support supplied with thew javaIOC. Applications can add
new database definitions and support. This section just gives a few example
of using these database definitions. The complete set of definitions are
described in the second part of this document.</p>

<h4 style="text-align: center" id="Database3">Database Definitions</h4>

<p>The example uses the following database definitions:</p>
<dl>
  <dt>doubleCommon</dt>
    <dd>Defines fields common to structure "double" and recordType
    "double"</dd>
  <dt>doubleRecord</dt>
    <dd>Defines structure "double" and recordType "double"</dd>
  <dt>powerSupplyCommon</dt>
    <dd>Defines fields common to structure "powerSupply" and recordType
      "powerSupply"</dd>
  <dt>powerSupplyRecord</dt>
    <dd>Defines structure "powerSupply" and recordType "powerSupply"</dd>
</dl>

<h5 id="doubleComm">doubleCommon</h5>

<p>The following defines the fields that are common to both recordType double
and structure double.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="doubleReco">doubleRecord</h5>

<p>The following defines both a recordType and a structure named "double". It
also defines a support named "doubleRecord". The same support is the default
support for both the structure and for the recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "double" supportName = "generic" &gt;
  &lt;include href = "doubleCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "doubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;/DBDefinition&gt;</pre>

<h5 id="powerSuppl">powerSupplyCommon</h5>

<p>The following defines both a recordType and a structure named "double". It
also defines a support named "doubleRecord". The same support is the default
support for both the structure and for the recordType.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;support name = "powerSupplyCurrent"
   factoryName = "org.epics.ioc.support.PowerSupplyFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="powerSuppl1">powerSupplyRecord</h5>

<p>The following defines the fields that are common to both recordType double
and structure double.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "power" type = "structure" structureName = "double" /&gt;
  &lt;field name = "voltage" type = "structure" structureName = "double" /&gt;
  &lt;field name = "current" type = "structure" structureName = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 style="text-align: center" id="Support">Support Implementation</h4>

<p>The example uses the following support</p>
<ul>
  <li>generic</li>
</ul>
<ul>
  <li>powerSupply</li>
</ul>
<dl>
    <dd>Requires fields power, voltage, and current. If a field named
      "voltageInput" has support it is called. If a field names
      "currentOutput" has support it is called. When it processes it computes
      current from power and voltage.</dd>
</dl>
<ul>
  <li>linearConvertInput</li>
</ul>
<dl>
    <dd>Implements linear conversion from a rawValue to engineering
    units.</dd>
</dl>
<ul>
  <li>linearConvertOutput</li>
</ul>
<dl>
    <dd>Implements linear conversion from engineering units to a
    rawValue.</dd>
</dl>
<ul>
  <li>CALink</li>
</ul>
<dl>
    <dd>JaveIOC implements channel access links between records.</dd>
</dl>
<ul>
  <li>portDriver Support</li>
</ul>
<dl>
    <dd>portDriver provides access to hardware.</dd>
</dl>

<h4 style="text-align: center" id="Record2">Record Instance Examples</h4>

<h5 id="doubleInpu">doubleInput</h5>

<p>The following creates a record instance of type double. It is an input
record because input is initialized to a Channel Access inputLink.</p>
<pre>&lt;record name = "doubleInput" type = "double"&gt;
    &lt;input supportName = "inputLink" &gt;
        &lt;configure structureName = "inputLink"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/configure&gt;
    &lt;/input&gt;
&lt;/record&gt;</pre>

<h5 id="doubleOutp">doubleOutput</h5>

<p>The following creates a record instance of type double. It is an output
record because output is initialized to a Channel Access outputLink.</p>
<pre>&lt;record name = "doubleOutput" type = "double"&gt;
    &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
            &lt;pvname&gt;counterCounter&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h5 id="ai">ai</h5>

<p>The following creates an instance of an aiRecord. The raw ADC value is
read via portDriver support and converted via linearConvertInput support.</p>
<pre>&lt;record name = "ai" type = "double" &gt;
    &lt;input structureName = "linearConvertInput"&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;input supportName = "pdrvInt32Input" structureName = "pdrvSupport"&gt;
            &lt;portName&gt;syncInt32Driver&lt;/portName&gt;
            &lt;addr&gt;0&lt;/addr&gt;
            &lt;timeout&gt;.2&lt;/timeout&gt;
        &lt;/input&gt;
    &lt;/input&gt;
    &lt;valueAlarm structureName = "doubleAlarm"&gt;
          &lt;active&gt;true&lt;/active&gt;
          &lt;interval&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;2.0&lt;/value&gt;
                  &lt;severity&gt;major&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;4.0&lt;/value&gt;
                  &lt;severity&gt;minor&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;6.0&lt;/value&gt;
                  &lt;severity&gt;none&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;8.0&lt;/value&gt;
                  &lt;severity&gt;minor&lt;/severity&gt;
              &lt;/value&gt;
              &lt;value structureName = "doubleAlarmInterval"&gt;
                  &lt;value&gt;10.0&lt;/value&gt;
                  &lt;severity&gt;major&lt;/severity&gt;
              &lt;/value&gt;
          &lt;/interval&gt;
          &lt;outOfRange&gt;invalid&lt;/outOfRange&gt;
          &lt;hystersis&gt;0.1&lt;/hystersis&gt;
    &lt;/valueAlarm&gt;
    &lt;displayCharacteristics structureName = "doubleDisplayCharacteristics" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/displayCharacteristics&gt;

&lt;/record&gt;</pre>

<h5 id="ao">ao</h5>

<p>The following creates an instance of an aoRecord. The value is converted
via linearConvertOutput support to a rawValue which is written via portDriver
support.</p>
<pre>&lt;record name = "ao" type = "double" &gt;
    &lt;output structureName = "linearConvertOutput"&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;output supportName = "pdrvInt32Output" structureName = "pdrvSupport"&gt;
            &lt;portName&gt;syncInt32Driver&lt;/portName&gt;
            &lt;addr&gt;0&lt;/addr&gt;
            &lt;timeout&gt;.2&lt;/timeout&gt;
        &lt;/output&gt;
    &lt;/output&gt;
&lt;/record&gt;</pre>

<h5 id="psSimple">psSimple</h5>

<p>The following creates a powerSupply instance that does no input or output.
The voltage and power must be written via channel access.</p>
<pre>&lt;record name = "psSimple" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;&lt;value&gt;10.0&lt;/value&gt;&lt;/voltage&gt;
    &lt;current&gt;
        &lt;input supportName = "powerSupplyCurrent" /&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>

<h5 id="psLinked">psLinked</h5>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via channel access.</p>
<pre>&lt;record name = "psLinked" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;
        &lt;input  supportName = "inputSupport" structureName = "inputSupport"&gt;
            &lt;pvname&gt;voltage&lt;/pvname&gt;
            &lt;process&gt;false&lt;/process&gt;
        &lt;/input&gt;
    &lt;/voltage&gt;
    &lt;current&gt;
       &lt;input supportName = "powerSupplyCurrent" /&gt;
       &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
          &lt;pvname&gt;current&lt;/pvname&gt;
          &lt;process&gt;true&lt;/process&gt;
       &lt;/output&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>

<h5 id="psEmbeded">psEmbeded</h5>

<p>The following creates a powerSupply record that gets its voltage and
writes its current via embeded support.</p>
<pre>&lt;record name = "psEmbeded" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;voltage&gt;
        &lt;input structureName = "linearConvertInput"&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;input supportName = "inputSupport" structureName = "inputSupport"&gt;
                    &lt;pvname&gt;adcVoltageEmbeded&lt;/pvname&gt;
                    &lt;process&gt;false&lt;/process&gt;
            &lt;/input&gt;
        &lt;/input&gt;
    &lt;/voltage&gt;
    &lt;current&gt;
        &lt;alarm structureName = "alarm" /&gt;
        &lt;input supportName = "powerSupplyCurrent" /&gt;
        &lt;output structureName = "linearConvertOutput"&gt;
            &lt;linearConvert&gt;
                &lt;deviceHigh&gt;4095&lt;/deviceHigh&gt;
                &lt;deviceLow&gt;0&lt;/deviceLow&gt;
                &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
            &lt;/linearConvert&gt;
            &lt;output supportName = "outputSupport" structureName = "outputSupport"&gt;
                &lt;pvname&gt;dacCurrentEmbeded&lt;/pvname&gt;
                &lt;process&gt;true&lt;/process&gt;
            &lt;/output&gt;
        &lt;/output&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>
<hr />
<hr />

<h2 style="text-align: center" id="Part1">Part II: javaIOC Data Model</h2>
<hr />
<hr />
<hr />

<h3 style="text-align: center" id="Summary">Summary</h3>
<hr />

<p>The Data Model supports general purpose client tools. A set of structures
are defined that support the data model. A recordType supports the data model
if it follows a few simple guidelines.</p>

<p>The model can briefly be described as follows: Clients access fields in a
structure. A field meant for general purpose clients is considered a property
and the field name is the property name. The structure normally has a field
named "value". It is usually a data field, i.e. a scalar type or an array
with the elementType being scalar. All other fields of the structure support
the value. Typical property fields are timeStamp, alarm, display, control,
and history.</p>
<hr />

<h3 style="text-align: center" id="JavaIOC">JavaIOC Data Model</h3>
<hr />

<h4 id="Basic1">Basic Concept</h4>

<p>A javaIOC structure follows the javaIOC Data Model if it has a set of
fields that have names and types that support the data model. It can have
additional fields, that can also be considered properties. The following
field names have special meaning, i.e. are properties for general purpose
clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients expect
      this property. All other fields in the structure support or describe
      the value field. The type can any supported type but is usually one of
      the following: 
      <dl>
        <dt>scalar</dt>
          <dd>One of boolean, byte, short, int, long, float, double, or
          string</dd>
        <dt>scalar array</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index, choice, and
            choices. index is an int that selects a choice. choice is the
            currently selected choice. choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients
            and support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      javaIOC structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>A history structure as described below. It provides a history buffer
      for the value field.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition the javaIOC structure can have additional fields that support
the value field but are not recognized by most general purpose client tools.
Typical examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
      value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link.
      It can write a value to hardware. Etc.</dd>
</dl>

<p>The model allows for device records. A device record has fields that are
structures that support the javaIOC data model. For example a powerSupport
record can have fields power, voltage, current that each support the javaIOC
data model. </p>

<h4 id="structure">structure null</h4>

<p>A null structure, by definition, is a structure that has no fields and no
support. It allows general purpose structures and record types to be defined.
For example:</p>
<pre>&lt;structure name = "example" &gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;</pre>

<p>In the above definition Al fields except value are by default a null
structure. If a record instance does not override the default than code must
act as if the field does not exist. If a record instance does override the
field than it must replace the structure with a structure that supports the
data model.</p>

<h4 id="getPropety">getPropety</h4>

<p>Interface PVField has two methods that make it easy to locate fields of
interest:</p>
<pre>     PVField PVField.getProperty(String fieldName);
     PVField[] PVField.getPropertys;</pre>

<p>where</p>
<dl>
  <dt>getProperty</dt>
    <dd>Locates a "property" associated with the PVField.</dd>
  <dt>getPropertys</dt>
    <dd>PVField is a value field than the value field itself will not be in
      the PVField[].</dd>
</dl>

<p>getProperty locates a field relative to the PVField. It can search down
the structure hierarchy and handles value and timeStamp as a special case.
getProperty does the following:</p>
<ul>
  <li>The fieldName is of the form item.item... where item is a "name" or a
    "name[index]". (Note multiple levels of index are allowed)</li>
  <li>getPropertry locates each item starting from the left. If any item is
    not found it returns null. It it finds all inems it returns the interface
    to the last item. </li>
  <li>For each item it locates name as follows: 
    <ul>
      <li>If the current item is a field is named "value" the current item
        becomes the parent of value..</li>
      <li>If the current item is a structure and the structure has a field
        named "name" and the field is anything except a null structure it is
        selected</li>
      <li>If a field has not been found but "name" is timeStamp than a search
        up the parent tree is made to locate a field named timeStamp.</li>
      <li>If no field is found than getProperty returns null.</li>
    </ul>
  </li>
  <li>If [index] is specified than the field found for name must be an array
    with elementType array or structure. If the array has an element
    corresponding to the index than that element becomes the current item. In
    all other cases getProperty returns null.</li>
</ul>

<p>The following example assume that pvField is set to a structure or
record.</p>
<pre>    PVField valuePVField = pvField.getProperty("value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>

<p>The following example assume that pvField is set to a powerSupply
structure or record.</p>
<pre>    PVField valuePVField = pvField.getProperty("power.value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>

<p>The following example assume that pvField is a structure with a field
named supply that is an array of powerSupply structures.</p>
<pre>    PVField valuePVField = pvField.getProperty("supply[2].power.value");
    if(valuePVField==null) { /* do something */ }
    PVField timeStampPVField = valuePVField.getProperty("timeStamp");
    PVField displayPVField = valuePVField.getProperty("display");</pre>
<hr />

<h3 style="text-align: center" id="Definition">Definitions for Standard
Properties</h3>
<hr />

<p>The following are the proposed set of structures for standard properties
for general purpose client tools. </p>

<h4 id="timeStamp">timeStamp</h4>
<pre>&lt;structure name = "timeStamp"&gt;
  &lt;field name = "secondsPastEpoch" type = "long" /&gt;
  &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<h4 id="alarm">alarm</h4>
<pre>&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "ackTransient" type = "boolean" /&gt;
  &lt;field name = "ackSeverity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "typeCode" type = "structure" /&gt;
&lt;/structure&gt;</pre>

<h4 id="display">display</h4>
<pre>&lt;structure name = "display"&gt;
    &lt;field name = "description" type = "string" /&gt;
    &lt;field name = "format" type = "string" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "resolution" type = "int" /&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>

<h4 id="control">control</h4>
<pre>&lt;structure name = "control"&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "minStep" type = "double" /&gt;
&lt;/structure&gt;</pre>

<h4 id="history">history</h4>

<p>The following describes the structures for history for a double value
field. Definitions will also appear for booleanHistory, byteHistory, ...,
stringHistory.</p>
<pre>&lt;structure name = "doubleHistory" &gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "alarm" type = "structure"
         structureName = "alarm" supportName = "null" /&gt;
&lt;/structure&gt;

&lt;structure name = "history" supportName = "doubleHistory" &gt;
    &lt;field name = "size" type = "int" /&gt;
    &lt;!-- other fields are needed. TODO --&gt;
    &lt;!-- support will make this an array of doubleHistory structures --&gt;
    &lt;field name = "data" type = "array" elementType = "structure" /&gt;
&lt;/structure&gt;</pre>
<hr />
<hr />

<h2 style="text-align: center" id="Part2">Part III: javaIOC - Database
Definition</h2>
<hr />
<hr />

<p>Part III describes the Database Definitions provided with the javaIOC.</p>
<hr />

<h3 style="text-align: center" id="Overview1">Overview Of Part III</h3>
<hr />

<p>The menu, structure, and support definitions required by the support
implemented by javaIOC are defined. In addition an extensive set of
recordType/structure definitions that use the support are provided. A brief
summary is:</p>
<dl>
  <dt style="font-family: courier;">javaIOC/dbd</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt style="font-family: courier;">common.xml</dt>
          <dd>Defines fields scan, and timeStamp. These are fields that are
            in most recordType definitions. Note that this is not a valid
            structure definition. It can only be used by including this file
            within a recordType definition. </dd>
        <dt style="font-family: courier;">structure.xml</dt>
          <dd>Includes all the support definitions from dbd/structure.</dd>
        <dt style="font-family: courier;">recordType.xml</dt>
          <dd>Includes all the support definitions from dbd/recordType except
            powerSupply.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">javaIOC/dbd/structure</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt style="font-family: courier;">commonFields.xml</dt>
          <dd>Contains definitions for the fields that appear in
            dbd/common.xml.</dd>
        <dt style="font-family: courier;">limit.xml</dt>
          <dd>Contains a structure definition for each numeric type. Each
            structure contains two fields: low and high.</dd>
        <dt style="font-family: courier;">display.xml</dt>
          <dd>Defines display characteristics.</dd>
        <dt style="font-family: courier;">control.xml</dt>
          <dd>Defines control characteristics.</dd>
        <dt style="font-family: courier;">alarm.xml</dt>
          <dd>Contains definitions related to alarms.</dd>
        <dt style="font-family: courier;">booleanHistory.xml</dt>
          <dd>Defines history for boolean data..</dd>
        <dt style="font-family: courier;">byteHistory.xml</dt>
          <dd>Defines history for byte data..</dd>
        <dt style="font-family: courier;">shortHistory.xml</dt>
          <dd>Defines history for short data..</dd>
        <dt style="font-family: courier;">intHistory.xml</dt>
          <dd>Defines history for int data..</dd>
        <dt style="font-family: courier;">longHistory.xml</dt>
          <dd>Defines history for long data..</dd>
        <dt style="font-family: courier;">floatHistory.xml</dt>
          <dd>Defines history for float data..</dd>
        <dt style="font-family: courier;">doubleHistory.xml</dt>
          <dd>Defines history for double data..</dd>
        <dt style="font-family: courier;">stringHistory.xml</dt>
          <dd>Defines history for string data..</dd>
        <dt style="font-family: courier;">analog.xml</dt>
          <dd>Support for analog I/O.</dd>
        <dt style="font-family: courier;">digital.xml</dt>
          <dd>Support for digital I/O.</dd>
        <dt style="font-family: courier;">calc.xml</dt>
          <dd>Support for calculations. No generic calculation support is
            implemented but something similar to the EPICS calcPerform will
            be implemented in the future. For now a calculation support
            modules must be implemented similar to the EPICS subroutine
            record.</dd>
        <dt style="font-family: courier;">channelAccess.xml</dt>
          <dd>Support for links to other records.</dd>
        <dt style="font-family: courier;">delay.xml</dt>
          <dd>Support that implements an asynchronous delay when the process
            method is called. It is normally only used for testing.</dd>
        <dt style="font-family: courier;">disable.xml</dt>
          <dd>Not implemented but it will provide features like the EPICS
            disable fields.</dd>
        <dt style="font-family: courier;">enumerated.xml</dt>
          <dd>Defines an enumerated structure and create for enumerated</dd>
        <dt style="font-family: courier;">event.xml</dt>
          <dd>Support that announces an event when the process method is
            called.</dd>
        <dt style="font-family: courier;">generic.xml</dt>
          <dd>Support code that can be used to support many recordTypes and
            or structures. It just looks for fields that have associated
            support and calls the support.</dd>
        <dt style="font-family: courier;">noop.xml</dt>
          <dd>Defines noop support, which is support that does nothing except
            complete all support methods successfully and synchronously.</dd>
        <dt style="font-family: courier;">portDriver.xml</dt>
          <dd>Definitions for portDriver support for the javaIOC</dd>
        <dt style="font-family: courier;">supportArray.xml</dt>
          <dd>Support for an array of structures that have support. It is
            used with many record types.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">javaIOC/dbd/recordType</dt>
    <dd>This defines record types. Most of the definitions define both a
      recordType and a structure. The associated support will work for
      either. Thus the associated support can be used like an embeded record
      by using the structure rather than the recordType definition. 
      <dl>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/primitive</dt>
          <dd>This defines a set of record types for primitive types, i.e.
            boolean, byte, short, int, long, float, double, and string. Each
            can be used for input, output, or both. Each has a supportArray.
            Each uses generic support by default..</dd>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/primitiveArray</dt>
          <dd>This defines a set of record types for an array of primitive
            type, i.e. boolean, byte, short, int, long, float, double, and
            string. Each can be used for input, output, or both. Each has a
            supportArray. Each uses generic support by default.</dd>
        <dt style="font-family: courier;">javaIOC/dbd/recordType/analog</dt>
          <dd>This defines a recordType and structure for
            aoIncrementalDouble. The incremental support limits the rate at
            which the output changes.</dd>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/enumerated</dt>
          <dd>A recordType for enumerated values. The value field is an
            enumerated structure.</dd>
        <dt style="font-family: courier;">javaIOC/dbd/recordType/event</dt>
          <dd>A record type that announces an event when it is processed.</dd>
        <dt style="font-family: courier;">javaIOC/dbd/recordType/calc</dt>
          <dd>Record types for performing calculations.</dd>
        <dt
        style="font-family: courier;">javaIOC/dbd/recordType/portDriver</dt>
          <dd>Link support that connects to portDriver. In addition tow
            record types are defined. portRecord initializes a port.
            portDeviceControl provides access to the connection management
            and trace facilities of a portDriver port or device.</dd>
      </dl>
    </dd>
</dl>

<p>An application can include all the support defined in this package by
using the following xml file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "dbd" /&gt;
&lt;include href = "structure.xml" /&gt;
&lt;include href = "recordType.xml" /&gt;
&lt;include removePath = "dbd" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>This package overview does not discuss the algorithms implemented by the
support implementations. See package org.epics.ioc.support for details.</p>

<h3 style="text-align: center;" id="javaIOC2">javaIOC/dbd</h3>
<hr />

<h4 id="common.xml">common.xml</h4>

<p>This has definitions for fields that are common to most record types.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"
         supportName = "scan" /&gt;
&lt;/DBDefinition&gt;</pre>

<p>For example a record type for a double record starts with:</p>
<pre>&lt;recordType name = "double" supportName = "generic" &gt;
    &lt;include href = "common.xml" /&gt;
    ...</pre>

<p>Field scan determines the scan mechanism, i.e. passive, periodic, or
event, that determines when a precord is processed.</p>

<p>Each time a record is processed the time is recorded in field
timeStamp.</p>

<h4 id="structure.">structure.xml</h4>

<p>This file includes all definitions needed for the support provided by
javaIOC.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "dbd/structure" /&gt;
&lt;include href = "limit.xml" /&gt;
&lt;include href = "enumerated.xml" /&gt;
&lt;include href = "commonFields.xml" /&gt;
&lt;include href = "alarm.xml" /&gt;
&lt;include href = "byteStructures.xml" /&gt;
&lt;include href = "shortStructures.xml" /&gt;
&lt;include href = "intStructures.xml" /&gt;
&lt;include href = "longStructures.xml" /&gt;
&lt;include href = "floatStructures.xml" /&gt;
&lt;include href = "doubleStructures.xml" /&gt;
&lt;include href = "noop.xml" /&gt;
&lt;include href = "generic.xml" /&gt;
&lt;include href = "supportArray.xml" /&gt;
&lt;include href = "channelAccess.xml" /&gt;
&lt;include href = "analog.xml" /&gt;
&lt;include href = "digital.xml" /&gt;
&lt;include href = "event.xml" /&gt;
&lt;include href = "calc.xml" /&gt;
&lt;include href = "disable.xml" /&gt;
&lt;include href = "delay.xml" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "dbd/structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="recordType">recordType.xml</h4>

<p>This file includes for all the recordType (and associated structure)
definitions provided by javaIOC.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;include addPath = "dbd/recordType/primitive" /&gt;
&lt;include href = "booleanRecord.xml" /&gt;
&lt;include href = "byteRecord.xml" /&gt;
&lt;include href = "shortRecord.xml" /&gt;
&lt;include href = "intRecord.xml" /&gt;
&lt;include href = "longRecord.xml" /&gt;
&lt;include href = "floatRecord.xml" /&gt;
&lt;include href = "doubleRecord.xml" /&gt;
&lt;include href = "stringRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/primitive" /&gt;
&lt;include addPath = "dbd/recordType/primitiveArray" /&gt;
&lt;include href = "booleanArrayRecord.xml" /&gt;
&lt;include href = "byteArrayRecord.xml" /&gt;
&lt;include href = "shortArrayRecord.xml" /&gt;
&lt;include href = "intArrayRecord.xml" /&gt;
&lt;include href = "longArrayRecord.xml" /&gt;
&lt;include href = "floatArrayRecord.xml" /&gt;
&lt;include href = "doubleArrayRecord.xml" /&gt;
&lt;include href = "stringArrayRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/primitiveArray" /&gt;
&lt;include addPath = "dbd/recordType/analog" /&gt;
&lt;include href = "aoIncrementalDoubleRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/analog" /&gt;
&lt;include addPath = "dbd/recordType/enumerated" /&gt;
&lt;include href = "enumeratedRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/enumerated" /&gt;
&lt;include addPath = "dbd/recordType/event" /&gt;
&lt;include href = "eventRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/event" /&gt;
&lt;include addPath = "dbd/recordType/calc" /&gt;
&lt;include href = "calcDoubleRecord.xml" /&gt;
&lt;include href = "calcDoubleArrayRecord.xml" /&gt;
&lt;include href = "calcBooleanArrayRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/calc" /&gt;
&lt;include addPath = "dbd/recordType/portDriver" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "dbd/recordType/portDriver" /&gt;
&lt;include addPath = "dbd/recordType/powerSupply" /&gt;
&lt;include href = "powerSupplyRecord.xml" /&gt;
&lt;include href = "powerSupplyArrayRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/powerSupply" /&gt;
&lt;include addPath = "dbd/recordType/allTypes" /&gt;
&lt;include href = "allTypesRecord.xml" /&gt;
&lt;include removePath = "dbd/recordType/allTypes" /&gt;
&lt;!--
--&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structure1">dbd/structure/alarm.xml</h3>
<hr />

<p>This file contains database definitions related to alarms.</p>

<p>See package org.epics.ioc.support for a description of the algorithm for
raising alarms.</p>

<p>After defining the alarm severities, it defines a structure alarm. This is
the structure for a field, usually named alarm, that provides the alarm
severity and a message describing why an alarm was raised. A recordType can
have an alarm field and each structure field in a recordType can optionally
have an alarm field, i.e. a hierarachy of alarms is supported. If a structure
has an alarm field then when it's support is called to raise an alarm, the
support looks up the parent tree for the first alarm field it finds and
raises an alarm equal to it's own alarm severity. Thus the alarm field for
the recordType always has an alarm severity greater than or equal to all
lower level alarms.</p>

<p>The remaining definitions are for checking alarms for value fields.
Definitions and support are available for the numeric types, boolean, and
enumerated. </p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "alarmSeverity" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
    default = "none minor major invalid" /&gt;
&lt;/structure&gt;

&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "ackTransient" type = "boolean" /&gt;
  &lt;field name = "ackSeverity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "typeCode" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "byteAlarmInterval"&gt;
  &lt;field name = "value" type = "byte" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "byteAlarm" supportName = "byteAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "byte" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortAlarmInterval"&gt;
  &lt;field name = "value" type = "short" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "shortAlarm" supportName = "shortAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "short" /&gt;
&lt;/structure&gt;

&lt;structure name = "intAlarmInterval"&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "intAlarm" supportName = "intAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "longAlarmInterval"&gt;
  &lt;field name = "value" type = "long" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "longAlarm" supportName = "longAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "long" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatAlarmInterval"&gt;
  &lt;field name = "value" type = "float" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "floatAlarm" supportName = "floatAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleAlarmInterval"&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;
&lt;structure name = "doubleAlarm" supportName = "doubleAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "interval" type = "array" elementType = "structure" /&gt;
  &lt;field name = "outOfRange" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "hystersis" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "booleanAlarm"  supportName = "booleanAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
  &lt;field name = "falseAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "trueAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "changeStateAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;structure name = "enumeratedAlarm"  supportName = "enumeratedAlarm" &gt;
  &lt;field name = "active" type = "boolean" /&gt;
   &lt;!-- each array element must have structureName  alarmSeverity --&gt;
  &lt;field name = "stateAlarm" type = "array" elementType = "structure" design = "false" /&gt;
  &lt;field name = "changeStateAlarm" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;support name = "alarm"
  factoryName = "org.epics.ioc.support.AlarmFactory" /&gt;
&lt;support name = "booleanAlarm"
  factoryName = "org.epics.ioc.support.BooleanAlarmFactory" /&gt;
&lt;support name = "byteAlarm"
  factoryName = "org.epics.ioc.support.ByteAlarmFactory" /&gt;
&lt;support name = "shortAlarm"
  factoryName = "org.epics.ioc.support.ShortAlarmFactory" /&gt;
&lt;support name = "intAlarm"
  factoryName = "org.epics.ioc.support.IntAlarmFactory" /&gt;
&lt;support name = "longAlarm"
  factoryName = "org.epics.ioc.support.LongAlarmFactory" /&gt;
&lt;support name = "floatAlarm"
  factoryName = "org.epics.ioc.support.FloatAlarmFactory" /&gt;
&lt;support name = "doubleAlarm"
  factoryName = "org.epics.ioc.support.DoubleAlarmFactory" /&gt;
&lt;support name = "enumeratedAlarm"
  factoryName = "org.epics.ioc.support.EnumeratedAlarmFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="numeric">numeric alarms</h4>

<p>The definitions for byte, short, int, long, float, and double are all the
same except for the data type. The following describes the fields for double.
Except for the data type it also is valid for the other types.</p>

<p>Structure doubleAlarmInterval has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The upper limit for the interval. If a data value is &gt; the
      previous interval value and &lt;= value than this interval determines
      the alarm severity.</dd>
  <dt>severity</dt>
    <dd>The alarm severity if the data value falls into this interval.</dd>
</dl>

<p>Structure doubleAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>interval</dt>
    <dd>An array of doubleAlarmIntervals. These must be defined in increasing
      order.</dd>
  <dt>outOfRange</dt>
    <dd>The alarm severity if a data value does not fall into any
    interval.</dd>
  <dt>hystersis</dt>
    <dd>A hystersis value for changing the alarm severity. It prevents alarm
      "chatter".</dd>
</dl>

<h4 id="boolean">boolean alarms</h4>

<p>Structure booleanAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>falseAlarm</dt>
    <dd>alarm severity if the data value is false.</dd>
  <dt>trueAlarm</dt>
    <dd>alarm severity if the data value is true.</dd>
  <dt>changeStateAlarm</dt>
    <dd>alarm severity if the data value has changed since the last
    process.</dd>
</dl>

<h4 id="enumerated">enumerated alarms</h4>

<p>Enumerated alarms are for a data type that is an enumerated structure.</p>

<p>Structure enumeratedAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>stateSeverity</dt>
    <dd>An array of menuSeverity structures.</dd>
  <dt>changeStateAlarm</dt>
    <dd>A severity for change of state.</dd>
</dl>
<hr />

<h3 style="text-align: center" id="structure2">dbd/structure/analog.xml</h3>
<hr />

<p>This is the support for analog I/O. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "linearConvert" &gt;
  &lt;field name = "engUnitsLow" type = "double" /&gt;
  &lt;field name = "engUnitsHigh" type = "double" /&gt;
  &lt;field name = "deviceHigh" type = "int" /&gt;
  &lt;field name = "deviceLow" type = "int" /&gt;
  &lt;field name = "slope" type = "double" /&gt;
  &lt;field name = "intercept" type = "double" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertInput" supportName = "generic"&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "linearConvert" type = "structure"
     structureName = "linearConvert" supportName = "linearConvertInput" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "linearConvertOutput" supportName = "generic"&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "linearConvert" type = "structure"
     structureName = "linearConvert" supportName = "linearConvertOutput" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;structure name = "incrementalDouble" supportName = "generic" &gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "input" type = "structure" structureName = "null" /&gt;
  &lt;field name = "incremental" type = "boolean" supportName = "incremental"/&gt;
  &lt;field name = "rateOfChange" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
&lt;/structure&gt;
&lt;support name = "linearConvertInput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "linearConvertOutput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "incremental"
   factoryName = "org.epics.ioc.support.IncrementalFactory" /&gt;&lt;support name = "linearConvertInput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "linearConvertOutput"
  factoryName = "org.epics.ioc.support.LinearConvertFactory" /&gt;

&lt;support name = "incremental"
   factoryName = "org.epics.ioc.support.IncrementalFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="linearConv">linearConvert</h4>

<p>Structure linearConvert is for linear conversions. The slope and intercept
can be specified directly or can be computed from the other four fields.
Normally the record instance defines engUnitsLow and engUnitsHigh and support
code provides values for deviceHigh and deviceLow but other combinations are
also permitted. Structure linearConvert has the fields:</p>
<dl>
  <dt>engUnitsLow</dt>
    <dd>Engineering units value for deviceLow.</dd>
  <dt>engUnitsHigh</dt>
    <dd>Engineering units value for deviceHigh.</dd>
  <dt>deviceHigh</dt>
    <dd>Highest possible raw value.</dd>
  <dt>deviceLow</dt>
    <dd>Lowest possible raw value.</dd>
  <dt>slope</dt>
    <dd>Slope for converting raw value to engineering units.</dd>
  <dt>intercept</dt>
    <dd>Intrercept for converting raw value to engineering units.</dd>
</dl>

<h4 id="linearConv1">linearConvertInput</h4>

<p>Structure linearConvertInput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to get the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that inputs the raw value.</dd>
</dl>

<h4 id="linearConv2">linearConvertOutput</h4>

<p>Structure linearConvertOutput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to put the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that outputs the raw value.</dd>
</dl>

<h4 id="incrementa">incrementalDouble</h4>

<p>This is for rate limited output. The output value incrementally reaches
the desired value. The structure has the fields:</p>
<dl>
  <dt>desiredValue</dt>
    <dd>The desired value.</dd>
  <dt>input</dt>
    <dd>A structure for reading the desired value.</dd>
  <dt>incrementalOutput</dt>
    <dd>If false the output is set to the desired value if it falls within
      the control limits.</dd>
  <dt>rateOfChange</dt>
    <dd>Rate of change per process if incrementalInput is true.</dd>
  <dt>units</dt>
    <dd>units.</dd>
  <dt>controlLimit</dt>
    <dd>control limits. The output value is forced to be within the control
      limits.</dd>
</dl>
<hr />

<h3 style="text-align: center" id="structure3">dbd/structure/limit.xml</h3>
<hr />

<p>This contains structure definitions for limits for each of the numeric
types. No default support is provided. Each structure has just two fields:
low and high.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "byteLimit"&gt;
    &lt;field name = "low" type = "byte" /&gt;
    &lt;field name = "high" type = "byte" /&gt;
&lt;/structure&gt;

&lt;structure name = "shortLimit"&gt;
    &lt;field name = "low" type = "short" /&gt;
    &lt;field name = "high" type = "short" /&gt;
&lt;/structure&gt;

&lt;structure name = "intLimit"&gt;
    &lt;field name = "low" type = "int" /&gt;
    &lt;field name = "high" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "longLimit"&gt;
    &lt;field name = "low" type = "long" /&gt;
    &lt;field name = "high" type = "long" /&gt;
&lt;/structure&gt;

&lt;structure name = "floatLimit"&gt;
    &lt;field name = "low" type = "float" /&gt;
    &lt;field name = "high" type = "float" /&gt;
&lt;/structure&gt;

&lt;structure name = "doubleLimit"&gt;
    &lt;field name = "low" type = "double" /&gt;
    &lt;field name = "high" type = "double" /&gt;
&lt;/structure&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structures">dbd/structures/display.xml</h3>
<hr />

<p>This section defines the history characteristics for display.</p>
<pre>&lt;structure name = "display"&gt;
    &lt;field name = "description" type = "string" /&gt;
    &lt;field name = "format" type = "string" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "resolution" type = "int" /&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structures1">dbd/structures/doubleHistory.xml</h3>
<hr />

<p>This section defines the history characteristics for a double field.
Similar definitions exist for boolean, byte, short, int, long, float, and
string.</p>
<pre>&lt;structure name = "doubleHistory" supportName = "history" &gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "alarm" type = "structure"
         structureName = "alarm" supportName = "null" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structures2">dbd/structures/commonFields.xml</h3>
<hr />

<p>This file contains database definitions for fields in common.xml, i.e.
fields alarm, scan, and timeStamp, which are present in most recordTypes.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "scanPriority" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int"/&gt;
  &lt;field name = "choice" type = "string"/&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
      default = "lowest lower low middle high higher highest" /&gt;
&lt;/structure&gt;

&lt;structure name = "scanType"  createName = "enumerated" &gt;
  &lt;field name = "index"  type = "int"/&gt;
  &lt;field name = "choice" type = "string"/&gt;
  &lt;field name = "choices" type = "array" elementType = "string"
      default = "passive event periodic" /&gt;
&lt;/structure&gt;

&lt;structure name = "timeStamp"&gt;
  &lt;field name = "secondsPastEpoch" type = "long" /&gt;
  &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;

&lt;structure name = "scan"&gt;
  &lt;field name = "priority" type = "structure" structureName = "scanPriority" /&gt;
  &lt;field name = "type" type =  "structure" structureName = "scanType" /&gt;
  &lt;field name = "rate" type = "double"  default = "1.0" /&gt;
  &lt;field name = "eventName" type = "string" /&gt;
  &lt;field name = "processSelf" type = "boolean" /&gt;
    &lt;field name = "processAfterStart" type = "boolean" default = "false" /&gt;
&lt;/structure&gt;

&lt;support name = "scan"
  factoryName = "org.epics.ioc.support.ScanFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<p>Definitions for the following structuress:</p>
<dl>
  <dt>priority</dt>
    <dd>The scan priorities: lowest,...,highest</dd>
  <dt>scanType</dt>
    <dd>An enumerated structure that defines the scan types: 
      <dl>
        <dt>passive</dt>
          <dd>A record that is neither periodically or event scanned.
            Something elase can make it process. For example another record
            with a process link.</dd>
        <dt>event</dt>
          <dd>An event scanned record. In this case an eventName is also
            assigned to the record.</dd>
        <dt>periodioc</dt>
          <dd>A periodically scanned record. In this case a rate is also
            assigned to the record.</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt>timeStamp</dt>
    <dd><dl>
        <dt>secondsPastEpoch</dt>
          <dd>Seconds past the epoch which is Jan 1, 1970 UTC. This is
            compatible with Java and POSIX.</dd>
        <dt>nanoSeconds</dt>
          <dd>nanoseconds within the second.</dd>
      </dl>
    </dd>
  <dt>scan</dt>
    <dd><dl>
        <dt>priority</dt>
          <dd>The thread priority for a periodic and event scanning.</dd>
        <dt>scan</dt>
          <dd>Scan type, i.e. passive, event, or periodic</dd>
        <dt>rate</dt>
          <dd>Periodic scan rate in seconds</dd>
        <dt>eventName</dt>
          <dd>The event name for event scanned records.</dd>
        <dt>processSelf</dt>
          <dd>Should the record process itself?</dd>
        <dt>processAfterStart</dt>
          <dd>determines if the record instance should be processed one time
            after the record enters the ready state. If the value is true
            than recordProcess attempts to process the record immeriately
            after it becomes ready. The attempt is only successfull if no
            record processor is registered of if the record has been
            initialized to be processSelf.</dd>
      </dl>
    </dd>
</dl>
<hr />

<h3 style="text-align: center" id="structure4">dbd/structure/noop.xml</h3>
<hr />

<p>noop is support that implements each of the support methods by just
completing successfully. One use is for a record that just holds data.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;!-- structure null is created automatically --&gt;

&lt;support name = "noop"
    factoryName = "org.epics.ioc.support.NoopFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structure5">dbd/structure/generic.xml</h3>
<hr />

<p>Generic is the default support for many record types. It just calls the
support for any fields that have support. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;support name = "generic"
   factoryName = "org.epics.ioc.support.GenericFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure6">dbd/structure/supportArray.xml</h3>
<hr />

<p>This is the support for an array of links, which is part of many record
types. See org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "supportArrayElement"&gt;
  &lt;field name = "wait" type = "boolean" /&gt;
  &lt;field name = "link" type = "structure" structureName = "null" /&gt;
&lt;/structure&gt;

&lt;support name = "supportArray"
  factoryName = "org.epics.ioc.support.SupportArrayFactory" /&gt;
&lt;/DBDefinition&gt;</pre>
<dl>
  <dt>supportArrayElement</dt>
    <dd><dl>
        <dt>wait</dt>
          <dd>After this link is started should supportArraySupport wait for
            completion of all links currently started before starting the
            next link.</dd>
        <dt>link</dt>
          <dd>A database link</dd>
        <dt>name</dt>
          <dd>A name that can be used is desired. For example a calculation
            record (not implemented) could use it.</dd>
      </dl>
    </dd>
</dl>
<hr />

<h3 style="text-align: center"
id="support6">dbd/structure/channelAccess.xml</h3>
<hr />

<p>This is the support for a links to other records. See
org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "monitorType" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;file name = "choices" type = "array" elementType = "string"
   default = "put change absoluteChange percentageChange" /&gt;
&lt;/structure&gt;

&lt;structure name = "processSupport"&gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
&lt;/structure&gt;

&lt;structure name = "monitorSupport"&gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "type" type = "structure" structureName = "monitorType"
     default = "put" /&gt;
  &lt;field name = "deadband" type = "double" /&gt;
  &lt;field name = "queueSize" type = "int"  default = "3" /&gt;
  &lt;field name = "reportOverrun" type = "boolean" /&gt;
  &lt;field name = "process" type = "boolean"&gt;
      &lt;!-- process this record when monitor occurs --&gt;
  &lt;/field&gt;
  &lt;field name = "propertyNames" type = "string" &gt;
      &lt;!-- only applicable if process is true --&gt;
  &lt;/field&gt;
&lt;/structure&gt;

&lt;structure name = "monitorNotifySupport"&gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "type" type = "structure" structureName = "monitorType"
     default = "change" /&gt;
  &lt;field name = "deadband" type = "double" /&gt;
  &lt;field name = "onlyWhileProcessing" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;structure name = "inputSupport"&gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "process" type = "boolean" /&gt;
  &lt;field name = "propertyNames" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "outputSupport"&gt;
  &lt;field name = "providerName" type = "string" default = "local" /&gt;
  &lt;field name = "pvname" type = "string" link = "true" /&gt;
  &lt;field name = "process" type = "boolean" /&gt;
&lt;/structure&gt;

&lt;support name = "processSupport"
  factoryName = "org.epics.ioc.support.CASupportFactory" /&gt;
&lt;support name = "monitorSupport"
  factoryName = "org.epics.ioc.support.CASupportFactory" /&gt;
&lt;support name = "monitorNotifySupport"
  factoryName = "org.epics.ioc.support.CASupportFactory" /&gt;
&lt;support name = "inputSupport"
  factoryName = "org.epics.ioc.support.CASupportFactory" /&gt;
&lt;support name = "outputSupport"
  factoryName = "org.epics.ioc.support.CASupportFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4 id="processSup">processSupport</h4>

<p>Structure processSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
</dl>

<h4 id="monitorSup">monitorSupport</h4>

<p>Structure monitorSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
  <dt>queueSize</dt>
    <dd>Must be greater than 1. The default is 2.</dd>
  <dt>reportOverrun</dt>
    <dd>If the data queue is overrun should it be reported by setting status
      and severity?</dd>
  <dt>process</dt>
    <dd>Should the record containing the link be processed after the
      monotered data is read.</dd>
  <dt>propertyNames</dt>
    <dd>A set of propertyNames. If a name is alarm than this record inherits
      the alarm from the linked record.</dd>
</dl>

<h4 id="monitorNot">monitorNotifySupport</h4>

<p>Structure monitorNotifySupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
</dl>

<h4 id="inputSuppo">inputSupport</h4>

<p>Structure inputSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>process</dt>
    <dd>Should the linked record be processed before getting data?</dd>
  <dt>propertyNames</dt>
    <dd>A set of propertyNames. If a name is alarm than this record inherits
      the alarm from the linked record.</dd>
</dl>

<h4 id="outputSupp">outputSupport</h4>

<p>Structure outputSupport has the fields:</p>
<dl>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>process</dt>
    <dd>Should the linked record be processed after putting data?</dd>
</dl>
<hr />

<h3 style="text-align: center" id="structure7">dbd/structure/digital.xml</h3>
<hr />

<p>This is the support for digital I/O. See org.epics.ioc.support for
details. It reads a registerValue. The raw value is the low order
numberOfBits of the registerValue. This value deterrmines the digitalState.
</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "digitalState"&gt;
  &lt;field name = "name" type = "string" /&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "digital" supportName = "generic" &gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- each structureName must be digitalState --&gt;
  &lt;!-- supportName can be digitalInput or digitalOutput --&gt;
  &lt;field name = "states" type = "array" elementType = "structure" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/structure&gt;

&lt;support name = "digitalInput"
   factoryName = "org.epics.ioc.support.DigitalFactory" /&gt;

&lt;support name = "digitalOutput"
   factoryName = "org.epics.ioc.support.DigitalFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4 id="digitalSta">digitalState</h4>

<p>This provides a name, value, and severity for a single digital state.</p>
<dl>
  <dt>name</dt>
    <dd>The name for this state.</dd>
  <dt>value</dt>
    <dd>The raw value for this state.</dd>
  <dt>severity</dt>
    <dd>Alarm severity for this state.</dd>
</dl>

<h4 id="digital">digital</h4>

<p>This is the structure required by the digital support. The field states,
which must be an array of digitalState structures, is the field that is
supported by digitalInput or digitalOutput.</p>
<hr />

<h3 style="text-align: center" id="structure8">dbd/structure/event.xml</h3>
<hr />

<p>This is the support for announcing events. See org.epics.ioc.support for
details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;support name = "event"
   factoryName = "org.epics.ioc.support.EventFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structure9">dbd/structure/calc.xml</h3>
<hr />

<p>This is the support for calculations. See org.epics.ioc.support for
details. Note that at the present time there is no support equivalent to
EPICS calcPerform. </p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;support name = "calcArgArray"
   factoryName = "org.epics.ioc.support.CalcArgArrayFactory" /&gt;


&lt;!-- example calculators --&gt;

&lt;linkSupport name = "counterCalculator"
   factoryName = "org.epics.ioc.support.CounterCalculatorFactory" /&gt;

&lt;linkSupport name = "arrayIncrementCalculator"
   factoryName = "org.epics.ioc.support.ArrayIncrementCalculatorFactory" /&gt;

&lt;linkSupport name = "booleanArrayToggleCalculator"
   factoryName = "org.epics.ioc.support.BooleanArrayToggleCalculatorFactory" /&gt;


&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structure10">dbd/structure/disable.xml</h3>
<hr />

<p>This is the support for disabling a record. NOT IMPLEMENTED.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "disableLink"&gt;
    &lt;field name = "disabled" type = "boolean" /&gt;
    &lt;field name = "value" type = "short" default = "1" /&gt;
    &lt;field name = "input" type = "short" /&gt;
    &lt;field name = "link" type = "link" /&gt;
    &lt;field name = "disableAlarmSeverity"
           type = "menu" menuName = "alarmSeverity" /&gt;
&lt;/structure&gt;

&lt;!-- support not implemented --&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="structure11">dbd/structure/delay.xml</h3>
<hr />

<p>This is the support that delays before completing. It is used for testing.
See org.epics.ioc.support for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "delay"&gt;
    &lt;!-- min, max, inc are delay in milliseconds --&gt;
    &lt;field name = "min" type = "long" /&gt;
    &lt;field name = "max" type = "long" /&gt;
    &lt;field name = "inc" type = "long" /&gt;
&lt;/structure&gt;

&lt;support name = "delay"
    factoryName = "org.epics.ioc.support.DelayFactory" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure12">dbd/structure/enumerated.xml</h3>
<hr />
<pre>&lt;structure name = "enumerated" createName = "enumerated" &gt;
  &lt;field name = "index" type = "int" /&gt;
  &lt;field name = "choice" type = "string" /&gt;
  &lt;field name = "choices" type = "array" elementType = "string" /&gt;
&lt;/structure&gt;

&lt;create name = "enumerated"
  factoryName = "org.epics.ioc.create.EnumeratedFactory" /&gt;</pre>
<hr />

<h3 style="text-align: center"
id="structure13">dbd/structure/portDriver.xml</h3>
<hr />

<p>This is the support for portDriver. See org.epics.ioc.support and
org.epics.ioc.portDriver for details.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "pdrvSupport"&gt;
  &lt;field name = "portName" type = "string" /&gt;
  &lt;field name = "addr" type = "int" /&gt;
  &lt;field name = "timeout" type = "double" /&gt;
  &lt;field name = "mask" type = "int" /&gt;
  &lt;field name = "size" type = "int" /&gt;
  &lt;field name = "process" type = "boolean" default = "false" /&gt;
  &lt;field name = "drvParams" type = "structure" /&gt;
&lt;/structure&gt;

&lt;support name = "pdrvOctetInput"
  factoryName = "org.epics.ioc.support.PDRVSuppowerSupplyCurrentportFactory" /&gt;
&lt;support name = "pdrvOctetInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvOctetOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvInt32Input"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32InterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32AverageInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32Output"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvInt32ArrayOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvFloat64Input"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64InterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64AverageInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64Output"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvFloat64ArrayInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64ArrayInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvFloat64ArrayOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;support name = "pdrvUInt32DigitalInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvUInt32DigitalInterruptInput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;
&lt;support name = "pdrvUInt32DigitalOutput"
  factoryName = "org.epics.ioc.support.PDRVSupportFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4 id="pdrvSuppor">pdrvSupport</h4>

<p>This structure has fields for connecting to a port.</p>
<dl>
  <dt>portName</dt>
    <dd>The name of the port.</dd>
  <dt>addr</dt>
    <dd>The device address.</dd>
  <dt>timeout</dt>
    <dd>The timeout for low level I/O operations.</dd>
  <dt>mask</dt>
    <dd>Only for digital I/O. It is the mask.</dd>
  <dt>size</dt>
    <dd>Only for octet support. It is the size of the buffer for I/O.</dd>
  <dt>process</dt>
    <dd>For interrupt support. Shouls an interrupt cause the record to
      process.</dd>
  <dt>drvParams</dt>
    <dd>Driver parameters. Driver specific.</dd>
</dl>
<hr />

<h3 style="text-align: center" id="recordType1">dbd/recordType/primitive</h3>
<hr />

<h4 id="Overview2">Overview</h4>

<p>A recordType and a structure are defined for each of the primitive types
including string. The structure is used to create "device" records. A device
record is like a set of recordTypes contained in a single record. All the
recordTypes and structures described in this section define generic to be the
default support. For each primitive support a Common.xml file and a
Record.xml file is provided. The Common file defines fields that appear in
both the recordType and the structure. The Record file defines both the
structure and the recordType. </p>

<p>The Common file defines the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The value field.</dd>
  <dt>alarm</dt>
    <dd>An alarm field. Note that since this appears in the structure
      definition alarm hierarchiries are supported.</dd>
  <dt>input</dt>
    <dd>A structure for reading the value. If this is defined but output is
      not than the record instance is an input record.</dd>
  <dt>valueAlarm</dt>
    <dd>A field for checking for value alarms.</dd>
  <dt>output</dt>
    <dd>A structure for writing the value. If this is defined but input is
      not than the record instance is an output record.</dd>
  <dt>displayCharacteristics</dt>
    <dd>Display characteristics. Instance will have null structure unless
      record instance defines structureName</dd>
  <dt>history</dt>
    <dd>History. Instance will have null structure unless record instance
      defines structureName</dd>
</dl>

<p>The Record file defines a structure that contains the fields in common.</p>

<p>The Record file defines a recordType that has the fields from Comman as
well as:</p>
<dl>
  <dt>common.xml</dt>
    <dd>The fields that are common to most recordTypes.</dd>
  <dt>supportArray</dt>
    <dd>A array of fields that have support.</dd>
</dl>

<h4 id="boolean1">boolean</h4>

<h5 id="booleanCom">booleanCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "boolean" /&gt;
  &lt;field name = "alarm" type = "structure" /&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "booleanAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
   &lt;!-- instance can set structureName = "booleanHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="booleanRec">booleanRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "boolean" supportName = "generic" &gt;
  &lt;include href = "booleanCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "boolean" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "booleanCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;/DBDefinition&gt;</pre>

<h4 id="byte">byte</h4>

<h5 id="byteCommon">byteCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "byte" /&gt; 
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "byteAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "byteHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="byteRecord">byteRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "byte" supportName = "generic" &gt;
  &lt;include href = "byteCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "byte" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "byteCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="short">short</h4>

<h5 id="shortCommo">shortCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "short" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "shortAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "shortHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="shortRecor">shortRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "short" supportName = "generic" &gt;
  &lt;include href = "shortCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "short" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "shortCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="int">int</h4>

<h5 id="intCommon.">intCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "int" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "intHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="intRecord.">intRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "int" supportName = "generic" &gt;
  &lt;include href = "intCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "int" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "intCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="long">long</h4>

<h5 id="longCommon">longCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "long" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "longAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "longHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="longRecord">longRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "long" supportName = "generic" &gt;
  &lt;include href = "longCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "long" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "longCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="float">float</h4>

<h5 id="floatCommo">floatCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "float" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "floatAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "floatHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="floatRecor">floatRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "float" supportName = "generic" &gt;
  &lt;include href = "floatCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "float" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "floatCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="double">double</h4>

<h5 id="doubleComm1">doubleCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="doubleReco1">doubleRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "double" supportName = "generic" &gt;
  &lt;include href = "doubleCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "doubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="string">string</h4>

<h5 id="stringComm">stringCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "string" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "stringHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="stringReco">stringRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "string" supportName = "generic" &gt;
  &lt;include href = "stringCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "string" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  
  &lt;include href = "stringCommon.xml" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="recordType2">dbd/recordType/primitiveArray</h3>
<hr />

<h4 id="Overview3">Overview</h4>

<p>A recordType and a structure are defined for an array of each of the
primitive types including string. The structure is used to create "device"
records. A device record is like a set of recordTypes contained in a single
record. All the recordTypes and structures described in this section define
generic to be the default support. For each primitive support a Common.xml
file and a Record.xml file is provided. The Common file defines fields that
appear in both the recordType and the structure. The Record file defines both
the structure and the recordType. </p>

<p>The Common file defines the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The value field.</dd>
  <dt>alarm</dt>
    <dd>An alarm field. Note that since this appears in the structure
      definition alarm hierarchiries are supported.</dd>
  <dt>input</dt>
    <dd>A link for reading the value. If this is defined but output is not
      than the record instance is an input record.</dd>
  <dt>valueAlarm</dt>
    <dd>A field for checking for value alarms.</dd>
  <dt>output</dt>
    <dd>A link for writing the value. If this is defined but input is not
      than the record instance is an output record.</dd>
  <dt>displayCharacteristics</dt>
    <dd>Display Characteristics. Unless instance defines structureName this
      will be null structure.</dd>
  <dt>history</dt>
    <dd>History</dd>
</dl>

<p>The Record file defines a structure that contains the fields in
common..</p>

<p>The Record file defines a recordType that has the fields from Comman as
well as:</p>
<dl>
  <dt>common.xml</dt>
    <dd>The fields that are common to most recordTypes.</dd>
  <dt>supportArray</dt>
    <dd>A array of structures with support.</dd>
</dl>

<h4 id="booleanArr">booleanArray</h4>

<h5 id="booleanArr1">booleanArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "boolean" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="booleanArr2">booleanArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "booleanArray" supportName = "generic" &gt;
  &lt;include href = "booleanArrayCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "booleanArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;  
  &lt;include href = "booleanArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="byteArray">byteArray</h4>

<h5 id="byteArrayC">byteArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "byte" /&gt; 
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="byteArrayR">byteArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "byteArray" supportName = "generic" &gt;
  &lt;include href = "byteArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "byteArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "byteArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="shortArray">shortArray</h4>

<h5 id="shortArray1">shortArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "short" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="shortArray2">shortArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "shortArray" supportName = "generic" &gt;
  &lt;include href = "shortArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "shortArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "shortArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="intArray">intArray</h4>

<h5 id="intArrayCo">intArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "int" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="intArrayRe">intArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "intArray" supportName = "generic" &gt; 
  &lt;include href = "intArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "intArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "intArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="longArray">longArray</h4>

<h5 id="longArrayC">longArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "long" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="longArrayR">longArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "longArray" supportName = "generic" &gt;
  &lt;include href = "longArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "longArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "longArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="floatArray">floatArray</h4>

<h5 id="floatArray1">floatArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "float" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="floatArray2">floatArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "floatArray" supportName = "generic" &gt;
  &lt;include href = "floatArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "floatArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "floatArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="doubleArra">doubleArray</h4>

<h5 id="doubleArra1">doubleArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="doubleArra2">doubleArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "doubleArray" supportName = "generic" &gt;
  &lt;include href = "doubleArrayCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "doubleArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "doubleArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="stringArra">stringArray</h4>

<h5 id="stringArra1">stringArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "string" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
&lt;/DBDefinition&gt; </pre>

<h5 id="stringArra2">stringArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "stringArray" supportName = "generic" &gt;
  &lt;include href = "stringArrayCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "stringArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "stringArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="recordType3">dbd/recordType/analog</h3>
<hr />

<h4 id="Overview4">Overview</h4>

<p>Regular analog records can be created via the double structure and
recordType. This section defines definitions for incremental analog
output.</p>

<h4 id="aoIncremen">aoIncrementalDouble</h4>

<h5 id="aoIncremen1">aoIncrementalDoubleCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "desired" type = "structure"
      structureName = "incrementalDouble" supportName = "incremental" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "byteAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "byteHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="aoIncremen2">aoIncrementalDoubleRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "aoIncrementalDouble" supportName = "generic" &gt;
  &lt;include href = "aoIncrementalDoubleCommon.xml" /&gt;
&lt;/structure&gt;
    
&lt;recordType name = "aoIncrementalDouble" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  
  &lt;include href = "aoIncrementalDoubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt; 
&lt;/DBDefinition&gt;</pre>

<p>The structure has the common fields. The recordType has the common fields,
the fields common to most recordTypes and a value field.</p>
<hr />

<h3 style="text-align: center" id="recordType4">dbd/recordType/enumerated</h3>
<hr />

<h4 id="Overview5">Overview</h4>

<p>This is support for a value field that is an enumerated structure.</p>

<h4 id="enumerated1">enumerated</h4>

<h5 id="enumerated2">enumeratedCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "structure" structureName = "enumerated" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "enumeratedAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure"/&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "enumeratedHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="enumerated3">enumeratedRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "enumeratedStruvture" supportName = "generic" &gt;
  &lt;include href = "enumeratedCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "enumerated" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "enumeratedCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<p>The structure has the common fields. The recordType has the common fields,
the fields common to most recordTypes and a value field.</p>
<hr />

<h3 style="text-align: center" id="recordType5">dbd/recordType/event</h3>
<hr />

<h4 id="Overview6">Overview</h4>

<p>This is a record type that announces an event. The value field is a string
the is the event name.</p>

<h4 id="event">event</h4>

<h5 id="eventCommo">eventCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "string" supportName = "event" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "stringHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="eventRecor">eventRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "event" supportName = "generic" &gt;
  &lt;include href = "eventCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "event" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "eventCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="recordType6">dbd/recordType/calc</h3>

<h4 id="Overview7">Overview</h4>

<p>This defines recordTypes and structures for calculations. Definitions are
available for calculating a double, an array of doubles, and an array of
booleans. Other types can easily be defined. What the calculation doews is
determined by the calculation field, which is a link. Currently only three
test calculations are implemented: CounterCalculator implements a simple
counter. ArrayIncrementCalculator increments element of an array.
BooleanArrayToggleCalculator toggles each element of a booleran array between
false and true.</p>

<p>It is envisioned that general purpose calculators will be developed.
Support equvalent to the EPICS calcPerform, stringCalc, and arrayCalc should
be created.</p>

<p>The remaining fields should be usable by a wide variety of calculations.
The most important field is calcArgArray, which is an array of structures.
Each element of calcArgArray is an argument for the calculation. The exact
type of structure for the elements of calcArgArray is determined by the
calculation but if thye following fields appear than support calcArgArray
will do the I/O and also provide an addition method getPVField, which returns
a PV interface for reading an argument value.:</p>
<dl>
  <dt>value</dt>
    <dd>A place to put the value for the argument.</dd>
  <dt>name</dt>
    <dd>The name for the argument.</dd>
  <dt>input</dt>
    <dd>A link for reading the argument value. If the link has support
      calcArgArray calls it and has the support put the result in value.</dd>
</dl>

<h4 id="calcDouble">calcDouble</h4>

<h5 id="calcDouble1">calcDoubleCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "calcArgArray" type = "array"
     elementType = "structure" supportName = "calcArgArray" /&gt;
  &lt;field name = "calculator" type = "structure" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleAlarm" --&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;!-- instance can set structureName = "doubleHistory" --&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="calcDouble2">calcDoubleRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "calcDoubleArg" &gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "name" type = "string" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
&lt;/structure&gt;
  
&lt;structure name = "calcDouble" supportName = "generic" &gt;
  &lt;include href = "calcDoubleCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "calcDouble" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "calcDoubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array" 
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="calcDouble3">calcDoubleArray</h4>

<h5 id="calcDouble4">calcDoubleArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "double"  /&gt;
  &lt;field name = "calcArgArray" type = "array"
     elementType = "structure" supportName = "calcArgArray" /&gt;
  &lt;field name = "calculator" type = "structure" structureName = "null" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="calcDouble5">calcDoubleArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "calcDoubleArrayArg" &gt;
  &lt;field name = "value" type = "array"  elementType = "double" /&gt; 
  &lt;field name = "name" type = "string" /&gt;
  &lt;field name = "input" type = "structure" structureName = "null" /&gt;
&lt;/structure&gt;
  
&lt;structure name = "calcDoubleArray" supportName = "generic" &gt;
  &lt;include href = "calcDoubleArrayCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "calcDoubleArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;  
  &lt;include href = "calcDoubleArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt; 
&lt;/DBDefinition&gt;</pre>

<h4 id="calcBoolea">calcBooleanArray</h4>

<h5 id="calcBoolea1">calcBooleanArrayCommon.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "value" type = "array" elementType = "boolean"  /&gt;
  &lt;field name = "calcArgArray" type = "array"
     elementType = "structure" supportName = "calcArgArray" /&gt;
  &lt;field name = "calculator" type = "structure" structureName = "null" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h5 id="calcBoolea2">calcBooleanArrayRecord.xml</h5>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "calcBooleanArrayArg" &gt;
  &lt;field name = "value" type = "array"  elementType = "boolean" /&gt;
  &lt;field name = "name" type = "string" /&gt;
  &lt;field name = "input" type = "structure" structureName = "null" /&gt;
&lt;/structure&gt;
  
&lt;structure name = "calcBooleanArray" supportName = "generic" &gt;
  &lt;include href = "calcBooleanArrayCommon.xml" /&gt;
&lt;/structure&gt;
  
&lt;recordType name = "calcBooleanArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "calcBooleanArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="recordType7">dbd/recordType/portDriver</h3>
<hr />

<h4 id="Overview8">Overview</h4>

<p>This defines everything required for performing I/O via portDriver. See
portDriver for details.</p>

<p>In addition two record types are defined: portCreate and
portDeviceControl. portCreate is a recordType for creating a port.
portDeviceControl is a recordType for accessing the connect and trace
features of portDriver.</p>

<h4 id="portDriver">portDriver.xml</h4>
<pre>&lt;DBDefinition&gt;
&lt;recordType name = "portCreate" supportName = "portCreate" &gt;
  &lt;field name = "factoryName" type = "string" /&gt;
  &lt;field name = "portName" type = "string" /&gt;
  &lt;field name = "autoConnect" type = "boolean" default = "true" /&gt;
  &lt;field name = "priority" type = "structure" structureName = "scanPriority" /&gt;
  &lt;field name = "driverParameters" type = "structure" structureName = "null"/&gt;
&lt;/recordType&gt;


&lt;recordType name = "portDeviceControl" supportName = "portDeviceControl" &gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "portDevice" type = "string" /&gt;
  &lt;field name = "connect" type = "boolean" /&gt;
  &lt;field name = "enable" type = "boolean"  /&gt;
  &lt;field name = "autoConnect" type = "boolean" /&gt;
  &lt;field name = "traceMask" type = "int" /&gt;
  &lt;field name = "traceIOMask" type = "int" /&gt;
  &lt;field name = "report" type = "int" /&gt;
&lt;/recordType&gt;

&lt;support name = "portCreate"
   factoryName = "org.epics.ioc.support.PDRVPortCreateFactory" /&gt;

&lt;support name = "portDeviceControl"
   factoryName = "org.epics.ioc.support.PDRVPortDeviceControlFactory" /&gt;


&lt;include addPath = "src/org/epics/ioc/pdrv/testDriver" /&gt;
&lt;include href = "octetDriver.xml" /&gt;
&lt;include href = "int32Driver.xml" /&gt;
&lt;include href = "float64Driver.xml" /&gt;
&lt;include href = "uint32DigitalDriver.xml" /&gt;
&lt;include href = "int32ArrayDriver.xml" /&gt;
&lt;include href = "float64ArrayDriver.xml" /&gt;
&lt;include removePath = "src/org/epics/ioc/pdrv/testDriver" /&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center"
id="recordType8">dbd/recordType/powerSupply</h3>
<hr />

<h4 id="Overview9">Overview</h4>

<p>This is an example of a device record. It can input the desired power. It
has a structure for voltageInput and for currentOutput. Each record instance
can configure the voltageInput and currentOutput as desired. For example they
could be configured to input the voltage via and ADC accessed using
portDriver and ooutput the current to a DAC via portDriver. A structure could
be configured to link to other records.</p>

<p>A record that holds an array of powerSupplies is also defined.</p>

<h4 id="powerSuppl2">powerSupplyCommon.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "power" type = "structure" structureName = "double" /&gt;
  &lt;field name = "voltage" type = "structure" structureName = "double" /&gt;
  &lt;field name = "current" type = "structure" structureName = "double" /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="powerSuppl3">powerSupplyRecord.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt; 
&lt;/structure&gt;
  
&lt;recordType name = "powerSupply" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "powerSupplyCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;support name = "powerSupplyCurrent"
   factoryName = "org.epics.ioc.support.PowerSupplyFactory" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="powerSuppl4">powerSupplyArrayCommon.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "supply" type = "array" elementType = "structure" supportName = "supportArray"  /&gt;
  &lt;field name = "alarm" type = "structure"/&gt;
  &lt;field name = "timeStamp" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>

<h4 id="powerSuppl5">powerSupplyArrayRecord.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "powerSupplyArray" supportName = "generic" &gt;
  &lt;include href = "powerSupplyArrayCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "powerSupplyArray" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "powerSupplyArrayCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h3 style="text-align: center" id="recordType9">dbd/recordType/allTypes</h3>
<hr />

<h4 id="Overview10">Overview</h4>

<p>This is a structure and a recordType that has a field of each supported
type. It is used as an example and for testing.</p>

<h4 id="allTypesCo">allTypesCommon.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "boolean" type = "boolean" default = "true" /&gt;
    &lt;field name = "byte" type = "byte"  default = "-0x7f" /&gt;
    &lt;field name = "short" type = "short"  default = "101" /&gt;
    &lt;field name = "int" type = "int"  default = "102" /&gt;
    &lt;field name = "long" type = "long"  default = "103" /&gt;
    &lt;field name = "float" type = "float"  default = "1.0" /&gt;
    &lt;field name = "double" type = "double"  default = "2.0" /&gt;
    &lt;field name = "string" type = "string"  default = "test string" /&gt;
    &lt;field name = "doubleLimit"
         type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "booleanArray" type = "array" elementType = "boolean"
         default = "false true false" /&gt;
    &lt;field name = "byteArray" type = "array" elementType = "byte"
         default = "1 2 3" /&gt;
    &lt;field name = "shortArray" type = "array" elementType = "short"
         default = "10 20 30" /&gt;
    &lt;field name = "intArray" type = "array" elementType = "int"
         default = "100 200 300" /&gt;
    &lt;field name = "longArray" type = "array" elementType = "long"
         default = "1000 2000 3000" /&gt;
    &lt;field name = "floatArray" type = "array" elementType = "float"
         default = "1.0 2.0 3.0" /&gt;
    &lt;field name = "doubleArray" type = "array" elementType = "double"
         default = "10.0 20.0 30.0" /&gt;
    &lt;field name = "stringArray" type = "array" elementType = "string"
         default = "one two three" /&gt;
    &lt;field name = "structArray" type = "array" elementType = "structure" /&gt;
    &lt;field name = "arrayArray" type = "array" elementType = "array" /&gt;

&lt;/DBDefinition&gt;</pre>

<h4 id="allTypesRe">allTypesRecord.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;

&lt;structure name = "allTypes" supportName = "generic" &gt;
  &lt;include href = "allTypesCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "allTypes" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;

  &lt;include href = "allTypesCommon.xml" /&gt;
  &lt;field name = "allTypes" type = "structure" structureName = "allTypes" /&gt;
&lt;/recordType&gt;

&lt;/DBDefinition&gt;</pre>
<hr />

<h2 style="text-align: center;text-align: center;" id="License">License
Agreement</h2>
<pre>Copyright (c) 2006 All rights reserved 
The University of Chicago, as Operator of Argonne National Laboratory,
    (UofC) Chicago Ilinois, USA,
Deutsches Elektronen-Synchroton, Member of the Helmholtz Association,
    (DESY), HAMBURG, GERMANY,
BERLINER SPEICHERRING GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H.
    (BESSY), BERLIN, GERMANY.

EPICS JavaIOC is distributed subject to the following license conditions:

 SOFTWARE LICENSE AGREEMENT
 Software: EPICS JavaIOC
 Versions: All

 1. The "Software", below, refers to EPICS JavaIOC (in either source code, or
    binary form and accompanying documentation). Each licensee is
    addressed as "you" or "Licensee."

 2. The copyright holders shown above and their third-party licensors
    hereby grant Licensee a royalty-free nonexclusive license, subject to
    the limitations stated herein and U.S. Government license rights.

 3. You may modify and make a copy or copies of the Software for use
    within your organization, if you meet the following conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement.
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy.

 4. You may modify a copy or copies of the Software or any portion of it,
    thus forming a work based on the Software, and distribute copies of
    such work outside your organization, if you meet all of the following
    conditions:
      a. Copies in source code must include the copyright notice and this
         Software License Agreement;
      b. Copies in binary form must include the copyright notice and this
         Software License Agreement in the documentation and/or other
         materials provided with the copy;
      c. Modified copies and works based on the Software must carry
         prominent notices stating that you changed specified portions of
         the Software.

 5. Portions of the Software resulted from work developed under a U.S.
    Government contract and are subject to the following license: the
    Government is granted for itself and others acting on its behalf a
    paid-up, nonexclusive, irrevocable worldwide license in this computer
    software to reproduce, prepare derivative works, and perform publicly
    and display publicly.

 6. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT WARRANTY
    OF ANY KIND. THE COPYRIGHT HOLDERS, THEIR THIRD PARTY LICENSORS, THE
    UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
    BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME
    ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS,
    OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE
    SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT
    THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE
    OR THAT ANY ERRORS WILL BE CORRECTED.

 7. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDERS, THEIR
    THIRD PARTY LICENSORS, THE UNITED STATES, THE UNITED STATES DEPARTMENT
    OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE,
    INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY
    REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
    POSSIBILITY OF SUCH LOSS OR DAMAGES.


________________________________________________________________________

This software is in part copyrighted by the University of Chicago (UofC)

In no event shall UofC be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
UofC has been advised of the possibility of such damage.

UofC specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and UofC has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the BERLINER SPEICHERRING
GESELLSCHAFT FUER SYNCHROTRONSTRAHLUNG M.B.H. (BESSY), BERLIN, GERMANY.

In no event shall BESSY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
BESSY has been advised of the possibility of such damage.

BESSY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and BESSY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.

________________________________________________________________________

This software is in part copyrighted by the Deutsches Elektronen-Synchroton,
    Member of the Helmholtz Association, (DESY), HAMBURG, GERMANY.

In no event shall DESY be liable to any party for direct, indirect,
special, incidental, or consequential damages arising out of the use of
this software, its documentation, or any derivatives thereof, even if
DESY has been advised of the possibility of such damage.

DESY specifically disclaims any warranties, including, but not limited
to, the implied warranties of merchantability, fitness for a particular
purpose, and non-infringement.  This software is provided on an "as is"
basis, and DESY has no obligation to provide maintenance, support,
updates, enhancements, or modifications.
________________________________________________________________________</pre>
</body>
</html>
