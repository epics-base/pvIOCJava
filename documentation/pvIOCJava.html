<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Java Input/Output Controller</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
/*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     body { margin-right: 10% }
/*]]>*/</style>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Java Input/Output Controller<br />
Overview<br />
2011.12.08</h1>
CONTENTS 

<div class="toc">
<ul>
  <li><a href="#L54">Preface</a></li>
  <li><a href="#L107">Part I: JavaIOC - Brief Description</a> 
    <ul>
      <li><a href="#L117">Overview Of Part I</a> 
        <ul>
          <li><a href="#L127">Getting Started</a></li>
          <li><a href="#L312">Status and Remaining Tasks</a></li>
        </ul>
      </li>
      <li><a href="#L357">Package Summary</a> 
        <ul>
          <li><a href="#L363">default - javaIOC/src</a></li>
          <li><a href="#L369">org.epics.ioc</a></li>
          <li><a href="#L373">org.epics.ioc.swtshell</a></li>
          <li><a href="#L377">javaIOC/xml</a></li>
          <li><a href="#L381">javaIOC/example</a></li>
          <li><a href="#L385">javaIOC/test</a></li>
          <li><a href="#L387">org.epics.ioc.database </a></li>
          <li><a href="#L391">org.epics.ioc.support</a></li>
          <li><a href="#L395">org.epics.ioc.install</a></li>
          <li><a href="#L399">org.epics.ioc.pvCopy</a></li>
          <li><a href="#L403">org.epics.ioc.monitor</a></li>
          <li><a href="#L407">org.epics.ioc.support.basic</a></li>
          <li><a href="#L411">org.epics.ioc.support.alarm</a></li>
          <li><a href="#L415">org.epics.ioc.support.caLink</a></li>
          <li><a href="#L419">org.epics.ioc.support.dbLink</a></li>
          <li><a href="#L423">org.epics.ioc.support.calc</a></li>
          <li><a href="#L427">org.epics.ioc.support.rpc</a></li>
          <li><a href="#L431">org.epics.ioc.support.device</a></li>
          <li><a href="#L435">org.epics.ioc.caV3</a></li>
          <li><a href="#L439">org.epics.ioc.pvAccess</a></li>
          <li><a href="#L443">org.epics.ioc.util</a></li>
          <li><a href="#L463">org.epics.ioc.pdrv</a></li>
          <li><a href="#L467">org.epics.ioc.pdrv.interfaces</a></li>
          <li><a href="#L471">org.epics.ioc.pdrv.testDriver</a></li>
          <li><a href="#L475">org.epics.ioc.pdrv.vxi11</a></li>
        </ul>
      </li>
      <li><a href="#L483">Database Syntax For javaIOC</a></li>
      <li><a href="#L495">Channel Access</a></li>
      <li><a href="#L530">Record Processing</a></li>
      <li><a href="#L635">Database Examples</a> 
        <ul>
          <li><a href="#L679">Record Instance Examples</a> 
            <ul>
              <li><a href="#L681">doubleInput</a></li>
              <li><a href="#L687">doubleOutput</a></li>
              <li><a href="#L693">ai</a></li>
              <li><a href="#L699">ao</a></li>
              <li><a href="#L705">psSimple</a></li>
              <li><a href="#L711">psLinked</a></li>
              <li><a href="#L717">psEmbeded</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L727">Part II: javaIOC Data Model</a> 
    <ul>
      <li><a href="#L735">Summary</a></li>
      <li><a href="#L759">javaIOC Data Model</a> 
        <ul>
          <li><a href="#L763">Basic Concept</a></li>
        </ul>
      </li>
      <li><a href="#L851">Definitions for Standard Properties</a></li>
    </ul>
  </li>
  <li><a href="#L861">Part III: javaIOC - Database Definition</a> 
    <ul>
      <li><a href="#L869">Overview Of Part III</a></li>
      <li><a href="#L979">javaIOC/xml/structures.xml</a> 
        <ul>
          <li><a href="#L981">structures.xml</a></li>
          <li><a href="#L987">records.xml</a></li>
        </ul>
      </li>
      <li><a href="#L999">xml/structure/alarm.xml</a> 
        <ul>
          <li><a href="#L1011">numeric alarms</a></li>
          <li><a href="#L1015">boolean alarms</a></li>
          <li><a href="#L1040">enumerated alarms</a></li>
        </ul>
      </li>
      <li><a href="#L1062">xml/structure/analog.xml</a> 
        <ul>
          <li><a href="#L1066">linearConvert</a></li>
          <li><a href="#L1101">linearConvertInput</a></li>
          <li><a href="#L1121">linearConvertOutput</a></li>
          <li><a href="#L1141">incrementalDouble</a></li>
        </ul>
      </li>
      <li><a href="#L1176">xml/structure/calc.xml</a></li>
      <li><a href="#L1180">xml/structure/caLink.xml</a> 
        <ul>
          <li><a href="#L1184">caProcessLink</a></li>
          <li><a href="#L1204">caMonitorLink</a></li>
          <li><a href="#L1259">caMonitorNotifyLink</a></li>
          <li><a href="#L1294">caInputLink</a></li>
          <li><a href="#L1319">caOutputLink</a></li>
        </ul>
      </li>
      <li><a href="#L1344">xml/structure/dbLink.xml</a> 
        <ul>
          <li><a href="#L1346">dbProcessLink</a></li>
          <li><a href="#L1361">caInputLink</a></li>
          <li><a href="#L1381">caOutputLink</a></li>
        </ul>
      </li>
      <li><a href="#L1403">xml/structures/commonFields.xml</a></li>
      <li><a href="#L1490">xml/structures/control.xml</a></li>
      <li><a href="#L1494">xml/structure/delay.xml</a></li>
      <li><a href="#L1498">xml/structure/event.xml</a></li>
      <li><a href="#L1502">xml/structure/generic.xml</a></li>
      <li><a href="#L1506">xml/structure/portDriver</a> 
        <ul>
          <li><a href="#L1510">portDriver.xml</a></li>
        </ul>
      </li>
      <li><a href="#L1527">xml/structure/rpc.xml</a> 
        <ul>
          <li><a href="#L1531">recordList</a></li>
          <li><a href="#L1535">structureList</a></li>
          <li><a href="#L1539">iocShow</a></li>
          <li><a href="#L1543">recordShow</a></li>
          <li><a href="#L1568">supportStateSet</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L1576">Part IV: JavaIOC - Package Descriptions</a></li>
  <li><a href="#L1586">Package org.epics.ioc</a> 
    <ul>
      <li><a href="#L1590">Overview</a></li>
      <li><a href="#L1664">Starting the JavaIOC with eclipse</a></li>
      <li><a href="#L1670">Starting the JavaIOC without eclipse</a> 
        <ul>
          <li><a href="#L1674">source</a></li>
          <li><a href="#L1680">example</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L1692">Package org.epics.ioc.swtshell</a> 
    <ul>
      <li><a href="#L1696">Overview</a></li>
      <li><a href="#L1749">Channel Access</a> 
        <ul>
          <li><a href="#L1769">Getting a list of the channels in a
          javaIOC.</a></li>
          <li><a href="#L1783">Connecting to a Channel</a></li>
          <li><a href="#L1795">Creating a Request</a></li>
          <li><a href="#L1817">process</a></li>
          <li><a href="#L1827">get</a></li>
          <li><a href="#L1863">put</a></li>
          <li><a href="#L1894">putGet</a></li>
          <li><a href="#L1944">channelRPC</a></li>
          <li><a href="#L1960">array</a></li>
          <li><a href="#L1970">structureArray</a></li>
          <li><a href="#L1984">monitor</a></li>
        </ul>
      </li>
      <li><a href="#L2009">Local JavaIOC</a> 
        <ul>
          <li><a href="#L2011">loadDatabase</a></li>
          <li><a href="#L2040">introspectDatabase</a> 
            <ul>
              <li><a href="#L2048">Database Definitions</a></li>
              <li><a href="#L2052">Local Record Instance</a></li>
              <li><a href="#L2092">Show Information</a></li>
            </ul>
          </li>
          <li><a href="#L2107">portDriver</a></li>
        </ul>
      </li>
      <li><a href="#L2117">iocConsole</a></li>
    </ul>
  </li>
  <li><a href="#L2129">Package org.epics.ioc.xml</a> 
    <ul>
      <li><a href="#L2133">Overview</a></li>
      <li><a href="#L2137">Database XML Syntax</a> 
        <ul>
          <li><a href="#L2139">database</a></li>
          <li><a href="#L2145">auxInfo</a></li>
          <li><a href="#L2180">structure and record</a></li>
          <li><a href="#L2233">package and import</a></li>
          <li><a href="#L2261">Field definition</a></li>
          <li><a href="#L2343">Scalar Types</a></li>
          <li><a href="#L2441">Enumerated Structure</a></li>
          <li><a href="#L2477">Examples</a></li>
          <li><a href="#L2501">Field Initialization</a></li>
          <li><a href="#L2510">Scalar Types</a></li>
          <li><a href="#L2521">string</a></li>
          <li><a href="#L2527">structure scalar</a></li>
          <li><a href="#L2537">structure</a></li>
          <li><a href="#L2555">array</a> 
            <ul>
              <li><a href="#L2599">structureArray</a></li>
            </ul>
          </li>
          <li><a href="#L2609">Macro Substitution and Include</a></li>
          <li><a href="#L2611">Include</a></li>
          <li><a href="#L2638">Macro Substitution</a></li>
          <li><a href="#L2683">Example Include and Macro Substitution</a></li>
        </ul>
      </li>
      <li><a href="#L2693">Database XML Code</a> 
        <ul>
          <li><a href="#L2714">Warning About XML element syntax</a></li>
          <li><a href="#L2748">Java Definitions</a></li>
          <li><a href="#L2752">XML To PVDatabase</a> 
            <ul>
              <li><a href="#L2756">XMLToPVDatabaseFactory</a></li>
              <li><a href="#L2803">XMLToPVDatabaseListener</a></li>
            </ul>
          </li>
          <li><a href="#L2880">Include and Substitution</a></li>
          <li><a href="#L2886">IncludeSubstituteXMLListener</a> 
            <ul>
              <li><a href="#L2915">IncludeSubstituteDetailsXMLListener</a></li>
              <li><a href="#L2968">IncludeSubstituteXMLReader</a></li>
              <li><a href="#L2972">IncludeSubstituteXMLReaderFactory</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L2978">Package org.epics.ioc.util</a> 
    <ul>
      <li><a href="#L2982">Overview</a></li>
      <li><a href="#L2997">Scan Field Support</a> 
        <ul>
          <li><a href="#L2999">Definitions</a></li>
          <li><a href="#L3003">ScanField</a></li>
          <li><a href="#L3007">ScanType</a></li>
          <li><a href="#L3035">ScanFieldFactory</a></li>
        </ul>
      </li>
      <li><a href="#L3045">Periodic and Event Scanners</a> 
        <ul>
          <li><a href="#L3047">Definitions</a></li>
          <li><a href="#L3051">EventAnnounce</a></li>
          <li><a href="#L3059">EventScanner</a></li>
          <li><a href="#L3089">PeriodicScanner</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L3111">Package org.epics.rpc</a> 
    <ul>
      <li><a href="#L3115">Overview</a></li>
      <li><a href="#L3146">Install Factory</a> 
        <ul>
          <li><a href="#L3150">Definitions</a></li>
          <li><a href="#L3154">installStructures</a></li>
          <li><a href="#L3164">installRecords</a></li>
          <li><a href="#L3178">Initialize, and Start Record Instances</a></li>
        </ul>
      </li>
      <li><a href="#L3219">Support Creation</a> 
        <ul>
          <li><a href="#L3223">Definitions</a></li>
          <li><a href="#L3227">Factory</a></li>
          <li><a href="#L3231">SupportCreation</a></li>
        </ul>
      </li>
      <li><a href="#L3249">After Start</a> 
        <ul>
          <li><a href="#L3263">Definitions</a></li>
          <li><a href="#L3267">AfterStartNode</a></li>
          <li><a href="#L3271">AfterStartRequester</a></li>
          <li><a href="#L3275">NewAfterStartRequester</a></li>
          <li><a href="#L3279">AfterStartFactory</a></li>
          <li><a href="#L3302">AfterStart</a></li>
        </ul>
      </li>
      <li><a href="#L3325">Introduction</a></li>
      <li><a href="#L3407">Client</a></li>
      <li><a href="#L3495">Server</a></li>
      <li><a href="#L3562">Examples</a> 
        <ul>
          <li><a href="#L3566">Running the examples</a></li>
          <li><a href="#L3606">The service record</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L3633">Package org.epics.ioc.install</a> 
    <ul>
      <li><a href="#L3637">Overview</a></li>
      <li><a href="#L3668">Install Factory</a> 
        <ul>
          <li><a href="#L3672">Definitions</a></li>
          <li><a href="#L3676">installStructures</a></li>
          <li><a href="#L3686">installRecords</a></li>
          <li><a href="#L3700">Initialize, and Start Record Instances</a></li>
        </ul>
      </li>
      <li><a href="#L3741">Support Creation</a> 
        <ul>
          <li><a href="#L3745">Definitions</a></li>
          <li><a href="#L3749">Factory</a></li>
          <li><a href="#L3753">SupportCreation</a></li>
        </ul>
      </li>
      <li><a href="#L3771">After Start</a> 
        <ul>
          <li><a href="#L3785">Definitions</a></li>
          <li><a href="#L3789">AfterStartNode</a></li>
          <li><a href="#L3793">AfterStartRequester</a></li>
          <li><a href="#L3797">NewAfterStartRequester</a></li>
          <li><a href="#L3801">AfterStartFactory</a></li>
          <li><a href="#L3824">AfterStart</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L3849">Package org.epics.ioc.database</a> 
    <ul>
      <li><a href="#L3853">Overview</a></li>
      <li><a href="#L3889">RecordField Interfaces</a> 
        <ul>
          <li><a href="#L3893">PVRecordField</a></li>
          <li><a href="#L3960">PVRecordStructure</a></li>
        </ul>
      </li>
      <li><a href="#L3979">Record Interfaces</a> 
        <ul>
          <li><a href="#L3981">PVListener</a></li>
          <li><a href="#L4015">PVRecordClient</a></li>
          <li><a href="#L4021">PVRecord</a> 
            <ul>
              <li><a href="#L4135">Record Locking</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#L4143">PVRecord Definition and Creation</a> 
        <ul>
          <li><a href="#L4145">PVDatabase</a></li>
          <li><a href="#L4254">PVRecordCreate</a></li>
          <li><a href="#L4268">PVReplaceFactory</a></li>
        </ul>
      </li>
      <li><a href="#L4292">PVDatabase</a> 
        <ul>
          <li><a href="#L4409">PVDatabaseFactory</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L4433">Package org.epics.ioc.support</a> 
    <ul>
      <li><a href="#L4437">Overview</a> 
        <ul>
          <li><a href="#L4441">RecordProcess</a></li>
          <li><a href="#L4476">Support</a></li>
        </ul>
      </li>
      <li><a href="#L4582">Record Processing Theory of Operation</a> 
        <ul>
          <li><a href="#L4588">Definitions</a></li>
          <li><a href="#L4641">Requester Examples</a></li>
          <li><a href="#L4684">RecordProcess Overview</a></li>
          <li><a href="#L4811">Local Channel Access Example</a></li>
          <li><a href="#L4846">Link Support Example</a></li>
          <li><a href="#L5013">Locking</a></li>
          <li><a href="#L5052">Support Overview</a></li>
        </ul>
      </li>
      <li><a href="#L5091">Record Process</a> 
        <ul>
          <li><a href="#L5093">Definitions</a></li>
          <li><a href="#L5114">RecordProcess - General Purpose Methods</a></li>
          <li><a href="#L5152">RecordProcess - Record Lifetime Methods.</a></li>
          <li><a href="#L5198">RecordProcess - Record Process Requester
            Methods</a></li>
          <li><a href="#L5247">RecordProcess - Support Processing
          methods.</a></li>
          <li><a href="#L5283">RecordProcessRequester</a></li>
          <li><a href="#L5321">ProcessCallbackRequester</a></li>
          <li><a href="#L5331">ProcessContinueRequester</a></li>
          <li><a href="#L5341">RecordProcessFactory</a></li>
        </ul>
      </li>
      <li><a href="#L5347">Support</a> 
        <ul>
          <li><a href="#L5351">Support State</a></li>
          <li><a href="#L5382">Support</a></li>
          <li><a href="#L5461">Record Support</a></li>
        </ul>
      </li>
      <li><a href="#L5467">AbstractSupport</a> 
        <ul>
          <li><a href="#L5469">AbstractSupport</a></li>
          <li><a href="#L5471">Definitions</a></li>
        </ul>
      </li>
      <li><a href="#L5538">Package org.epics.ioc.support.rpc</a> 
        <ul>
          <li><a href="#L5540">Overview</a> 
            <ul>
              <li><a href="#L5555">putProcessGet RPC</a></li>
              <li><a href="#L5574">channelRPC</a></li>
            </ul>
          </li>
          <li><a href="#L5578">ExampleChannelRPC</a></li>
          <li><a href="#L5590">RecordList</a></li>
          <li><a href="#L5618">StructureList</a></li>
          <li><a href="#L5646">IocShow</a></li>
          <li><a href="#L5685">RecordShow</a></li>
          <li><a href="#L5739">SupportStateSet</a></li>
        </ul>
      </li>
      <li><a href="#L5783">Package org.epics.ioc.support.basic</a> 
        <ul>
          <li><a href="#L5785">Overview</a></li>
          <li><a href="#L5841">Generic Support</a></li>
          <li><a href="#L5865">Noop Support</a></li>
          <li><a href="#L5871">ScanFactory</a></li>
          <li><a href="#L5879">Control Limit</a></li>
          <li><a href="#L5885">Linear Conversion</a> 
            <ul>
              <li><a href="#L5889">linearConversion</a></li>
              <li><a href="#L5924">LinearConvertInputFactory</a></li>
              <li><a href="#L5946">LinearConvertOutputFactory</a></li>
            </ul>
          </li>
          <li><a href="#L5968">Incremental Support</a></li>
          <li><a href="#L6001">Event Support</a></li>
          <li><a href="#L6015">DelaySupport</a></li>
        </ul>
      </li>
      <li><a href="#L6045">Package org.epics.ioc.support.calc</a> 
        <ul>
          <li><a href="#L6047">Overview</a></li>
          <li><a href="#L6070">Basic Calculation Support</a> 
            <ul>
              <li><a href="#L6072">Database Definitions for
              Calculations</a></li>
              <li><a href="#L6171">Performing Calculations</a></li>
              <li><a href="#L6179">calcArgs</a></li>
            </ul>
          </li>
          <li><a href="#L6194">ExpressionCalculator</a> 
            <ul>
              <li><a href="#L6198">Simple Examples</a></li>
              <li><a href="#L6216">Expression Syntax</a></li>
              <li><a href="#L6228">Expression Arguments</a></li>
              <li><a href="#L6268">Unary Operators</a></li>
              <li><a href="#L6293">Binary Operators</a></li>
              <li><a href="#L6413">Ternary Operator</a></li>
              <li><a href="#L6417">Math Functions</a></li>
              <li><a href="#L6421">Constant optimization</a></li>
              <li><a href="#L6425">Test</a></li>
            </ul>
          </li>
          <li><a href="#L6429">Package
          org.epics.ioc.support.calc.example</a></li>
        </ul>
      </li>
      <li><a href="#L6449">Package org.epics.ioc.support.alarm</a> 
        <ul>
          <li><a href="#L6451">Overview</a></li>
          <li><a href="#L6527">XML definitions For alarms</a> 
            <ul>
              <li><a href="#L6531">Numeric Scalar</a></li>
              <li><a href="#L6549">Boolean</a></li>
              <li><a href="#L6557">Enumerated</a></li>
            </ul>
          </li>
          <li><a href="#L6585">Alarm Support</a></li>
          <li><a href="#L6632">Value Alarms</a> 
            <ul>
              <li><a href="#L6636">Boolean Alarms</a></li>
              <li><a href="#L6663">Numeric Alarms</a></li>
              <li><a href="#L6669">Enumerated Alarms</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#L6693">Package org.epics.ioc.support.caLink</a> 
        <ul>
          <li><a href="#L6695">Overview</a></li>
          <li><a href="#L6725">Data Types Supported</a></li>
          <li><a href="#L6754">Support Structure Definition</a></li>
        </ul>
      </li>
      <li><a href="#L6764">Package org.epics.ioc.support.dbLink</a> 
        <ul>
          <li><a href="#L6766">Overview</a></li>
          <li><a href="#L6786">Data Types Supported</a></li>
        </ul>
      </li>
      <li><a href="#L6817">Package org.epics.ioc.support.device</a> 
        <ul>
          <li><a href="#L6819">Overview</a></li>
          <li><a href="#L6823">Power Supply Support</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L6847">Package org.epics.ioc.pdrv</a> 
    <ul>
      <li><a href="#L6851">Preface</a></li>
      <li><a href="#L6905">Purpose</a></li>
      <li><a href="#L6961">Status</a></li>
      <li><a href="#L6996">Acknowledgments</a></li>
      <li><a href="#L7005">Overview of portDriver</a> 
        <ul>
          <li><a href="#L7007">Definitions</a></li>
          <li><a href="#L7130">portDriver Interfaces</a></li>
          <li><a href="#L7134">portDriver Factory</a></li>
          <li><a href="#L7151">Connection Management</a></li>
          <li><a href="#L7175">Protecting a Thread from Blocking</a></li>
          <li><a href="#L7181">portThread</a></li>
          <li><a href="#L7226">Driver Can Also Be User</a></li>
          <li><a href="#L7230">Initialization</a></li>
          <li><a href="#L7261">Requesting access to a port</a></li>
        </ul>
      </li>
      <li><a href="#L7276">PortDriver Record Types</a> 
        <ul>
          <li><a href="#L7278">portCreate record</a></li>
          <li><a href="#L7312">portDeviceControl record</a></li>
        </ul>
      </li>
      <li><a href="#L7357">portDriver Factory</a> 
        <ul>
          <li><a href="#L7363">createUser</a></li>
          <li><a href="#L7377">createPort</a></li>
          <li><a href="#L7416">getPortNames</a></li>
          <li><a href="#L7422">getPort</a></li>
        </ul>
      </li>
      <li><a href="#L7436">User</a> 
        <ul>
          <li><a href="#L7442">Status</a></li>
          <li><a href="#L7471">REASON</a></li>
          <li><a href="#L7485">duplicateUser</a></li>
          <li><a href="#L7504">User Queue Request</a></li>
          <li><a href="#L7543">User lock/unlock Port.</a></li>
          <li><a href="#L7555">User connection to a port</a></li>
          <li><a href="#L7561">getPort</a></li>
          <li><a href="#L7567">User connection to a device</a></li>
          <li><a href="#L7575">getDevice</a></li>
          <li><a href="#L7581">User Messages</a></li>
          <li><a href="#L7587">I/O Timeouts</a></li>
          <li><a href="#L7593">Driver Private</a></li>
          <li><a href="#L7606">User Private</a></li>
          <li><a href="#L7612">Passing Information Between User and
          Driver</a></li>
        </ul>
      </li>
      <li><a href="#L7619">Connect Exception</a></li>
      <li><a href="#L7649">Port</a> 
        <ul>
          <li><a href="#L7657">User Locate Device</a></li>
          <li><a href="#L7663">User Connection Methods</a></li>
          <li><a href="#L7669">Informational Methods</a></li>
          <li><a href="#L7708">Connection Methods</a></li>
          <li><a href="#L7752">Driver Methods</a></li>
          <li><a href="#L7786">LockPortNotify</a></li>
        </ul>
      </li>
      <li><a href="#L7822">Device</a> 
        <ul>
          <li><a href="#L7828">User findInterface</a></li>
          <li><a href="#L7847">User Connection Methods</a></li>
          <li><a href="#L7853">User Blocking</a></li>
          <li><a href="#L7859">Informational Methods</a></li>
          <li><a href="#L7893">Connection Methods</a></li>
          <li><a href="#L7942">Driver Methods</a></li>
        </ul>
      </li>
      <li><a href="#L7971">Trace</a> 
        <ul>
          <li><a href="#L7981">Trace Mask Options</a></li>
          <li><a href="#L8024">TraceIO Options</a></li>
          <li><a href="#L8073">Trace File</a></li>
          <li><a href="#L8092">Trace Option Change Listener</a></li>
          <li><a href="#L8102">Generating Trace Messages</a></li>
        </ul>
      </li>
      <li><a href="#L8129">Driver</a> 
        <ul>
          <li><a href="#L8131">PortDriver</a></li>
          <li><a href="#L8160">DeviceDriver</a></li>
        </ul>
      </li>
      <li><a href="#L8184">Appendix: Java Definitions</a></li>
      <li><a href="#L8196">Package org.epics.ioc.support.interfaces</a> 
        <ul>
          <li><a href="#L8198">Overview</a></li>
          <li><a href="#L8277">miscellaneous</a> 
            <ul>
              <li><a href="#L8279">Interface</a></li>
              <li><a href="#L8300">Option</a></li>
              <li><a href="#L8324">DriverUser</a></li>
              <li><a href="#L8345">AbstractInterface</a></li>
            </ul>
          </li>
          <li><a href="#L8394">serial</a> 
            <ul>
              <li><a href="#L8398">SerialInterruptListener</a></li>
              <li><a href="#L8412">Serial</a></li>
              <li><a href="#L8481">AbstractSerial</a></li>
            </ul>
          </li>
          <li><a href="#L8528">uint32Digital</a> 
            <ul>
              <li><a href="#L8530">DigitalInterruptReason</a></li>
              <li><a href="#L8554">UInt32DigitalInterruptListener</a></li>
              <li><a href="#L8568">UInt32Digital</a></li>
              <li><a href="#L8622">AbstractUInt32Digital</a></li>
            </ul>
          </li>
          <li><a href="#L8674">int32</a> 
            <ul>
              <li><a href="#L8680">Int32InterruptListener</a></li>
              <li><a href="#L8694">Int32</a></li>
              <li><a href="#L8735">AbstractInt32</a></li>
            </ul>
          </li>
          <li><a href="#L8780">int32Array</a> 
            <ul>
              <li><a href="#L8786">Int32ArrayInterruptListener</a></li>
              <li><a href="#L8800">Int32Array</a></li>
              <li><a href="#L8849">AbstractInt32Array</a></li>
            </ul>
          </li>
          <li><a href="#L8898">float64</a> 
            <ul>
              <li><a href="#L8904">Float64InterruptListener</a></li>
              <li><a href="#L8918">Float64</a></li>
              <li><a href="#L8962">AbstractFloat64</a></li>
            </ul>
          </li>
          <li><a href="#L8996">float64Array</a> 
            <ul>
              <li><a href="#L9002">Float64ArrayInterruptListener</a></li>
              <li><a href="#L9016">Float64Array</a></li>
              <li><a href="#L9060">AbstractFloat64Array</a></li>
            </ul>
          </li>
          <li><a href="#L9114">GPIB Interfaces</a> 
            <ul>
              <li><a href="#L9118">GpibController</a></li>
              <li><a href="#L9214">GpibDevice</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#L9270">Package org.epics.ioc.pdrv.serial</a> 
        <ul>
          <li><a href="#L9272">Overview</a></li>
          <li><a href="#L9278">Configuration</a></li>
          <li><a href="#L9292">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#L9305">Package org.epics.ioc.pdrv.vxi11</a> 
        <ul>
          <li><a href="#L9307">Overview</a></li>
          <li><a href="#L9378">Configuration</a></li>
          <li><a href="#L9394">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#L9413">Package org.epics.ioc.support.pdrv</a> 
        <ul>
          <li><a href="#L9415">Overview</a></li>
          <li><a href="#L9454">portDriverLink</a></li>
          <li><a href="#L9466">portDriverSupport</a></li>
          <li><a href="#L9472">Support for PortDriverLink</a></li>
          <li><a href="#L9478">Port Creation</a></li>
          <li><a href="#L9492">Port and Device Control</a></li>
          <li><a href="#L9506">Package org.epics.ioc.support.pdrv.scalar</a> 
            <ul>
              <li><a href="#L9508">Overview</a></li>
              <li><a href="#L9512">Int32</a></li>
              <li><a href="#L9522">Float64</a></li>
              <li><a href="#L9532">Java Definitions</a></li>
            </ul>
          </li>
          <li><a href="#L9540">Package org.epics.ioc.support.pdrv.array</a> 
            <ul>
              <li><a href="#L9542">Overview</a></li>
              <li><a href="#L9546">Int32Array</a></li>
              <li><a href="#L9556">Float64Array</a></li>
              <li><a href="#L9566">Java Definitions</a></li>
            </ul>
          </li>
          <li><a href="#L9574">Package org.epics.ioc.support.pdrv.digital</a> 
            <ul>
              <li><a href="#L9576">Overview</a></li>
              <li><a href="#L9580">UInt32Digital</a></li>
              <li><a href="#L9596">Java Definitions</a></li>
            </ul>
          </li>
          <li><a href="#L9604">Package org.epics.ioc.support.pdrv.serial</a> 
            <ul>
              <li><a href="#L9606">Overview</a></li>
              <li><a href="#L9687">UInt32Digital</a></li>
              <li><a href="#L9693">Java Definitions</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L9703">Package org.epics.ioc.pvAccess</a> 
    <ul>
      <li><a href="#L9707">pvAccess Server</a></li>
      <li><a href="#L9711">pvAccess client</a></li>
    </ul>
  </li>
  <li><a href="#L9717">Package org.epics.ioc.pvCopy</a> 
    <ul>
      <li><a href="#L9721">Overview</a></li>
      <li><a href="#L9791">Request String</a> 
        <ul>
          <li><a href="#L9799">Simple Requests</a></li>
          <li><a href="#L9817">Full Request Syntax</a></li>
          <li><a href="#L9861">Examples</a> 
            <ul>
              <li><a href="#L9867">Simple example</a></li>
              <li><a href="#L9891">Power Supply Example</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#L9901">pvRequest</a> 
        <ul>
          <li><a href="#L9903">PVStructure pvRequest</a></li>
          <li><a href="#L9984">Examples</a> 
            <ul>
              <li><a href="#L9988">Simple example</a> 
                <ul>
                  <li><a href="#L9990">The quickest Way</a></li>
                  <li><a href="#L10000">Using the field notation</a></li>
                </ul>
              </li>
              <li><a href="#L10022">Power Supply Example</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#L10036">PVCopy</a></li>
      <li><a href="#L10111">PVCopyMonitor</a></li>
      <li><a href="#L10153">PVCopyFactory</a> 
        <ul>
          <li><a href="#L10155">Java Definition</a></li>
        </ul>
      </li>
      <li><a href="#L10201">PVShare</a></li>
    </ul>
  </li>
  <li><a href="#L10209">Package org.epics.ioc.monitor</a> 
    <ul>
      <li><a href="#L10213">Overview</a></li>
      <li><a href="#L10242">Implementing New Monitor Algorithms</a> 
        <ul>
          <li><a href="#L10258">MonitorFactory</a></li>
          <li><a href="#L10298">MonitorAlgorithm</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#L10327">Package org.epics.ioc.caV3</a> 
    <ul>
      <li><a href="#L10331">Overview</a></li>
      <li><a href="#L10346">Server</a> 
        <ul>
          <li><a href="#L10348">Syntax</a></li>
          <li><a href="#L10395">Get and Put Options</a></li>
          <li><a href="#L10403">monitor options</a></li>
        </ul>
      </li>
      <li><a href="#L10407">Client</a> 
        <ul>
          <li><a href="#L10409">Overview</a></li>
          <li><a href="#L10464">Naming conventions.</a></li>
          <li><a href="#L10497">Data Types Supported</a></li>
          <li><a href="#L10519">Implementation Overview</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</div>

<h2 id="L54">Preface</h2>

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This document is the project and package overviews for pvIOCJava. The
javaDOC is available at <a href="./html/index.html">JavaDoc</a></p>

<p><b>NOTE</b> Originally epics-pvdata was called javaIOC and consisted of a
single eclipse project named javaIOC. This project is the what remains of the
IOC portion of the original javaIOC. The name JavaIOC is still used in many
places in this project.</p>

<p>A JavaIOC is a network accessable smart real time database. A database has
memory resident records which can link to hardware or to other records. A
record consists of a structured set of fields. A record can be processed, i.e.
asked to do something. Each field has an object which implements interface
PVField that provides access to the field's data. Each field of a record can
optionally have associated support, which is defined by a Java interface called
Support. One of the methods of Support is named process. When a process request
is made the process method of each field support is called. Support is what
makes the database a "smart" database.</p>

<p>The JavaIOC project uses project pvData, which provides the database, and
pvAccess, which provides network support for pvData. This package assumes that
you are familiar with pvData and pvAccess.</p>

<p>An Extensible Markup Language (XML) parser is provided for creating a
PVDatabase. The JavaIOC adds support that allows a PVDatabase to become a smart
soft realtime database. The JavaIOC attaches support code to every record and
optionally to any field of a record. The support is configured via xml
definitions. A structure defining support provides the name of a Java factory
that creates support for a field.</p>

<p>The pvData overview gives a simple example of a record instance:</p>
<pre>&lt;record recordName = "simple"&gt;
  &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<p>For the JavaIOC, this lis like it was declared:</p>
<pre>&lt;record recordName = "simple" &gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;scalar name = "value" scalarType = "double"/&gt;
&lt;/record&gt;</pre>

<p>When the ioc adds a new record to the database it looks for support attached
to the record. If it does not find any, it assigns generic support. The
definition for generic is:</p>
<pre>&lt;structure structureName = "genericFactory"&gt;
  &lt;scalar name = "supportFactory" scalarType = "string"&gt;
     org.epics.ioc.support.basic.GenericFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure structureName = "generic"&gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;genericFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>Thus generic is a structure that has no fields and support named generic.
</p>

<p>The overview portion of this document has four parts:</p>
<ul>
  <li>Part I is a brief description of the JavaIOC.</li>
  <li>Part II describes the JavaIOC Data Model. The model 1) supports general
    purpose tools and 2) is used by the JavaIOC support code.</li>
  <li>Part III is a description of the Database Definitions that come with
    JavaIOC.</li>
  <li>Part IV is a description of specific packages that belong to the
    pvIOCJava.</li>
</ul>
<hr />
<hr />

<h2 style="text-align: center" id="L107">Part I: JavaIOC - Brief
Description</h2>
<hr />
<hr />

<p>Part I describes the JavaIOC. Detailed descriptions of the JavaIOC packages
are provided with each package.</p>
<hr />

<h3 style="text-align: center" id="L117">Overview Of Part I</h3>
<hr />

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for large
scientific instruments such as a particle accelerators, telescopes, etc. An IOC
(Input/Output Controller) is a network node that controls and/or monitors a
collection of devices. An IOC contains a memory resident real time database.
The real time database has a set of "smart" records. </p>

<p>JavaIOC is a JAVA implementation of an IOC. It has many similarities to a
EPICS V3 ( the 3.13 and 3.14 releases of EPICS base) but extends the data types
to support structures and arrays and allows any field to optionally have
support.</p>

<h4 id="L127">Getting Started</h4>

<p>JavaIOC is developed as an eclipse project. The following assumes that you
have eclipse installed and have imported javaIOC into a project named
"javaIOC".</p>

<p>In order to use the examples in the javaIOC, the environment variables
IOCNAME, PVDATA, and javaIOC must be defined. For example on linux define:</p>
<pre>export IOCNAME=laptop
export PVDATA=${HOME}/workspace/pvData
export javaIOC=${HOME}/workspace/javaIOC</pre>

<p>Package <span style="font-family: courier;">org.epics.ioc</span> has a Java
program, <span style="font-family: courier;">org.epics.ioc.javaIOC</span>, that
does the following:</p>
<ul>
  <li>Is a javaIOC.</li>
  <li>Reads and installs structures and records into the running IOC.</li>
  <li>Dumps the resulting structure and record definitions.</li>
  <li>Starts servers.</li>
  <li>Invokes swtshell, which is a Graphical User Interface (GUI) shell that
    interacts with a running javaIOC.</li>
</ul>

<p>The arguments to javaIOC can be any combination of:</p>
<ul>
  <li>-structures <br />
    followed by filenames of files containing XML structure definitions.<br />
  </li>
  <li>-records <br />
    followed by filenames of files containing XML record definitions.<br />
  </li>
  <li>-dumpStructures<br />
    dump the structure, create, and support definitions</li>
  <li>-dumpRecords<br />
    dump the record instances</li>
  <li>-server 
    <p>followed by a filenames. Each field is a list of servers to start.</p>
  </li>
  <li>-swtshell<br />
    Start swtshell.</li>
</ul>

<p>For example:</p>
<pre>    -structures xml/structures.xml -records example/exampleDB.xml -dumpStructures -dumpRecords</pre>

<p>Reads a set of files creating structures and records and then dumps the
structures and records.</p>

<p>As a first example specify the arguments as:</p>
<pre>    -server server/pvAccessClient.txt server/caV3Client.txt \
    -structures xml/structures.xml \   
    -records example/exampleDB.xml \  
    -server server/pvAccessServer.txt \ 
    -swtshell</pre>

<p>This:</p>
<ul>
  <li>Starts channel access client support for both pvAccess and caV3. pvAccess
    supports pvData. caV3 supports V3 channel access, i.e. it can communicate
    with a V3 epics IOC.</li>
  <li>Loads a set of structures then a set of record instances.</li>
  <li>Starts the swtshell and also starts the ioc.</li>
  <li>Starts the swtshell.</li>
  <li>Starts the pvAccess server. This allows pvAccess clients to access this
    javaIOC. </li>
</ul>

<p>Just try it. The following window appears:</p>

<center>
<p><img src="./swtshell.gif" alt="swtshell" /></p>
</center>

<p>Next do the following:</p>
<ul>
  <li>click the monitor button and a new window appears 
    <ul>
      <li>click the connect button. A popup window appear.</li>
      <li>click the selectLocalChannel button and select "counter". The popup
        window disappears.</li>
      <li>click the createRequest button. A popup window appears. Click the
        request button. The small window disappears.</li>
    </ul>
  </li>
  <li>click startMonitor button 
    <p>after awhile click "stop" and "disconnect" buttons</p>
  </li>
</ul>

<p>The following is displayed: </p>

<center>
<p><img src="./monitor.gif" alt="monitor" /></p>
</center>

<p>Click the connect button and the following window appears:</p>

<center>
<p><img src="./connectChannel.gif" alt="connectChannel" /></p>
</center>

<p>Click the selectLocal button and select "counter". the connectChannel window
goes away. Next click startMonitor and then start. The monitor updates will
appear.</p>

<p>Leave the monitor window running and do the following:</p>
<ul>
  <li>on swtshell window click introspectDatabase button and a new window
    appears 
    <ul>
      <li>The menu bar at the top provides access to the structure definitons. 
        <ul>
          <li>select and look at the various definitions.</li>
        </ul>
      </li>
      <li>the recordName row provides access to record instances. Click the
        select button and select record "counter" and then click dump. 
        <ul>
          <li>The current value of all fields in record ai are shown</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Now start another instance of javaIOC on another computer in the same local
network with the arguments as:</p>
<pre>    -server server/pvAccessClient.txt\
    -structures xml/structures.xml \   
    -swtshell </pre>

<p>This starts without any local records. Use this to access the records in the
javaIOC that has the example database.</p>

<p>The remainder of this document gives an overview of the javaIOC:</p>
<ul>
  <li>Java interfaces for accessing records and fields.</li>
  <li>Record processing<br />
    A javaIOC has a "smart" real time database. A record instance can be
    Records have associated support code. In addition each field can optionally
    have support. </li>
  <li>Example database definitions and record instances.</li>
</ul>

<h4 id="L312">Status and Remaining Tasks</h4>

<p>The javaIOC has both client and server Channel Access support for both caV3
and pvAccess. Eclipse project pvAccess fully supports network access to pvData.
Support for caV3 means that an existing EPICS channel accesss client can access
any primitive field (or an array of primitives) of a javaIOC record and that a
javaIOC record can link to an EPICS IOC.</p>

<p>The existing features means that the javaIOC is now ready for use at least
as a soft IOC.</p>

<p>The javaIOC implements portDriver which provides the same functionality as
the asynDriver module for EPICS V3. At the present time it is not very useful
because almost no driver support has been implemented. </p>

<p>The following javaIOC components are desirable.</p>
<ul>
  <li>Message Server<br />
    javaIOC interfaces provide methods for sending messages to requesters.
    Currently the requesters just write the messages to System.out or to a
    swtshell text window. A message server facility similar to the V3
    logMessage facility needs to be implemented. Once in place it will be easy
    to modify the existing code to use the message server.</li>
  <li>portDriver<br />
    Hardware drivers. Some support is already available but lots needs to be
    done.</li>
</ul>

<p>Additional components are also desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool. Cosylab is implementing a
    version of VDCT that supports pvData.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a javaIOC.</li>
  <li>Channel Access Clients that implement the javaIOC Channel Access
    Semantics.</li>
  <li>A javaIOC replacement for the sCalc and arrayCalc that come with
  synAPPS.</li>
  <li>etc, etc.</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>
<hr />

<h3 style="text-align: center" id="L357">Package Summary</h3>
<hr />

<p>Documentation is provided via javaDOC. Each package of the javaIOC project
has a package.html overview document. The packages that currently exists
are:</p>

<h4 id="L363">default - javaIOC/src</h4>
<ul>
  <li>This package contains the overview package.html document you are now
    reading.</li>
</ul>

<h4 id="L369">org.epics.ioc</h4>

<p>This package has the javaIOC class.</p>

<h4 id="L373">org.epics.ioc.swtshell</h4>

<p>This is a GUI shell for an ioc. It is implemented via the Standard Widget
Toolkit. Getting Started explains how to invoke it. See the package overview
for a description of swtshell.</p>

<h4 id="L377">javaIOC/xml</h4>

<p>This directory and the structures subdirectory contains the xml structure
definitions for the javaIOC. It also loads the xml definitions from pvData.</p>

<h4 id="L381">javaIOC/example</h4>

<p>This directory contains the example xml files.</p>

<h4 id="L385">javaIOC/test</h4>

<h4 id="L387">org.epics.ioc.database </h4>

<p>This package describes and implements the PVDatabase.</p>

<h4 id="L391">org.epics.ioc.support</h4>

<p>This package provides the framework for processing IOC database records. The
subpackages of this package provide support that uses the framework. Each
record instance must have associated support and each field of a record
instance can optionally have support. </p>

<h4 id="L395">org.epics.ioc.install</h4>

<p>This package provides the code that installs structure and records into a
javaIOC. It allows new structures or records to be installed into a running
IOC.</p>

<h4 id="L399">org.epics.ioc.pvCopy</h4>

<p>This package describes and implements support for creating a PVStructure
that contains a copy of a subset of the fields in a PVRecord. It is used by
pvAccess.</p>

<h4 id="L403">org.epics.ioc.monitor</h4>

<p>This package describes and implements support for monitoring a subset of the
fields in a PVRecord. It is a companion to pvCopy and is used by pvAccess.</p>

<h4 id="L407">org.epics.ioc.support.basic</h4>

<p>This provides basic support such as noop, generic, etc.</p>

<h4 id="L411">org.epics.ioc.support.alarm</h4>

<p>This provides support for alarms.</p>

<h4 id="L415">org.epics.ioc.support.caLink</h4>

<p>This provides for channel access links, i.e. it allows records to
get/put/monitor data in other records.</p>

<h4 id="L419">org.epics.ioc.support.dbLink</h4>

<p>This provides for database links, i.e. it allows records to get/put/monitor
data in other records in this javaIOC.</p>

<h4 id="L423">org.epics.ioc.support.calc</h4>

<p>The provides support for calculations. A calcaulator is support that
produces a result that is assigned to a value field. Included is support named
expressionCalculator, which supports scalar expressions that have standard Java
syntax.</p>

<h4 id="L427">org.epics.ioc.support.rpc</h4>

<p>This provides remote procedure call support for pvAccess channel access
clients. It allows remore clients to list the records and structures in a
javaIOC database,. display information about a javaIOC and about a record in a
javaIOC. </p>

<h4 id="L431">org.epics.ioc.support.device</h4>

<p>This contains examples of support for "device" abstractions.</p>

<h4 id="L435">org.epics.ioc.caV3</h4>

<p>This package is Channel Access V3, e.g. channel access Version 3. Server
support was implemented by Matej Sekoranja (COSYLAB). Client support is also
implemented. Both the client and server require JCA/CAJ, which is supplied by
COSYLAB..</p>

<h4 id="L439">org.epics.ioc.pvAccess</h4>

<p>This package connects pvAccess to the javaIOC. It implements a Channe; as
described by pvAccess. It can be used directly by other records in the same
javaIOC for the pvAccess faculities or can be used by remote pvAccess to access
records in this javaIOC.</p>

<h4 id="L443">org.epics.ioc.util</h4>
This package provides utility code for a javaIOC: 
<dl>
  <dt>Scan Field Support</dt>
    <dd>Support for accessing the scan field of a record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
</dl>

<h4 id="L463">org.epics.ioc.pdrv</h4>

<p>These packages implement portDriver, which is support for accessing and
controlling hardware. It is modeled after the EPICS asynDriver and thus
provides support for synchronous and asynchronous devices. Each device is
accessed via a port. Each port provides access to one or more devices.</p>

<h4 id="L467">org.epics.ioc.pdrv.interfaces</h4>

<p>This directory defines the interfaces for portDriver.</p>

<h4 id="L471">org.epics.ioc.pdrv.testDriver</h4>

<p>This directory contains test port drivers.</p>

<h4 id="L475">org.epics.ioc.pdrv.vxi11</h4>

<p>This directory has a portDriver that implements the VXI11 protocal. Some
testing has been done but more is required befoe it is robust.</p>
<hr />
<hr />

<h3 style="text-align: center" id="L483">Database Syntax For javaIOC</h3>
<hr />

<p>The syntax for both structure and record definitions is XML based. In
addition XML based macro substitution and include is supported. Project pvData
describes the XML syntax. This section gives definitions for a javaIOC
application.</p>

<p>Support is defined via a structure definition. Support is assigned to a
field via an auxInfo attached to the field. For example the definition for
alarm support is:</p>
<pre>&lt;structure structureName = "alarmSupportFactory"&gt;
  &lt;scalar name = "supportFactory" scalarType = "string"&gt;
     org.epics.ioc.support.alarm.AlarmSupportFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure structureName = "alarm" extends = "org.epics.pvData.alarm" &gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;alarmSupportFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>
<hr />

<h3 style="text-align: center" id="L495">Channel Access</h3>
<hr />

<p>Channel Access for pvData is implemented as a separate eclipse project named
pvAccess. See it for details. This project provides the code that implements
the pvAccess Channel interface. It can be used by local records directly or by
the server for remote pvAccess..</p>

<p>This project provides both client and server support for epics V3 channel
access.</p>

<p>For channel access this project has the following features.</p>
<ul>
  <li>Support for attaching the javaIOC to pvAccess.</li>
  <li>An EPICS V3 Channel Access server is available. Thus Channel Access
    clients can access a javaIOC database.</li>
  <li>EPICS V3 Channel Access client code is implemented. This allows the
    javaIOC to communicate with an EPICS IOC.</li>
  <li>Link support is implemented. 
    <ul>
      <li>Get, Put, and PutGet are all supported. Each can optionally process
        the record. Each can access a group of fields in a record instance.
        Structure and Array fields can be accessed.</li>
      <li>MonitorNotify is supported. In this case the client is notified of
        changes but must issue a get to retrieve the data</li>
      <li>Monitor is supported. A monitor includes the data which has changed.
        Any group of fields within a record instance can be monitored.
        Structure and Array fields can be monitored including an entire record
        instance. For appropriate field types onPut, onChange, absoluteChange,
        and percentChange are all supported.</li>
    </ul>
  </li>
</ul>
<hr />

<h3 style="text-align: center" id="L530">Record Processing</h3>
<hr />

<p>Package org.epics.ioc.support describes and implements code directly related
to record processing. The package overview has a section "Record Processing:
Theory of Operation" that provides a description of record processing.</p>

<p>Sub-packagea of org.epics.ioc.support describe and implement all the support
code that comes with javaIOC. Applications can add additional support.</p>

<p>When a set of javaIOC record instances are created and initialized, a
recordProcess object is created for each record instance. The primary function
of recordProcess is to call record support code, which may in turn call field
support code. RecordProcess has methods for the following: </p>
<ul>
  <li>Lifetime Management: initialize, start, stop, uninitialize<br />
    recordProcess just calls the support methods with the same name.</li>
  <li>Processing</li>
  <li>timeStamp support:<br />
    Get/Set methods for a timeStamp.</li>
  <li>trace<br />
    A record instance can generate diagnostic message while processing.</li>
</ul>

<p>The primary purpose of recordProcess is to be the "gatekeeper" for record
processing. Only one object can process a record. A record can be declared to
be self processed which allows an arbitrary number of clients to request
processing. The default is self process true. Methods are available to request
being the record processor and to request processing. A process can be
synchronous or asynchronous. An asynchronous operation is an operation that
blocks, e.g. file I/O. recordProcess provides methods that allow asynchronous
support but that only lock a record instance while the record is being
accessed. </p>

<p>Whenever any field of a record is being accessed or whenever anything is
done that can modify the state of a record, the record must be locked. In most
cases recordProcess automatically takes care of locking and unlocking.</p>

<p>Each record instance must have associated support and each field of a record
can optionally have support.</p>

<p>Support implements interface Support:</p>

<p></p>
<pre>    public interface Support extends Requester {
        String getSupportName();
        SupportState getSupportState();
        PVRecordField getPVRecordField();
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
    }</pre>

<p>where</p>
<dl>
  <dt>Requestor, getSupportName, getSupportState, getPVRecordField</dt>
    <dd>See package org.epics.ioc.support for details.</dd>
  <dt>initialize</dt>
    <dd>Initialization related to the record itself. Support must not connect
      to another record or to hardware.</dd>
  <dt>start</dt>
    <dd>Support can connect to other record or hardware.</dd>
  <dt>stop</dt>
    <dd>Disconnect from other record or hardware.</dd>
  <dt>uninitialize</dt>
    <dd>Remove any connection to the record.</dd>
  <dt>process</dt>
    <dd>Do whatever the support should do for record processing.</dd>
</dl>

<p>The primary purpose of a support module is to help with record processing.
Most support does something with a "value" field. For example the support for a
channel access input link will get a value and put it in the "value" field.</p>

<p>Typical support code does the following core functions:</p>
<ul>
  <li>initialize<br />
    Find the "value" field. Most support modules look for a field named
    "value".<br />
    Many support modules also provide support for other fields, which are
    identified by name. For example if a support module supports alarms it
    looks for a field "alarm".</li>
  <li>process<br />
    This is the core of record processing. What happens is up to the support
    module. For example it can interact with hardware. The channel access
    support reads or write other records.</li>
</ul>

<p>There is no separate concept of record support. Record support just happens
to be the support called by recordProcess, i.e. it is the highest level support
for a record instance. The record support that comes with javaIOC is also
designed to also be structure support, i.e. support for a structure field
embeded within a record.</p>

<p>Support code should not be aware of specific structure types. A support
modules works with some set of fields that it locates at initialization. While
processing it uses the PV interfaces to access the fields. Thus support is
generic. If a structure has the fields required by the support then the support
can be used to help support that structure.</p>

<p>An extreme example is generic support. This can used for a record itself or
for any field that is a stucture. All that it does is look at all the fields in
the structure that it supports. For each field that has support it calls the
support.</p>
<hr />

<h3 style="text-align: center" id="L635">Database Examples</h3>
<hr />

<p>javaIOC/xml the structure definitions for the javaIOC. It also includes the
xml definitions from pvData. Applications can add new structure definitions and
support. This section just gives a few example of using these database
definitions. The complete set of definitions are described in the second part
of this document.</p>

<p>The following are a few examples of record instances. The examples uses the
following support</p>
<ul>
  <li>generic</li>
</ul>
<ul>
  <li>powerSupplyCurrent</li>
</ul>
<dl>
    <dd>Requires fields power, voltage, and current. When it processes it
      computes current from power and voltage.</dd>
</dl>
<ul>
  <li>linearConvertInput</li>
</ul>
<dl>
    <dd>Implements linear conversion from a rawValue to engineering units.</dd>
</dl>
<ul>
  <li>linearConvertOutput</li>
</ul>
<dl>
    <dd>Implements linear conversion from engineering units to a rawValue.</dd>
</dl>
<ul>
  <li>caLink</li>
</ul>
<dl>
    <dd>javaIOC implements channel access links between records</dd>
</dl>

<h4 style="text-align: center" id="L679">Record Instance Examples</h4>

<h5 id="L681">doubleInput</h5>

<p>The following creates a record instance of type double. It is an input
record because input is initialized to a Channel Access inputLink.</p>
<pre>&lt;record recordName = "doubleInput"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "input" extends = "caInputLink"&gt;
        &lt;scalar name = "pvname"&gt;counter&lt;/scalar&gt;
        &lt;scalar name = "request"&gt;value,alarm&lt;/scalar&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5 id="L687">doubleOutput</h5>

<p>The following creates a record instance of type double. It is an output
record because output is initialized to a Channel Access outputLink.</p>
<pre>&lt;record recordName = "doubleOutput"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "output" extends = "caOutputLink"&gt;
        &lt;scalar name = "pvname"&gt;someOutput&lt;/scalar&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5 id="L693">ai</h5>

<p>The following creates an instance of an aiRecord. The raw ADC value is read
via channelAccess support and converted via linearConvertInput support.</p>
<pre>&lt;record recordName = "ai"&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "input" extends = "linearConvertInput"&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "deviceHigh"&gt;2047&lt;/scalar&gt;
            &lt;scalar name = "deviceLow"&gt;-2048&lt;/scalar&gt;
            &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "input" extends = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;somePort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "input" extends = "pdrvInt32Input"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;    
&lt;/record&gt;</pre>

<h5 id="L699">ao</h5>

<p>The following creates an instance of an aoRecord. The value is converted via
linearConvertOutput support to a rawValue which is written via portDriver
support.</p>
<pre>&lt;record recordName = "ao"&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "output" extends = "linearConvertOutput"&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "deviceHigh"&gt;2047&lt;/scalar&gt;
            &lt;scalar name = "deviceLow"&gt;-2048&lt;/scalar&gt;
            &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "output" extends = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;somePort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "output" extends = "pdrvInt32Output"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5 id="L705">psSimple</h5>

<p>The following creates a powerSupply instance that does no input or output.
The power.value must be set via channel access.</p>
<pre>&lt;record recordName = "psSimple" &gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage"&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "current"&gt;
       &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.genericFactory&lt;/auxInfo&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;
         &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.powerSupplyFactory&lt;/auxInfo&gt;
       &lt;/scalar&gt;
    &lt;/structure&gt;
     &lt;structure name = "power"&gt;
      &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "scan" extends = "scan"&gt;
        &lt;scalar name = "processAfterStart"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 id="L711">psLinked</h5>

<p>The following creates a powerSupply record that gets its voltage and writes
its current via channel access.</p>
<pre>&lt;record recordName = "psLinked" &gt;
   &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
        &lt;structure name = "input" extends = "caInputLink"&gt;
            &lt;scalar name = "pvname"&gt;adcVoltageSupported&lt;/scalar&gt;
            &lt;scalar name = "process"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "current" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" &gt;
           &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.powerSupplyFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;structure name = "output" extends = "caOutputLink"&gt;
            &lt;scalar name = "pvname"&gt;current&lt;/scalar&gt;
            &lt;scalar name = "request"&gt;record[process=true]&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "power"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 id="L717">psEmbeded</h5>

<p>The following creates a powerSupply record that gets its voltage and writes
its current via embeded support.</p>
<pre>&lt;record recordName = "psEmbeded"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
        &lt;structure name = "alarm" extends = "alarm" /&gt;
        &lt;structure name = "input" extends = "linearConvertInput"&gt;
            &lt;structure name = "linearConvert"&gt;
                &lt;scalar name = "deviceHigh"&gt;4095&lt;/scalar&gt;
                &lt;scalar name = "deviceLow"&gt;0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "input" extends = "caInputLink"&gt;
                &lt;scalar name = "pvname"&gt;adcVoltageEmbeded&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "current" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double"&gt;
            &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.powerSupplyFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;structure name = "alarm" extends = "alarm" /&gt;
        &lt;structure name = "output" extends = "linearConvertOutput"&gt;
            &lt;structure name = "linearConvert"&gt;
                &lt;scalar name = "deviceHigh"&gt;4095&lt;/scalar&gt;
                &lt;scalar name = "deviceLow"&gt;0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "output" extends = "caOutputLink"&gt;
                &lt;scalar name = "pvname"&gt;dacCurrentEmbeded&lt;/scalar&gt;
                &lt;scalar name = "request"&gt;record[process=true]&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "power"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>
<hr />
<hr />

<h2 style="text-align: center" id="L727">Part II: javaIOC Data Model</h2>
<hr />
<hr />
<hr />

<h3 style="text-align: center" id="L735">Summary</h3>
<hr />

<p>The Data Model supports general purpose client tools. A set of structures
are defined that support the data model. A record supports the data model if it
follows a few simple guidelines.</p>

<p>The model can briefly be described as follows: Clients access a field named
value, which may be a field in the top level structure of a record or in a
substructure. All other fields in the structure are considered properties of
the value field. The fieldname is the property name. The value is usually a
data field, i.e. a scalar type or an array with the elementType being scalar.
All other fields of the structure support the value. Typical property fields
are timeStamp, alarm, display, control, and history.</p>

<p>The timeStamp is a special case. It it appears anywhere in the structure
hieraracy above the value field it is considered a property</p>

<p>For example the following record has a single value field. The value field
has propertys alarm, timeStamp, and display.</p>
<pre>&lt;record recordName = "someRecord" &gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "display" extends = "display" &gt;
        &lt;scalar name = "description"&gt;Sample Description&lt;/scalar&gt;
        &lt;scalar name = "format"&gt;%f&lt;/scalar&gt;
        &lt;scalar name = "resolution"&gt;1&lt;/scalar&gt;
        &lt;scalar name = "units"&gt;volts&lt;/scalar&gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following example has three value fields each with propertys alarm and
timeStamp.</p>
<pre>&lt;record recordName = "psSimple"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage"&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
       &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;/structure&gt;
    &lt;structure name = "current"&gt;
       &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.genericFactory&lt;/auxInfo&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;
         &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.powerSupplyFactory&lt;/auxInfo&gt;
       &lt;/scalar&gt;
       &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;/structure&gt;
     &lt;structure name = "power"&gt;
      &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
      &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;/structure&gt;
    &lt;structure name = "scan" extends = "scan"&gt;
        &lt;scalar name = "processAfterStart"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>A client could ask for power.value, current.value, or voltage.value.</p>

<p>This data model supports existing EPICS V3 channel access clients. More
powerful or special purpose clients can handle structured data. Such clients
can access a structure. For example a client can ask for an entire record. An
example is swtshell.</p>
<hr />

<h3 style="text-align: center" id="L759">javaIOC Data Model</h3>
<hr />

<h4 id="L763">Basic Concept</h4>

<p>A javaIOC structure follows the javaIOC Data Model if it has a set of fields
that have names and types that support the data model. It can have additional
fields, that can also be considered properties. The following field names have
special meaning, i.e. are properties for general purpose clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients access this
      field. All other fields in the structure support or describe the value
      field. The type can any supported type but is usually one of the
      following: 
      <dl>
        <dt>scalar</dt>
          <dd>One of boolean, byte, short, int, long, float, double, or
          string</dd>
        <dt>scalar array</dt>
          <dd>An array with the element type being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index, choice, and
            choices. index is an int that selects a choice. choice is the
            currently selected choice. choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structures can also be defined if clients and support code
            agree on the meaning. Some examples are: 1) A structure defining a
            2D matrix, 2) A structure defining an image, 3) A structure that
            simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      javaIOC structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. </dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>A history structure as described below. It provides a history buffer
      for the value field. Note that currently the javaIOC does not include
      history suppoprt.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition the javaIOC structure can have additional fields that support
the value field but are not recognized by most general purpose client tools.
Typical examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
    value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link. It
      can write a value to hardware. Etc.</dd>
  <dt>link, links</dt>
    <dd>A structure field that contains one or more fields that are database or
      channel access links to other records and that do not effect the record
      containing the linkl field. Thus the database or channel access links are
      either process or output links.</dd>
</dl>

<p>The model allows for device records. A device record has fields that are
structures that support the javaIOC data model. For example a powerSupport
record can have fields power, voltage, current that each support the javaIOC
data model. </p>
<hr />

<h3 style="text-align: center" id="L851">Definitions for Standard
Properties</h3>
<hr />

<p>The set of structures for standard properties for general purpose client
tools are defined in pvData.</p>
<hr />
<hr />

<h2 style="text-align: center" id="L861">Part III: javaIOC - Database
Definition</h2>
<hr />
<hr />

<p>Part III describes the Database Definitions provided with the javaIOC.</p>

<h3 id="L869">Overview Of Part III</h3>

<p>The create, and support definitions implemented by javaIOC are defined. In
addition a set of structure definitions that use the support are provided. A
brief summary is:</p>
<dl>
  <dt style="font-family: courier;">javaIOC/xml</dt>
    <dd>This directory has a file <span
      style="font-family: courier;">structures.xml</span> ,which includes all
      the definitions from xml/structure, and a file <span
      style="font-family: courier;">records.xml</span> ,which includes all the
      definitions from xml/record. </dd>
  <dt style="font-family: courier;">javaIOC/xml/structure</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt style="font-family: courier;">alarm.xml</dt>
          <dd>Contains definitions related to alarms.</dd>
        <dt style="font-family: courier;">analog.xml</dt>
          <dd>Support for analog I/O.</dd>
        <dt style="font-family: courier;">calc.xml</dt>
          <dd>Support for calculations.</dd>
        <dt style="font-family: courier;">caLink.xml</dt>
          <dd>Support for links to other records.</dd>
        <dt style="font-family: courier;">commonFields.xml</dt>
          <dd>Contains definitions for the commonly defined fields.</dd>
        <dt style="font-family: courier;">control.xml</dt>
          <dd>Defines control characteristics.</dd>
        <dt style="font-family: courier;">dbLink.xml</dt>
          <dd>Support for links to other records in the same javaIOC.</dd>
        <dt style="font-family: courier;">delay.xml</dt>
          <dd>Support that implements an asynchronous delay when the process
            method is called. It is normally only used for testing.</dd>
        <dt style="font-family: courier;">digital.xml</dt>
          <dd>Support for digital I/O.</dd>
        <dt style="font-family: courier;">event.xml</dt>
          <dd>Support that announces an event when the process method is
          called.</dd>
        <dt style="font-family: courier;">generic.xml</dt>
          <dd>Support code that can be used to support many records and or
            structures. It just looks for fields that have associated support
            and calls the support.</dd>
        <dt style="font-family: courier;">portDriver.xml</dt>
          <dd>Definitions for portDriver support for the javaIOC</dd>
        <dt style="font-family: courier;">powerSupply.xml</dt>
          <dd>Definitions for the power supply device example.</dd>
        <dt style="font-family: courier;">supportState.xml</dt>
          <dd>Defines the current state of support for a record or field.</dd>
        <dt style="font-family: courier;">rpc.xml</dt>
          <dd>Defines support for RPC records implemented by the javaIOC.</dd>
      </dl>
    </dd>
  <dt style="font-family: courier;">javaIOC/xml/record</dt>
    <dd>This directory has the following file. 
      <dl>
        <dt style="font-family: courier;">rpc.xml</dt>
          <dd>Contains definitions for RPC (Remote Procedure Call) records.</dd>
      </dl>
    </dd>
</dl>

<p>This package overview does not discuss the algorithms implemented by the
support implementations. See package org.epics.ioc.support and sub-packages for
details.</p>

<h3 id="L979">javaIOC/xml/structures.xml</h3>

<h4 id="L981">structures.xml</h4>

<p>This file includes all definitions needed for the support provided by
javaIOC.</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.ioc.*" /&gt;
&lt;include addPath = "${JAVAIOC}/xml/structure" /&gt;
&lt;package name = "org.epics.ioc" /&gt;
&lt;include href = "enumerated.xml" /&gt;
&lt;include href = "timeStamp.xml" /&gt;
&lt;include href = "limit.xml" /&gt;
&lt;include href = "display.xml" /&gt;
&lt;include href = "deadband.xml" /&gt;
&lt;include href = "channelAccess.xml" /&gt;
&lt;include href = "generic.xml" /&gt;
&lt;include href = "commonFields.xml" /&gt;
&lt;include href = "control.xml" /&gt;
&lt;include href = "alarm.xml" /&gt;
&lt;include href = "supportState.xml" /&gt;
&lt;include href = "caLink.xml" /&gt;
&lt;include href = "dbLink.xml" /&gt;
&lt;include href = "analog.xml" /&gt;
&lt;include href = "event.xml" /&gt;
&lt;include href = "calc.xml" /&gt;
&lt;include href = "delay.xml" /&gt;
&lt;include href = "rpc.xml" /&gt;
&lt;include href = "powerSupply.xml" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/xml/structure" /&gt;:qa
&lt;/database&gt;</pre>

<h4 id="L987">records.xml</h4>

<p>This file includes RPC record definition and support provided by the
javaIOC.</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.ioc.*" /&gt;
&lt;include addPath = "${JAVAIOC}/xml/record" /&gt;
&lt;package name = "org.epics.ioc" /&gt;
&lt;include href = "rpc.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/xml/record" /&gt;
&lt;/database&gt;</pre>

<p>The single record is:</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.ioc.*" /&gt;
&lt;import name = "org.epics.pvData.*" /&gt;
&lt;record recordName = "${IOCNAME}recordListRPC" extends = "recordList" /&gt;
&lt;record recordName = "${IOCNAME}structureListRPC" extends = "structureList" /&gt;
&lt;record recordName = "${IOCNAME}iocShowRPC" extends = "iocShow" /&gt;
&lt;record recordName = "${IOCNAME}recordShowRPC" extends = "recordShow" /&gt;
&lt;record recordName = "${IOCNAME}supportStateSetRPC" extends = "supportStateSet" /&gt;
&lt;/database&gt;</pre>

<p>These two files crate a set of RPC records for a javaIOC. The record types
are defined in structure/rpc.xml below.</p>

<h3 id="L999">xml/structure/alarm.xml</h3>

<p>This file contains database definitions related to alarms. Note that pvData
also defines alarms as seen by general purpose tools.</p>

<p>See package org.epics.ioc.support.alarm for a description of the algorithm
for raising alarms.</p>

<p>After defining the alarm severities, it defines a structure alarm. This is
the structure for a field, usually named alarm, that provides the alarm
severity and a message describing why an alarm was raised. A record can have an
alarm field and each structure field in a record can optionally have an alarm
field, i.e. a hierarachy of alarms is supported. If a structure has an alarm
field then when it's support is called to raise an alarm, the support looks up
the parent tree for the first alarm field it finds and raises an alarm equal to
it's own alarm severity. Thus the top level alarm field for the record always
has an alarm severity greater than or equal to all lower level alarms.</p>

<p>The remaining definitions are for checking alarms for value fields.
Definitions and support are available for the numeric types, boolean, and
enumerated. </p>

<p>Look at file xml/structure/alarm.xml to see the actual definitions.</p>

<h4 id="L1011">numeric alarms</h4>

<p>The definitions for byte, short, int, long, float, and double are all the
same except for the data type. The algorithn is the same as the algorithm used
by the ai and ao records from EPICS V3.</p>

<h4 id="L1015">boolean alarms</h4>

<p>Structure booleanAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>falseAlarm</dt>
    <dd>alarm severity if the data value is false.</dd>
  <dt>trueAlarm</dt>
    <dd>alarm severity if the data value is true.</dd>
  <dt>changeStateAlarm</dt>
    <dd>alarm severity if the data value has changed since the last
    process.</dd>
</dl>

<h4 id="L1040">enumerated alarms</h4>

<p>Enumerated alarms are for a data type that is an enumerated structure.</p>

<p>Structure enumeratedAlarm has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>If false than no alarm checking is done.</dd>
  <dt>stateSeverity</dt>
    <dd>An array of alarm severities..</dd>
  <dt>changeStateAlarm</dt>
    <dd>A severity for change of state.</dd>
</dl>

<h3 id="L1062">xml/structure/analog.xml</h3>

<p>This is the support for analog I/O. See org.epics.ioc.support.basic for
details</p>

<h4 id="L1066">linearConvert</h4>

<p>Structure linearConvert is for linear conversions. The slope and intercept
can be specified directly or can be computed from the other four fields.
Normally the record instance defines engUnitsLow and engUnitsHigh and support
code provides values for deviceHigh and deviceLow but other combinations are
also permitted. Structure linearConvert has the fields:</p>
<dl>
  <dt>engUnitsLow</dt>
    <dd>Engineering units value for deviceLow.</dd>
  <dt>engUnitsHigh</dt>
    <dd>Engineering units value for deviceHigh.</dd>
  <dt>deviceHigh</dt>
    <dd>Highest possible raw value.</dd>
  <dt>deviceLow</dt>
    <dd>Lowest possible raw value.</dd>
  <dt>slope</dt>
    <dd>Slope for converting raw value to engineering units.</dd>
  <dt>intercept</dt>
    <dd>Intrercept for converting raw value to engineering units.</dd>
</dl>

<h4 id="L1101">linearConvertInput</h4>

<p>Structure linearConvertInput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to get the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that inputs the raw value.</dd>
</dl>

<h4 id="L1121">linearConvertOutput</h4>

<p>Structure linearConvertOutput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to put the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that outputs the raw value.</dd>
</dl>

<h4 id="L1141">incrementalDouble</h4>

<p>This is for rate limited output. The output value incrementally reaches the
desired value. The structure has the fields:</p>
<dl>
  <dt>desiredValue</dt>
    <dd>The desired value.</dd>
  <dt>input</dt>
    <dd>A structure for reading the desired value.</dd>
  <dt>incrementalOutput</dt>
    <dd>If false the output is set to the desired value if it falls within the
      control limits.</dd>
  <dt>rateOfChange</dt>
    <dd>Rate of change per process if incrementalInput is true.</dd>
  <dt>units</dt>
    <dd>units.</dd>
  <dt>controlLimit</dt>
    <dd>control limits. The output value is forced to be within the control
      limits.</dd>
</dl>

<h3 id="L1176">xml/structure/calc.xml</h3>

<p>This is the support for calculations. See org.epics.ioc.support.calc for
details. Note that expressionCalculator is the default calculator.. </p>

<h3 id="L1180">xml/structure/caLink.xml</h3>

<p>This is the support for a links to other records. See
org.epics.ioc.support.ca for details.</p>

<h4 id="L1184">caProcessLink</h4>

<p>Structure caProcessLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
</dl>

<h4 id="L1204">caMonitorLink</h4>

<p>Structure caMonitorLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
  <dt>queueSize</dt>
    <dd>Must be greater than 1. The default is 2.</dd>
  <dt>reportOverrun</dt>
    <dd>If the data queue is overrun should it be reported by setting status
      and severity?</dd>
  <dt>process</dt>
    <dd>Should the record containing the link be processed after the monotered
      data is read.</dd>
  <dt>request</dt>
    <dd>Specifies the fields to monitor and options.</dd>
</dl>

<h4 id="L1259">caMonitorNotifyLink</h4>

<p>Structure caMonitorNotifyLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
</dl>

<h4 id="L1294">caInputLink</h4>

<p>Structure caInputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider</dd>
  <dt>request</dt>
    <dd>Specifies the fields to get and options. If a requested field is alarm
      than this record inherits the alarm from the linked record.</dd>
</dl>

<h4 id="L1319">caOutputLink</h4>

<p>Structure caOutputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>request</dt>
    <dd>Field to put and options.</dd>
</dl>

<h3 id="L1344">xml/structure/dbLink.xml</h3>

<h4 id="L1346">dbProcessLink</h4>

<p>Structure dbProcessLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
</dl>

<h4 id="L1361">caInputLink</h4>

<p>Structure caInputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>request</dt>
    <dd>fields to get and options.</dd>
</dl>

<h4 id="L1381">caOutputLink</h4>

<p>Structure caOutputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>request</dt>
    <dd>field to put and options.</dd>
</dl>
<hr />

<h3 id="L1403">xml/structures/commonFields.xml</h3>

<p>This file contains database definitions for fields scan and timeStamp.</p>

<p>Definitions for the following structuress:</p>
<dl>
  <dt>priority</dt>
    <dd>The scan priorities: lowest,...,highest</dd>
  <dt>scanType</dt>
    <dd>An enumerated structure that defines the scan types: 
      <dl>
        <dt>passive</dt>
          <dd>A record that is neither periodically or event scanned. Something
            elase can make it process. For example another record with a
            process link.</dd>
        <dt>event</dt>
          <dd>An event scanned record. In this case an eventName is also
            assigned to the record.</dd>
        <dt>periodioc</dt>
          <dd>A periodically scanned record. In this case a rate is also
            assigned to the record.</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt>timeStamp</dt>
    <dd><dl>
        <dt>secondsPastEpoch</dt>
          <dd>Seconds past the epoch which is Jan 1, 1970 UTC. This is
            compatible with Java and POSIX.</dd>
        <dt>nanoSeconds</dt>
          <dd>nanoseconds within the second.</dd>
      </dl>
    </dd>
  <dt>scan</dt>
    <dd><dl>
        <dt>priority</dt>
          <dd>The thread priority for a periodic and event scanning.</dd>
        <dt>type</dt>
          <dd>Scan type, i.e. passive, event, or periodic</dd>
        <dt>rate</dt>
          <dd>Periodic scan rate in seconds</dd>
        <dt>eventName</dt>
          <dd>The event name for event scanned records.</dd>
        <dt>singleProcessRequester</dt>
          <dd>Is only a single requester allowed to request processing? The
            default is false..</dd>
        <dt>processAfterStart</dt>
          <dd>determines if the record instance should be processed one time
            after the record enters the ready state. If the value is true than
            recordProcess attempts to process the record immeriately after it
            becomes ready. The attempt is only successfull if no record
            processor is registered of if the record has been initialized to be
            processSelf.</dd>
        <dt>maxConsecutiveActive</dt>
          <dd>The periodic and event scanners will generate a message if they
            find the record active maxConsecutiveActive times.</dd>
      </dl>
    </dd>
</dl>

<h3 id="L1490">xml/structures/control.xml</h3>

<p>This is a structure and support for control limits.</p>

<h3 id="L1494">xml/structure/delay.xml</h3>

<p>This is the support that delays before completing. It is used for testing.
See org.epics.ioc.support.basic for details.</p>

<h3 id="L1498">xml/structure/event.xml</h3>

<p>This is the support for announcing events. See org.epics.ioc.support.basic
for details.</p>

<h3 id="L1502">xml/structure/generic.xml</h3>

<p>Generic is the default support for many record types. It just calls the
support for any fields that have support. See org.epics.ioc.support.basic for
details.</p>

<h3 id="L1506">xml/structure/portDriver</h3>

<p>This is the support for portDriver. See org.epics.ioc.support.pdrv and
org.epics.ioc.portDriver for details.</p>

<h4 id="L1510">portDriver.xml</h4>

<p>This includes portDriver related files.</p>
<dl>
  <dt>portDriver/arraySupport.xml</dt>
  <dt>portDriver/digitalSupport.xml</dt>
  <dt>portDriver/scalarSupport.xml</dt>
  <dt>portDriver/serialSupport.xml</dt>
  <dt>portDriver/support.xml</dt>
  <dt>portDriver/drivers.xml</dt>
</dl>

<h3 id="L1527">xml/structure/rpc.xml</h3>

<p>This contains for RPC records and support:</p>

<h4 id="L1531">recordList</h4>

<p>This provides a list of record names selected via a regular expression. See
swtshell for an example of how a client issues a request.</p>

<h4 id="L1535">structureList</h4>

<p>This provides a list of structure names selected via a regular expression.
See swtshell for an example of how a client issues a request.</p>

<h4 id="L1539">iocShow</h4>

<p>This provides information about tjhe javaIOC: badRecords, threads, and
memory usage. It also provides the ability to ask java to garbage collect.</p>

<h4 id="L1543">recordShow</h4>

<p>This provides the following features:</p>
<dl>
  <dt>trace</dt>
    <dd>Trace can be turned on or off for a record instance.</dd>
  <dt>enable</dt>
    <dd>Processing of a record instance can be enabled or disabled.</dd>
  <dt>timeProcess</dt>
    <dd>If no record processor is registered foe the record or if it is
      selfProcessd a request can be made to measure how many times per second
      the record can be processed..</dd>
  <dt>releaseProcessor</dt>
    <dd>A request can be made to release the record processor. THIS IS A
      DANGEROUS OPERATION. It should only be issued if the record processor
      fails. </dd>
</dl>

<h4 id="L1568">supportStateSet</h4>

<p>This allows a client to set the support state for a record.</p>
<hr />
<hr />

<h2 style="text-align: center" id="L1576">Part IV: JavaIOC - Package
Descriptions</h2>
<hr />
<hr />

<p>The following sections provide documentation for packages that belong to
pvIOCJava.</p>
<hr />

<h2 style="text-align: center" id="L1586">Package org.epics.ioc</h2>
<hr />

<h3 id="L1590">Overview</h3>

<p>This package has a single class called JavaIOC. It's purpose is to start a
JavaIOC.</p>

<p>NOTE: The environment variables IOCNAME, PVDATA, PVACCESS. and JAVAIOC
should be defined.</p>

<p>JavaIOC is developed as part of an eclipse project. It uses two other
eclipse projects: pvData and pvAccess. One way to start it is to check out the
eclipse projects and then use then run JavaIOC as a java application. The
following assumes that you have eclipse installed and have imported pvIOCJava
into a project named "pvIOCJava". In addition project pvDataJavai and
pvAccessJava must also exist as eclipse projects.</p>

<p>JavaIOC does the following:</p>
<ul>
  <li>Reads xml files containing structure and record definitions.</li>
  <li>Dumps the resulting structure and record definitions.</li>
  <li>Starts servers.</li>
  <li>Starts running the javaIOC. There are two options: 
    <ul>
      <li>Invokes swtshell, which is a Graphical User Interface (GUI) shell
        that interacts with a running JavaIOC</li>
      <li>Run without a shell.</li>
    </ul>
  </li>
</ul>

<p>The arguments to JavaIOC can be any combination of:</p>
<ul>
  <li>-structures<br />
    followed by filenames of files containing XML structure definitions.</li>
  <li>-records<br />
    followed by filenames of files containing XML record definitions.</li>
  <li>-dumpStructures<br />
    dump the structure, create, and support definitions</li>
  <li>-dumpRecords<br />
    dump the record instances</li>
  <li>-server 
    <p>followed by filenames. Each field is a list of servers to start. See
    javaIOC/server for a list of the server files supplied by javaIOC
    itself.</p>
  </li>
  <li>-run<br />
    Stop processing arguments and run forever.</li>
  <li>-swtshell<br />
    Start swtshell. This will also stop processing arguments.</li>
</ul>

<h3 id="L1664">Starting the JavaIOC with eclipse</h3>

<p>Open the src tree and the select org.epics.ioc.JavaIOC and then run as Java
Application. If this is the first time or it is not the configuration desired
then stop the running JavaIOC.</p>

<p>With the run menu select "run configurations". Then select Arguments. Then
add the desired arguments as described above and then run. </p>

<h3 id="L1670">Starting the JavaIOC without eclipse</h3>

<p>The JavaIOC can also be started without eclipse. In the same directory have
a file named source and files that start JavaIOC. The following is an example
that works on linux or macOS.</p>

<h4 id="L1674">source</h4>

<p>This is a sample source file:</p>
<pre>pwd=$PWD
# The following assumes that pvDataJava, pvAccessJava, and pvIOCJava
# are eclipse projects in $HOME/hg
export WORKSPACE=$HOME/hg
export PVDATA=${WORKSPACE}/pvDataJava
export PVACCESS=${WORKSPACE}/pvAccessJava
export JAVAIOC=${WORKSPACE}/pvIOCJava
export CLASSPATH=${CLASSPATH}:${PVDATA}/bin
export CLASSPATH=${CLASSPATH}:${PVACCESS}/bin
export CLASSPATH=${CLASSPATH}:${JAVAIOC}/bin
export CLASSPATH=${CLASSPATH}:${JAVAIOC}jar/CAJ.jar
export CLASSPATH=${CLASSPATH}:${JAVAIOC}jar/JCA.jar
# The following MUST be changed to locate the release of swt on your system
export CLASSPATH=${CLASSPATH}:/usr/lib/eclipse/swt.jar</pre>

<h4 id="L1680">example</h4>

<p>The following is the contents of a file named startExample</p>
<pre>#! /bin/bash
source source
java \ 
     -server \
     org.epics.ioc.JavaIOC \
     -structures ${JAVAIOC}/xml/structures.xml \
     -records  ${JAVAIOC}/example/exampleDB.xml \
     -server ${JAVAIOC}/server/pvAccessServer.txt \
     -swtshell </pre>

<p>To start the example just type:</p>
<pre>./startExample</pre>
<hr />

<h2 style="text-align: center" id="L1692">Package org.epics.ioc.swtshell</h2>
<hr />

<h3 style="text-align: center" id="L1696">Overview</h3>

<p>This package provides a GUI shell implemented via the SWT toolkit that comes
with eclipse. The default JavaIOC package overview document gives brief
instructions for starting the swtshell. If you want to communicate with another
javaIOC then the option "-server server/pvAccessClient.txt" must be given when
the javaIOC is started. If you want to communicate with a V3 EPICS IOC then the
option "-server server/caV3Client.txt" must be given. Both options can be
given. </p>

<p>The following window appears when swtshell is started:</p>

<center>
<p><img src="./swtshell.gif" alt="swtshell" /></p>
</center>

<p>The window has the following buttons:</p>
<ul>
  <li>channelList:<br />
    This obtains a list of the channels in a javaIOC. </li>
  <li>process,get,put,putGet,channelRPC, monitor, array, and structureArray:<br
    />
    Each of these brings up another window which provides the ability to access
    data via channel access. The next section describes these windows:</li>
  <li>iocConsole<br />
    This provide a window which shows all messages sent to any record of the
    local javaIOC. This is shown in a later section.</li>
  <li>loadDatabase and introspectDatabase<br />
    Each of these buttons starts another window for interacting with the local
    javaIOC. They are described below.</li>
  <li>portDriver<br />
    Starts a window for interacting with a portDriver port and device.</li>
  <li>v3iocshell<br />
    The v3iocshell buttom starts a V3 epics ioc that is part of the same
    process as the javaIOC. In the future this will be used to communicate with
    asynDriver port drivers. For now this button is not documented. </li>
</ul>

<p><span style="font-weight:bold;">NOTE</span>: After text is typed into any
text input window, the enter key must be pressed.</p>

<h3 style="text-align: center" id="L1749">Channel Access</h3>

<p>The channelList, get, put, process,putGet,channelRPC, monitor,array, and
structureArray buttons each start a new window. Each window provides the
ability to connect to a PV (Process Variable). </p>

<p>The window gets data from a local or remote IOC. The data is accessed via
Channel Access, which can be either V3 or V4 channelAccess</p>

<p>For EPICS V3 Channel Access only the following data can be accessed:</p>
<ul>
  <li>primitive data </li>
  <li>array of primitive data</li>
  <li>Channel Access V3 properties.</li>
</ul>

<p>See package org.epics.ioc.caV3 for details about caV3.</p>

<h4 id="L1769">Getting a list of the channels in a javaIOC.</h4>

<p>This obtains a list of a subset, selected by a regular expression, of the
records in a javaIOC. A name can be selected and dropped into a connect window
descibed in the next sub-section.</p>

<p>When channelList is selected from the main swtshell window the following
window appears.</p>

<center>
<p><img src="./channelList.gif" alt="channelList" /></p>
</center>

<p>The provider is normally CAV4 but could also be selected as local, i.e. the
javaIOC that is in the same process as swtshell. The icname must be specified.
A regular expression selects the set of records to list. The above example
selects all records with names ending in "RPC". The default regular expression
".*" selects all records. When the enter key is pressed in the
regularExpression, the list of channels is read via channel access.</p>

<p>The implementation issues a channel access putGet request to get the channel
list It requres that the javaIOC have an RPC record ( RPC records are descibed
below) that provides the record list. The record must be named
"${IOCNAME}recordListRPC" where IOCNAME is the name of the javaIOC.</p>

<h4 id="L1783">Connecting to a Channel</h4>

<p>The process,get, put, putGet, channelRPC, monitor, and array windows all
have a connect button. When this button is pressed the following window
appears:</p>

<center>
<p><img src="./connectChannel.gif" alt="connectChannel" /></p>
</center>

<p>If selectLocalRecord is clicked then a list of all the records in the local
javaIOC is presented. When a record is selected a request is made to create a
channel connected to the record and control returned to the window that has the
connect button.</p>

<p>For a remote record a pvname can be entered. Note that the record name can
be obtained from the channelList described in the previous sub-section. When
return is clicked a request is made to create a channel to the selected record
and control returned to the window that has the connect button.</p>

<h4 id="L1795">Creating a Request</h4>

<p>The get, put, putGet and monotor windows all have a createRequest button,
which can activated after connecting to a channel. createRequest allows you to
select an arbitarary set of fields from the PVRecord to which the channel is
connected. All also show a text window with the curent request string
displayed. This text window can be modified or the createRequest button can be
clicked to use introspection to select a set of fields.</p>

<p>When the createRequest button is pressed the following window appears:</p>

<center>
<p><img src="./createRequest.gif" alt="createRequest" /></p>
</center>

<p>Again the text window can be edited. If options are provided for fields
thety must be manually entered.</p>

<p>When the introspect button is clicked a window like the following appears.
The details depend on the record structure.</p>

<center>
<p><img src="./getSubSet.gif" alt="getSubSet" /></p>
</center>

<p>This window allows the user to select an arbitrary set of fields from the
PVRecord to which the channel is attached. When the arrow for a structure field
is clicked the fields for that structure appear. A field is selected by
clicking the button next to the field name. If a structure field is selected
the entire structure is selected.</p>

<p>A request can also be specified via a text window and then clicking the
request button. The rules for specifying the request via a text string are
specified by org.epics.pvData.pvCopy See the package overview for details.</p>

<h4 id="L1817">process</h4>

<p>The following window appears when the process button is pushed:</p>

<center>
<p><img src="./process.gif" alt="process" /></p>
</center>

<p>The connect button is for connecting and disconnecting to/from a channel.
The createProcess button is for creating and destroying a channelProcess
request. The process button sends a process request to the channel access
server.</p>

<h4 id="L1827">get</h4>

<p>Clicking the get button of the swtshell window creates the following window.
The following shows the window after connecting to a channel and clicking
createGet.:</p>

<center>
<p><img src="./get.gif" alt="get" /></p>
</center>

<p>The first row has the following widgets:</p>
<dl>
  <dt>conect</dt>
    <dd>This was described above. Note that after connecting to a channel the
      button becomes disconnect.</dd>
  <dt>createRequest</dt>
    <dd>This was described above. Note that the test window can also be
    edited.</dd>
  <dt>crateGet</dt>
    <dd>Create and destroy a channelGet request.</dd>
  <dt>get</dt>
    <dd>Issue a get request. The result is shown in the text window.</dd>
  <dt>dump</dt>
    <dd>This shows the current data values.</dd>
</dl>

<h4 id="L1863">put</h4>

<p>The following window appears when the put button is pushed:</p>

<center>
<p><img src="./put.gif" alt="put" /></p>
</center>

<p>Except for put the top row is just like get.</p>

<p>When the put button is clicked then what happens depends of how many fields
where selected from the PVRecord. If only a single scalar or array field was
selected, then a text entry box apppears. When a value is entered and the
return key is pressed then this value is sent via channel access.</p>

<p>If more than a single scalar or array field was selected then when put is
clicked a window appears that allows the user to provide values to each scalar
or array field of the selected fields. This window is:</p>

<center>
<p><img src="./getValue.gif" alt="getValue" /></p>
</center>

<p>This display allows the user to give values to any of the scalar or array
fields.</p>

<p>If a primitive or array of primitives is selected then when edit is clicked
the following happens: </p>
<ul>
  <li>The text entry window shows the current value.</li>
  <li>After text is entered and the enter key presssed the data is put in the
    PVStructure created as a result of createRequest.</li>
</ul>

<p>When done is clicked the modified fields are sent to the channel access
server and written to the PVRecord.</p>

<h4 id="L1894">putGet</h4>

<p>The following window appears when the putGet button is pushed. It is similar
to get and put except that both a putRequest and a getRequest must be
specified.</p>

<center>
<p><img src="./putGet.gif" alt="putGet" /></p>
</center>

<p>A typical use of putGet is to issue a remote procedure call. An RPC record,
by convention, has the following:</p>
<ol>
  <li>A top level feld named arguments.</li>
  <li>A top level field named result.</li>
  <li>Support that implements the RPC semantics.</li>
</ol>

<p>A client issues an RPC request as follows:</p>
<ol>
  <li>Gives values to the arguments.</li>
  <li>issues a putProcessGet</li>
  <li>Gets the result values.</li>
</ol>

<p>To use the putGet swt window to issue an RPC the client connects to a RPC
record, selects process, and for the createPutRequest selects arguments from
the following window.</p>

<center>
<p><img src="./RPCputRequest.gif" alt="RPCputRequest" /></p>
</center>

<p>Then result is selected from the createGetRequest window.</p>

<center>
<p><img src="./RPCgetRequest.gif" alt="RPCgetRequest" /></p>
</center>

<center>
<p>The following shows an example result.</p>

<p><img src="./putGet.gif" alt="putGet" /></p>
</center>

<h4 id="L1944">channelRPC</h4>

<p>The following window appears when the channelRPC button is pushed. A
channelRPC returns a new PVStructure for each request. The record must support
a channelRPC request.</p>

<center>
<p><img src="./channelRPC.gif" alt="channelRPC" /></p>
</center>

<p>The createArgument and argument controls are used to create the
introspection interface for the data the client will pass to the server. The
text window that shows the value "argument" is the field name of the top level
structure for the argument. It can be changed to any valid field name, e. g.
"NTTable". When the createArgument button is clicked the following window
appears:</p>

<center>
<p><img src="./createStructure.gif" alt="createStructure" /></p>
</center>

<p>You enter a fieldName and select a type. If the type is scalar or
scalarArray then you must also select a scalarType. When you click add the new
field will appear in the console window. If you select type structure or
structureArray then when you select add a new structureArray window will
appear. You follow the same procedure to create a sub structure.When you click
done the createStructure window disappears. </p>

<h4 id="L1960">array</h4>

<p>The following window appears when the array button is pushed:</p>

<center>
<p><img src="./array.gif" alt="array" /></p>
</center>

<p>This window has a connect/disconnect button and a createArray/destroyArray
button. It has a text entry for subField. The get button issues a array get
request. The offset and count can be specified. The result is written into the
value field of the put row. The put button issues a put array request. The
offset can be specified. The value field provides the array values. The
setLength button is used to set the length and/or capacity of the array. A
value of -1 means leave as is.</p>

<h4 id="L1970">structureArray</h4>

<p>This is used to get and modify elements of a PVStructureArray. You must get
before issuing a put. The puts will modify the data obtained via the get and
then put the data back.</p>

<p>The following window appears when the structureArray button is pushed:</p>

<center>
<p><img src="./structureArray.gif" alt="structureArray" /></p>
</center>

<p>This window has a connect/disconnect button and a createArray/destroyArray
button. It has a text entry for subField. The get button issues a array get
request. The offset and count can be specified. The result is written to the
consoleText window. You must issue a get before using put.</p>

<p>The put row acts on the data received from a put. You change elements by
giving a value to index and clicking putElement. A tree structured window just
like for put appears. This is changing the local data. When you click put the
data is written to the actual record. The setLength button is used to set the
length and/or capacity of the array. A value of -1 means leave as is.</p>

<h4 id="L1984">monitor</h4>

<p>The following window appears when the monitor button is pushed:</p>

<center>
<p><img src="./monitor.gif" alt="monitor" /></p>
</center>

<p>The controls in the first row are similat to get and put. Note that the
queueSize can be set.</p>

<p>The other controls provide:</p>
<dl>
  <dt>serverInfo</dt>
    <dd>The status of the connection is shown </dd>
  <dt>simulateDelay</dt>
    <dd>This is for testing channel access. If a non-zero value is specified a
      delay occurs after each monitor is received.</dd>
  <dt>When start is clicked monitoring is started. It changes to a stop button
  while monitoring is active.</dt>
</dl>

<h3 style="text-align: center" id="L2009">Local JavaIOC</h3>

<h4 id="L2011">loadDatabase</h4>

<p>The following window appears when the loadDatabase button is pushed:</p>

<center>
<p><img src="./loadDatabase.gif" alt="loadDatabase" /></p>
</center>

<p>This is used to load additional IOCDB definitions to a running IOC. It has
the following controls:</p>
<dl>
  <dt>find</dt>
    <dd>This brings up a file selection box that allows the selection of a DBD
      or DB file.</dd>
  <dt>show</dt>
    <dd>Lists the selected file.</dd>
  <dt>loadDB</dt>
    <dd>Adds definitions from the selected file to the JavaIOC file. Structure,
      create, and support definitions are added only if the file loads without
      error. It is an error if the definition already exists.</dd>
    <dd>Record instances are loaded, initialized, and started. If all of the
      new record instances are stated, then the records are added to ther
      master database. If any record fails to start, all the records are
      uinitialized and are not added to the master database.</dd>
</dl>

<h4 id="L2040">introspectDatabase</h4>

<p>The following window appears when the introspectDatabase button is
pushed:</p>

<center>
<p><img src="./introspectDatabase.gif" alt="introspectonsole" /></p>
</center>

<h5 id="L2048">Database Definitions</h5>

<p>The top menubar allows the use to see all the structure definitions in the
master database.</p>

<h5 id="L2052">Local Record Instance</h5>

<p>The next three row allows the user to select and interact with a local
record. The select button is used to select a local record. The text window
after select shows the currently selected record and can also be used to enter
a record name. The remaining buttons apply to the selected button. They are:</p>
<dl>
  <dt>dump</dt>
    <dd>shows the contents of the record.</dd>
  <dt>showState</dt>
    <dd>shows the state of the record.</dd>
  <dt>setTrace</dt>
    <dd>Allows the user to set trace on or off.</dd>
  <dt>setEnable</dt>
    <dd>Allows the use to set the enable state on or off.</dd>
  <dt>timeProcess</dt>
    <dd>Show how many times selected record can be processed per second.</dd>
  <dt>setSupportState</dt>
    <dd>Allows the use to issue a support state method, i.e. initialize, start,
      stop, or uninitialize.</dd>
  <dt>releaseProcessor</dt>
    <dd>Allows the use to force the release of the current record processor.
      This is a dangorous operation!!</dd>
</dl>

<h5 id="L2092">Show Information</h5>

<p>The third row has two buttons that show information. They are:</p>
<dl>
  <dt>showBadRecords</dt>
    <dd>Show all records that havesomething out of ordinary. For example
      disabled, in alarm state, active, not ready.</dd>
  <dt>showThreads</dt>
    <dd>Shows all threads created via the thread utilities in package
      org.epics.ioc.util.</dd>
</dl>

<h4 id="L2107">portDriver</h4>

<p>The following window appears when the portDriver button is pushed:</p>

<center>
<p><img src="./portDriver.gif" alt="portDriver" /></p>
</center>

<p>The first row has buttons to select a port and a device. The other rows are
for setting trace options and for connect and enable commands.</p>

<h3 style="text-align: center" id="L2117">iocConsole</h3>

<p>The following window appears when the iocConsole button is pushed:</p>

<center>
<p><img src="./iocConsole.gif" alt="iocConsole" /></p>
</center>

<p>When this is started, it calls iocdb.addRequester where iocdb is the master
IOCDB. Whenever any code sends a message to the iocdb, the message is displayed
on the iocConsole window. Note that iocdb puts the messages on a queue and has
a separate thead that send the messages to the requesters.</p>
<hr />

<h2 style="text-align: center" id="L2129">Package org.epics.ioc.xml</h2>
<hr />

<h3 style="text-align: center" id="L2133">Overview</h3>

<p>One way to create structures and records for a PVDatabase is via
XMLToPVDatabaseFactory, which parses structure and record definitions from an
xml file, creates structure and record instances and adds then to a PVDatabase.
This overview first defines the xml syntax and then interfaces and code for
reading the xml files.</p>

<h3 style="text-align: center" id="L2137">Database XML Syntax</h3>

<h4 style="text-align:center;" id="L2139">database</h4>
A JavaIOC database file is an XML file with the following structure: 
<pre> &lt;?xml version="1.0" ?&gt;
&lt;database
   xmlns="urn:schemas-epics-org:javaioc:1.0"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="urn:schemas-epics-org:javaioc:1.0 javaioc.xsd"
   xmlns:model="urn:schemas-cosylab-com:model:1.0"
   name="database"&gt;
   &lt;!--  arbitrary set of structure and record definitions --&gt;
&lt;/database&gt;</pre>

<h4 style="text-align:center;" id="L2145">auxInfo</h4>

<p>An auxInfo defines additional information for a record, structure, or field.
It is for use by applications that require additional information for a field.
An arbitrary number of auxInfo can be created for any field. </p>

<p>An auxInfo is defined as follows:</p>
<pre>&lt;auxInfo name = "auxInfoName" scalarType = "scalarType"&gt;
   value
&lt;/auxInfo&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">auxInfoName</span></dt>
    <dd>The auxInfo name.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The type as described below.</dd>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>The value as described below.</dd>
</dl>

<p>The following auxInfo is supported for every field:</p>
<pre>    &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;
         value
    &lt;/auxInfobu&gt;</pre>

<p>value must be the name of a structure that provides the name of a factory
that will provide the PVField implementation.</p>

<h4 style="text-align:center;" id="L2180">structure and record</h4>

<p>Structure definitions exist so that a structure field of a record can be
initialized with the fields of a previously defined structure definition. A
structure is defined as follows:</p>
<pre>&lt;structure structureName = "structureName" extends = "otherStructureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>The structure name.</dd>
  <dt><span style="font-family: courier">otherStructureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current structure will be initialized to have all
      attributes and fields of the other structure. The current structure can
      changed the attributes and fields and can append additional fields to the
      structure.</dd>
  <dt>field</dt>
    <dd>Zero or more fields can be defined. Each field must have a unique name.
      Order is important.</dd>
</dl>

<p>A record is a structure instance which has a record instance name. A record
is defined as follows:</p>
<pre>&lt;record recordName = "recordName" extends = "structureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">recordName</span></dt>
    <dd>The record name. If the record with this name already exists then this
      definition can modify fields in the existing record but structureName
      must not be defined. recordName which must be specified,is a string with
      a combination of the following characters: 
      <ul>
        <li><span style="font-family: courier">0-9 A-Z a-z _ - : ; [
        ]</span></li>
        <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
      </ul>
    </dd>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current record will be initialized to have all attributes
      and fields of the structure. The record can changed the attributes and
      fields and can append additional fields to the structure. The name should
      follow the same convention that Java uses for package names. See the next
      section for details.</dd>
</dl>

<h4 style="text-align:center;" id="L2233">package and import</h4>

<p>These two elements are both related to structures defined in the previous
section.</p>
<pre>&lt;package name = "packageName" /&gt;
&lt;import name = "packageName" /&gt;</pre>

<p>For both the packageName is of the form:</p>
<pre>     name.name...
     or for import
     name.name...*</pre>

<p>package applys to the structureName in a structure definition: For example
the following:</p>
<pre>&lt;package name = "org.epics.pvData" /&gt;
&lt;structure structureName = "alarm"&gt;
  &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;structure structureName = "org.epics.pvData.alarm"&gt;
   &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>import applys to extends structureNames in structure, record, and field
structure definitions. For example the following:</p>
<pre>&lt;import name = "org.epics.pvData.*" /&gt;
&lt;import name = "org.me.myStuff.*" /&gt;
&lt;record recordName = "xxx" extends = "myStructure"&gt;
    &lt;structure name = "alarm" extends = "alarm"&gt;
&lt;/record&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;record recordName = "xxx" extends = "org.me.myStuff.myStructure"&gt;
    &lt;structure name = "alarm" extends = "org.epics.pvData.alarm"&gt;
&lt;/record&gt;</pre>
<pre></pre>

<h4 style="text-align:center;" id="L2261">Field definition</h4>

<p>A field of a record or structure can have one of the following tag names:
scalar, scalarArray, or structure,.</p>

<p>A scalar field is defined as follows:</p>
<pre>  &lt;scalar name = "fieldName" scalarType = "scalarType"&gt;
     value
  &lt;/scalar&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The scalar type as defined below.</dd>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>The value. The syntax is described below where scalar types are
    defined.</dd>
</dl>

<p>An array field is defined as follows:</p>
<pre>  &lt;array name = "fieldName" scalarType = "scalarType"
   capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset"&gt;
     arrayValues
  &lt;/array&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">scalarType</span></dt>
    <dd>The element type as defined below.</dd>
  <dt><span
  style="font-family: courier">capacity,capacityMutable,length,offset</span></dt>
    <dd>Each is these is optional.</dd>
  <dt><span style="font-family: courier">arrayValues</span></dt>
</dl>

<p>arrayValues is a comma separated set of values appropriate to the element
type. It can optionally be enclosed in []. Examples: </p>
<pre>     &lt;array name = "field0" scalarType = "double"&gt;
         2.3,5e10,66.0
     &lt;/array&gt;
     &lt;array name = "field1" scalarType = "double"&gt;
         [2.3,5e10,66.0]
     &lt;/array&gt;</pre>

<p>For all array elementTypes except string the convert library will remove all
white space so white space is permitted. If the elementType is string then
white space is not removed. Also each array element is not allowed to have the
character ','. What to do? Should also allow other escape sequences like \n,
etc.</p>

<p>A structure field is defined as follows:</p>
<pre>  &lt;structure name = "fieldName" extends = "structureName"&gt;
     &lt;!-- sequence of field --&gt;
  &lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt><span style="font-family: courier">fieldName</span></dt>
    <dd>The name of the field.</dd>
  <dt><span style="font-family: courier">structureName</span></dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current record will be initialized to have all attributes
      and fields of the structure. The record can change the attributes and
      field values and append additional fields appended to the instance
      structure.</dd>
</dl>

<h4 style="text-align:center;" id="L2343">Scalar Types</h4>
The scalar types are: <span style="font-family: courier">boolean</span>, <span
style="font-family: courier">byte</span>, <span
style="font-family: courier">short</span>, <span
style="font-family: courier">int</span>, <span
style="font-family: courier">long</span>, <span
style="font-family: courier">float</span>, <span
style="font-family: courier">double</span>, <span
style="font-family: courier">string</span>,<span
style="font-family: courier">structure</span>. 

<p>Thus all Java primitrive types except char are support and are implemented
via the corresponding Java type. Type string is implemented as a Java String.
</p>

<p>For example </p>
<pre>     
    &lt;scalar name = "value", scalarType = "double" /&gt;
    &lt;scalar name = "rawValue" scalarType = "int" /&gt;
    &lt;scalar name = "description" scalarType = "string" /&gt;</pre>

<p>value for scalar fields must be specified as follows:</p>
<dl>
  <dt><span style="font-family: courier">boolean</span></dt>
    <dd>Must be true or false.</dd>
  <dt><span style="font-family: courier">byte</span></dt>
    <dd>A valid Java long literal value that is cast to a byte</dd>
  <dt><span style="font-family: courier">short</span></dt>
    <dd>A valid Java long literal value that is cast to a short</dd>
  <dt><span style="font-family: courier">int</span></dt>
    <dd>A valid Java long literal value that is cast to a int</dd>
  <dt><span style="font-family: courier">long</span></dt>
    <dd>A valid Java long literal value</dd>
  <dt><span style="font-family: courier">float</span></dt>
    <dd>A valid Java float literal value</dd>
  <dt><span style="font-family: courier">double</span></dt>
    <dd>A valid Java double literal value</dd>
  <dt><span style="font-family: courier">string</span></dt>
    <dd>A valid Java string literal value</dd>
  <dt><span style="font-family: courier">structure</span></dt>
    <dd>If this is the first time the field is being crated than an extends
      must also be specified. The field will hold a PVStructure with a
      structure defined by extends. This value is just definitions for fields
      in the structure.</dd>
</dl>

<p>NOTE about byte, short, int. The syntax allows unsigned instead of signed
values for hex values. For example the following is legal syntax although Java
would complain.</p>
<pre>    &lt;scalar name = "mask" scalarType = "byte"&gt;0xff&lt;/scalar&gt;</pre>

<h4 style="text-align:center;" id="L2441">Enumerated Structure</h4>

<p>An enumerated structure is a structure that:</p>
<ol>
  <li>Has exactly two fields.</li>
  <li>The first field is named <span style="font-family: courier">index</span>
    and has scalarType <span style="font-family: courier">int</span></li>
  <li>The second field is named <span
    style="font-family: courier">choices</span> and is an array with element
    type <span style="font-family: courier">string</span></li>
</ol>

<p>If the current structure is an enumerated structure then the following
syntax is allowed:</p>
<pre>    &lt;scalar name = "choice"&gt;someChoice&lt;/scalar&gt;</pre>

<p>where <span style="font-family: courier">someChoice</span> must be one of
the elements of <span style="font-family: courier">choices</span>. This results
in the index field being initialized to the correct value. </p>

<h4 style="text-align:center;" id="L2477">Examples</h4>

<p>If <span style="font-family: courier;">fieldName</span> does not exist then
a new field can be created and appended to the end of the current structure. In
this case a new field will be appended to the end of the structure in which
this field appears. </p>

<p>For example:</p>
<pre>&lt;record recordName = "simple" &gt;
  &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<p>Because the record definition does not specify a scalarType =
"structureName", it starts with the generic structure, which has no fields. A
field with name <span style="font-family: courier">value</span> does not exist
so it is created and appended to the structure. i.e. the record will have a
single field of type double and named "value".</p>

<p>The following creates a record which has a structure field that represents a
timeStamp..</p>
<pre>&lt;record recordName = "structureField" &gt;
  &lt;structure name = "timeStamp"&gt;
     &lt;scalar name = "secondsSinceEpoch" scalarType = "long"&gt;
     &lt;scalar name = "nanoSeconds" scalarType = "int"&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following creates a record which has a field named output that is an
array of structures:</p>
<pre>&lt;record recordName = "complexExample"&gt;
  &lt;stucture name = "lotsOfStuff" &gt;
     &lt;scalar name = "value" scalarType = "double"&gt;
     &lt;structure name = "output"&gt;
         &lt;structure name = "0"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest0&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
         &lt;structure name = "1"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest1&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
      &lt;/structure&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<h4 style="text-align:center;" id="L2501">Field Initialization</h4>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the <span style="font-family: courier">initializer</span>
depends on the field type.</p>

<h4 id="L2510">Scalar Types</h4>

<p>For scalar types the initializer has the same format as the Java constants
for the type. For example if the type for field value is double:</p>
<pre>    &lt;scalar name = "value"&gt;.98&lt;/scalar&gt;</pre>

<p>Note: For integer data types <span
style="font-family: courier">Long.decode</span> is used to convert a string to
a long, which is then converted to the final integer data type . Thus hex
values are allowed. Java does not allow the sign bit to be set. By converting
first to a long all interger types except long can have the sign bit set. For
example the byte value 0xff is allowed even though Java would raise an
exception if Byte.decode was used. The sign problem does exist for long
values.</p>

<h4 id="L2521">string</h4>

<p>For string types the initializer is a valid Java string constant, which can
optionally be enclosed in quotes. For example:</p>
<pre>    &lt;scalar = "units"&gt;voltage&lt;/scalar&gt;</pre>

<h4 id="L2527">structure scalar</h4>

<p>A structure scalar field is initialized by giving field definitions for any
fields in the associated structure. For example assume that the following
structure definitions have been given:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure scalar field:</p>
<pre>&lt;record recordName = "structureScalarTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "structure" extends = "test.testStructure"&gt;
        &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
        &lt;structure name = "location"&gt;
           &lt;scalar name = "x"&gt;1.0&lt;/scalar&gt;
            &lt;scalar name = "y"&gt;2.0&lt;/scalar&gt;&gt;
        &lt;/structure&gt;
    &lt;/scalar&gt;
&lt;/record&gt;</pre>

<h4 id="L2537">structure</h4>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure definitions:</p>
<pre>    &lt;structure structureName = "doubleLimit"&gt;
        &lt;scalar name = "low" type ="double"/&gt;
        &lt;scalar name = "high" type ="double"/&gt;
   &lt;/structure&gt;

   &lt;structure structureName = "control"&gt;
     &lt;structure name = "limit" extends = "doubleLimit" /&gt;
     &lt;scalar name = "minStep" scalarType = "double" /&gt;
   &lt;/structure&gt;</pre>

<p>limit is initilized as follows:.</p>
<pre>    &lt;structure name = "control" extends = "control"&gt;
      &lt;structure name = "limit"&gt;
         &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
         &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
      &lt;/structure&gt;
      &lt;scalar name = "minStep"&gt;.1&lt;/scalar&gt;
   &lt;/structure&gt;</pre>

<p>It is permissible, in a database definition, to define a field to be a
structure without providing a structure name. In this case the default is
"null" which is a structure with no fields.</p>

<p>The default structure and auxInfo can be overridden when a field instance is
defined. The syntax is:</p>
<pre>    &lt;structure name = "fieldName" extends = "structureName"&gt;
       &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;someFactory&lt;/auxinfo&gt;
    &lt;/structurte&gt;</pre>

<h4 id="L2555">array</h4>
The syntax for a array initializer is: 
<pre>    &lt;array name = "fieldName" scalarType = "scalarType"
    capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset" &gt;
        valueList
    &lt;/array&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized. If the
      capacity is given a value &gt; 0 and capacityMutable is not specified
      then capacityMutable is set to true. </dd>
  <dt style="font-family: courier;">capacityMutable</dt>
    <dd>Can the capacity be changed?</dd>
  <dt style="font-family: courier;">length</dt>
    <dd>The initial length for the array.</dd>
  <dt style="font-family: courier;">offset</dt>
    <dd>The offset of the first element being defined.</dd>
  <dt style="font-family: courier;">valueList</dt>
    <dd>A list of values, which is a comma separated set of values.</dd>
  <dt></dt>
</dl>

<p>The following perform the same initialization:</p>
<pre>    &lt;array name = "intArray" scalarType = "double"&gt;
        0.0,1.0,0.0
    &lt;/array&gt;
    &lt;array name = "intArray" scalarType = "double" length = "3"&gt;
        0.0,1.0
    &lt;/array&gt;</pre>

<p>The following initializes an array of structures</p>
<pre>    &lt;complexArray name = "example"&gt;
      &lt;structure name = "structArray" &gt;
        &lt;structure name = "0" extends = "doubleLimit" &gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "1"  extends = "doubleLimit"&gt;
            &lt;scalar name = "low"&gt;-10.0&lt;/scalarmit&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
      &lt;/structure&gt;
    &lt;/array&gt;</pre>

<h5 id="L2599">structureArray</h5>

<p>The first time a structure array field is created an extends must also be
provided. The extended structure is used to create the array elements. For
example assume that the following structures have been defined:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure array</p>
<pre>&lt;record recordName = "structureArrayTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;array name = "value" scalarType = "structure" extends = "test.testStructure" capacity = "2"&gt;
       &lt;structure&gt;
          &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;0.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;0.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
        &lt;structure&gt;
          &lt;scalar name = "value"&gt;200.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;5.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;10.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       
    &lt;/array&gt;
&lt;/record&gt;</pre>

<h4 style="text-align:center;" id="L2609">Macro Substitution and Include</h4>

<h4 id="L2611">Include</h4>
The XML file can include other files also containing Record Instance
Definitions. Included files can also include other files. The syntax is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt style="font-family: courier;">href</dt>
    <dd>The <span style="font-family: courier;">filename</span>, which must be
      a valid XML Record Instance file, is processed. If any addPaths have been
      defined the last one specified is prefixed to the filename.</dd>
  <dt style="font-family: courier;">addPath</dt>
    <dd>Add a path.</dd>
  <dt style="font-family: courier;">removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4 id="L2638">Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt style="font-family: courier;">from</dt>
    <dd><span style="font-family: courier;">fromString</span> is the string
      that appears in ${from}. If <span
      style="font-family: courier;">from</span> is specified then <span
      style="font-family: courier;">to</span> must also be specified.</dd>
  <dt style="font-family: courier;">to</dt>
    <dd><span style="font-family: courier;">toString</span> replaces
    ${from}</dd>
  <dt style="font-family: courier;">toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
    commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<p>NOTE: If a substitution is being performed and a substitute is not found
then if the value is found in the system environment table that value is
used.</p>

<h4 id="L2683">Example Include and Macro Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;record recordName = "ai${recordExtension}Record"&gt;
    &lt;scalar name = "value" scalarType = "double"/&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "input" extends = "linearConvertInput" &gt;
        &lt;structure name = "input" extends = "inputSupport"&gt;
            &lt;scalar name = "pvname"&gt;${pvname}&lt;/scalar&gt;
            &lt;scalar name = "wait"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "engUnitsLow"&gt;${engUnitsLow}&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;${engUnitsHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "display" extends = "display" &gt;
        &lt;scalar name = "units"&gt;volts&lt;/scalar&gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;${displayLow}&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;${displayHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;
se&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/database&gt;</pre>

<h3 style="text-align: center" id="L2693">Database XML Code</h3>

<p>This section describes the Java support for converting files, which have XML
definitions for PVData structures and records, to PVDatabase PVStructures and
PVRecords.</p>

<p>The support has two components:</p>
<ol>
  <li>Include and Substitute<br />
    Support for macro substitution and include.</li>
  <li>XML to PVDatabase<br />
    Support that parsers the PVData XML statements. It uses the Include and
    Substitute support</li>
</ol>

<p>This section first shows the Java Definitions, then it discusses XML to
PVDatabase parsing, and last Include and Substitute.</p>

<h4 id="L2714">Warning About XML element syntax</h4>

<p>This is a warning for utility code that genetrates xml for PVData. The
problem is the special XML characters:</p>
<ul>
  <li>Less than &lt;</li>
  <li>Greater Than &gt;</li>
  <li>Quote "</li>
  <li>Apostrophe ''</li>
  <li>Ampersand &amp;</li>
</ul>

<p>These symbols are part of the xml syntax. This is a problem when the value
for a string is being defined. For example:</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;value&lt;/scalar&gt;</pre>

<p>In order to set value = "a&lt;b" Then one of the following must be
entered.</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;a&amp;lt;b&lt;/scalar&gt;</pre>

<p>or</p>
<pre>    &lt;scalar name = "xxx" elmentType = "string"&gt;&lt;![CDATA[a&lt;b]]&gt;&lt;/scalar&gt;</pre>

<p>I (Marty Kraimer) do not know how to determine, using SAX, what appears in
the original xml source file. What appears to the ContentHandler callback is
just the converted characters. What to do? One suggestion is that any code that
generates PVData xml should look at all string scalar and scalar array element
values. If any of the special XML characters are present then use
the&lt;![CDATA[value]]&gt; method of encoding the value.</p>

<h4 id="L2748">Java Definitions</h4>
<pre>    class XMLToPVDatabaseFactory {
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            XMLToPVDatabaseListener pvListener,
            IncludeSubstituteXMLListener isListener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester);
    }

    interface XMLToPVDatabaseListener {
        void startStructure(PVStructure pvStructure);
        void endStructure();
        void startRecord(PVRecord pvRecord);
        void endRecord(); 
        void newStructureField(PVStructure pvStructure);
        void endStructureField();
        void startArray(PVArray pvArray);
        void endArray();
        void startScalar(PVScalar pvScalar);
        void endScalar();
        void startAuxInfo(String name,Map&lt;String,String&gt; attributes);
        void endAuxInfo();
    }

    interface IncludeSubstituteXMLListener {
        void endDocument();
        void startElement(String name, Map&lt;String,String&gt; attributes);
        void element(String content);
        void endElement(String name);
    }

    interface IncludeSubstituteDetailsXMLListener {
        void startElementBeforeSubstitution(String name, Map&lt;String,String&gt; attributes);
        void elementBeforeSubstitution(String content);
        void newSourceFile(String fileName);
        void endSourceFile();
        void addPath(String pathName);
        void removePath(String pathName);
        void substitute(String from,String to);
        void removeSubstitute(String from);
    }
    
    interface IncludeSubstituteXMLReader {
        void parse(String rootElementName,String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            IncludeSubstituteXMLListener listener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        void message(String message,MessageType messageType);
    }

    class IncludeSubstituteXMLReaderFactory {
        static public IncludeSubstituteXMLReader getReader();
    }</pre>

<h4 id="L2752">XML To PVDatabase</h4>

<p>This support processes PVData XML statements. Code that wants to parse
PVData XML statements calls one of the XMLToPVDatabaseFactory.convert methods.
The only difference between the two methods is that the first provides access
to detailed information about parsing while the second only provides
errors..</p>

<h5 id="L2756">XMLToPVDatabaseFactory</h5>

<p>This provides two methods both named convert. The first provides detailed
information about parsing. It is intended for use by VDCT. The second reports
all errors including substitution failues but none of the detailed information.
The arguments for the first method are:</p>
<dl>
  <dt><span style="font-family: Courier">pvDatabase</span></dt>
    <dd>The PVDatabase into which structure and record instances are put.</dd>
  <dt><span style="font-family: Courier">fileName</span></dt>
    <dd>The name of the XML file.</dd>
  <dt><span style="font-family: Courier">requester</span></dt>
    <dd>The Requester interface which must be implemented by the caller.</dd>
  <dt><span style="font-family: Courier">reportSubstitutionFailure</span></dt>
    <dd>Should substitution failures be reported?</dd>
  <dt><span style="font-family: Courier">pvListener</span></dt>
    <dd>The XMLToPVDatabaseListener interface, which can be null. If
      implemented the caller is notified when PV XML elements have been
    parsed.</dd>
  <dt><span style="font-family: Courier">isListener</span></dt>
    <dd>The IncludeSubstituteXMLListener interface, which can be null.
      XMLToPVDatabaseFactory implements it's own version but will also call
      this instance if implemented.See the interface description below for
      details.</dd>
  <dt><span style="font-family: Courier">detailsListener</span></dt>
    <dd>The IncludeSubstituteDetailsXMLListener interface, which can be
    null.</dd>
</dl>

<h5 id="L2803">XMLToPVDatabaseListener</h5>

<p>This provides a callback for the beginning and end of the parsing of PVData
XML elements not related to macro substitution and include. It provides the
following methods:</p>
<dl>
  <dt><span style="font-family: Courier">startStructure</span></dt>
    <dd>A new structure instance is being created.</dd>
  <dt><span style="font-family: Courier">endStructure</span></dt>
    <dd>The definition of the new structure is complete.</dd>
  <dt><span style="font-family: Courier">startRecord</span></dt>
    <dd>A new record instance is being created or an existing record is being
      modified.</dd>
  <dt><span style="font-family: Courier">endRecord</span></dt>
    <dd>The definition on the new or existing record is complete.</dd>
  <dt><span style="font-family: Courier">newStructureField</span></dt>
    <dd>A new structure field is being created.</dd>
  <dt><span style="font-family: Courier">endStructureField</span></dt>
    <dd>The definition on the new structure field is complete</dd>
  <dt><span style="font-family: Courier">startArray</span></dt>
    <dd>A new array field is being created.</dd>
  <dt><span style="font-family: Courier">endArray</span></dt>
    <dd>The definition on the new array field is complete</dd>
  <dt><span style="font-family: Courier">startScalar</span></dt>
    <dd>A new scalar field is being created.</dd>
  <dt><span style="font-family: Courier">endScalar</span></dt>
    <dd>The definition on the new scalar field is complete</dd>
  <dt><span style="font-family: Courier">startAuxInfo</span></dt>
    <dd>A new auxInfo is being created.</dd>
  <dt><span style="font-family: Courier">endAuxInfo</span></dt>
    <dd>The definition on the new auxInfo is complete</dd>
</dl>

<h4 id="L2880">Include and Substitution</h4>

<p>This support completely handles all details of Macro Substitution and
Include. The code that calls this support sees only the results of substitution
and include.. This support also implements the SAX2 ContentHandler and
EventHandler interfaces. Instead of the SAX2 interfaces, code that uses this
code must implement at least the IncludeSubstituteXMLListener interface.
Support that wants additional information can also implement the
IncludeSubstituteDetailsXMLListener interface. This code, in addition to macro
substitution, provides a simplified version of what SAX2 provides, which also
means that it does not provide access to all of SAX2. </p>

<p>This code does not understand the complete pvData XML syntax. It only
understands the include, substitute, package, and import elements. Thus it
could be used by code other than XML to PVDatabase but any such code must
realize that it does not provide access to all of SAX2.</p>

<h4 id="L2886">IncludeSubstituteXMLListener</h4>

<p>This interface must be implemented by the caller. It is a simplified version
of the SAX2 ContentHandler. The methods are:</p>
<dl>
  <dt><span style="font-family: Courier">endDocument</span></dt>
    <dd>The end of the xml input file. This is NOT called for included
    files.</dd>
  <dt><span style="font-family: Courier">startElement</span></dt>
    <dd>The opening tag of an xml element is being processed.</dd>
  <dt><span style="font-family: Courier">element</span></dt>
    <dd>The value of an xml element, i.e. what appears between the opening and
      closing tags. Any leading and trailing white space of any element
      fragment is removed.</dd>
  <dt><span style="font-family: Courier">endElement</span></dt>
    <dd>The end tag opf an xml element is being processed.</dd>
</dl>

<h5 id="L2915">IncludeSubstituteDetailsXMLListener</h5>

<p>This interface can optionally be implemented by the caller. It provides
details about include and substitution details. The methods are:</p>
<dl>
  <dt><span
  style="font-family: Courier">startElementBeforeSubstitution</span></dt>
    <dd>This is the opening tag of an xml element before any substitutions.</dd>
  <dt><span style="font-family: Courier">elementBeforeSubstitution</span></dt>
    <dd>This is an xml element value before any substitutions.</dd>
  <dt><span style="font-family: Courier">newSourceFile</span></dt>
    <dd>A new file is being included.</dd>
  <dt><span style="font-family: Courier">endSourceFile</span></dt>
    <dd>End of an included file,</dd>
  <dt><span style="font-family: Courier">addPath</span></dt>
    <dd>A new addPath</dd>
  <dt><span style="font-family: Courier">removePath</span></dt>
    <dd>A addPath is being removed.</dd>
  <dt><span style="font-family: Courier">substitute</span></dt>
    <dd>A new substitute is defined.</dd>
  <dt><span style="font-family: Courier">removeSubstitute</span></dt>
    <dd>A substitute is being removed.</dd>
</dl>

<h5 id="L2968">IncludeSubstituteXMLReader</h5>

<p>The interface implemented by IncludeSubstituteXMLReaderFactory. It provides
two methods: parse and message. The arguments to parse have already been
describes. The message method adds the location within the input xml files when
this method is called.</p>

<h5 id="L2972">IncludeSubstituteXMLReaderFactory</h5>

<p>The factory that implements macro substitution and include.</p>
<hr />

<h2 style="text-align: center" id="L2978">Package org.epics.ioc.util</h2>
<hr />

<h3 style="text-align: center" id="L2982">Overview</h3>

<p>This package provides utility code for a javaIOC:</p>
<dl>
  <dt>Scan Field</dt>
    <dd>Interface that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
</dl>

<h3 style="text-align: center;" id="L2997">Scan Field Support</h3>

<h4 id="L2999">Definitions</h4>
<pre>    public interface ScanField {
        ThreadPriority getPriority();
        PVInt getPriorityIndexPV();
        ScanType getScanType();
        PVInt getScanTypeIndexPV();
        double getRate();
        PVDouble getRatePV();
        String getEventName();
        PVString getEventNamePV();
        boolean getProcessSelf();
        PVBoolean getProcessSelfPV();
        boolean getProcessAfterStart();
        PVBoolean getProcessAfterStartPV();
    }
     
    public enum ScanType {
        passive,
        event,
        periodic;
        public static Enumerated getScanType(PVField dbField);
    }
    
    public class ScanFieldFactory {
        public static ScanField create(PVRecord dbRecord);
    }</pre>

<h4 id="L3003">ScanField</h4>

<p>ScanField is a convenience interface for accessing the scan field of a
record. </p>

<h4 id="L3007">ScanType</h4>

<p>This is a Java enum which defines the scan types:</p>
<dl>
  <dt style="font-family: courier;">passive</dt>
    <dd>This is a record that is not periodically or event scanned. It can be
      processed by another requester. For example database links can request
      processing and Channel Access clients can also request processing.</dd>
  <dt style="font-family: courier;">event</dt>
    <dd>A record can be event scanned. If so the record also has an eventName
      assigned to it. An event announcer, defined below, can declare and event.
      This makes all records with the associated eventName process.</dd>
  <dt style="font-family: courier;">periodic</dt>
    <dd>The record is periodically scanned. A peridically scanned record has a
      rate assigned it it.</dd>
</dl>

<p>The method is:</p>
<dl>
  <dt style="font-family: courier;">getScanType</dt>
    <dd>If dbField has an Enumerated Create interface and if the choices match
      the ScanType enum names than it returns the Enumerated interface.
      Otherwise it returns null.</dd>
</dl>

<h4 id="L3035">ScanFieldFactory</h4>

<p>This is a factory for creating a ScanField.</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create a ScanField.</dd>
</dl>

<h3 style="text-align: center;" id="L3045">Periodic and Event Scanners</h3>

<h4 id="L3047">Definitions</h4>
<pre>    public interface EventAnnounce {
        void announce();
    }
    public interface EventScanner {
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord,String eventName,ThreadPriority scanPriority));
        EventAnnounce addEventAnnouncer(String eventName,String announcer);
        void removeEventAnnouncer(EventAnnounce eventAnnounce,String announcer);
        String show(String eventName);
    }
    
    public interface PeriodicScanner {
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord,double rate,ThreadPriority threadPriority);
        String show(ThreadPriority priority);
        String show(double rate);
        String show(double rate,ThreadPriority priority);
    }
    
    public class ScannerFactory {
         public static PeriodicScanner getPeriodicScanner();
         public static EventScanner getEventScanner();
    }</pre>

<h4 id="L3051">EventAnnounce</h4>

<p>This is the interface for announcing an event. The event scanner implements
this interface. An announcer calls eventScanner.addEventAnnouncer in order to
get an EventAnnounce. The announcer then just calls:</p>
<pre>    eventAnnounce.announce();</pre>

<p>when it wants to announce an event.</p>

<h4 id="L3059">EventScanner</h4>

<p>This is the interface for the event scanning facility implemented by
ScannerFactory. It implements the methods:</p>
<dl>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add an event scanned record.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove a record from being event scanned.</dd>
  <dt style="font-family: courier;">addEventAnnouncer</dt>
    <dd>Add an event announcer.</dd>
  <dt style="font-family: courier;">removeEventAnnouncer</dt>
    <dd>Remove an event announcer.</dd>
  <dt style="font-family: courier;">show</dt>
    <dd>report announcers and event scanned records</dd>
</dl>

<h4 id="L3089">PeriodicScanner</h4>

<p>This is the interface for the periodic scanning facility implemented by
ScannerFactory. It implements the methods:</p>
<dl>
  <dt style="font-family: courier;">addRecord</dt>
    <dd>Add a new record to a periodically scanned list.</dd>
  <dt style="font-family: courier;">removeRecord</dt>
    <dd>Remove a record from being periodically scanned.</dd>
  <dt style="font-family: courier;">show</dt>
    <dd>Show periodically scanned records.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="L3111">Package org.epics.rpc</h2>
<hr />

<h3 style="text-align: center" id="L3115">Overview</h3>

<p>This package provides code to install structures and records into a javaIOC.
A javaIOC is started via JavaIOC.main. Once started structures and records can
be installed either by JavaIOC or by any thread running as part of the
javaIOC.</p>

<p>A javaIOC has two databases: a PVDatabase and an IOCDatabase. The
PVDatabase, which is described in project pvData, holds the memory resident
data. The IOCDatabase provides access to the PVDatabase and to support code.
Both databases are named master.</p>

<p>New structure instances or record instances can be installed into a running
javaIOC. It is not legal to install both new structures and records at the same
time. Installation is done as follows: New instances are read into a new
PVDatabase named beingInstalled. If any error is detected while reading the
file, nothing more is done, i.e. installation fails. If the beingInstalled
database has only structure definitions the new definitions are merged into
master and installation is complete. If the beingInstalled database has only
record instances then the record instances are initialized and started. If any
record can not be started nothing more is done, i.e. the installation fails. If
all records start then an AfterStart procedure described below is performed. As
part of this procedure the new record instances are merged into master. When
the AfterStart procedure is done installation is done. The InstallFactory
ensures that only one installation at a time is allowed.</p>

<p>This overview describes the following:</p>
<dl>
  <dt>Install</dt>
    <dd>The interface for installing structures and records.</dd>
  <dt>InstallFactory</dt>
    <dd>The factory which implements a single instance of Install.</dd>
  <dt>SupportCreation</dt>
    <dd>Support to create, initialize, and start records.</dd>
  <dt>AfterStart</dt>
    <dd>Support that allows support and servers to perform various functions
      after new records have started but before installation is complete. After
      Start allows unrelated support to execute in parallel.</dd>
</dl>

<h3 style="text-align: center" id="L3146">Install Factory</h3>

<p>InstallFactory is used to install structure or records into master database
of a javaIOC. Only one set of definitions at a time can be installed.</p>

<h4 id="L3150">Definitions</h4>
<pre>interface Install {
    boolean installStructures(String xmlFile,Requester requester);
    boolean installStructures(PVDatabase pvDatabase,Requester requester);
    boolean installStructure(PVStructure pvStructure,Requester requester);
    boolean installRecords(String xmlFile,Requester requester);
    boolean installRecords(PVDatabase pvDatabase,Requester requester);

    boolean installRecord(PVRecord pvRecord,Requester requester);
}

class InstallFactory {
    public static Install get();
}</pre>

<h4 id="L3154">installStructures</h4>

<p>Three methods are provided. The first install structure definitions from
file. The second installs structure definitions from a PVDatabase. The last
installs a single PVStructure.</p>

<p>The xml file must contain xml structure definitions as described in project
pvData. The file is read into a PVDatabase named beingInstalled. If the file is
read successfully the second installStructures method is called.</p>

<p>The next method attempts to install structures from a PVDatabase. The
pvDatabase must not have any records and must not have any structure that is
already in master. If these checks succeed the new definitions are merged into
master. The return value is (false,true) if the new structures (were not, were)
installed.</p>

<p>The last method installs a PVStructure if the structure does not already
exist in the master.</p>

<h4 id="L3164">installRecords</h4>

<p>Three methods are provided. The first Install record definitions from file.
The second installs records from a PVDatabase. The last installs a single
PVRecord.</p>
<ol>
  <li>The xml file must contain xml record definitions as described in project
    pvData. The file is read into a PVDatabase named beingInstalled. If the
    file is read successfully method 2 is called</li>
  <li>This method attempts to install records from a PVDatabase. The pvDatabase
    must not have any structuress and must not have any record that is already
    in master. If these checks succeed an attempt is made to initialize and
    start the records instances as described below.</li>
  <li>The last method creates a PVDatabase named beingInstalled, adds the
    PVRecord to it, and calls method 2.</li>
</ol>

<h4 id="L3178">Initialize, and Start Record Instances</h4>

<p>PVReplaceFactory.replace is called for the PCDatabase holding the new
records.</p>

<p>An IOCDatabase is created for the PVDatabase holding the new records. </p>

<p>A SupportCreation named beingInstalled is created and the following steps
performed</p>
<dl>
  <dt>createSupport</dt>
    <dd>supportCreation.createSupport is called. If it fails installation
    fails.</dd>
  <dt>initialize</dt>
    <dd>supportCreation.initializeSupport is called. If it fails installation
      fails.</dd>
  <dt>start</dt>
    <dd>An AfterStart is created and then supportCreation.start(afterStart) is
      called. If it fails installation fails. </dd>
  <dt>before merge</dt>
    <dd>afterStart.callRequesters(false) is called.</dd>
  <dt>merge</dt>
    <dd>The beingInstalled databases (PVDatabase and IOCDatabase) are each
      merged into the corresponding master database.</dd>
  <dt>after merge</dt>
    <dd>afterStart.callRequesters(true) is called.</dd>
</dl>

<p>The return value is (false,true) if the new records (were not, were)
installed.</p>

<h3 style="text-align: center;" id="L3219">Support Creation</h3>

<p>A SupportCreation is used to create, initialize, and start record instances.
After it is done it is no longer accessable.</p>

<h4 id="L3223">Definitions</h4>
<pre>public class SupportCreationFactory {
    static public SupportCreation create(
         IOCDatabase supportDatabase,Requester requester);
}

public interface SupportCreation {
    boolean createSupport();
    boolean initializeSupport();
    boolean  startSupport(AfterStart afterStart);
}</pre>

<h4 id="L3227">Factory</h4>

<p>This has the single method which creates a SupportCreation.</p>

<h4 id="L3231">SupportCreation</h4>
<dl>
  <dt>createSupport</dt>
    <dd>Create the support. It first created a RecordProcess and then support
      for fields with support.</dd>
  <dt>initializeSupport</dt>
    <dd>Initialize the support. For each record it calls
      recordProcess.initialize. It returns true if all records are
    initialized.</dd>
  <dt>startSupport</dt>
    <dd>Start the support. For each record it calls recordProcess.start. It
      returns true if all records are started.</dd>
</dl>

<h3 style="text-align: center;" id="L3249">After Start</h3>

<p>After Start is a facility that allows support code and servers like Channel
Access to perform various functions after new records are started but before
installation completes. It is designed so that unrelated functions can execute
in parallel and so that related functions can execute in the order they
require</p>

<p>Code can request to be called back before or after the beingInstalled is
merged into the master. Each request also specifies a priority. A callback
should not block. When it is done it must notify AfterStart that is is done.
All callbacks at a particular priority must complete before the callbacks at
the next lower priority are called.</p>

<p>The start method of Support is defined as:</p>
<pre>    void start(AfterStart afterStart);</pre>

<p>The support code can call afterStart.requestCallback. If so it must
implement interface AfterStartRequester. When AfterStartRequester.callback is
called the support code can do what it wants but should not block. Instead it
should arrage for some other thread to do the work. When done the support code
must call afterStart.done.</p>

<p>Servers, i. e. code that is not attached to a record can call
AfterStartFactory.newAfterStartRegister. An example of a server is Channel
Access. The NewAfterStartRequester is called each time a new AfterStart is
created, i.e. every time a new set of records are being installed. The server
can then call afterStart.requestCallback just like support code.</p>

<h4 id="L3263">Definitions</h4>
<pre>public interface AfterStartNode {}

public interface AfterStartRequester {
    void callback(AfterStartNode node);
}

public class AfterStartFactory {
    public static  AfterStart create();
    public static AfterStartNode allocNode(AfterStartRequester requester);
    public static void newAfterStartRegister(NewAfterStartRequester requester);
    public static void newAfterStartUnregister(NewAfterStartRequester requester);
}

public interface AfterStart {
    void callRequesters(boolean afterMerge);
    void requestCallback(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
    void done(AfterStartNode node);
    void doneAndRequest(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
}


public interface NewAfterStartRequester {
    void callback(AfterStart afterStart);
}</pre>

<h4 id="L3267">AfterStartNode</h4>

<p>Any code that calls afterStart.requestCallback must create an afterStartNode
by calling AfterStartFactory.allocNode. It passes this to
afterStart.requestCallback. A node can only be on one request list at a
time.</p>

<h4 id="L3271">AfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
afterStart.requestCallback. It has a single method which is the callback.</p>

<h4 id="L3275">NewAfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
AfterStartFactory.NewAfterStartRegister.</p>

<h4 id="L3279">AfterStartFactory</h4>
<dl>
  <dt>create</dt>
    <dd>Create a new AfterStart. This is called by InstallFactory.</dd>
  <dt>allocNode</dt>
    <dd>This is called by any code that calls afterStart.requestCallback. It
      can be reused as desired but a node can only be on a single request queue
      at any given time. </dd>
  <dt>NewAfterStartRegister</dt>
    <dd>This is called by code that wants to be notified when a new AfterStart
      is created, i.e. when new records are being installed.</dd>
  <dt>NewAfterStartUnregister</dt>
    <dd>Remove a NewAfterStartRequester.</dd>
</dl>

<h4 id="L3302">AfterStart</h4>
<dl>
  <dt>callRequesters</dt>
    <dd>Call requesters. This is called by InstallFactory.</dd>
  <dt>requestCallback</dt>
    <dd>A request to be called back. The ThreadPriority does not choose a
      thread but just a priority.</dd>
  <dt>done</dt>
    <dd>The callback is done.</dd>
  <dt>doneAndRequest</dt>
    <dd>The callback is done but want to be called back again. The new request
      queue must be for a later time then the current queue.</dd>
</dl>

<h3 style="text-align: center" id="L3325">Introduction</h3>

<p>This package provides support for services that are implemented as an RPC
(Remote Procedure Call). PVAccess provideds two flavors of RPC: putProcessGet
and channelRPC. </p>

<p>If the service is accessed via a putProcessGet the record that implements
the RPC has the structure</p>
<pre>record serviceName
    // may be optional fields
   structure arguments
      // sevice specific
  structure result
     // service specific</pre>

<p>If the service is accessed via a channelRPC the record that implements the
RPC has the structure:</p>
<pre>record serviceName
    // may be optional fields
   structure arguments
      // sevice specific</pre>

<p>The main difference between the two types of service is that for a
putProcessGet the structure of the result is fixed and for a channelRPC a
completely new structure is returned for each request.</p>

<p>This package provides support for channelRPC: It provides client and server
support for implementing a network accessable service that uses PVData for all
data communication between a client and the service. The service is implemented
via a PVRecord that is present in a javaIOC. The client communicates with the
server via a ChannelRPC (Remote Procedure Call) as defined by pvAccess.</p>

<p>The record name is the name of the service. The record has the following
fields: </p>
<dl>
  <dt>factoryRPC</dt>
    <dd>A string field that is the name of a factory that implements the
      specific RPC service.</dd>
  <dt>arguments</dt>
    <dd>A structure that defines the arguments for the RPC.</dd>
</dl>

<p>This package provides:</p>
<ul>
  <li>Client - The client code that interfaces to PVAccess, i.e. manages
    channel access communication with the service </li>
  <li>Server - Code that implements Support code for a record instance that
    implements a service. It calls service specific code.</li>
</ul>

<p>A sevice implementation must implement the following interfaces, which are
described in detail below.</p>
<ul>
  <li>Server - Defined in javaIOC. package org.epics.ioc.pvAccess 
    <pre>interface RPCServer {
    void destroy()
    Status initialize(...);
    void request()
}</pre>
  </li>
  <li>Client 
    <pre>interface ServiceClientRequester extends Requester{
    void connectResult(...);
    void requestResult(...);
}</pre>
  </li>
</ul>

<p>The rest of this document describes the following:</p>
<ul>
  <li>client<br />
    The java interfaces and factories this project provides for a service
    client.</li>
  <li>server<br />
    The java interfaces and factories this project provides for a service
    server.</li>
  <li>Examples: 
    <ul>
      <li>table<br />
        An example that returns data that can be interpeted as a table.</li>
      <li>example<br />
        A example of a service that returns a somewhat complex structure.</li>
    </ul>
  </li>
</ul>

<h3 style="text-align: center" id="L3407">Client</h3>

<p>The client is implemented via the following interfaces and factory:</p>
<pre>interface ServiceClientRequester extends Requester{
    void connectResult(Status status,PVStructure pvArguments,BitSet bitSet);
    void requestResult(Status status,PVStructure pvResult);
}

interface ServiceClient {
    void destroy();
    void waitConnect(double timeout);
    void sendRequest();
    void waitRequest();
}

class ServiceClientFactory {
    public static ServiceClient create(String serviceName,ServiceClientRequester requester);
}</pre>

<p>ServiceClientRequester, which must be implemented by each client, has the
following methods:</p>
<dl>
  <dt>connectResult</dt>
    <dd>This is called when ServiceClient has connected to the service or when
      a timeout occurs. It has the methods: 
      <dl>
        <dt>status</dt>
          <dd>The status as descibed in project pvData.</dd>
        <dt>pvArguments</dt>
          <dd>The arguments structure defined in the service record.</dd>
        <dt>bitSet</dt>
          <dd>A bitSet for pvArguments. The client must call bitSet.set for any
            fields it changes in pvAguments before issuing a request.</dd>
      </dl>
    </dd>
  <dt>requestResult</dt>
    <dd>This is called when the ServiceClient receives the request data from
      the service. It has the methods: 
      <dl>
        <dt>status</dt>
          <dd>The status of the request as described in project pvData.</dd>
        <dt>pvResult</dt>
          <dd>The pvStructure created by the service.</dd>
      </dl>
    </dd>
</dl>

<p>ServiceClient is created by ServiceClientFactory. It has the methods:</p>
<dl>
  <dt>destroy</dt>
    <dd>Called by the client when it no longer requires the service.</dd>
  <dt>waitConnect</dt>
    <dd>Called by the client to wait until a connection has been made to the
      service or a timeout occurs.</dd>
  <dt>sendRequest</dt>
    <dd>Called by the client to send a request to the service.</dd>
  <dt>waitRequest</dt>
    <dd>Called by the client to wait until the request response has been
      returned by the service.</dd>
</dl>

<p>ServiceClientFactory, which is also implemented by this project, has the
following method:</p>
<dl>
  <dt>create</dt>
    <dd>Creates a ServiceClient and connects to the service. It has the
      arguments: 
      <dl>
        <dt>serviceName</dt>
          <dd>The name of the channel, i.e. record, that implements the
          service.</dd>
        <dt>requester</dt>
          <dd>The serviceChannelRequester as described above.</dd>
      </dl>
    </dd>
</dl>

<h3 style="text-align: center" id="L3495">Server</h3>

<p>The service is implemented via the following interfaces and factory:</p>
<pre>//RPCServer defined in org.epics.ca.server.impl.local
public interface RPCServer {
    void destroy();
    Status initialize(
         Channel channel,
         PVRecord pvRecord,
         ChannelRPCRequester channelRPCRequester,
         PVStructure pvArgument,
         BitSet bitSet,
         PVStructure pvRequest);
    void request();
}

class XXXServiceFactory {
    public static RPCServer create();
}</pre>

<p>RPCService, which is implemented by each service, has the following
methods:</p>
<dl>
  <dt>destroy</dt>
    <dd><p>Called when a client disconnects from the ChannelRPC.</p>
    </dd>
  <dt>initialize</dt>
    <dd>Called when a client creates a ChannelRPC. It has the arguments: 
      <dl>
        <dt>channel</dt>
          <dd>The channel that is connecting to the service.</dd>
        <dt>pvRecord</dt>
          <dd>The record that implements the service.</dd>
        <dt>channelRPCRequester</dt>
          <dd>The remote pvAccess server implements this and passes the
            information back to the client.</dd>
        <dt>pvArgument</dt>
          <dd>The arguments structure as defined in the record.</dd>
        <dt>bitSet</dt>
          <dd>A bitSet for arguments. The service can use this to determine
            what has changed since the last request.</dd>
        <dt>pvRequest</dt>
          <dd>An optional pvStructure than can be passed between client an d
            server. See pvAccess for details.</dd>
      </dl>
    </dd>
  <dt>request</dt>
    <dd>Called when a client calls channelRPC.request. The service is expected
      to create a new pvStructure and call: 
      <pre>channelRPCRequester.requestDone(okStatus, pvTop);</pre>
      where pvTop is the newly created pvStructure. </dd>
</dl>

<p>Also the service must implement a XXXServiceFactory, which is specified in
the record.factory field of the PVRecord. It has the following method:</p>
<dl>
  <dt>create</dt>
    <dd>Called by org.epics.ca.server.impl.local.ChannelServerFactory when the
      PVRecord for the service is initialized.</dd>
</dl>

<h3 style="text-align: center" id="L3562">Examples</h3>

<p>The project provides examples in package (org.epics.pvService.example). This
section describes ExampleClient and ExampleServiceFactory, which are the client
and server sides of the example. The example is skeleton code for a service
that, given a search string, returns a set of pvnames. Each pvName can have
associated properties. The example ignores the search request. Instead it just
makes up two pvnames (pvName0 and pvName1) and makes up some properties for
each pvname.</p>

<h4 id="L3566">Running the examples</h4>

<p>The example package has a file pvService.zip that runs the example. To run
the example do the following:</p>
<ol>
  <li>Copy pvService.zip to some test directory and unzip it.</li>
  <li>change directory location to pvService.</li>
  <li>Edit the source file so that it has the correct locations for WORKSPACE
    and for the org.eclipse.swt definitions.</li>
  <li>Open two windows in the pvService directory</li>
  <li>In one window execute the command: 
    <pre>    ./serviceExample
    </pre>
  </li>
  <li>In other window execute the command: 
    <pre>    ./clientExample
    </pre>
  </li>
  <li>In other window execute the command: 
    <pre>    ./clientTable
    </pre>
  </li>
</ol>

<p>In the window where clientExample is run you should see:</p>
<pre>structure 
{
    0 = structure
    {
        name = pvName0
        properties = structure
        {
            a = structure
            {
                value = avalue
                owner = aowner
            }
            b = structure
            {
                value = bvalue
                owner = bowner
            }
        }
    }
    1 = structure
    {
        name = pvName1
        properties = structure
        {
            a = structure
            {
                value = avalue
                owner = aowner
            }
            b = structure
            {
                value = bvalue
                owner = bowner
            }
        }
    }
}
all done</pre>

<p>In the window where clientTable is run you should see:</p>
<pre>mrk&gt; ./clientTable 
structure table
    int nrows 2
    structure columns
        string[] name [name0,name1]
        double[] value [10.0000,20.0000]
        structure[] timeStamp 
            structure timeStamp
                long secondsPastEpoch 946702800
                int nanoSeconds 582000000
            structure timeStamp
                long secondsPastEpoch 946702801
                int nanoSeconds 582000000
timeStamp[] [ 2000-01-01 00:00:00.582, 2000-01-01 00:00:01.582]
structure table
    int nrows 5
    structure columns
        string[] name [name0,name1,name2,name3,name4]
        double[] value [10.0000,20.0000,30.0000,40.0000,50.0000]
        structure[] timeStamp 
            structure timeStamp
                long secondsPastEpoch 946702800
                int nanoSeconds 582000000
            structure timeStamp
                long secondsPastEpoch 946702801
                int nanoSeconds 582000000
            structure timeStamp
                long secondsPastEpoch 946702802
                int nanoSeconds 582000000
            structure timeStamp
                long secondsPastEpoch 946702803
                int nanoSeconds 582000000
            structure timeStamp
                long secondsPastEpoch 946702804
                int nanoSeconds 582000000
timeStamp[] [ 2000-01-01 00:00:00.582, 2000-01-01 00:00:01.582, 2000-01-01 00:00:02.582, 2000-01-01 00:00:03.582, 2000-01-01 00:00:04.582]
all done</pre>

<h4 id="L3606">The service record</h4>

<p>The xml file that implements the example service is:</p>
<pre>&lt;database&gt;
&lt;record recordName = "exampleService" extends = "org.epics.pvService.service"&gt;
    &lt;scalar name = "factoryRPC"&gt;org.epics.pvService.example.ExampleServiceFactory&lt;/scalar&gt;
    &lt;structure name = "arguments"&gt;
        &lt;scalar name = "search" scalarType = "string" /&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record recordName = "tableService" extends = "org.epics.pvService.service"&gt;
    &lt;scalar name = "factoryRPC"&gt;org.epics.pvService.example.TableServiceFactory&lt;/scalar&gt;
    &lt;structure name = "arguments"&gt;
        &lt;scalar name = "search" scalarType = "string" /&gt;
        &lt;scalar name = "number" scalarType = "int" /&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;</pre>

<p>This creates two records.</p>
<dl>
  <dt>exampleService</dt>
    <dd>This is the record for clientExample</dd>
  <dt>tableSevice</dt>
    <dd>This is the record for clientTable</dd>
  You should see:</dl>

<p>Note that both records are created by extending org.epics.pvService.service.
This is defined in pvService.xml.structure.service.xml:</p>
<pre>&lt;structure structureName = "service"&gt;
  &lt;scalar name = "factoryRPC" scalarType = "string" /&gt;
  &lt;structure name = "arguments" /&gt;
&lt;/structure&gt;</pre>
<hr />

<h2 style="text-align: center" id="L3633">Package org.epics.ioc.install</h2>
<hr />

<h3 style="text-align: center" id="L3637">Overview</h3>

<p>This package provides code to install structures and records into a javaIOC.
A javaIOC is started via JavaIOC.main. Once started structures and records can
be installed either by JavaIOC or by any thread running as part of the
javaIOC.</p>

<p>A javaIOC has two databases: a PVDatabase and an IOCDatabase. The
PVDatabase, which is described in project pvData, holds the memory resident
data. The IOCDatabase provides access to the PVDatabase and to support code.
Both databases are named master.</p>

<p>New structure instances or record instances can be installed into a running
javaIOC. It is not legal to install both new structures and records at the same
time. Installation is done as follows: New instances are read into a new
PVDatabase named beingInstalled. If any error is detected while reading the
file, nothing more is done, i.e. installation fails. If the beingInstalled
database has only structure definitions the new definitions are merged into
master and installation is complete. If the beingInstalled database has only
record instances then the record instances are initialized and started. If any
record can not be started nothing more is done, i.e. the installation fails. If
all records start then an AfterStart procedure described below is performed. As
part of this procedure the new record instances are merged into master. When
the AfterStart procedure is done installation is done. The InstallFactory
ensures that only one installation at a time is allowed.</p>

<p>This overview describes the following:</p>
<dl>
  <dt>Install</dt>
    <dd>The interface for installing structures and records.</dd>
  <dt>InstallFactory</dt>
    <dd>The factory which implements a single instance of Install.</dd>
  <dt>SupportCreation</dt>
    <dd>Support to create, initialize, and start records.</dd>
  <dt>AfterStart</dt>
    <dd>Support that allows support and servers to perform various functions
      after new records have started but before installation is complete. After
      Start allows unrelated support to execute in parallel.</dd>
</dl>

<h3 style="text-align: center" id="L3668">Install Factory</h3>

<p>InstallFactory is used to install structure or records into master database
of a javaIOC. Only one set of definitions at a time can be installed.</p>

<h4 id="L3672">Definitions</h4>
<pre>interface Install {
    boolean installStructures(String xmlFile,Requester requester);
    boolean installStructures(PVDatabase pvDatabase,Requester requester);
    boolean installStructure(PVStructure pvStructure,Requester requester);
    boolean installRecords(String xmlFile,Requester requester);
    boolean installRecords(PVDatabase pvDatabase,Requester requester);

    boolean installRecord(PVRecord pvRecord,Requester requester);
}

class InstallFactory {
    public static Install get();
}</pre>

<h4 id="L3676">installStructures</h4>

<p>Three methods are provided. The first install structure definitions from
file. The second installs structure definitions from a PVDatabase. The last
installs a single PVStructure.</p>

<p>The xml file must contain xml structure definitions as described in project
pvData. The file is read into a PVDatabase named beingInstalled. If the file is
read successfully the second installStructures method is called.</p>

<p>The next method attempts to install structures from a PVDatabase. The
pvDatabase must not have any records and must not have any structure that is
already in master. If these checks succeed the new definitions are merged into
master. The return value is (false,true) if the new structures (were not, were)
installed.</p>

<p>The last method installs a PVStructure if the structure does not already
exist in the master.</p>

<h4 id="L3686">installRecords</h4>

<p>Three methods are provided. The first Install record definitions from file.
The second installs records from a PVDatabase. The last installs a single
PVRecord.</p>
<ol>
  <li>The xml file must contain xml record definitions as described in project
    pvData. The file is read into a PVDatabase named beingInstalled. If the
    file is read successfully method 2 is called</li>
  <li>This method attempts to install records from a PVDatabase. The pvDatabase
    must not have any structuress and must not have any record that is already
    in master. If these checks succeed an attempt is made to initialize and
    start the records instances as described below.</li>
  <li>The last method creates a PVDatabase named beingInstalled, adds the
    PVRecord to it, and calls method 2.</li>
</ol>

<h4 id="L3700">Initialize, and Start Record Instances</h4>

<p>PVReplaceFactory.replace is called for the PCDatabase holding the new
records.</p>

<p>An IOCDatabase is created for the PVDatabase holding the new records. </p>

<p>A SupportCreation named beingInstalled is created and the following steps
performed</p>
<dl>
  <dt>createSupport</dt>
    <dd>supportCreation.createSupport is called. If it fails installation
    fails.</dd>
  <dt>initialize</dt>
    <dd>supportCreation.initializeSupport is called. If it fails installation
      fails.</dd>
  <dt>start</dt>
    <dd>An AfterStart is created and then supportCreation.start(afterStart) is
      called. If it fails installation fails. </dd>
  <dt>before merge</dt>
    <dd>afterStart.callRequesters(false) is called.</dd>
  <dt>merge</dt>
    <dd>The beingInstalled databases (PVDatabase and IOCDatabase) are each
      merged into the corresponding master database.</dd>
  <dt>after merge</dt>
    <dd>afterStart.callRequesters(true) is called.</dd>
</dl>

<p>The return value is (false,true) if the new records (were not, were)
installed.</p>

<h3 style="text-align: center;" id="L3741">Support Creation</h3>

<p>A SupportCreation is used to create, initialize, and start record instances.
After it is done it is no longer accessable.</p>

<h4 id="L3745">Definitions</h4>
<pre>public class SupportCreationFactory {
    static public SupportCreation create(
         IOCDatabase supportDatabase,Requester requester);
}

public interface SupportCreation {
    boolean createSupport();
    boolean initializeSupport();
    boolean  startSupport(AfterStart afterStart);
}</pre>

<h4 id="L3749">Factory</h4>

<p>This has the single method which creates a SupportCreation.</p>

<h4 id="L3753">SupportCreation</h4>
<dl>
  <dt>createSupport</dt>
    <dd>Create the support. It first created a RecordProcess and then support
      for fields with support.</dd>
  <dt>initializeSupport</dt>
    <dd>Initialize the support. For each record it calls
      recordProcess.initialize. It returns true if all records are
    initialized.</dd>
  <dt>startSupport</dt>
    <dd>Start the support. For each record it calls recordProcess.start. It
      returns true if all records are started.</dd>
</dl>

<h3 style="text-align: center;" id="L3771">After Start</h3>

<p>After Start is a facility that allows support code and servers like Channel
Access to perform various functions after new records are started but before
installation completes. It is designed so that unrelated functions can execute
in parallel and so that related functions can execute in the order they
require</p>

<p>Code can request to be called back before or after the beingInstalled is
merged into the master. Each request also specifies a priority. A callback
should not block. When it is done it must notify AfterStart that is is done.
All callbacks at a particular priority must complete before the callbacks at
the next lower priority are called.</p>

<p>The start method of Support is defined as:</p>
<pre>    void start(AfterStart afterStart);</pre>

<p>The support code can call afterStart.requestCallback. If so it must
implement interface AfterStartRequester. When AfterStartRequester.callback is
called the support code can do what it wants but should not block. Instead it
should arrage for some other thread to do the work. When done the support code
must call afterStart.done.</p>

<p>Servers, i. e. code that is not attached to a record can call
AfterStartFactory.newAfterStartRegister. An example of a server is Channel
Access. The NewAfterStartRequester is called each time a new AfterStart is
created, i.e. every time a new set of records are being installed. The server
can then call afterStart.requestCallback just like support code.</p>

<h4 id="L3785">Definitions</h4>
<pre>public interface AfterStartNode {}

public interface AfterStartRequester {
    void callback(AfterStartNode node);
}

public class AfterStartFactory {
    public static  AfterStart create();
    public static AfterStartNode allocNode(AfterStartRequester requester);
    public static void newAfterStartRegister(NewAfterStartRequester requester);
    public static void newAfterStartUnregister(NewAfterStartRequester requester);
}

public interface AfterStart {
    void callRequesters(boolean afterMerge);
    void requestCallback(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
    void done(AfterStartNode node);
    void doneAndRequest(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
}


public interface NewAfterStartRequester {
    void callback(AfterStart afterStart);
}</pre>

<h4 id="L3789">AfterStartNode</h4>

<p>Any code that calls afterStart.requestCallback must create an afterStartNode
by calling AfterStartFactory.allocNode. It passes this to
afterStart.requestCallback. A node can only be on one request list at a
time.</p>

<h4 id="L3793">AfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
afterStart.requestCallback. It has a single method which is the callback.</p>

<h4 id="L3797">NewAfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
AfterStartFactory.NewAfterStartRegister.</p>

<h4 id="L3801">AfterStartFactory</h4>
<dl>
  <dt>create</dt>
    <dd>Create a new AfterStart. This is called by InstallFactory.</dd>
  <dt>allocNode</dt>
    <dd>This is called by any code that calls afterStart.requestCallback. It
      can be reused as desired but a node can only be on a single request queue
      at any given time. </dd>
  <dt>NewAfterStartRegister</dt>
    <dd>This is called by code that wants to be notified when a new AfterStart
      is created, i.e. when new records are being installed.</dd>
  <dt>NewAfterStartUnregister</dt>
    <dd>Remove a NewAfterStartRequester.</dd>
</dl>

<h4 id="L3824">AfterStart</h4>
<dl>
  <dt>callRequesters</dt>
    <dd>Call requesters. This is called by InstallFactory.</dd>
  <dt>requestCallback</dt>
    <dd>A request to be called back. The ThreadPriority does not choose a
      thread but just a priority.</dd>
  <dt>done</dt>
    <dd>The callback is done.</dd>
  <dt>doneAndRequest</dt>
    <dd>The callback is done but want to be called back again. The new request
      queue must be for a later time then the current queue.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="L3849">Package org.epics.ioc.database</h2>
<hr />

<h3 style="text-align: center" id="L3853">Overview</h3>

<p>This package provides everything required to create and access a PVDatabase.
</p>

<p>A PVDatabase consists of :</p>
<ol>
  <li>A set of structures. Each has a unique name and is implemented as a top
    level PVStructure. The primary use of these structures is as "templates"
    for creating structure fields within a PVRecord.</li>
  <li>A set of record instances. Each has a unique name and is implemented as a
    PVRecord.</li>
</ol>

<p>Each PVRecord has a unique record name and has top level PVStructure, which
is a structured set of PVFields. A PVRecord can be:</p>
<dl>
  <dt>processed</dt>
    <dd>A record can be processed. In addition each field of a record can
      optionally have attached support. The database does not implement
      processing but allows other code to attach support to fields and
      recordProcess to a record.</dd>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. The JavaIOC requires
      that a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is modified.
      PVField provides a method postPut, which must be called by the code that
      calls the put method of the PVField. Note the caller must call postPut
      because for array fields the array might be written in chunks. Only the
      caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever a
      message is generated.</dd>
</dl>

<h3 style="text-align: center" id="L3889">RecordField Interfaces</h3>

<p>Each field of a record has an associated PVRecordField and each structure
field a PVRecordStructure.</p>

<h4 id="L3893">PVRecordField</h4>
<pre>    interface PVRecordField extends Requester{
        Support getSupport();
        void setSupport(Support support);
        PVRecordStructure getParent();
        PVField getPVField();
        void replacePVField(PVField newPvField);
        String getFullFieldName();
        String getFullName();
        PVRecord getPVRecord();
        void renameField(String newName);
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getSupport</dt>
    <dd>Get the attached support. This is null if no support has been
    attached.</dd>
  <dt>setSupport</dt>
    <dd>Set support for the field.</dd>
  <dt>getParent</dt>
    <dd>Get the parent PVRecordStructure for this field.</dd>
  <dt>getPVField</dt>
    <dd>Get the PVField associated with this PVRecordField.</dd>
  <dt>replacePVField</dt>
    <dd>If the associated PVField is being replaced it must be replaced by
      calling this instead if directly replacing the PVfield.</dd>
  <dt>getFullName</dt>
    <dd>This gets recordname plus the full name of the field, i.e.
      recordName.field,field,..</dd>
  <dt>getFullFieldName</dt>
    <dd>This gets the full name of the field, i.e. field,field,..</dd>
  <dt>getPVRecord</dt>
    <dd>Returns the PVRecord to which this field belongs.</dd>
  <dt>renameField</dt>
    <dd>Renames the field name. This must be called rather than directly
      calling PVField.renameField.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield if
      this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>This is called by the code that implements the data interface. It is
      called whenever the put method is called.</dd>
</dl>

<h4 id="L3960">PVRecordStructure</h4>

<p>Each structure field has the following interface: Note that it extends
PVRecordField</p>
<pre>    public interface PVRecordStructure extends PVRecordField {
        PVRecordField[] getPVRecordFields();
        PVStructure getPVStructure();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVRecordFields</dt>
    <dd>Get the PVRecordField array.</dd>
  <dt>getPVStructure</dt>
    <dd>Get the PVStructure this field accesses.</dd>
</dl>

<h3 style="text-align: center" id="L3979">Record Interfaces</h3>

<h4 id="L3981">PVListener</h4>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is modified.
If the field is a structure then the PVListener is notified whenever that field
or any subfield is modified. Please note that PVStructureScalar and
PVStructureArray fields are treated as leaf fields so that the underlying
fields can not have attached listeners.</p>
<pre>    public interface PVListener {
        void dataPut(PVRecordField pvRecordField);
        void dataPut(PVRecordStructure requested,PVRecordField pvRecordField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. This is called if the listener has called
      PVRecordField.addListener for pvRecordField.</dd>
  <dt>dataPut(PVRecordStructure requested,PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener. This is called if the listener
      has called PVRecordField.addListener for requested.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when the
      record is being destroyed or when the record structure (not the data
      values) is being changed.</dd>
</dl>

<h4 id="L4015">PVRecordClient</h4>

<p>Any client that accesses a PVRecord must call registerClient so that the
client can be notified when the record is being removed from the master
database. The client must imnplement the following interface:</p>
<pre>    public interface PVRecordClient {
        void detach(PVRecord pvRecord);
    }</pre>

<h4 id="L4021">PVRecord</h4>

<p>A PVRecord has a top level PVStructure that provides the following
methods:</p>
<pre>    interface PVRecord extends Requester {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        PVRecordField findPVRecordField(PVField pvField);
        PVRecordStructure getPVRecordStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
        void registerClient(PVRecordClient pvRecordClient);
        void unregisterClient(PVRecordClient pvRecordClient);
        void detachClients();
        int getNumberClients();
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordProcess</dt>
    <dd>Get the record process for the record.</dd>
  <dt>setRecordProcess</dt>
    <dd>Set the record process for the record.</dd>
  <dt>findPVRecordField</dt>
    <dd>Given a PVField find the PVRecordField.</dd>
  <dt>getPVRecordStructure</dt>
    <dd>Get the top level PVRecordStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This is called by AbstractPVField if it has a RecordField. It can be
      called by other code but most code will not need it.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If the
      other record is already locked than this record may be temporily unlocked
      and then relocked. The caller must call the unlock merthod of the other
      record when done with it. The implementation prevents deadlocks BUT code
      must not try to lock more than two records at the same time or deadlocks
      can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvRecordField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
  <dt>registerClient</dt>
    <dd>Every client that accesses the record must call this so that the client
      can be notified when the record is deleted.</dd>
  <dt>unregisterClient</dt>
    <dd>Client is no longer accessing the record.</dd>
  <dt>detachClients</dt>
    <dd>All client are asked to detach from the record.</dd>
  <dt>getNumberClients</dt>
    <dd>Get the number of registered clients.</dd>
</dl>

<h5 id="L4135">Record Locking</h5>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example the JavaIOC, it may be required
that the thread does not block between lock and unlock.</p>

<h3 style="text-align: center" id="L4143">PVRecord Definition and Creation</h3>

<h4 id="L4145">PVDatabase</h4>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        String[] getStructureNames();
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database. If the record already exists it is not
      modified and false is returned.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database. If the record was not in the
      database false is returned.</dd>
  <dt>getRecordNames</dt>
    <dd>Get an array of the record names.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database. If it already exists false is
    returned.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database. If it did not exist false is
      returned.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the structure names.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are sent
      to System.out (info) or System.err (all other message types). If at least
      one requester is present then the messages are given to the requesters
      without writing to System.out or System.err. If the database is the
      master, the message is put of a queue that is emptied by another thread.
      This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
    expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
    expression.</dd>
</dl>

<h4 id="L4254">PVRecordCreate</h4>

<p>Interface and factory for creating PVrecords and PVStructures.</p>
<pre>    interface PVRecordCreate {
        PVRecord createPVRecord(String recordName,PVStructure pvStructure);
    }

    class PVRecordCreateFactory{
        PVRecordCreate getPVRecordCreate();
    }</pre>

<p>where</p>
<dl>
  <dt>createPVRecord</dt>
    <dd>Create a PVRecord with pvStructure as the top level structure.</dd>
</dl>

<h4 id="L4268">PVReplaceFactory</h4>

<p>Factory that looks for and calls factories that replace the default
implementation of a field.</p>
<pre>    class PVReplaceFactory {
        public static void replace(PVDatabase pvDatabase);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordStructure pvRecordStructure);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordField pvRecordField);</pre>

<p>where</p>
<dl>
  <dt>replace(PVDatabase pvDatabase)</dt>
    <dd>Look at every field of every record in the database and see if field
      implementation should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordStructure
  pvRecordStructure)</dt>
    <dd>Look at every field of pvStructure and see if the field implementation
      should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordField
  pvRecordField)</dt>
    <dd><p>Look at the field and see if the field implementation should be
      replaced. If it is a structure field also look at the subfields.</p>
    </dd>
</dl>

<h3 style="text-align: center" id="L4292">PVDatabase</h3>

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances or other structures. When a structure field of a record is defined as
follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" extends = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The Interface definition is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String recordName);
        boolean addRecord(PVRecord record);
        boolean removeRecord(PVRecord record);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String structureName);
        boolean addStructure(PVStructure structure);
        boolean removeStructure(PVStructure structure);
        String[] getStructureNames();
        PVStructure[] getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database that is
    processed,</dd>
  <dt>getName</dt>
    <dd>Get the name of this database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into master. The database must be named
      "beingInstalled". After this returns another beingInstalled database can
      be created.</dd>
  <dt>findRecord</dt>
    <dd>Find a PVRecord. If not found null is returned.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database.</dd>
  <dt>gerRecordNames</dt>
    <dd>Get an array of the names of the current records in the database.</dd>
  <dt>getRecords</dt>
    <dd>Get an array of the current records in the database.</dd>
  <dt>findStructure</dt>
    <dd>Find a PVStructure. If not found null is returned.</dd>
  <dt>addStructure</dt>
    <dd>Add a PVStructure to the database.</dd>
  <dt>removeStructure</dt>
    <dd>Removed a PVStructure from the database.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the names of the current structures in the
    database.</dd>
  <dt>getStructures</dt>
    <dd>Get an array of the current structuress in the database.</dd>
  <dt>message</dt>
    <dd>Called by a PVDatabase to report messages. This gives a way for a
      client to get all messages from all records in a database.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get an array of record names that satisfy a regular expression.</dd>
  <dt>structureList</dt>
    <dd>Get an array of structure names that satisfy a regular expression.</dd>
  <dt>recordToString</dt>
    <dd>Dumps all records with record names that satisfy a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Dumps all structures with structure names that satisfy a regular
      expression.</dd>
</dl>

<h4 id="L4409">PVDatabaseFactory</h4>

<p>This is a factort that creates a PVDatabase.</p>
<pre>    class PVDatabaseFactory {
        public static PVDatabase create(String name);
        public static PVDatabase getMaster();
        public static PVDatabase getBeingInstalled();
    }</pre>
<dl>
  <dt>create</dt>
    <dd>Create a PVDatabase. If this is a database that is intended to merge
      into master it MUST be named "beingInstalled". If a beingInstalled
      database already exists than an IllegalStateException is thrown.</dd>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database than can be
      processed and the only database pvAccess uses.</dd>
  <dt>getBeingInstalled</dt>
    <dd>Get the beingInstalled database. In not present null is returned.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="L4433">Package org.epics.ioc.support</h2>
<hr />

<h3 style="text-align: center" id="L4437">Overview</h3>

<p>This package describes how records are processed. Package install describes
how records are initialized and started. During database creation each record
is assigned an instance of RecordProcess, which coordinates record processing.
In addition each record has a Support instance and each field can optionally
have an associated Support instance. </p>

<h4 id="L4441">RecordProcess</h4>

<p>The following interfaces are involved with record processing:</p>
<dl>
  <dt><span style="font-family: courier;">RecordProcess</span></dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt><span style="font-family: courier;">ProcessToken</span></dt>
    <dd>A token that allocated by RecordProcess and used by
      RecordProcessRequesters.</dd>
  <dt><span style="font-family: courier;">RecordProcessRequester</span></dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt><span style="font-family: courier;">ProcessCallbackRequester</span></dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt><span style="font-family: courier;">ProcessContinueRequester</span></dt>
    <dd>Implemented by code that calls recordProcess.processContinue.</dd>
</dl>

<h4 id="L4476">Support</h4>

<p>Every JavaIOC record instance has associated support code and each field of
a record instance can optionally have associated support code. This package
contains: </p>
<dl>
  <dt><span style="font-family: courier;">Support</span></dt>
    <dd>The interface which is implemented by every support module.</dd>
  <dt><span style="font-family: courier;">AbstractSupport</span></dt>
    <dd>An abstract class that is the base class for every support module.</dd>
</dl>

<p>This package has sub-packages for the support modules implemented by the
javaIOC itself. Other JavaIOC applications can implement additional support
modules. The sub-packages are:</p>
<dl>
  <dt>basic</dt>
    <dd>Implements the following support: 
      <dl>
        <dt>generic</dt>
          <dd>Generic support for a record type, structure, and an array of
            arrays or structures.</dd>
        <dt>noop</dt>
          <dd>Support that does nothing except complete successfully.</dd>
        <dt>linearConvert</dt>
          <dd>Implements linear conversion for a numeric scalar field.</dd>
        <dt>digital</dt>
          <dd>Support for digital I/O.</dd>
        <dt>incremental</dt>
          <dd>Support for incremental output.</dd>
        <dt>delay</dt>
          <dd>Adds a delay to record processing.</dd>
        <dt>event</dt>
          <dd>Support for a string field that is the name of an event.</dd>
        <dt>processControl</dt>
          <dd>Support for the processControl record type. This is a record type
            that attaches to another record. The scan state of the record can
            be changed, the trace and enable states can be changed, and the
            structure of a sub-field can be changed.</dd>
        <dt>scan</dt>
          <dd>Support for the scan field.</dd>
        <dt>supportArray</dt>
          <dd>Support for an array field where each element is a structure.</dd>
      </dl>
    </dd>
  <dt>ca</dt>
    <dd>Implements support for channel access links, i.e. links to other
      records.</dd>
  <dt>dbLink</dt>
    <dd>Implements support for database links, i.e. links to other records in
      the same javaIOC.</dd>
  <dt>alarm</dt>
    <dd>Raises alarms for value fields.</dd>
  <dt>calc</dt>
    <dd>Support for performing calculations.</dd>
  <dt>device</dt>
    <dd>Examples of support that implements device abstractions.</dd>
  <dt>drv</dt>
    <dd>Support for communicating with portDriver.</dd>
</dl>

<h3 style="text-align: center" id="L4582">Record Processing Theory of
Operation</h3>

<p>A JavaIOC Database is a "smart" database. Each record has associated support
code and each field of a record can optionally have associated support.</p>

<p>Each record has an implementation of recordProcess associated with it.
recordProcess can be requested to process the record. It in turn calls the
process method of the support attached to the record. A record is also the top
level structure. The record support process method calls the support for any
field of the top level structure that has associated support. Any support can
call other support.</p>

<h4 id="L4588">Definitions</h4>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke other
      support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance. Support that is attached
      to a structure can also be record support if the structure is the top
      level structure. </dd>
  <dt>recordProcess</dt>
    <dd>During database initialization every record instance is assigned an
      instances of RecordProcess, which coordinates record processing.</dd>
  <dt>process requester</dt>
    <dd>Code that asks recordProcess to process a record. A process requester
      must get a ProcessToken from record process in order to request that a
      record can be processed. A record instance can optionally be set to allow
      only a single process requester, in which case only the first requester
      that asks for a token will receive a token..</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h4 id="L4641">Requester Examples</h4>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests: 
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status, severity,
            and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be done
      with as few lock/unlock cycles and context switches as possible. In
      particular only asynchronous support should cause a context switch. <br />
      Typical requests are: 
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>

<h4 id="L4684">RecordProcess Overview</h4>

<p>A record is processed via a call to RecordProcess.process. It in turn calls
the record support process method. Record support optionally calls the process
methods of field support modules. Each support module can optionally call the
process method of support code for subfields. Record support is just like field
support except that it is attached to the record rather than to a subfield of
the record.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support 
    <p>Synchronous support is suport that can implemented without blocking.
    Asynchronous support is support that must wait. For example network
    requests must block. Asynchronous support does not cause record processing
    to block. Instead the support code returns without completing and arranges
    some other way to perform it's function. When it is done it again interacts
    with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active and
    other requests to process the record will fail.</p>
  </li>
  <li>record locking 
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
  <li>RecordProcsssRequester 
    <p>A record instance can have 0 or more record process requesters. A record
    can optionally be set to allow at most one record process requesters. Code
    that wants to request processing must first request a ProcesssToken. Then
    it can queue requests to call process.</p>
  </li>
  <li>RecordProcess 
    <p>Each record has an instance of RecordProcess. It manages all process
    related activities.</p>
  </li>
</ul>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess 
    <ul>
      <li>queueRequest 
        <p>A process requester calls this method to request processing. When a
        request is taken from the queue, the record is set active and the
        becomeProcessr method implemented by the process requester is called.
        The requester can optionally put data into the record and then calls
        process.</p>
      </li>
      <li>process 
        <p>recordSupport.process is called. The results of processing are sent
        to the requester via the RecordProcessRequester methods. The requester
        can request the record be left active when processing completes.</p>
      </li>
      <li>setInactive 
        <p>Must be called if the requester asked that the record be left active
        when processing completes.</p>
      </li>
      <li>processContinue 
        <p>Called by asynchronous support when it is ready to continue
        processing. The record is locked and
        processContinueRequester.processContinue is called..</p>
      </li>
      <li>requestProcessCallback 
        <p>Any support code called directly or indirectly by process or
        processContinue can call this method.
        processRequestRequester.processCallback is called with the record
        unlocked. Support code that processes other records must only issue the
        process requests via this method or deadlocks can occur.</p>
      </li>
    </ul>
  </li>
  <li>Support - defined in package org.epics.ioc.support 
    <ul>
      <li>process(SupportProcessRequester supportProcessRequester) 
        <p>This is a method that must be implemented by all support modules.
        When the support is done it calls the supportProcessRequester to report
        completion.</p>
      </li>
    </ul>
  </li>
  <li>RecordProcessRequester 
    <ul>
      <li>becomeProcessor 
        <p>Called as a result of a queueRequest.</p>
      </li>
      <li>canNotProcess 
        <p>The requester has issued a queue request but is not able to process
        the record, for example the record might be disabled.</p>
      </li>
      <li>lostRightToProcess 
        <p>The requester has lost the right to issue queue requests. One reason
        why this could be called is the a recod is dynamically declared to have
        only a single process requester.</p>
      </li>
    </ul>
    <ul>
      <li>recordProcessResult 
        <p>Called with the record locked and all processing is complete.</p>
      </li>
      <li>recordProcessComplete() 
        <p>Called with the record inlocked and processing complete.</p>
      </li>
    </ul>
  </li>
  <li>SupportProcessRequester 
    <ul>
      <li>supportProcessDone(RequestResult requestResult) 
        <p>called by whoever calls support.process. In particular recordSupport
        implements this interface</p>
      </li>
    </ul>
  </li>
  <li>ProcessCallbackRequester 
    <ul>
      <li>processCallback() 
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
  <li>ProcessContinueRequester 
    <ul>
      <li>processContinue() 
        <p>called by recordProcess with record locked.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="L4811">Local Channel Access Example</h4>

<p>As an example assume that a channel access server does the following to a
record:</p>
<ul>
  <li>Puts data into the record.</li>
  <li>Processes the record.</li>
  <li>Reads a large array from the record. The array is too big to fit in a
    single network buffer.</li>
</ul>

<p>This can be implemented as follows:</p>
<ul>
  <li>server calls recordSupport.queueRequest. As a result becomeProcessor will
    be called.</li>
  <li>server locks the record, puts data, unlocks the record.</li>
  <li>server calls recordSupport.process and specifies that the record be left
    active.</li>
  <li>When processing is complete recordSupport calls
    server.recordProcessResult and server.recordProcessDone.</li>
  <li>The server gets the array. It may have to access the array multiple times
    because of the network buffer restrictions. It must lock the record as it
    reads each segment.</li>
  <li>The server calls recordSupport.setInactive.</li>
</ul>

<h4 id="L4846">Link Support Example</h4>

<p>As an example assume that a record type double has the following fields:</p>
<dl>
  <dt>value</dt>
    <dd>A PVDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A PVStructure field which is by default a null structure, i.e. it has
      no fields and no support. A record instance can override this to be any
      structure defined in the master Database Definition Database. The default
      support can also be overridden.</dd>
  <dt>output</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>valueAlarm</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>supportArray</dt>
    <dd>An array field with the elementType set to structure and the
      supportName set to supportArray.</dd>
  <dt>...</dt>
    <dd>Several other null PVStructure fields are present.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>generic</dt>
    <dd>Support for a structure. For each field in the structure that has
      support, generic calls it. </dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e. a
      link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links, i.e.
      a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e. a
      link that can put data to another record.</dd>
  <dt>...</dt>
    <dd>Support modules are also available that can be attached to other null
      PVStructure fields.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "generic"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "display" type = "display" /&gt;
    &lt;structure name = "input" type = "inputSupport"&gt;
        &lt;scalar name = "pvname"&gt;recordForInput&lt;/scalar&gt;
        &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;scalar name = "propertyNames"&gt;alarm,display&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "generic" &gt;
        &lt;structure name = "process" type = "processSupport"&gt;
            &lt;scalar name = "pvname"&gt;processRecord&lt;/scalar&gt;
            &lt;scalar name = "wait" type = "boolean" &gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "output" type = "outputSupport"&gt;
             &lt;scalar name = "pvname"&gt;outputRecord&lt;/scalar&gt;
             &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess locks the record and prepares the for processing. The
    record will remain active until the record is completely processed.</li>
  <li>recordProcess calls doubleRecord.process, which is actually generic
    support. For this example it will be called doubleRecord so that it is not
    confused with the generic support for field link</li>
  <li>doubleRecord calls inputSupport.process.</li>
  <li>Assuming the recordForInput is local and since process is false, the
    input support just: 
    <ul>
      <li>locks the linked record</li>
      <li>transfers data from the linked record to the double record.</li>
      <li>unlocks the linked record.</li>
      <li>notifys doubleRecord that it has completed.</li>
    </ul>
  </li>
  <li>doubleRecord calls link.process.</li>
  <li>generic calls recordProcess.requestProcessCallback.</li>
  <li>doubleRecord returns.</li>
  <li>recordProcess unlocks the record and calls generic.processCallback.<br />
    generic calls the process method of both processSupport and outputSupport. 
    <p>processSupport does the following:</p>
    <ul>
      <li>calls recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to request that
        the linked record be processed. The request does not block. When
        channel access completes the request it calls the processDone method of
        processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>outputSupport does the following.</p>
    <ul>
      <li>Copies the value field to a private data store. It then calls
        recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to put the
        private data into the linked record and then process the record. When
        channel access completes the request it calls the processDone method of
        processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>generic keeps track of each support it calls. When all have called
    supportProcessDone then supportArray is also done.</p>
  </li>
  <li>generic, when done, calls recordSupport.processContinue.</li>
  <li>recordSupport calls generic.processContinue</li>
  <li>generic calls doubleRecord.supportProcessDone.</li>
  <li>doubleRecord calls recordProcess.supportProcessDone</li>
  <li>recordProcess completes record processing 
    <ul>
      <li>calls recordProcessRequester.recordProcessResult</li>
      <li>unlocks the record and sets the record inactive.</li>
      <li>calls recordProcessRequester.recordProcessComplete.</li>
    </ul>
  </li>
</ul>

<h4 id="L5013">Locking</h4>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when any field is being accessed.</li>
  <li>A record must be locked while processing. 
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support interacts
        with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks taken.</li>
  <li>Locks should always be taken with code that has the form: 
    <pre>record.lock();
try {
     ...

} finally {
    record.unlock();
}
    </pre>
  </li>
  <li>Code must not block while a record is locked.</li>
  <li>Two records can be locked simultaneously via: 
    <pre>record.lockOtherRecord(otherRecord);
try {
     ...

} finally {
    otherRecord.unlock();
}
    </pre>
    While a record is locked another record should never be locked by calling
    it's record.lock directly. Doing so can lead to deadlocks. It is NOT
    permissible to lock more than two records at a time.</li>
</ul>

<h4 id="L5052">Support Overview</h4>

<p>A support module implements the following methods:</p>
<dl>
  <dt><span style="font-family: courier;">initialize</span></dt>
    <dd>The support can do any initialization that does not connect outside the
      record.</dd>
  <dt><span style="font-family: courier;">start</span></dt>
    <dd>The support can connect outside the record. For example channel access
      support can connect to another record.</dd>
  <dt><span style="font-family: courier;">stop</span></dt>
    <dd>The support must terminate outside connections.</dd>
  <dt><span style="font-family: courier;">uninitialize</span></dt>
    <dd>The support must undo everything it did during initialization.</dd>
  <dt><span style="font-family: courier;">process</span></dt>
    <dd>Implements the semantics of record procession.</dd>
</dl>

<p>The methods initialize, start, stop, and uninitialize provide the ability to
dynamically modify a record.</p>

<p>Support is associated with a structure, record, or field definition via an
auxInfo definition that has a name of "supportFactory". In addition there must
be a structure definition for the factory itself. Look at the xml structure
definitions that come with the javaIOC for examples.</p>

<h3 style="text-align: center;" id="L5091">Record Process</h3>

<h4 id="L5093">Definitions</h4>

<p>The following are the interfaces for record processing:</p>
<pre>    
    public interface RecordProcess {
        // general purpose methods
        boolean isEnabled();
        boolean setEnabled(boolean value);
        boolean isActive();
        PVRecord getRecord();
        boolean isTrace();
        boolean setTrace(boolean value);
        SupportState getSupportState();
        // support lifecycle methods
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        // record process requester methods
        ProcessToken requestProcessToken(RecordProcessRequester recordProcessRequester);
        void releaseProcessToken(ProcessToken processToken);
        void forceInactive();
        String getRecordProcessRequesterName();
        void queueProcessRequest(ProcessToken processToken);
        void process(ProcessToken processToken,
            boolean leaveActive, TimeStamp timeStamp);
        void setInactive(ProcessToken processToken);
        // support processing methods
        void processContinue(
            ProcessContinueRequester processContinueRequester);
        void requestProcessCallback(
            ProcessCallbackRequester processCallbackRequester);
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
        // self processing method
    }

    public interface ProcessToken {}

    public interface RecordProcessRequester extends Requester{
        void becomeProcessor();
        void canNotProcess(String reason);
        void lostRightToProcess();
        void recordProcessResult(RequestResult requestResult);
        void recordProcessComplete();
    }

    public interface ProcessCallbackRequester extends Requester{
        void processCallback();
    }

    public interface ProcessContinueRequester {
        void processContinue();
    }
    
    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>An instance of RecordProcess is created for each IOCrecord. Each method
falls into one of the following classes:</p>
<ol>
  <li>General Purpose. These are methods that can be called by any code. If
    necessary a method locks the record while performing its action and unlocks
    before returning.</li>
  <li>Record Support Lifetime. Initialize,start,stop,ininitialize.</li>
  <li>Record Process Requester: These are methods for code that requests record
    processing.</li>
  <li>Support Processing. These are methods for use by support code, i.e. code
    that implements record processing.</li>
</ol>

<h4 id="L5114">RecordProcess - General Purpose Methods</h4>
<dl>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>Is the record enabled?</dd>
  <dt style="font-family: courier;">setEnabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when a record is disabled the current process is
      allowed to complete.</dd>
  <dt style="font-family: courier;">isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt style="font-family: courier;">getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt style="font-family: courier;">isTrace</dt>
    <dd>Is trace active for this record?</dd>
  <dt style="font-family: courier;">setTrace</dt>
    <dd>Set tracing on or off. When true info messages are sent to
      pvRecord.message whenever any processing related method of RecordProcess
      is called.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the current support state.</dd>
</dl>

<h4 id="L5152">RecordProcess - Record Lifetime Methods.</h4>

<p><span style="font-family: courier;">RecordProcess</span> looks for the
fields <span style="font-family: courier;">timeStamp</span>, <span
style="font-family: courier;">processAfterStart</span> , and <span
style="font-family: courier;">scan</span>. It handled these fields itself. The
record support code must ignore these fields.</p>
<dl>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Initialize record support. record support, in turn, initializes support
      that it invokes. Initialize should perform any initialiation not
      requiring access aanything outside the record. For example it is not
      permissible to connect to other records. If initialize is successful
      record support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span></dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Start record support. Again record support calls start for any support
      it invokes. If successful, the support enters state <span
      style="font-family: courier;">SupportState.ready</span>. Until record
      support is in the ready state and attempt to process a record will
    fail.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Stop record support. Record support calls stop for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForStart</span>.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Unitialize record support. It calls unitialize for any support it
      invokes. The support enters state <span
      style="font-family: courier;">SupportState.readyForInitialize.</span></dd>
</dl>

<h4 id="L5198">RecordProcess - Record Process Requester Methods</h4>

<p>These are methods called by code that wants a record processed.</p>
<dl>
  <dt style="font-family: courier;">requestProcessToken</dt>
    <dd>Called by a code that wants to call queueProcessRequest.</dd>
  <dt style="font-family: courier;">releaseProcessToken</dt>
    <dd>Called by code that no longer wants to call queueRequest.</dd>
  <dt style="font-family: courier;">forceInactive</dt>
    <dd>Called by code that has a ProcessToken but will no longer be allowed to
      call queueProcessRequest.</dd>
  <dt style="font-family: courier;">getRecordProcessRequesterName</dt>
    <dd>Get the name of the recordProcessRequester.</dd>
  <dt style="font-family: courier;">queueProcessRequest</dt>
    <dd>Request to be the record processor. Each record instance can have only
      one record process requester. If a requester is already registered a
      message is sent to the requester and false is returned.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Request that the record be processed. If the caller has not called
      setActive the record is prepared for processing. In either case if the
      record is ready record support process is called. If true is returned the
      methods implemented by the recordProcessRequester are called to show the
      results of the process request. If <span
      style="font-family: courier;">leaveActive</span> is true than when the
      record completes processing it is left active until setInActive is
      called. Until the record becomes inactive another request to process the
      record will fail. Record support is called with the record locked.<br />
      If false is returned the request has failed and
      recordProcessRequester.message is called to provide the reason. If
      recordProcessRequester is null an IllegalStateException is thrown. </dd>
  <dt style="font-family: courier;">setInActive</dt>
    <dd>Call by the record process requester when it is done with processing.
      Calling process with <span
      style="font-family: courier;">leaveActive</span> true and then calling
      setInactive allows the requester to communicated with other code after
      the record is unlocked but before it becomes inactive.</dd>
</dl>

<h4 id="L5247">RecordProcess - Support Processing methods.</h4>

<p>Methods called by support code which may be record support or support called
directly or indirectly by record support. Except for <span
style="font-family: courier;">processContinue</span> these methods throw an
exception unless <span style="font-family: courier;">process</span> or <span
style="font-family: courier;">processContinue</span> is running.</p>
<dl>
  <dt style="font-family: courier;">requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but before
      RecordProcess.process returns. The callback is made with the record
      unlocked. Thus the callback can request that other records be processed.
      This is the way support code can process other records. If support code
      directly request processing of linked records deadlocks can occur.</dd>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only way
      asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt style="font-family: courier;">setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a record
      is being processed, then RecordProcess will set the time stamp if the
      record has a timeStamp field.</dd>
  <dt style="font-family: courier;">getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <span
      style="font-family: courier;">setTimeStamp</span></dd>
</dl>

<h4 id="L5283">RecordProcessRequester</h4>

<p>Methods implemented by code that requests that a record be processed.</p>
<dl>
  <dt style="font-family: courier;">becomeProcessor</dt>
    <dd>Called as a result of queueRequeProcessst. The requester can the call
      process.</dd>
  <dt style="font-family: courier;">canNotProces</dt>
    <dd>Called as a result of queueProcessRequest but the record can not be
      processed. For example it might be disabled.</dd>
  <dt style="font-family: courier;">lostRightToProcess</dt>
    <dd>Called when code that has a ProcessToken will no longer be allowed to
      call queueProcessRequest. This can happen if a record is dynamically set
      to allow only a single process requester.</dd>
  <dt style="font-family: courier;">recordProcessResult</dt>
    <dd>The results of record processing. This is called with the record locked
      so that the process requester can access data from the record.</dd>
  <dt style="font-family: courier;">recordProcessComplete</dt>
    <dd>Processing is complete. This is called with the record unlocked. If the
      process requester called process with <span
      style="font-family: courier;">leaveActive</span> <span
      style="font-family: courier;">true</span> then the requester must call
      <span style="font-family: courier;">setInactive.</span></dd>
</dl>

<h4 id="L5321">ProcessCallbackRequester</h4>

<p>The method implemented by code that calls requestProcessCallback.</p>
<dl>
  <dt style="font-family: courier;">processCallback</dt>
    <dd>The callback to call when the record support process method returns it
      RecordProcess. Any support code that wants to process other records must
      use this interface. The callback is called with the record unlocked.</dd>
</dl>

<h4 id="L5331">ProcessContinueRequester</h4>

<p>The method implemented by code that calls processContinue.</p>
<dl>
  <dt style="font-family: courier;">processContinue</dt>
    <dd>A request to call support with the record locked. This is the only way
      asynchronous support should continue processing.</dd>
</dl>

<h4 id="L5341">RecordProcessFactory</h4>

<p>A factory is provided to create an instance of RecordProcess for a record
instance. It has the method:</p>
<pre>public class RecordProcessFactory {
    static public RecordProcess createRecordProcess(
          RecordSupport recordSupport,PVRecord pvRecord);
}</pre>

<h3 style="text-align: center" id="L5347">Support</h3>

<p>This section describes the interfaces and abstract base class involved with
support for fields of an IOC record. This also means support for the record
itself.</p>

<h4 id="L5351">Support State</h4>

<p>Before support is ready for processing it must be ready. In addition on-line
add and delete is supported. Thus it is possible to dynamically redefine link
fields, array fields, etc. Unless a support module is in the ready state it's
process method should not be called and if it is it should just report
failure.</p>
<pre>    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public static SupportState getSupportState(int value);
    public static Enumerated getSupportState(PVField pvField);</pre>

<p><span style="font-family: courier;">SupportState</span> has the following
values:</p>
<dl>
  <dt style="font-family: courier;">readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt style="font-family: courier;">readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting to
      other records and/or support.</dd>
  <dt style="font-family: courier;">ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt style="font-family: courier;">zombie</dt>
    <dd>Support is being removed and can never again process.</dd>
</dl>

<h4 id="L5382">Support</h4>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>    
    public interface Support extends Requester {
        String getSupportName();
        SupportState getSupportState();
        PVField getPVField();
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
    }

    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p><span style="font-family: courier;">Support</span> has the methods:</p>
<dl>
  <dt><span style="font-family: courier">getSupportName</span></dt>
    <dd>Get the support name.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>A requester method to get the name of the support.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>A Requester method. This is called to pass messages to the support.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Get the <span style="font-family: courier;">PVField</span> interface
      for the field that is being supported. For record support this will be
      the record itself. <span style="font-family: courier;"></span></dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt style="font-family: courier;">uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Process.</dd>
</dl>

<p>Every Support module must implement the methods initialize, start, stop, and
uninitialize. Initialize performs initialization related to the record instance
being supported but can not access anything outside the record. Start completes
all initialization including linking to the outside, e.g. to other records.
Stop must remove all access to the outside. Uninitialize must remove all access
to the record instance being supported.</p>

<p><span style="font-family: courier;">SupportProcessRequester</span> has the
method:</p>
<dl>
  <dt style="font-family: courier;">supportProcessDone</dt>
    <dd>The callback to call when support is done . Any support code that wants
      to process other records must implement this interface. This MUST be
      called with either process or processContinue running.</dd>
</dl>

<h4 id="L5461">Record Support</h4>

<p>Every record instance has an attached RecordSupport:</p>
<pre>    public interface RecordSupport {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        Support getSupport(PVField pvField);
        void setSupport(PVField pvField,Support support);
    }</pre>

<h3 style="text-align: center" id="L5467">AbstractSupport</h3>

<h4 id="L5469">AbstractSupport</h4>

<h4 id="L5471">Definitions</h4>
<pre>    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,PVRecordField pvRecordField);
        // methods from Requester
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public PVField getPVField();
        // following normally overridden
        public void initialize();
        public void start(AfterStart afterStart);
        public void stop();
        public void uninitialize();
        public void process(SupportProcessRequester supportProcessRequester);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following is for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
    }</pre>

<p>All support code should extend AbstractSupport. Abstract Support implements
all Support methods. Thus support code only has to override the methods it
needs.</p>
<dl>
  <dt style="font-family: courier;">AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
    constructor.</dd>
  <dt style="font-family: courier;">getRequesterName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt style="font-family: courier;">message</dt>
    <dd>Calls pvField.message.</dd>
  <dt style="font-family: courier;">getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt style="font-family: courier;">getPVField</dt>
    <dd>Returns pvField.</dd>
  <dt style="font-family: courier;">initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt style="font-family: courier;">stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt style="font-family: courier;">unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt style="font-family: courier;">process</dt>
    <dd>Normally overridden. The default version just calls
      supportProcessRequester.supportProcessDone(RequestResult.success);</dd>
  <dt style="font-family: courier;">setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt style="font-family: courier;">checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
</dl>

<h3 id="L5538">Package org.epics.ioc.support.rpc</h3>

<h4 style="text-align: center" id="L5540">Overview</h4>

<p>This package provides support for remote procedure calls from a channel
access client. Two types of RPCs are possible:</p>
<dl>
  <dt>putProcessGet</dt>
    <dd>This is used if the PVStructure for the data returned by a request
      always has the same structure.</dd>
  <dt>channelRPC</dt>
    <dd>This is used if a new PVStructure must be send for each request.</dd>
</dl>

<h5 id="L5555">putProcessGet RPC</h5>

<p>A RPC is implemented via a structure that has the following fields:</p>
<dl>
  <dt>arguments</dt>
    <dd>A structure that has a set of fields that are defined by the
      implementation. It defines the arguments required by the RPC. </dd>
  <dt>result</dt>
    <dd>Also a structure that has a set of fields that are defined by the
      implementation. It contains the results.</dd>
</dl>

<p>The client issues a putGet with process request. The put contains the
arguments and the get retrieves the result.</p>

<p>javaIOC/xml/structure/rpc.xml has the definitions for the structures
required by the support provided by this package. The following sections
provide a brief description of the arguments and result for each support.</p>

<h5 id="L5574">channelRPC</h5>

<p>A ChannelRPC allows a different PVStructure to be passed to the server and
returned to the client for each request.</p>

<h4 style="text-align: center" id="L5578">ExampleChannelRPC</h4>

<p>This is an example of how to implement support for a record that supports a
ChannelRPC request. See the package description for org.epics.ca.client for
details about ChannelRPC.</p>

<p>The example uses the record instance that is in
test/channelRPC/channelRPCDB.xml :</p>
<pre>&lt;record recordName = "exampleChannelRPC"&gt;
    &lt;scalar name = "factoryRPC" scalarType = "string"&gt;org.epics.ioc.support.rpc.ExampleChannelRPCFactory&lt;/scalar&gt;
    &lt;structure name = "element"&gt;
        &lt;scalar name = "value" scalarType = "double"/&gt;
        &lt;structure name = "alarm" extends = "alarm"/&gt;
        &lt;structure name = "timeStamp" extends = "timeStamp"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;</pre>

<p>Note that factoryName field. It must give the name of the factory that
creates an object that implements interface RPCServer. The example create a
PVStructure that has size subfields each of which is a clone of element. Look
at the source code for details.</p>
<pre></pre>

<h4 style="text-align: center" id="L5590">RecordList</h4>

<p>This returns a list of the names of a set of records specified by a regular
expression. The arguments are:</p>
<dl>
  <dt>database</dt>
    <dd>A scalar string that specifies the name of the database, e. g.
    master.</dd>
  <dt>regularExpression</dt>
    <dd>A scalar string that is the regular expression. The expression ".*"
      will return a list of all the records in the database.</dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>status</dt>
    <dd>A scalar string that is used to report errors.</dd>
  <dt>names</dt>
    <dd>An array wih element type of string. It contains the record names.</dd>
</dl>

<h4 style="text-align: center" id="L5618">StructureList</h4>

<p>This returns a list of the names of a set of structures specified by a
regular expression. The arguments are:</p>
<dl>
  <dt>database</dt>
    <dd>A scalar string that specifies the name of the database, e. g.
    master.</dd>
  <dt>regularExpression</dt>
    <dd>A scalar string that is the regular expression. The expression ".*"
      will return a list of all the structures in the database.</dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>status</dt>
    <dd>A scalar string that is used to report errors.</dd>
  <dt>names</dt>
    <dd>An array wih element type of string. It contains the structure
    names.</dd>
</dl>

<h4 style="text-align: center" id="L5646">IocShow</h4>

<p>This provides some useful commands for getting information about a JavaIOC.
The arguments are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>showBadRecords</dt>
          <dd>This gets a list of all records than have something unusual about
            them.</dd>
        <dt>showThreads</dt>
          <dd>This provides a list of the names of all the threads created by
            ThreadCreate.</dd>
        <dt>showMemory</dt>
          <dd>Produces a report of memory usage by Java.</dd>
        <dt>garbageCollect</dt>
          <dd>Asks java to collect garbage and then get memory usage.</dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>value</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h4 style="text-align: center" id="L5685">RecordShow</h4>

<p>This provides some useful commands for getting information about a record
The arguments are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>showState</dt>
          <dd>Get the state of the record.</dd>
        <dt>setTraceOn</dt>
          <dd>Set trace on for the record.</dd>
        <dt>setTraceOff</dt>
          <dd>Set trace off for the record.</dd>
        <dt>timeProcess</dt>
          <dd>Time how many times per second the record can be processed. This
            will only succeed if the record does not already have a record
            process requester.</dd>
        <dt>setEnableOn</dt>
          <dd>Enable the record.</dd>
        <dt>setEnableOff</dt>
          <dd>Disable the record. This prevents the record from processing.</dd>
        <dt>releaseProcessor</dt>
          <dd>Release the current record processor. This should only be used as
            a last attempt to fee a record with a record process requester that
            crashed.</dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>value</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h4 style="text-align: center" id="L5739">SupportStateSet</h4>

<p>This allows the support state of a record to be changed The arguments
are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>idle</dt>
          <dd>A do nothing request.</dd>
        <dt>initialize</dt>
          <dd>Initialize the record. The record must be in the
            readyForInitialize state.</dd>
        <dt>start</dt>
          <dd>Start the record. It must be in the readyForStart state.</dd>
        <dt>stop</dt>
          <dd>Stop the record and put it in the readyForStart state. It must be
            in the ready state. </dd>
        <dt>uninitialize</dt>
          <dd>Uninitialize the record and put it in the readyForeInitialize
            state. It must be in the ready or readyForStart state. </dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>message</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h3 id="L5783">Package org.epics.ioc.support.basic</h3>

<h4 style="text-align: center" id="L5785">Overview</h4>

<p>This package contains a set of modules that provide basic support
services.</p>

<p>The following factories are provided:</p>
<dl>
  <dt>GenericFactory</dt>
    <dd>Generic support for a structure or for an array with elementType of
      array or structure.</dd>
  <dt>NoopFactory</dt>
    <dd>Support for all fields that just acts like it always succeeds
      successfully.</dd>
  <dt>ScanFactory</dt>
    <dd>Complete support for the scan field which is defined in comon.xml</dd>
  <dt>Support for linear conversions.</dt>
    <dd><dl>
        <dt>LinearConvertInputFactory</dt>
          <dd>Support for linear conversion of input fields.</dd>
        <dt>LinearConvertOutputFactory</dt>
          <dd>Support for linear conversion of output fields.</dd>
      </dl>
    </dd>
  <dt>ControlLimit</dt>
    <dd>Enforce control limits.</dd>
  <dt>IncrementalFactory</dt>
    <dd>Support for incremental outputs.</dd>
  <dt>EventFactory</dt>
    <dd>Support for a string field that is the name of an event.</dd>
  <dt>DelayFactory</dt>
    <dd>It just causes an asynchronous delay before completing
    successfully.</dd>
</dl>

<h4 style="text-align: center" id="L5841">Generic Support</h4>
<pre>    public class GenericFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>
Generic Support is used for many record/structure definitions . It is often
used because it just looks for fields that have associated support and calls
the support. It also has a few conventions so that it works with a variety of
support modules. It implements the following semantics: 
<dl>
  <dt style="font-family: courier;">scan,timeStamp</dt>
    <dd>It does not call the support for field scan or timeStamp because
      recordProcess handles these fields.</dd>
  <dt style="font-family: courier;">alarm</dt>
    <dd>If field alarm is present and has AlarmSupport then it is handled
      properly.</dd>
  <dt>fields with associated support.</dt>
    <dd>For each field with support, the support methods are called, i.e.
      initialize,start,stop,uninitialize, and process. For process, by default,
      generic waits for each support to finish before it calls the next
      support. For a stucture subfield the default can be changed by appending
      a boolean scalar field to the structure and setting the value to
    false.</dd>
</dl>

<p>The generic support does not force the support for input to do input, the
support for output to do output, etc. The generic support merely calls support
if it exists. The generic support also does not check the types of any fields
but looks for support and calls it if it exists. Thus the generic support can
be used for many different types of data and many different types of
support.</p>

<h4 style="text-align: center" id="L5865">Noop Support</h4>
<pre>    public class NoopFactory {
        public static Support create(PVRecordField pvRecordField);
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>This can be used for record types that just hold data. It can also be used
to provide support for any field. The support acts as though it is synchronous.
All Support methods are implemented by just extending AbstractSupport without
overriding any methods.</p>

<h4 style="text-align: center" id="L5871">ScanFactory</h4>

<p>Support is provided for the scan field. This support is called by
recordProcess. The support handles all the fields in structure scan:</p>

<p>The following definitions are provided:</p>
<pre>    public class ScanFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<h4 style="text-align: center" id="L5879">Control Limit</h4>

<p>This is code to enforce control limits. It handles the following type of
definitions:</p>
<pre>&lt;record name = "aoIncremental"&gt;
    &lt;scalar name = "value" type = "double"&gt;
        &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;controlLimitFactory&lt;/auxInfo&gt;
    &lt;/scalar&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "control" type = "control" &gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;8.0&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;</pre>

<h4 style="text-align: center" id="L5885">Linear Conversion</h4>

<p>Support is available for input and output linear conversions. The xml
definitions for linear conversions are:</p>

<h5 id="L5889">linearConversion</h5>

<p>The structure linearConversion defines the fields used for linear
conversions. The fields slope and intercept are the values used to convert a
rawValue to engineering units. The rawValue is an integer value usually read
from an ADC (Analog to Digital Convertor). The slope and intercept can be
specified directly of calculated from the low and high engineering and device
values. If the later method is chosen the engUnitsLow and engUnitsHigh must be
provided. deviceLow and deviceHigh are either provided automatically by support
of must be provided. The following are the fields in structure
lineraConversion:</p>
<dl>
  <dt style="font-family: courier;">engUnitsLow</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceHigh.</dd>
  <dt style="font-family: courier;">engUnitsHigh</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceLow.</dd>
  <dt style="font-family: courier;">deviceHigh</dt>
    <dd>An int equal to the maximum value for the rawValue.</dd>
  <dt style="font-family: courier;">deviceLow</dt>
    <dd>An int equal to the minimum value for the rawValue.</dd>
  <dt style="font-family: courier;">slope</dt>
    <dd>The slope for the linear conversion.</dd>
  <dt style="font-family: courier;">intercept</dt>
    <dd>The intercept for the linear conversion.</dd>
</dl>

<h5 id="L5924">LinearConvertInputFactory</h5>
<pre>    public class LinearConvertFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is the factory that implements linear input conversion, i.e. it
converts a rawValue to engineering units. The auxInfo must have supportName
"linearConvertInputFactory" .A field for linear conversion for input is a
structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">input</dt>
    <dd>The link for reading the rawValue. If a field named is defined and has
      support the support is called.</dd>
</dl>

<h5 id="L5946">LinearConvertOutputFactory</h5>
<pre>    public class LinearConvertFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is the factory that implements linear output conversion, i.e. it
converts a value in engineering units to a rawValue.The auxInfo must have
supportName "linearConvertOutputFactory". A field for linear conversion for
output is a structure containing the following fields:</p>
<dl>
  <dt style="font-family: courier;">rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt style="font-family: courier;">linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt style="font-family: courier;">output</dt>
    <dd>The link for reading the rawValue. If a field named is defined and has
      support the support is called.</dd>
</dl>

<h4 style="text-align: center" id="L5968">Incremental Support</h4>

<p>This is support for incremental outputs.For example it supports a record
that has the following structure:</p>
<pre>&lt;record name = "aoIncremental"&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "desired" type = "incrementalDouble" &gt;
        &lt;scalar name = "value"&gt;
            &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;controlLimitFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;scalar name = "rateOfChange"&gt;.02&lt;/scalar&gt;
        &lt;scalar name = "incremental"&gt;true&lt;/scalar&gt;
        &lt;structure name = "control" type = "control" &gt;
            &lt;structure name = "limit"&gt;
                &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "high"&gt;8.0&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>This uses the Java definitions:</p>
<pre>    
    public class IncrementalFactory {
        public static Support create(PVField pvField);
    }</pre>

<p>This supports the following fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>The value field.</dd>
  <dt style="font-family: courier;">desired.value</dt>
    <dd>This must be a double field. When this field changes the support
      changes the value field until it has the desired value. If control limits
      are specified then the desired value is forced to be within the control
      limits. If incrementalOutput is true then each time the record is
      processed the value field is changed by rateOfChange until the desired
      value is reached.</dd>
  <dt style="font-family: courier;">incremental</dt>
    <dd>This field is optional. If the record/structure has a field named then
      it must be have type boolean. If not present the default is true. If this
      has the value true the output is adjusted by rateOfChange otherwise the
      value field is changed in one step to the desired value.</dd>
  <dt style="font-family: courier;">rateOfChange</dt>
    <dd>If incrementalOutput is true this is the amount the value will change
      each time the record is processed.</dd>
</dl>

<h4 style="text-align: center" id="L6001">Event Support</h4>
<pre>    public class EventFactory {
        public static Support create(PVField pvField);
    }</pre>

<p>EventFactory implements record or structure support for announcing a scan
event. The event name is given in the field:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>This must be a string field named located in the parent of this field,
      which is normally the value field itself.</dd>
</dl>

<p>Whenever the record is processed eventScanner.announce is called, i.e. the
support announces an event. All event scanned records with the event name
associated with the value field are processed. Each time process is called, the
event support checks to see if the event name has changed.</p>

<h4 style="text-align: center;" id="L6015">DelaySupport</h4>

<p>This is link support that simulates asynchronous support. It uses a
configStructure that has the definition:</p>
<pre>&lt;structure name = "delayFactory"&gt;
 &lt;scalar name = "supportFactory" type = "string"&gt;
   org.epics.ioc.support.basic.DelayFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "delay"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;delayFactory&lt;/auxInfo&gt;
  &lt;!-- min, max, inc are delay in milliseconds --&gt;
  &lt;scalar name = "min" type = "long" /&gt;
  &lt;scalar name = "max" type = "long" /&gt;
  &lt;scalar name = "inc" type = "long" /&gt;
&lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">min</dt>
    <dd>The minimum delay</dd>
  <dt style="font-family: courier;">max</dt>
    <dd>The maximum delay</dd>
  <dt style="font-family: courier;">inc</dt>
    <dd>The delay increment between process requests</dd>
</dl>

<p>Each time process is called it delays a number of milliseconds determined by
min,max, and inc. It starts with a delay on min. Each time it proceses it
increases the delay by inc until it reaches max. It then goes back to a delay
of min.</p>

<p>The factory definition is:</p>
<pre>    public class DelaySupportFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<h3 id="L6045">Package org.epics.ioc.support.calc</h3>

<h4 style="text-align: center" id="L6047">Overview</h4>

<p>This package provides support for calculations. A calculation computes a
result that is assigned to the value field. This package provides:</p>
<ol>
  <li>ExpressionCalculator<br />
    This is support for an expression that has the same syntax as a Java scalar
    expression. For example: 
    <pre>      a + b*c * Math.sin(d)
   </pre>
    For such expressions a complete expression factory is provided. </li>
  <li>Calculation Intrastructure Support<br />
    CalcArgArray support,AbstractCalculatorSupport, and the Database
    Definitions related to calculations. </li>
</ol>

<p>Basic calculation support is described first and then
ExpressionCalculator.</p>

<h4 style="text-align: center" id="L6070">Basic Calculation Support</h4>

<h5 id="L6072">Database Definitions for Calculations</h5>

<p>xml/structure/calx.xml defines the following:</p>
<pre>&lt;structure name = "calcArgsFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.calc.CalcArgsFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "calcArg" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;!-- instance must define value --&gt;
  &lt;scalar name = "name" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "expressionCalculator" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;expressionCalculatorFactory&lt;/auxInfo&gt;
  &lt;scalar name = "expression" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "calculation" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;structure name = "calcArgs"&gt;
     &lt;!-- each field of calcArgs must be a calcArg structure --&gt;
     &lt;auxInfo name = "supportFactory" type = "string"&gt;calcArgsFactory&lt;/auxInfo&gt;
  &lt;/structure&gt;
  &lt;structure name = "calculator" type = "expressionCalculator" /&gt;
  &lt;structure name = "alarm" type = "alarm" /&gt;
&lt;/structure&gt;</pre>

<p><span style="font-family: courier">calculation</span> is the structure used
for calculations. The parent of <span
style="font-family: courier">calculation</span> must have a field with the name
<span style="font-family: courier">value</span> and must have a type compatible
with the calculator. </p>

<p>Structure <span style="font-family: courier">calculation</span> has the
fields: </p>
<dl>
  <dt><span style="font-family: courier">calcArgs</span></dt>
    <dd>A field is a sequence of structures with each being a <span
      style="font-family: courier">calcArg</span> structure and the support
      <span style="font-family: courier">calcArgArray</span>. If the calculator
      uses any arguments from calcArgs this must be present. The name assigned
      to a calcArg field is the argument name for the calculation.</dd>
  <dt style="font-family: courier;">calculator</dt>
    <dd>This field has support that implements the calculation. The default
      support and structure name is expressionCalculator. This field must be
      present and must have support.</dd>
  <dt style="font-family: courier;">alarm</dt>
    <dd>This is present so that a record can be put in alarm if a calculation
      finds problems.</dd>
</dl>

<p><span style="font-family: courier">calcArg</span> is a structure that must
contain at least the field</p>
<dl>
  <dt><span style="font-family: courier">value</span></dt>
    <dd>This must be defined in record instances with a type that is compatible
      with the expression.</dd>
  <dt>other</dt>
    <dd>Other fields can also be defined. For example a field named <span
      style="font-family: courier">input</span> can be defined as a structure
      with associated support that puts data into the <span
      style="font-family: courier">value</span> field.</dd>
</dl>

<p><span style="font-family: courier">expressionCalculator</span> is the
default structure for the <span style="font-family: courier">calculator</span>
field of structure <span style="font-family: courier">calculation</span>. It is
the structure required by support <span
style="font-family: courier">expressioncalculator</span>. It has a single
field:</p>
<dl>
  <dt><span style="font-family: courier">expression</span></dt>
    <dd>The expression using Java syntax.</dd>
  <dt></dt>
</dl>

<p>Support <span style="font-family: courier">calcArgsFactory</span> is the
support for field <span style="font-family: courier">calcArgs</span>. Support
<span style="font-family: courier">expressionCalculator</span> is the support
described in the next section.</p>

<h5 id="L6171">Performing Calculations</h5>

<p>A calculation is performed by a calculation support. The following is done.
When the calculation support, which is generic, is called it calls the
calcArgArray support and the calculator support. For each element of
calcArgArray, the calcArgArray support calls The support for any subfields that
have support. The calcArgArray support extends Support to provide the
additional method</p>
<pre>    PVField getPVField(String argName);</pre>

<p>which is used by the calculator support to get arguments. The calculator
support uses the calcArgArray values to compute the calculated value.</p>

<h5 id="L6179">calcArgs</h5>

<p>This support implements support for a structure than is a sequence of
calcArg structures, which has the fields:</p>
<dl>
  <dt style="font-family: courier;">value</dt>
    <dd>A value for this argument. NOTE that record instances must define a
      value specifying the type required by the calculation expression.</dd>
  <dt style="font-family: courier;">other</dt>
    <dd>Other fields can be defined. For example a field input which is a link
      for obtaining the value for this argument. If no additional field
      specified then no input is read and the value field can just be set by
      the user.</dd>
</dl>

<h4 style="text-align: center" id="L6194">ExpressionCalculator</h4>

<p>This is support for an expression that has the form of a valid java
expression.</p>

<h5 id="L6198">Simple Examples</h5>

<p>The following example is a counter, i.e. each time the record is processed
the value field is incremented by 1.</p>
<pre>&lt;record name = "reallySimpleCounter"&gt;
    &lt;scalar name = "value" type = "byte" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
      &lt;structure name = "calculator"&gt;
        &lt;scalar name="expression"&gt;value+1&lt;/scalar&gt;
      &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following is an example that has arguments min, max, and inc. Each time
the record is processed the current value is incremented by inc. If the result
is less than or equal to max it becomes the new value; otherwise value is set
to max. Note that &lt; must be given as the xml escape sequence for &lt; , i.e.
&amp;lt;</p>
<pre>&lt;record name = "counter"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "min"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "max"&gt;
            &lt;scalar name = "value" type = "double" &gt;10.0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "inc"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.5&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;(value+inc)&amp;lt;=max ? value+inc : min&lt;/scalar&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;    
&lt;/record&gt;</pre>

<p>The next example computes the sin of an argument given in radians:</p>
<pre>&lt;record name = "sin"&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "a"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.5&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;
             Math.sin(Math.PI*a)
         &lt;/scalar&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<p>The last example demonstrates the use of the ?: operator:</p>
<pre>&lt;record name = "check"&gt;
    &lt;scalar name = "value" type = "boolean" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "a"&gt;
            &lt;scalar name = "value" type = "byte" &gt;0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "b"&gt;
            &lt;scalar name = "value" type = "byte" &gt;1&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;
            (a-b)==0 ? true : false
         &lt;/scalar&gt;
       &lt;/structure&gt;    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 id="L6216">Expression Syntax</h5>

<p>A expression is has the form of a valid Java scalar expression. The result
of the expression is assigned to the value field.</p>

<p>The precedence is the same as the Java precedence. For example the
following:</p>
<pre>   a + b*c + Math.sin(e*f)</pre>
Is the same as: 
<pre>   ((a + (b*c)) + Math.sin((e*f)))</pre>

<h5 id="L6228">Expression Arguments</h5>

<p>An argument can be one of the following:</p>
<dl>
  <dt>variable</dt>
    <dd>The argument is one of the calcArgArray names.</dd>
  <dt>value</dt>
    <dd>The "value" appears as an argument than the argument is the value field
      itself. Note that this is the first value field found searching up the
      parent tree.</dd>
  <dt>boolean constant</dt>
    <dd>The argument is "true" or "false"</dd>
  <dt>string constant</dt>
    <dd>A argument enclosed in "" is a string constant.</dd>
  <dt>integer constant</dt>
    <dd>The argument is a valid java integer constant. It becomes an int
      constant unless it is terminated with the character L, which means it is
      a long integer constant. The value can also be given as a valid hex
      integer, e.g. 0x0fff. </dd>
  <dt>real constant</dt>
    <dd>The argument is a valid java real constant, i.e. it is either a float
      or double constant.</dd>
  <dt>Math constant</dt>
    <dd>The argument is either Math.PI or Math.E</dd>
</dl>

<h5 id="L6268">Unary Operators</h5>

<p>The supported unary operators are:</p>
<dl>
  <dt>+</dt>
    <dd>Unary plus. The argument can be any numeric type.</dd>
  <dt>-</dt>
    <dd>Unary minus. The argument can be any numeric type.</dd>
  <dt>~</dt>
    <dd>Bitwise Complement. The argument can be any integer type.</dd>
  <dt>!</dt>
    <dd>Boolean not. The argument must be boolean.</dd>
</dl>

<h5 id="L6293">Binary Operators</h5>

<p>The supported binary operators are:</p>
<dl>
  <dt>*</dt>
    <dd>Multiplication. The argument can be any numeric type.</dd>
  <dt>/</dt>
    <dd>Division. The argument can be any numeric type.</dd>
  <dt>%</dt>
    <dd>Remainder. The argument can be an integer type.</dd>
  <dt>+</dt>
    <dd>Binary plus. The arguments can be any numeric type.</dd>
  <dt>+</dt>
    <dd>String concatenation. The first argument must be a string.</dd>
  <dt>-</dt>
    <dd>Binary minus. The arguments can be any numeric type.</dd>
  <dt>&lt;&lt;</dt>
    <dd>Left shift. The arguments must be an integer type.</dd>
  <dt>&gt;&gt;</dt>
    <dd>Right shift sign extended. The arguments must be an integer type.</dd>
  <dt>&gt;&gt;&gt;</dt>
    <dd>Right shift zero extended. The arguments must of an integer type.</dd>
  <dt>&lt;</dt>
    <dd>Less than. The arguments must be numeric.</dd>
  <dt>&lt;=</dt>
    <dd>Less than or equal. The arguments must be numeric.</dd>
  <dt>&gt;</dt>
    <dd>Greater than. The arguments must be numeric.</dd>
  <dt>&gt;=</dt>
    <dd>Greater than or equal. The arguments must be numeric.</dd>
  <dt>==</dt>
    <dd>Equal. The arguments can be any supported type.</dd>
  <dt>!=</dt>
    <dd>Not equal. The arguments can be any supported type.</dd>
  <dt>&amp; </dt>
    <dd>Integer and. The arguments must be integer.</dd>
  <dt>&amp; </dt>
    <dd>Boolean and. The arguments must be boolean.</dd>
  <dt>^</dt>
    <dd>Bitwise XOR. The arguments must be integer.</dd>
  <dt>^</dt>
    <dd>Boolean XOR. The arguments must be boolean.</dd>
  <dt>|</dt>
    <dd>Bitwise or. The arguments must be integer.</dd>
  <dt>|</dt>
    <dd>Boolean or. The arguments must be boolean.</dd>
  <dt>&amp;&amp;</dt>
    <dd>Conditional and. The arguments must be boolean.</dd>
  <dt>||</dt>
    <dd>Conditional or. The arguments must be boolean.</dd>
</dl>

<h5 id="L6413">Ternary Operator</h5>

<p>The ternary operator ?: is supported.</p>

<h5 id="L6417">Math Functions</h5>

<p>All the functions defined in java.lang.Math are supported.</p>

<h5 id="L6421">Constant optimization</h5>

<p>If the arguments of an operator are all constants then the result is
determioned during initialization and the operation not performed when the
record is processed.</p>

<h5 id="L6425">Test</h5>

<p>test/calc contains tests for ExpressionCalculator. After the test is
initialized use the swtshell to bring up the introspectDatabase screen. Select
the showBadRecordss button. No records should appear except possibly active
records. The only records without checks are random, calcSimpleCounter, and
calcCounter. These can be checked manually. For random issue get with process
requests. For calcSimpleCounter and calcCounter just monitor the records.</p>

<h4 id="L6429">Package org.epics.ioc.support.calc.example</h4>

<p>This package gives some examples of how to extend AbstractCalculatorSupport.
It has the following examples:</p>
<dl>
  <dt>arrayIncrement</dt>
    <dd>The value field must be an array of doubles. When process is called 1
      is added to each element of the array.</dd>
  <dt>booleanArrayToggle</dt>
    <dd>The value field must be an array of boolean. When process is called
      each array element is toggled between false and true.</dd>
  <dt>arrayAdd</dt>
    <dd>It has arguments named a and b. The fields a, b, and value must each be
      a double array. When process is called it sets value equal to a + b.</dd>
</dl>

<h3 id="L6449">Package org.epics.ioc.support.alarm</h3>

<h4 style="text-align: center" id="L6451">Overview</h4>

<p>Support is provided for the alarm field itself and raising alarms for the
primitive types and for an enumerated structure.</p>

<p>The next section describes the xml syntax for attaching alarm support to a
value field and raising alarms for the value field. The remaining sections
describe the support. </p>

<p>An alarm is defind as follows:</p>
<pre>&lt;structure structureName = "alarm"&gt;
  &lt;scalar name = "severity" scalarType = "int" /&gt;
  &lt;scalar name = "status" scalarType = "int" /&gt;
  &lt;scalar name = "message" scalarType = "string" /&gt;
&lt;/structure&gt;</pre>

<p>Thus an alarm is defined by a structure that has two fields:</p>
<dl>
  <dt>severity</dt>
    <dd>An integer that represents a severity index. org.epics.pvData.property
      has definitions for AlarmSeverity, Alarm, and AlarmFactory that
      implements a enum where the severity is the index. </dd>
  <dt>status</dt>
    <dd>An integer that represents a status index. org.epics.pvData.property
      has definitions for AlarmStatus, Alarm, and AlarmFactory that implements
      a enum where the status is the index. </dd>
  <dt>message</dt>
    <dd>A string field named message.</dd>
</dl>

<p>The following factories are provided:</p>
<dl>
  <dt>AlarmSupportFactory</dt>
    <dd>Complete support for field alarm.</dd>
  <dt>BooleanAlarmFactory</dt>
    <dd>Alarm support for boolean fields.</dd>
  <dt>ByteAlarmFactory</dt>
    <dd>Alarm support for byte fields.</dd>
  <dt>ShortAlarmFactory</dt>
    <dd>Alarm support for short fields.</dd>
  <dt>IntAlarmFactory</dt>
    <dd>Alarm support for int fields.</dd>
  <dt>LongAlarmFactory</dt>
    <dd>Alarm support for long fields.</dd>
  <dt>FloatAlarmFactory</dt>
    <dd>Alarm support for float fields.</dd>
  <dt>DoubleAlarmFactory</dt>
    <dd>Alarm support for double fields.</dd>
  <dt>EnumeratedAlarmFactory</dt>
    <dd>Alarm support for enum field..</dd>
</dl>

<h4 style="text-align: center" id="L6527">XML definitions For alarms</h4>

<p>Support for raising alarms is provided for all the primitive types and for
an enumerated structure. Each can be defined for any field of a record that has
the corresponding type and has the field name "value". A record instance can
have multiple fields with associated alarm support. Since a structure can have
only one field named value, the top level of a structure can only have a single
alarm support but each substructure can also have alarm support. Three basic
types of support are provided: numeric, boolean, and enumerated. Each is
discussed in a separate section below.</p>

<h5 id="L6531">Numeric Scalar</h5>

<p>Support is provided for all the numeric scalar types: byte, short, long,
float, and double. The following desription is for double but the support for
the other types is similar.</p>

<p>The structures associated with doubleAlarm are :</p>
<pre>&lt;structure structureName = "doubleAlarm" &gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.doubleAlarmFactory&lt;/auxInfo&gt;
  &lt;scalar name = "active" scalarType = "boolean" /&gt;
  &lt;scalar name = "lowAlarmLimit" scalarType = "double" /&gt;
  &lt;scalar name = "lowWarningLimit" scalarType = "double" /&gt;
  &lt;scalar name = "highWarningLimit" scalarType = "double" /&gt;
  &lt;scalar name = "highAlarmLimit" scalarType = "double" /&gt;
  &lt;scalar name = "lowAlarmSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "lowWarningSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "highWarningSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "highAlarmSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "hystersis" scalarType = "double" /&gt;
&lt;/structure&gt;</pre>

<p>The doubleAlarm structure must appear in a structure at the same level as a
double scalar field named value. There must be an alarm field at the same
level.:q</p>

<p></p>

<p>An example for a double field is:</p>
<pre>&lt;record recordName = "simpleCounter" &gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "int" /&gt;
    &lt;structure name = "input" extends = "calculation" &gt;
      &lt;structure name = "calculator"&gt;
        &lt;scalar name ="expression"&gt;(value+1)&amp;lt;=10 ? value+1 : 0&lt;/scalar&gt;
      &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" extends = "intAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;scalar name = "lowAlarmLimit"&gt;2&lt;/scalar&gt;
      &lt;scalar name = "lowAlarmSeverity"&gt;2&lt;/scalar&gt;
      &lt;scalar name = "lowWarningLimit"&gt;4&lt;/scalar&gt;
      &lt;scalar name = "lowWarningSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "highWarningLimit"&gt;8&lt;/scalar&gt;
      &lt;scalar name = "highWarningSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "highAlarmLimit"&gt;10&lt;/scalar&gt;
      &lt;scalar name = "highAlarmSeverity"&gt;2&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>This example reproduces the semantics of alarm support for an EPICS V3 ai
record but the details are different. The above xml definition is for a record
instance but it could also apply to a substructure of a record if record is
replaced by structure in the above example. What is important is that the
structure has fields named value and alarm and that a structure field that
extends doubleAlarm is defined.</p>

<h5 id="L6549">Boolean</h5>

<p>A example of attaching alarm support to a boolean record or structure is:</p>
<pre>&lt;record recordName = "booleanExample"&gt;
    &lt;scalar name = "value" scalarType = "boolean"/&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "valueAlarm" extends = "booleanAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;scalar name = "falseSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "trueSeverity"&gt;2&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The booleanAlarm structure also has a fields named changeOfStateAlarm and
changeOfStateMessage. It semantics should be easy to see.</p>

<h5 id="L6557">Enumerated</h5>

<p>Before explaining the example let's first define the structure associated
with enumerated alarm support.</p>
<pre>&lt;structure structureName = "enumeratedAlarm"&gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.ioc.enumeratedAlarmFactory&lt;/auxInfo&gt;
  &lt;scalar name = "active" scalarType = "boolean" /&gt;
  &lt;array name = "stateSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "changeStateSeverity" scalarType = "int" /&gt;
&lt;/structure&gt;</pre>

<p>An enumerated structure appears in a structure at the same level as an
enumerated field named value. It has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>Is alarm processing active?</dd>
  <dt>stateSeverity</dt>
    <dd>An array of alarmSeverity values. There must be exactly 1 for each
      element of the value field.</dd>
  <dt>changeStateSeverity</dt>
    <dd>The alarm severity for change of state.</dd>
</dl>

<p>The following shows how to create a record with enumerated alarms.</p>
<pre>&lt;record recordName = "enumerated"&gt;
     &lt;structure name = "value" extends = "enumerated"&gt;
       &lt;array name = "choices"&gt;zero,one,two,three,four&lt;/array&gt;
    &lt;/structure&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "valueAlarm" extends = "enumeratedAlarm"&gt;
            &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
            &lt;scalar name = "changeStateSeverity"&gt;0&lt;/scalar&gt;
            &lt;array name = "stateSeverity"&gt;2,1,0,1,2&lt;/array&gt;
    &lt;/structure&gt;

&lt;/record&gt;</pre>

<h4 style="text-align: center" id="L6585">Alarm Support</h4>

<p>AlarmSupport is support for a field named which must have type structure and
the structure must be an alarm structure. Within the structure hierarchy of a
record multiple alarm fields can exist. Some support, e.g. generic, calls the
support for the alarm field defined in the top level structure (defined in
common.xml). If multiple alarm fields reside in a record then the top level
alarm field, which is what the outside world normally accesses has a severity
at least as great as any of the lower level alarms.</p>
<pre>interface AlarmSupport extends Support{
    void beginProcess();
    void endProcess();
    boolean setAlarm(String message, AlarmSeverity severity,AlarmStatus status);
    Alarm getAlarm();
}

class AlarmSupportFactory {
    public static Support create(PVRecordStructure,pvRecordStructure)
    public static AlarmSupport getAlarmSupport(PVRecordField pvRecordField);
}</pre>

<p>AlarmSupport provides the methods:</p>
<dl>
  <dt style="font-family: courier;">Support</dt>
    <dd>Standard support methods..</dd>
  <dt style="font-family: courier;">beginProcess</dt>
    <dd>This is called when a field begins processing. It must be called by
      support for the structure that has alarm as a subfield. Support generic
      calls it.</dd>
  <dt style="font-family: courier;">endProcess</dt>
    <dd>This is called when a record finishes processing.It must be called by
      support for the structure that has alarm as a subfield. Support generic
      calls it. If setAlarm was not called since beginProcess was called than
      it makes sure that the severity is noAlarm. If the severity and/or
      message was changed during record processing it calls postPut.</dd>
  <dt style="font-family: courier;">setAlarm</dt>
    <dd>While a record is processing code, normally another support module, can
      call setAlarm. This method changes the new message, severity, and status
      only if the severity passed to setAlarm is greater than the current new
      severity or if this is the first call since the record started
    processing.</dd>
  <dt style="font-family: courier;">getAlarm</dt>
    <dd>Get the Alarm interface. This interface is defined in
      org.epics.pvData.property.</dd>
</dl>

<p>AlarmFactory provides the static methods:</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Create support for a alarm field. This is called by
    SupportCreation.</dd>
  <dt style="font-family: courier;">getAlarmSupport</dt>
    <dd>Get the alarm support for the field or return null if none is
    found.</dd>
</dl>

<h4 style="text-align: center" id="L6632">Value Alarms</h4>

<p>Support is provided for alarms for the following types of fields: boolean,
numeric, and enumerated.</p>

<h5 id="L6636">Boolean Alarms</h5>
<pre>    public class BooleanAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>This provides support for reporting alarms for boolean fields. The
configurationStructure must be a structure booleanAlarm, which has the
fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">falseAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is false.</dd>
  <dt style="font-family: courier;">trueAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is true.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h5 id="L6663">Numeric Alarms</h5>
<pre>    public class ByteAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class ShortAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class IntAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class LongAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class FloatAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class DoubleAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>The above factories provide alarm support for the associated type of field,
e.g. FloatAlarmFactory provides alarm support for a field of type float. The
support for each type except that float and double also support hystersis: If
value goes into alarm this is the amount it must come out of alarm before the
alarm severity is modified. This prevents alarm .</p>

<h5 id="L6669">Enumerated Alarms</h5>
<pre>    public class EnumeratedAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>The above factory provides support for an enumerated structure field.</p>

<p>The enumeratedAlarm structure has the following fields:</p>
<dl>
  <dt style="font-family: courier;">active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt style="font-family: courier;">stateSeverity</dt>
    <dd>An array of stateSeverity alarmSeverity menu definitions. When the
      process method is called the value field is the index for this array. The
      corresponding alarmSeverity menu is found and it determines the alarm
      severity.</dd>
  <dt style="font-family: courier;">changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h3 id="L6693">Package org.epics.ioc.support.caLink</h3>

<h4 style="text-align: center" id="L6695">Overview</h4>

<p>This is support for channel access links. It is implemented by making client
calls to CAJv4. It provides an implementation of support for the following:</p>
<dl>
  <dt>caProcessLink</dt>
    <dd>Support that requests that another record process without transfering
      any data.</dd>
  <dt>caInputLink</dt>
    <dd>Support that 1) optionally requests that another record process, and 2)
      transfers data from the other record this record..</dd>
  <dt>caOutputLink</dt>
    <dd>Support that 1) transfers data to another record, and 2) optionally
      requests that the other record process.</dd>
  <dt>caMonitorLink</dt>
    <dd>Support for monitoring another record. A monitor returns data.</dd>
  <dt>caMonitorNotifyLink</dt>
    <dd>Support for monitoring another record. A monitor does not return
    data.</dd>
</dl>

<h4 style="text-align: center" id="L6725">Data Types Supported</h4>

<p>Each requires that other support code, e.g. record support knows how to call
them.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.ioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the pvname.</dd>
</dl>

<h4 style="text-align: center" id="L6754">Support Structure Definition</h4>

<p>Look at the structure definitions in javaIOC/dbd/structures/caLink.xml for a
description of how the various structures are defined.</p>

<p>The following is an example of a definition for using caInputLink.</p>
<pre>&lt;record recordName = "exampleInput"&gt;
    &lt;scalar name = "value" scalarType = "double"/&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "input" extends = "caInputLink"&gt;
        &lt;scalar name = "providerName"&gt;pvAccess&lt;/scalar&gt;
        &lt;scalar name = "pvname"&gt;targetRecord&lt;/scalar&gt;
        &lt;scalar name = "request" scalarType = "string"&gt;value,alarm,display&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The request must provide a request definition as defined in package
org.epics.pvData.pvCopy. It can be given as either a scalar string or as a
structure. The example above uses the easiest method, which is to define a
scalar string field. The value of the field is a comma separated list of top
level fields in the record to which the support is attached. The example asks
to get the value, alarm, and display from the target record.</p>

<h3 id="L6764">Package org.epics.ioc.support.dbLink</h3>

<h4 style="text-align: center" id="L6766">Overview</h4>

<p>This is support for channel access links. It is implemented by making client
calls to org.epics.ioc.dbLink. It provides an implementation of support for the
following:</p>
<dl>
  <dt>dbProcessLink</dt>
    <dd>Support that requests that another record process without transfering
      any data.</dd>
  <dt>dbInputLink</dt>
    <dd>Support that 1) optionally requests that another record process, and 2)
      transfers data from the other record this record..</dd>
  <dt>dbOutputLink</dt>
    <dd>Support that 1) transfers data to another record, and 2) optionally
      requests that the other record process.</dd>
</dl>

<h4 style="text-align: center" id="L6786">Data Types Supported</h4>

<p>Each requires that other support code, e.g. record support knows how to call
them.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.ioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.ioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the pvname.</dd>
</dl>

<p>Look at the structure definitions in javaIOC/dbd/structures/dbLink.xml for a
description of how the various structures are defined.</p>

<h3 id="L6817">Package org.epics.ioc.support.device</h3>

<h4 style="text-align: center" id="L6819">Overview</h4>
This package will have support for device abstractions. For now it only has a
power supply example. 

<h4 style="text-align: center" id="L6823">Power Supply Support</h4>
<pre>    public class PowerSupplyFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is an example of support for a power supply. Given a voltage and power
it computes the current. It supports fields for reading the voltage and for
writing the current. The complete set of fields it suppports are:</p>
<dl>
  <dt style="font-family: courier;">voltage</dt>
    <dd>This is required. It must be a structure containing a scalar double
      field named value and an alarm field.</dd>
  <dt style="font-family: courier;">current</dt>
    <dd>This is required. It must be a structure containing a scalar double
      field named value and an alarm field.</dd>
  <dt style="font-family: courier;">power</dt>
    <dd>This is required. It must be a a structure containing a scalar double
      field named value and an alarm field.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="L6847">Package org.epics.ioc.pdrv</h2>
<hr />

<h3 style="text-align: center" id="L6851">Preface</h3>

<p><b>portDriver</b> is a general purpose facility for interfacing support code
to low level drivers.</p>

<p>This package overview describes the portDriver framework but not interfaces,
drivers, or support for accessing a portDriver via JavaIOC records. The
following other packages are related to portDriver.</p>
<dl>
  <dt>org.epics.ioc.pdrv.interfaces</dt>
    <dd>The interfaces implemented by port drivers.</dd>
  <dt>org.epics.ioc.pdrv.serial</dt>
    <dd>Drivers that communicate with serial devices.</dd>
  <dt>org.epics.ioc.pdrv.vxi11</dt>
    <dd>A diver that communicates with vxi11 devices.</dd>
  <dt>org.epics.ioc.pdrv.testDriver</dt>
    <dd>Code that simulates devices.</dd>
  <dt>org.epics.ioc.support.pdrv</dt>
    <dd>The base support for connecting a JavaIOC record to a port driver.</dd>
  <dt>org.epics.ioc.support.pdrv.scalar</dt>
    <dd>Support for read/write of scalar values via a port driver.</dd>
  <dt>org.epics.ioc.support.pdrv.array</dt>
    <dd>Support for read/write of array values via a port driver.</dd>
  <dt>org.epics.ioc.support.pdrv.serial</dt>
    <dd>Support for sending command and query messages to a serial device.</dd>
  <dt>org.epics.ioc.support.pdrv.digital</dt>
    <dd>Support for Digital I/O.</dd>
</dl>

<h3 style="text-align: center" id="L6905">Purpose</h3>

<p><b>portDriver</b> is a general purpose facility for interfacing support code
to low level drivers. Devices are accessed via a port. portDriver allows
non-blocking support that works with both blocking and non-blocking drivers.</p>

<p>A primary target for portDriver is support for fields of JavaIOC records.
However much of it is independent of the javaIOC.</p>

<p>portDriver has the following key concepts:</p>
<ul>
  <li>A port is a communication path to one or more devices, i.e. a device is
    accessed via a port.</li>
  <li>A driver implements interfaces PortDriver, DeviceDriver and I/O
    interfaces.</li>
  <li>portDriver implements interfaces User, Port, Device, and Trace.</li>
  <li>Interface User is an interface for support code to access portDriver and
    drivers.</li>
  <li>Interface Trace provides a general purpose diagnostic facility. 
    <p>Rules are defined for providing diagnostic messages. Provided support
    and drivers follow the rules, a user can obtain several levels of
    diagnostic information that can be displayed on the console, written to a
    file, or sent to an error logging facility.</p>
  </li>
  <li>A standard set of I/O interfaces are defined. 
    <p>Support code communicates with devices via the I/O interfaces. </p>
    <p>Drivers take care of the details of how to communicate with a device and
    implement interfaces for use by support. Interfaces are defined for both
    message and register based devices.</p>
  </li>
  <li>A port provides access to device instances 
    <p>A port, which has a portName, identifies a communication path to one or
    more device instances. For example a GPIB port can have up to 15 devices
    connected to it. An RS232 port communicates with a single device. Drivers
    register a port. Support connects to a port.</p>
  </li>
  <li>Interface Port controls access to a port 
    <p>Port provides exclusive access to a driver via calls to
    user.queueRequest or user.lockPort/user.unlockPort. Once support has
    access, it can make an arbitrary number of calls to the I/O interfaces
    knowing that no other support can call the driver. Support and drivers do
    not need to implement queues or semaphores since Port does this for
    them.</p>
  </li>
  <li>portDeviceControl - A record that allows a user to interact with a port
    or a device connected to a port. The user can connect/disconnect,
    enable/disable the port or device. The user can set autoConnect, traceMask,
    and traceIOMask. The user can request a report. </li>
  <li>Extensive Serial Support - ONLY LIMITED SUPPORT HAS BEEN IMPLEMENTED AND
    TESTED 
    <p>portDriver provides many facilities for communicating with RS232, RS485,
    GPIB, and ethernet.</p>
  </li>
  <li>portDriverLinkSupport - This is discussed in other packages.</li>
</ul>

<h3 style="text-align: center" id="L6961">Status</h3>

<p>This version provides</p>
<ul>
  <li>Factory: Implementations of User, Port, Device, and Trace.</li>
  <li>Standard interfaces: Standard message and register based interfaces are
    defined. Low Level Drivers implement standard interfaces. Support
    communicates with low level drivers via standard interfaces.</li>
  <li>portDriver Link Support: Generic support for javaIOC records. This is
    part of package org.epics.ioc.support.pdrv and it's sub-packages. See it
    for details.</li>
</ul>

<p>Some hardware support is currently ready for use but testing so far is
minimal. Lots remains to be done. The CLS (Canadian Light Source) has kindly
lent me some xvi11 based hardware which has been used for the tests.</p>
<ul>
  <li>Java Support for VXI-11 network devices has been written and some testing
    has been done. </li>
  <li>IPSerialDriver has been used to talk to a serial port connected to a MOXA
    UIC7408 network to serial server. A null modem connector is attached to the
    serial port so no test involving a real serial device has been done.</li>
  <li>See the org.epics.ioc.support.pdrv documentation to see how serial
    protocol support is implemented. Rather than support for protocol files,
    like STREAMS implements, the support uses embeded structures and somewhat
    generic special support.</li>
</ul>

<p>Future</p>
<ul>
  <li>Serial support: Instead of support like STREAMS, portDriver uses embeded
    structures and special support to provide the same features. It has been
    tested with the xvi support to implement a few simple SCPI (Standard
    Commands for Programmable Instruments) commands. The same technique can be
    used to implement things like checksums, discarding output from devices
    that respond to writes, etc.</li>
  <li>???</li>
</ul>

<h3 style="text-align: center" id="L6996">Acknowledgments</h3>

<p>portDriver is modeled after asynDriver. See <a
href="http://www.aps.anl.gov/epics/modules/soft/asyn/">asynDriver</a>. for
details about asynDriver.</p>

<p>Special thanks goes to Mark Rivers and Eric Norum who both made major
contributions to asynDriver and to Dirk Zimoch for developing STEAMS.</p>

<h3 style="text-align: center" id="L7005">Overview of portDriver</h3>

<h4 id="L7007">Definitions</h4>

<p>portDriver is a software layer between support code, e.g. javaIOC support,
and drivers that communicate with devices. It supports both blocking and
non-blocking communication and can be used with both register and message based
devices. portDriver uses the following terminology:</p>
<ul>
  <li>portDriver <br />
    The name for the code described in this package. </li>
  <li>port <br />
    A physical or logical entity which provides access to a device. A port
    provides access to one or more devices. </li>
  <li>Port <br />
    An interface, implemented by the Factory for this package, that manages the
    port. </li>
  <li>device <br />
    A device (instrument) is connected to a port. For example a GPIB interface
    can have up to 15 devices connected to it. Other ports, e.g. EIA232 serial
    ports, only support a single device. Whenever this document uses the word
    device without a qualifier, it means something that is connected to a port.
  </li>
  <li>Device <br />
    An interface, implemented by the Factory for this package, that manages a
    device. </li>
  <li>interface <br />
    All communication between software layers is done via Java interfaces. </li>
  <li>PortDriver <br />
    Interface implemented by a driver for the port. </li>
  <li>DeviceDriver <br />
    Interface implemented by a driver for a device connected to a port. </li>
  <li>support <br />
    The code that users portDriver. For example portDriverLinkSupport is
    portDriver support code for javaIOC records. </li>
  <li>User <br />
    An interface implemented by portDriver and used by support. It provide
    access to portDriver itself and driver I/O interfaces. It also allows a
    driver to pass error messages and other auxillary information to support
    code. </li>
  <li>Trace <br />
    An interface for diagnostic messages. </li>
  <li>portThread <br />
    If a port can block, a thread is created for the port, and all I/O is done
    via this thread. </li>
  <li>synchronous <br />
    Code that does not voluntarily give up control of the CPU, i.e. it does not
    block. Mutex operations are considered to be synchronous operations, i.e.
    they are permitted in synchronous code. </li>
  <li>asynchronous <br />
    Code that is not synchronous. Some examples of asynchronous operations are
    threadSleep, eventWait, and stdio operations. </li>
  <li>asynchronous Driver <br />
    A driver that blocks while communicating with a device. Typical examples
    are serial, gpib, and network based drivers. </li>
  <li>synchronous Driver <br />
    A driver that does not block while communicating with a device. Typical
    examples are register based devices. </li>
  <li>I/O Interface <br />
    An interface for performing Input or Output to a device. An I/O interface
    is implement by a DeviceDriver. </li>
  <li>interrupt <br />
    As implemented by portDriver, interrupt just means "I have a new value".
  </li>
</ul>

<p>Synchronous/asynchronous and message/register are orthogonal concepts. For
example a register based driver can be either synchronous or asynchronous. The
terminology register vs message is adapted from VXI.</p>

<p>Standard I/O interfaces are defined. For example if support does all its
communication via reads and writes consisting of 8 bit bytes (octets), then it
should work with any driver that implements interface Serial.</p>

<p>One or more devices can be attached to a port. For example, only one device
can be attached to an RS-232 port, but up to 15 devices can be attached to a
GPIB port.</p>

<p>A device driver can implement multiple interfaces.</p>

<p>portDriver uses some features of the javaIOC but it can be used by other
code, e.g. a sequence program when one is created for the javaIOC.</p>

<h4 id="L7130">portDriver Interfaces</h4>
The interfaces implemented by port drivers are described in the overview for
package org.epics.ioc.pdrv.interfaces. 

<h4 id="L7134">portDriver Factory</h4>

<p>This implements Port, Device, User, and Trace. It has static methods to:</p>
<ul>
  <li>Create a User.<br />
    Support code must create a User before it can access a port and it's
    associated devices.</li>
  <li>Create a Port.<br />
    This is called by a driver to register a port.</li>
</ul>

<h4 id="L7151">Connection Management</h4>

<p>Port and Device keep track of the following states:</p>
<ul>
  <li>connection 
    <p>Is the port or device connected? This state is initialized to
    disconnected.</p>
  </li>
  <li>enabled 
    <p>Is the port or device enabled? This state is initialized to enabled.</p>
  </li>
  <li>autoConnect 
    <p>Does Port or Device call connect if it finds the port or device
    disconnected? This is initialized to the state specified in the call to
    createPort. If autoConnect is true then Port and Device automatically
    connect. This is done by periodically calling the portDriver.connect or
    deviceDriver.connect.</p>
  </li>
</ul>

<p>Whenever any of the states change for a port or device, then all users that
previously called exceptionCallbackAdd for that port or device are called.</p>

<p>Drivers must call exceptionConnect whenever they connect to a port or device
and exceptionDisconnect whenever they disconnect.</p>

<h4 id="L7175">Protecting a Thread from Blocking</h4>

<p>The report methods can be called by any thread, but the caller is blocked
until the report finishes. lockPort, connect, disconnect and some other Port
and Device methods can block. See the documentation for these interfaces for
details.</p>

<p>Unless stated otherwise the methods of all I/O interfaces could block and
must only be called by QueueRequestCallback.callback or by calls between
lockPort/unlockPort.</p>

<h4 id="L7181">portThread</h4>

<p>If a driver calls Factory.createPort with canBlock true, then portDriver
creates a thread for the port. Each portThread has its own set of queues for
the calls to queueRequest. Three queues are maintained which provide different
priorities: low, medium, and high. portThread runs forever implementing the
following algorithm:</p>
<ol>
  <li>Wait for for an event. Other code such as queueRequest signals the
  event.</li>
  <li>If the port is disabled, go back to 1.</li>
  <li>If the port is still not connected, go back to 1.</li>
  <li>For each element of the queues asynQueuePriorityHigh,
    ...,asynQueuePriorityLow. 
    <ul>
      <li>If disabled, skip this element.</li>
      <li>If not connected, skip this element.</li>
      <li>If blocked by another thread, skip this element.</li>
      <li>If not blocked and user has requested blocking, then blocked.</li>
      <li>Remove from queue and: 
        <ul>
          <li>lockPort</li>
          <li>call user callback</li>
          <li>unlockPort</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>The actual code is more complicated because it unlocks before it calls code
outside asynManager. This means that the queues can be modified and exceptions
may occur.</p>

<h4 id="L7226">Driver Can Also Be User</h4>

<p>A driver can also be the user of another driver. For example a multi-drop
serial driver can use a standard serial driver to perform the actual I/O. Such
a driver implements interface LockPortNotify which is called whenever a user
locks the multi-drop port. The driver can than call lock/unlock for the serial
port so that it has exclusive access to the serial port which the multi-drip
user has access.</p>

<h4 id="L7230">Initialization</h4>

<p>During initialization, drivers register each communication port as well as
all supported interfaces.</p>

<p>Support code creates a User, which is a "handle" for accessing portDriver
facilities, by calling</p>
<pre>    Factory.createUser(QueueRequestCallback);</pre>
An User has the following features: 
<ul>
  <li>An User is the means by which portDriver manages multiple requests for
    accessing a port.</li>
  <li>QueueRequestCallback, which is used by queueRequest described below, has
    a single method which is the callback that is called when a request is
    taken from a queue.</li>
  <li>Support code should create a User for each "atomic" access to a driver,
    i.e. a set of calls that must not be interlaced with other calls to the
    driver. For example support for javaIOC records creates a User for each
    record instance. instance.</li>
  <li>Support should NOT try to share a User between multiple sources of
    requests for access to a port. If this is done then support must itself
    handle contention issues that are already handled by portDriver.</li>
</ul>

<p>User code connects to a low level driver via a call to</p>
<pre>    Port port = user.connectPort(portName);
    Device device = user.connectDevice(deviceName);</pre>
This call must specify the name of the port and the name of the device It then
calls findInterface to locate the interfaces with which it calls the driver.
For example: 
<pre>     Octet octet = (Octet)device.findInterface(user,"octet",true);</pre>

<h4 id="L7261">Requesting access to a port</h4>

<p>User code can request access to a port by two methods:</p>
<ul>
  <li>user.queueRequest - 
    <p>The processCallback passed to createAsynUser makes calls to the port
    interfaces.</p>
  </li>
  <li>user.lockPort/user.unlockPort - 
    <p>The caller can make calls to the I/O and also to Port and Device
    interfaces while the lock is held. The I/O methods and some of the
    Port/Device methods may block and thus should NOT be used by code that
    should not block, e.g. synchronous device support for EPICS records.</p>
  </li>
</ul>

<h3 style="text-align: center" id="L7276">PortDriver Record Types</h3>

<h4 id="L7278">portCreate record</h4>

<p>A recordType and support portCreate is provided. An instance creates a port.
The recordType has the following fields:</p>
<dl>
  <dt style="font-family: courier;">factoryName</dt>
    <dd>The name of the Java Factory that can create the portDriver.</dd>
  <dt style="font-family: courier;">portName</dt>
    <dd>The port name.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>(false,true) if port (should not,should) auto connect. The default is
      true.</dd>
  <dt style="font-family: courier;">priority</dt>
    <dd>The priority. This field is a threadPriority structure.</dd>
  <dt style="font-family: courier;">driverParameters</dt>
    <dd>Driver specific parameters. This is a structure field. The default is a
      null structure but can be overridden for a port instance.</dd>
</dl>

<p>The following is an example port instance.</p>
<pre>&lt;record name = "syncInt32Port" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.testDriver.Int32DriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
    &lt;structure name = "driverParameters" type = "int32Driver" &gt;
        &lt;scalar name = "delay"&gt;0.0&lt;/scalar&gt;
        &lt;scalar name = "numberRegisters"&gt;2&lt;/scalar&gt;
        &lt;scalar name = "low"&gt;-2048&lt;/scalar&gt;
        &lt;scalar name = "high"&gt;2047&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h4 id="L7312">portDeviceControl record</h4>

<p>A recordType and support portDeviceControl is provided. It allows a user to
interact with a port or a device connected to a port. The record has the
following fields:</p>
<dl>
  <dt style="font-family: courier;">message</dt>
    <dd>This is string field that has the results of a report request and any
      error messages generated by other requests. A Channel Access client can
      set a monitor on this field to see all messages.</dd>
  <dt style="font-family: courier;">portDevice</dt>
    <dd>This specifies the port or port and device for all the other fields. It
      has the syntax "port[addr]". If [addr] is not specified than the other
      fields refer to the port itself. Each time the user writes to this field
      a connection is made to the port and optionally the device.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>This is a boolean field. Putting a value of (false,true) issues a
      (disconnect,connect) request to the port or device.</dd>
  <dt style="font-family: courier;">enable</dt>
    <dd>This is a boolean field. Putting a value of (false,true) issues a
      (disable,enable) request to the port or device.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>This is a boolean field. Putting a value sets the autoConnect
    state.</dd>
  <dt style="font-family: courier;">traceMask</dt>
    <dd>This is an integer field. Issuing a put sets the traceMask.</dd>
  <dt style="font-family: courier;">traceIOMask</dt>
    <dd>This is an integer field. Issuing a put sets the traceIOMask.</dd>
  <dt style="font-family: courier;">report</dt>
    <dd>This is an integer field. Issuing a put requests a report with the
      specified details. The report is placed in the message field.</dd>
</dl>

<h3 style="text-align: center" id="L7357">portDriver Factory</h3>

<p>This is the factory for creating portDriver objects.</p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver portDriver,String driverName,
            boolean canBlock,boolean autoConnect,ThreadPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
}</pre>

<h4 id="L7363">createUser</h4>
<pre>    User createUser(QueueRequestCallback asynQueueRequestCallback);</pre>

<p>Create a User. This is called by code that wants to access a port and/or the
devices connected to the port.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">asynQueueRequestCallback</dt>
    <dd>This is an interface implemented by the user. It is called when a
      queueRequest is dequeued. See Port for details. If the user does not want
      to call queueRequest a null is acceptable.</dd>
</dl>

<h4 id="L7377">createPort</h4>
<pre>    Port createPort(
            String portName,PortDriver portDriver,String driverName,
            boolean canBlock,boolean autoConnect,ThreadPriority priority);</pre>

<p>Create a port. This is called by a driver to register a new port. The Port
interface is created and returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port. If the port already exists an exception is
    thrown.</dd>
  <dt style="font-family: courier;">portDriver</dt>
    <dd>The interface for the port driver.</dd>
  <dt style="font-family: courier;">driverName</dt>
    <dd>The name of the driver.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Can the device block while performing I/O? If the answer is yes than a
      thread is created for the port and all queueRequest callbacks are called
      via this thread. If the answer is no than all queueRequests result in the
      port being locked and the queueRequest callback is called
    synchronously.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>An initial value for the autoConnect state for both the port and any
      devices connected to the port. Unless the driver has a good reason, this
      should be true. </dd>
  <dt style="font-family: courier;">priority</dt>
    <dd>The priority for the port thread if the port can block.</dd>
</dl>

<h4 id="L7416">getPortNames</h4>
<pre>    String[] getPortNames();</pre>

<p>Get an array containing the name of each port. </p>

<h4 id="L7422">getPort</h4>
<pre>    Port getPort(String portName);</pre>

<p>Get the Port for the specified portName. If the port does not exist null is
returned.</p>

<p>The arguments are: </p>
<dl>
  <dt style="font-family: courier;">portName</dt>
    <dd>The name of the port.</dd>
</dl>

<h3 style="text-align: center" id="L7436">User</h3>

<p>User is the interface for accessing a port and/or device. It is created by
Factory and used by client code. </p>
<pre>public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(String deviceName);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setBoolean(boolean value);
    boolean getBoolean();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}</pre>

<h4 id="L7442">Status</h4>

<p>Many methods return a status which is defined by the following:</p>
<pre>public enum Status {
    success,
    timeout,
    overflow,
    error
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">success</dt>
    <dd>The request was satisfied.</dd>
  <dt style="font-family: courier;">timeout</dt>
    <dd>An I/O operation failed because of a timeout. An code returning this
      status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">overflow</dt>
    <dd>An request failed because of an overflow problem. An code returning
      this status must also call user.setMessage.</dd>
  <dt style="font-family: courier;">error</dt>
    <dd>An request failed. An code returning this status must also call
      user.setMessage.</dd>
</dl>

<h4 id="L7471">REASON</h4>

<p>setReason,getReason described below have an integer argument. The following
are some generic reasons:</p>
<pre>    public static final int REASON_SIGNAL = -1;</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">REASON_SIGNAL</dt>
    <dd>A signal occured.</dd>
</dl>

<h4 id="L7485">duplicateUser</h4>

<p>Create a new User that is connected to the same port and device. The new
user will also have the same reason and timeout as the orginal. </p>
<pre>    User duplicateUser(QueueRequestCallback queueRequestCallback);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>An existing user.</dd>
  <dt style="font-family: courier;">queueRequestCallback</dt>
    <dd>The callback for queueRequest. if queueRequest is never called this can
      be null.</dd>
</dl>

<h4 id="L7504">User Queue Request</h4>

<p>Any user that wants to make asynchronous I/O requests but does not want to
block while making the request can call queueRequest. An example is link
support for javaIOC records. Such support must not block or it will block the
record instance itself.</p>

<p>If queueRequest is called for a port that can block than the request is
queued. The port has an associated thread. When the request is taken from the
queue, the port is locked and the requestors callback is called. If
queueRequest is called for a port that can not block then the port is locked
and the requestors callback is called synchronously.</p>

<p>The port thread keeps three FIFO queues with the following priorities:</p>
<pre>public enum QueuePriority {
    low,
    medium, 
    high
}</pre>

<p>The requestor must implement the following interface:</p>
<pre>public interface QueueRequestCallback {
    void callback(Status status,User user);
}</pre>

<p>This interface is passed to Factory.createUser. The arguments to callback
are:</p>
<dl>
  <dt style="font-family: courier;">status</dt>
    <dd>Unless this is Status.success than the request has failed. The user
      must not call any I/O interfaces. user.getMessage can be called to find
      why the request failed. user.getAlarmStratus and user.getAlarmMessage can
      get an alarm status and message.</dd>
  <dt style="font-family: courier;">user</dt>
    <dd>This is passed back to the user so that code can implement a single
      callback that handles multiple users.</dd>
</dl>

<p>If the callback is called with status success than it can make multiple
calls to the device I/O interfaces.</p>

<p>A queueRequest is made via a call to</p>
<pre>    void queueRequest(QueuePriority queuePriority);</pre>

<p>At any time a user can call</p>
<pre>    void cancelRequest();</pre>

<p>If a request is queued it is removed from the queue. If no request is queued
than nothing happens. Note that it is possible for the callback to be called
between the time when cancel is called and when it returns.</p>

<h4 id="L7543">User lock/unlock Port.</h4>

<p>If a user is willing to block during asynchronous port I/O requests then it
can just call lockPort/unlockPort. </p>
<pre>    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();</pre>

<p>Code that uses lockPort should follow the pattern:</p>
<pre>     user.lockPort();
     try {
         // whatever
     } finally {
         user.unlockPort();
     }</pre>

<p>The other lock methods are for calling port.connect and device.connect.</p>

<h4 id="L7555">User connection to a port</h4>
<pre>    Port connectPort(String portName);
    void disconnectPort();</pre>

<p>connectPort connects the user to a port and disconnect disconnects. If the
port does not exist connectPort returns null. If the user is also connected to
a device then disconnectPort calls disconnectDevice. Note that these methods
only connects/disconnects the user to/from the port. Thus it does not effect
the connect/disconnect state of the port itself.</p>

<h4 id="L7561">getPort</h4>
<pre>    Port getPort();</pre>

<p>Get the port to which this user is connected. This can be null.</p>

<h4 id="L7567">User connection to a device</h4>
<pre>    Device connectDevice(String deviceName);
    void disconnectDevice();</pre>
The user must be connected to a port before connecting to a device. If the
device does not exist connectDevice returns null. 

<p>connectDevice connects the user to a device and disconnect disconnects. Note
that these methods only connects/disconnects the user to/from the device. Thus
it does not effect the connect/disconnect state of the device itself.</p>

<h4 id="L7575">getDevice</h4>
<pre>    Device getDevice();</pre>

<p>Get the device to which this user is connected. This can be null.</p>

<h4 id="L7581">User Messages</h4>
<pre>    void setMessage(String message);
    String getMessage();</pre>

<p>Methods that return a Status that does not have the value Status.success
must also call user.setMessage to explain why the method failed. The user can
then call getMessage to find the reason.</p>

<h4 id="L7587">I/O Timeouts</h4>
<pre>    void setTimeout(double timeout);
    double getTimeout();</pre>

<p>Asynchronous I/O operations can block forever. For example a serial line
could break. Each user that makes asynchronous request must call setTimeout. A
timeout value of &lt;= 0.0 means infinity. A portDriver or deviceDriver calls
getTimeout to get the timeout. It is the timeout for an individual I/O request.
For example for a serial driver it could mean the time to read/write a single
byte.</p>

<h4 id="L7593">Driver Private</h4>
<pre>    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();</pre>

<p>These are methods for the port or device driver. Some drivers may have to
keep data for each user. If a driver does than it must implement interface
<span style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces.DriverUser</span> and the user must find
and use it. It has the methods:</p>
<pre>    void create(User user,PVStructure drvParams);
    void dispose(User user);</pre>

<p>After the user connects to a port or device that implement DriverUser it
must call driverUser.create and when it disconnects it must call
driverUser.dispose. DriverUser.create can allocate data for the user and call
setPortDriverPvt or setDeviceDriverPvt. When the user calls a driver method the
driver can call getPortDriver or getDeviceDriver to get the private data for
the user. DriverUser.dispose should remove all provate state and data fot the
user.</p>

<h4 id="L7606">User Private</h4>
<pre>    void setUserPvt(Object userPvt);
    Object getUserPvt();</pre>

<p>These are for private use by the user.</p>

<h4 id="L7612">Passing Information Between User and Driver</h4>

<p>The set/get methods are for passing data between a user and a driver.
Normally it is the driver that calls a set method and the user that calls a get
method but the reverse is also possible. Both user and driver must understand
when the methods are used. The interfaces defined in <span
style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces</span> make use of these methods. For
example the octet interface use setInt to tell the user how many elements were
transfered.</p>

<h3 style="text-align: center" id="L7619">Connect Exception</h3>

<p>Both Port and Device provide a methods exceptionListenerAdd and
exceptionListenerRemove. The listener is called whenever the connection state
of a device changes. i.e. the connect state itself, the enable state, or the
autoConnect state.</p>

<p>The type of exception is defined by: </p>
<pre>public enum ConnectExceptionType {
    connect,
    enable,
    autoConnect
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">connect</dt>
    <dd>The port or device has connected or disconnected. The listener can call
      isConnected to determine the state.</dd>
  <dt style="font-family: courier;">enable</dt>
    <dd>The enable state has changed. The listener can call isEnabled to
      determine the state.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>The autoConnect state has changed. The listener can call isAutoConnect
      to determine the state.</dd>
</dl>

<p>The listener must implement the interface:</p>
<pre>public interface ConnectExceptionListener {
    void exception(ConnectExceptionType connectException);
}</pre>

<h3 style="text-align: center" id="L7649">Port</h3>

<p>A port manages user access to the I/O. All methods except connecy/disconnect
can be called without locking the port.</p>

<p>The complete set of definitions for Port are:</p>
<pre>public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    void scanQueues();
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, int addr);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h4 id="L7657">User Locate Device</h4>

<p>After a user has connected to a port via a call to user.connectPort it can
connect to a device by calling port.getDevice.</p>
<pre>    Device getDevice(User user, int addr);</pre>

<h4 id="L7663">User Connection Methods</h4>

<p>Most users do not ask the port to connect or disconnect but a specialized
client may. For example javaIOC link support is provided for connect/disconnect
requests. This allows a port to be connected or disconnected via a Channel
Access client. A client must either cann queueRequest or call
lockPort/unlockPort to call these methods.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h4 id="L7669">Informational Methods</h4>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Interface[] getInterfaces();
    String getDriverName();
    String getPortName();
    boolean canBlock();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the port and if specified all devices
      connected to the port. This method blocks. It does not lock so report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getDevices</dt>
    <dd>Get an array of the devices connected to the port.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the portDriver. Note that
      most drivers do not implement port interfaces but only device
    interfaces.</dd>
  <dt style="font-family: courier;">getDriverName</dt>
    <dd>Get the driver name.</dd>
  <dt style="font-family: courier;">getPortName</dt>
    <dd>Get the port name.</dd>
  <dt style="font-family: courier;">canBlock</dt>
    <dd>Is it possible for the driver to block while doing I/O?</dd>
</dl>

<h4 id="L7708">Connection Methods</h4>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the port. If the port is disabled then no
      queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the port is not
      connected when the first lockPort request is made than a connect request
      will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the port is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h4 id="L7752">Driver Methods</h4>

<p>These are methods called by a driver.</p>
<pre>    Device createDevice(DeviceDriver deviceDriver, int addr);
    void exceptionConnect();
    void exceptionDisconnect(); 
    Trace getTrace();
    void scanQueues();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>The driver calls this as a result of a call to port.createDevice, that
      is port.createDevice must itself call portDriver.createDevice.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
  <dt style="font-family: courier;">scanQueues</dt>
    <dd>Not normally called by drivers</dd>
</dl>

<h4 id="L7786">LockPortNotify</h4>

<p>A driver can be the user of another driver. For example a multidrop the
serial driver can use a serial port driver to do the actual I/O and just add
the multidrop protocal. In order to work properly the multidrop driver must
ensure that it has exclusive access to the serial driver whenever a user has
access to the multidrop driver. This it needs to know when a user has
successfully called lockPort. The driver that wants to be the user of another
driver must implement the following:</p>
<pre>public interface LockPortNotify {
    void lock(User user);
    void unlock();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">lock</dt>
    <dd>This is called each time a user obtains control of the port by
      successfully calling lockPort. The driver can call lockPort for the port
      it is using.</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>This is called each time a user call unlockPort. The driver can call
      unlockPort for the driver it is using.</dd>
</dl>

<p>The port methods are :</p>
<pre>void registerLockPortNotify(LockPortNotify lockPortNotify);
void unregisterLockPortNotify(); </pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerLockPortNotify</dt>
    <dd>Register to be notified of successful lockPort/unlockPort requests.
    </dd>
  <dt style="font-family: courier;">unregisterLockPortNotify</dt>
    <dd>Unregister the caller.</dd>
</dl>

<h3 style="text-align: center" id="L7822">Device</h3>

<p>A device provides methods related to a device. The complete set of
definitions for Device are:</p>
<pre>public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName();
    String getFullName(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    Interface findInterface(User user,String interfaceName);
    Status lockPort(User user);
    Status connect(User user);
    Status disconnect(User user);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}</pre>

<h4 id="L7828">User findInterface</h4>

<p>This is used by a user to locate an interface for the device. If the driver
does not implement the requested interface null is returned.</p>
<pre>    Interface findInterface(User user,
        String interfaceName);</pre>

<p>where the arguments are:</p>
<dl>
  <dt style="font-family: courier;">user</dt>
    <dd>The user.</dd>
  <dt style="font-family: courier;">interfaceName</dt>
    <dd>The name of the interface.</dd>
</dl>

<h4 id="L7847">User Connection Methods</h4>

<p>Most users do not handle the device connecting or disconnecting but a
specialized client may. For example javaIOC link support is provided for
connect/disconnect requests. This allows a device to be connected or
disconnected via a Channel Access client.</p>
<pre>    Status connect(User user);
    Status disconnect(User user);</pre>

<h4 id="L7853">User Blocking</h4>

<p>A user can block other users from accessing a device. This only works for
asynchronous drivers.</p>
<pre>Status blockOtherUsers(User user);
void unblockOtherUsers(User user);</pre>

<h4 id="L7859">Informational Methods</h4>

<p>The following can be used by any code that is interested.</p>
<pre>    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName(); 
    Port getPort();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generates a report about the device. It does not lock so some report
      information may be inconsistant.</dd>
  <dt style="font-family: courier;">getInterfaces</dt>
    <dd>Get an array of the interfaces implemented by the deviceDriver.</dd>
  <dt style="font-family: courier;">getDeviceName</dt>
    <dd>Get the name of this device.</dd>
  <dt style="font-family: courier;">getFullName</dt>
    <dd>Get the full name, which has the form portName[deviceName].</dd>
  <dt style="font-family: courier;">getPort</dt>
    <dd>Get the port to which this device is connected.</dd>
</dl>

<h4 id="L7893">Connection Methods</h4>

<p>The following can be used by any code that is interested.</p>
<pre>    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    boolean isBlockedByOtherUser(User user);
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">enable</dt>
    <dd>Set the enable state for the device. If the device is disabled then no
      queueRequests will be dequeued and lockPort will return error.</dd>
  <dt style="font-family: courier;">autoConnect</dt>
    <dd>Set the autoConnect state. If this is true than if the device is not
      connected when the first lockPort request is made than a connect request
      will be made.</dd>
  <dt style="font-family: courier;">isConnected</dt>
    <dd>returns (false,true) if the device is (not connected,connected)</dd>
  <dt style="font-family: courier;">isEnabled</dt>
    <dd>returns (false,true) if the enable state is (not enabled,enabled)</dd>
  <dt style="font-family: courier;">isAutoConnect</dt>
    <dd>returns (false,true) if the AutoConnect state is (not
      AutoConnect,AutoConnect)</dd>
  <dt style="font-family: courier;">isBlockedByOtherUser</dt>
    <dd>Is the device blocked by another user.</dd>
  <dt style="font-family: courier;">exceptionListenerAdd</dt>
    <dd>Add a listener that is called whenever the connect, enable, or
      autoConnect state changes.</dd>
  <dt style="font-family: courier;">exceptionListenerRemove</dt>
    <dd>Remove the listener.</dd>
</dl>

<h4 id="L7942">Driver Methods</h4>

<p>These are methods called by a driver.</p>
<pre>    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
    Trace getTrace();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">registerInterface</dt>
    <dd>A portDriver must call this for each interface it implements.</dd>
  <dt style="font-family: courier;">exceptionConnect</dt>
    <dd>When a port connects it must calls this.</dd>
  <dt style="font-family: courier;">exceptionDisconnect</dt>
    <dd>When a port disconnects it must calls this.</dd>
  <dt style="font-family: courier;">getTrace</dt>
    <dd>Get the trace interface for the port.</dd>
</dl>

<h3 style="text-align: center" id="L7971">Trace</h3>

<p>Both Port and Device provide access to a Trace facility, which allows
diagnostic messages to be generated on a port or device basis. Both support,
e.g. javaIOC record support, and drivers are expected to support the trace
facility.</p>

<p>The Java definitions for Trace are:</p>
<pre>public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    Status optionChangeListenerRemove(User user);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}

public class TraceFactory {
    public static Trace create() {
        return new TraceImpl();
    }
}</pre>

<p>TraceFactory is a factory that implements Trace. It can be used independent
of portDriver.</p>

<h4 id="L7981">Trace Mask Options</h4>

<p>The trace mask specifies when to generate messages. </p>
<pre>    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    void setMask(int mask);
    int getMask();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">ERROR</dt>
    <dd>Generate a message whenever an error is detected. This is the only bit
      of the mask that is set by default.</dd>
  <dt style="font-family: courier;">SUPPORT</dt>
    <dd>Support level code should generate a message whenever it calls any
      interface method.</dd>
  <dt style="font-family: courier;">DRIVER</dt>
    <dd>A driver should generate a message whenever any of it's methods are
      called.</dd>
  <dt style="font-family: courier;">FLOW</dt>
    <dd>Port or Device should generate a message whenever it performs some
      action. For example when a request is queued and when it is taken from a
      queue.</dd>
  <dt style="font-family: courier;">setMask</dt>
    <dd>Set the mask to some combination of the maks values. For example: 
      <pre>    device.setMask(ERROR|SUPPORT|DRIVER);</pre>
      will cause message to be generated whenever an error detected, when
      support level code calls an interface method, and when a device driver
      method is called.</dd>
  <dt style="font-family: courier;">getMask</dt>
    <dd>Get the current value of the mask.</dd>
</dl>

<h4 id="L8024">TraceIO Options</h4>

<p>The traceIO mask specifies what to generate for octet data values.</p>
<pre>    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setIOMask(int mask);
    int getIOMask();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">IO_NODATA</dt>
    <dd>Don't print any data.</dd>
  <dt style="font-family: courier;">IO_ASCII</dt>
    <dd>Print with a "%s" style format.</dd>
  <dt style="font-family: courier;">IO_ESCAPE</dt>
    <dd>Print with a "%s" style format but show control characters as escape
      sequences. For example a carriage return is printed as "\r".</dd>
  <dt style="font-family: courier;">IO_HEX</dt>
    <dd>Print each byte with " %2.2x".</dd>
  <dt style="font-family: courier;">setIOMask</dt>
    <dd>Set the IOMask to saome combination of the above. Note that IO_NODATA
      should not be specified with any other bits since it has no meaning.</dd>
  <dt style="font-family: courier;">getIOMask</dt>
    <dd>Get the current IOMask.</dd>
  <dt style="font-family: courier;">setIOTruncateSize</dt>
    <dd>Set the truncation size for data output. For printIO it means the
      number of bytes to print. For array data it means the number of elements
      to display.</dd>
  <dt style="font-family: courier;">getIOTruncateSize</dt>
    <dd>Get the current truncation size.</dd>
</dl>

<h4 id="L8073">Trace File</h4>

<p>The destination for trace messages.</p>
<pre>    void setFile(Writer file);
    Writer getFile();</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">setFile</dt>
    <dd>Set the destination for trace messages. The default is a buffered
      writer to standard out.</dd>
  <dt style="font-family: courier;">getFile</dt>
    <dd>Get the current destination for trace messages,</dd>
</dl>

<h4 id="L8092">Trace Option Change Listener</h4>

<p>Code that wants to listen for option change must implement the following:</p>
<pre>public interface TraceOptionChangeListener {
    void optionChange(); 
}</pre>

<p>The Trace methods for a listener are:</p>
<pre>    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    Status optionChangeListenerRemove(User user);</pre>

<h4 id="L8102">Generating Trace Messages</h4>

<p><span style="font-family: courier;">print</span> is called to generate
messages and <span style="font-family: courier;">printIO</span> to generate
messages and also the value of octet data.</p>
<pre>    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">print</dt>
    <dd>Generate a trace message. <span
      style="font-family: courier;">reason</span> is one of the trace mask
    bits.</dd>
  <dt style="font-family: courier;">printIO</dt>
    <dd>Does the same as print an then prints the buffer data using the traceIO
      features.</dd>
</dl>

<h3 style="text-align: center" id="L8129">Driver</h3>

<h4 id="L8131">PortDriver</h4>

<p>Every driver must implement the following methods:</p>
<pre>public interface PortDriver {
    String report(int details);
    Device createDevice(User user, int addr);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the port.</dd>
  <dt style="font-family: courier;">createDevice</dt>
    <dd>Create a device for the given address. The driver must implemnent
      interface DeviceDriver, call port.createDevice, and return the device it
      creates. If it can't create a device at the specified address, it should
      call user.setMessage and return null.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual port. If successful it must call
      port.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the port. If successfull call
      port.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>

<h4 id="L8160">DeviceDriver</h4>

<p>The driver implements the following for each device it acesses.</p>
<pre>public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">report</dt>
    <dd>Generate a report about the device.</dd>
  <dt style="font-family: courier;">connect</dt>
    <dd>Connect to the actual device. If successful it must call
      device.exceptionConnect(). It it fails it should return error.</dd>
  <dt style="font-family: courier;">disconnect</dt>
    <dd>Disconnect from the device. If successfull call
      device.exceptionDisconnect(). It it fails it should return error.</dd>
</dl>

<h3 style="text-align: center" id="L8184">Appendix: Java Definitions</h3>

<p>The following is a complete list of all the Java definitions for <span
style="font-family: courier;">package org.epics.ioc.portDriver. </span></p>

<p>The I/O interfaces implemented by drivers (port or device) are defined in
package <span style="font-family: courier;">package
org.epics.ioc.portDriver.interfaces</span></p>
<pre>public class Factory {
    public static User createUser(QueueRequestCallback asynQueueRequestCallback);
    public static Port createPort(
            String portName,PortDriver portDriver,
            String driverName,boolean canBlock,
            boolean autoConnect,ThreadPriority priority);
    public static String[] getPortNames();
    public static Port getPort(String portName);
}

public enum Status {
    success,
    timeout,
    overflow,
    error
}

public interface User {
    public static final int REASON_SIGNAL = -1;
    User duplicateUser(QueueRequestCallback queueRequestCallback);
    Port connectPort(String portName);
    void disconnectPort();
    Port getPort();
    Device connectDevice(String deviceName);
    void disconnectDevice();
    Device getDevice();
    void queueRequest(QueuePriority queuePriority);
    void cancelRequest();
    Status lockPort();
    Status lockPortForConnect();
    Status lockDeviceForConnect();
    void unlockPort();
    void setMessage(String message);
    String getMessage();
    void setTimeout(double timeout);
    double getTimeout();
    void setPortDriverPvt(Object portDriverPvt);
    Object getPortDriverPvt();
    void setDeviceDriverPvt(Object deviceDriverPvt);
    Object getDeviceDriverPvt();
    void setUserPvt(Object userPvt);
    Object getUserPvt();
    void setReason(int reason);
    int getReason();
    void setAuxStatus(int auxStatus);
    int getAuxStatus();
    void setBoolean(boolean value);
    boolean getBoolean();
    void setInt(int value);
    int getInt();
    void setDouble(double value);
    double getDouble();
    void setString(String value);
    String getString();
}

public enum ConnectException {
    connect,
    enable,
    autoConnect
}

public interface ConnectExceptionListener {
    void exception(ConnectException connectException);
}

public enum QueuePriority {
    low,
    medium, 
    high
}

public interface QueueRequestCallback {
    void callback(Status status,User user);
}

public interface LockPortNotify {
    void lock(User user);
    void unlock();
}

public interface Port {
    String report(boolean reportDevices,int details);
    Device[] getDevices();
    Trace getTrace();
    String getDriverName();
    String getPortName();
    boolean canBlock();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    Device getDevice(User user, String deviceName);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    void scanQueues();
    Status connect(User user);
    Status disconnect(User user);
    void registerLockPortNotify(LockPortNotify lockPortNotify);
    void unregisterLockPortNotify();
    Device createDevice(DeviceDriver deviceDriver, String deviceName);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface Device { 
    String report(int details);
    Interface[] getInterfaces();
    String getDeviceName(); 
    Port getPort();
    Trace getTrace();
    void enable(boolean trueFalse);
    void autoConnect(boolean trueFalse);
    boolean isConnected();
    boolean isEnabled();
    boolean isAutoConnect();
    Status exceptionListenerAdd(User user,ConnectExceptionListener connectExceptionListener);
    Status exceptionListenerRemove(User user);
    Interface findInterface(User user,String interfaceName);
    Status connect(User user);
    Status disconnect(User user);
    Status blockOtherUsers(User user);
    void unblockOtherUsers(User user);
    boolean isBlockedByOtherUser(User user);
    void registerInterface(Interface iface);
    void exceptionConnect();
    void exceptionDisconnect();
}

public interface TraceOptionChangeListener {
    void optionChange(); 
}

public interface Trace {
    public static final int ERROR = 0x0001;
    public static final int SUPPORT = 0x0002;
    public static final int DRIVER = 0x0008;
    public static final int FLOW = 0x0010;
    public static final int IO_NODATA = 0x0000;
    public static final int IO_ASCII = 0x0001;
    public static final int IO_ESCAPE = 0x0002;
    public static final int IO_HEX = 0x0004;
    void setMask(int mask);
    int getMask();
    void setIOMask(int mask);
    int getIOMask();
    void setFile(Writer file);
    Writer getFile();
    void setIOTruncateSize(int size);
    int getIOTruncateSize();
    Status optionChangeListenerAdd(User user,
         TraceOptionChangeListener traceOptionChangeListener);
    void optionChangeListenerRemove(User user);
    void print(int reason,String message);
    void print(int reason,String format, Object... args);
    void printIO(int reason, byte[] buffer,long len,String message);
    void printIO(int reason, byte[] buffer,long len,String format,Object... args);
}

public interface DeviceDriver {
    String report(int details);
    Status connect(User user);
    Status disconnect(User user);
}

public interface PortDriver {
    String report(int details);
    Device createDevice(User user,String deviceName);
    Status connect(User user);
    Status disconnect(User user);
}</pre>

<h3 id="L8196">Package org.epics.ioc.support.interfaces</h3>

<h4 style="text-align: center" id="L8198">Overview</h4>

<p>This package contains portDriver interfaces for communication with a port or
device. A driver implements one or more of these interfaces and a user calls
interface methods to communicate with a device..</p>

<p>For each interface, this package defines four components:</p>
<ol>
  <li>The interface itself.</li>
  <li>An interrupt listener interface<br />
    This is the interface implemented by a user that registers itself as an
    interrupt listener.</li>
  <li>An abstract base class that implements the interface.<br />
    This is used by drivers that implement the interface. The base class
    handles the interrupt listeners. It also provides a method
    interruptOccurred, which is called by the driver when an interrupt event
    occurs.</li>
</ol>

<p>This package overview has the following sections:</p>
<ul>
  <li>miscellaneous<br />
    Discusses some interfaces used by the other interfaces.</li>
  <li>serial<br />
    An interface for serial communication.</li>
  <li>uint32Digital<br />
    An interface for a Digital I/O register.</li>
  <li>int32<br />
    An interface for an integer register. For example ADC devices implement
    this interface.</li>
  <li>int32Array<br />
    An interface for an array of 32 bit integers.</li>
  <li>float64<br />
    An interface for double value.</li>
  <li>float64Array<br />
    An interface for an array of doubles.</li>
  <li>gpibController<br />
    An interface for a GPIB controller.</li>
  <li>gpibDevice<br />
    An interface for a GPIB device.</li>
</ul>

<h4 style="text-align: center" id="L8277">miscellaneous</h4>

<h5 id="L8279">Interface</h5>

<p><span style="font-family: courier;">Interface</span> is the base interface
for all portDriver interfaces.</p>
<pre>public interface Interface {
    String getInterfaceName();
    Device getDevice();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Returns the name of the interface.</dd>
  <dt style="font-family: courier;">getDevice</dt>
    <dd>Returns the Device the interface supports.</dd>
</dl>

<h5 id="L8300">Option</h5>

<p><span style="font-family: courier;">Option</span> is for drivers that accept
run time options.</p>
<pre>public interface Option extends Interface{
    Status setOption(User user,String key, String value);
    String getOption(User user,String key);
}</pre>

<p>It extends <span style="font-family: courier;">Interface</span> to include
the methods:</p>
<dl>
  <dt style="font-family: courier;">setOption</dt>
    <dd>Set an option. Each option is identified by a key and has an associated
      value.</dd>
  <dt style="font-family: courier;">getOption</dt>
    <dd>Get the option for the specified key.</dd>
</dl>

<h5 id="L8324">DriverUser</h5>

<p><span style="font-family: courier;">DriverUser</span> is an interface for
drivers that require per-user information. A user calls create when it connects
to the port or device and calls dispose when the user disconnects. The driver
can keep private data for each user.</p>
<pre>public interface DriverUser {
    void create(User user,PVStructure drvParams));
    void dispose(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">create</dt>
    <dd>Called by a user when it connects to a port or device.</dd>
  <dt style="font-family: courier;">dispose</dt>
    <dd>Called by a user when it disconnects from a port or device.</dd>
</dl>

<h5 id="L8345">AbstractInterface</h5>

<p>An abstract class for drivers that implement interfaces.</p>
<pre>public abstract class AbstractInterface implements Interface {
    protected Device device;
    protected String interfaceName;
    protected Trace trace;
    protected AbstractInterface(Device device,String interfaceName);
    protected void print(int reason,String message);
    protected void print(int reason,String format, Object... args);
    public Device getDevice();
    public String getInterfaceName();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">device</dt>
    <dd>The device which the interface supports.</dd>
  <dt style="font-family: courier;">interfaceName</dt>
    <dd>The name of the interface.</dd>
  <dt style="font-family: courier;">trace</dt>
    <dd>The trace interface.</dd>
  <dt style="font-family: courier;">AbstractInterface</dt>
    <dd>The constructor.</dd>
  <dt style="font-family: courier;">print</dt>
    <dd>The print method for the interface.</dd>
  <dt style="font-family: courier;">print</dt>
    <dd>The print to print the array.</dd>
  <dt style="font-family: courier;">getDevice</dt>
    <dd>Get the device interfacd.</dd>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Get the interface name.</dd>
</dl>

<h4 style="text-align: center" id="L8394">serial</h4>

<p>This is the interface for serial communication. It supports I/O of 8 bit
bytes and also has support for control characters that terminate serial
messages.</p>

<h5 id="L8398">SerialInterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface SerialInterruptListener {
    void interrupt(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new message is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L8412">Serial</h5>

<p>The interface methods are:</p>
<pre>public interface Serial extends Interface {
    public static final int EOM_CNT = 0x0001;
    public static final int EOM_EOS = 0x0002; 
    public static final int EOM_END = 0x0004; 
    Status write(User user,byte[] data,int nbytes);
    Status read(User user,byte[] data,int nbytes);
    Status flush(User user);
    Status setInputEos(User user,byte[] eos,int eosLen);
    Status getInputEos(User user,byte[] eos);
    Status setOutputEos(User user,byte[] eos,int eosLen);
    Status getOutputEos(User user,byte[] eos);
    Status addInterruptUser(User user,
        SerialInterruptListener serialInterruptListener);
    Status removeInterruptUser(User user,
        SerialInterruptListener serialInterruptListener);
    void interruptOccurred(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">EOM_CNT</dt>
    <dd>auxStatus that means the read/write terminated because the the number
      of bytes requested was transfered.</dd>
  <dt style="font-family: courier;">EOM_EOS</dt>
    <dd>auxStatus that means the read/write terminated with the EOS (End Of
      String).</dd>
  <dt style="font-family: courier;">EOM_END</dt>
    <dd>auxStatus that means the read/write terminated because the the end of a
      message Occurred.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. If
      setOutputEos has provided end of string characters they are written after
      the requested bytes are written. A driver should normally call
      interruptOccurred after writing a value. On a successful operation
      user.setInt is called to provide the number of bytes transfered and
      setAuxStatus gives the reason why the transfer terminated. The call to
      setInt does NOT include any eos characters. If Status.overflow is
      returned than auxStatus provides the number of bytes not transfered. </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver. If
      setInputEos has provided an end of string sequence then the EOS
      terminates the input if it is detected. On a successful operation
      user.setInt is called to provide the number of bytes transfered and
      setAuxStatus gives the reason why the transfer terminated. The call to
      setInt does NOT include the eos characters. If Status.overflow is
      returned than auxStatus provides the number of bytes not transfered. </dd>
  <dt style="font-family: courier;">flush</dt>
    <dd>Flush any characters residing in the input buffer.</dd>
  <dt style="font-family: courier;">setInputEos</dt>
    <dd>Provide end of string sequence for read requests.</dd>
  <dt style="font-family: courier;">getInputEos</dt>
    <dd>Get the input end of string sequence.</dd>
  <dt style="font-family: courier;">setOutputEos</dt>
    <dd>Provide end of string sequence for write requests.</dd>
  <dt style="font-family: courier;">getOutputEos</dt>
    <dd>Get the output end of string sequence.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
</dl>

<h5 id="L8481">AbstractSerial</h5>
<pre>public abstract class AbstractSerial
extends AbstractInterface
implements Serial
{
    protected AbstractSerial(Device device);
    protected void interruptOccurred(byte[] data,int nbytes);
    public Status addInterruptUser(User user,
            SerialInterruptListener serialInterruptListener);
    public Status removeInterruptUser(User user,
            SerialInterruptListener serialInterruptListener);
    public abstract Status write(User user,byte[] data,int nbytes);
    public abstract Status read(User user,byte[] data,int nbytes);
    public abstract Status flush(User user) ;
    public Status setInputEos(User user,byte[] eos,int eosLen);
    public Status getInputEos(User user,byte[] eos);
    public Status setOutputEos(User user,byte[] eos,int eosLen);
    public Status getOutputEos(User user,byte[] eos);
    public void interruptOccurred(byte[] data,int nbytes);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractSerial</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">setInputEos</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getInputEos</dt>
    <dd>Returns Status.success and auxStatus = 0.</dd>
  <dt style="font-family: courier;">setOutputEos</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getOutputEos</dt>
    <dd>Returns Status.success an auxStatus = 0.</dd>
</dl>

<h4 style="text-align: center" id="L8528">uint32Digital</h4>

<h5 id="L8530">DigitalInterruptReason</h5>

<p>The reason why an interrupt Occurred.</p>
<pre>public enum DigitalInterruptReason {
    zeroToOne,
    oneToZero,
    transition
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">zeroToOne</dt>
    <dd>A zero to one transition Occurred. This is used for devices that can
      detect such a transition.</dd>
  <dt style="font-family: courier;">oneToZero</dt>
    <dd>A one to zero transition Occurred. This is used for devices that can
      detect such a transition.</dd>
  <dt style="font-family: courier;">transition</dt>
    <dd>One or more mask bits have changed.</dd>
</dl>

<h5 id="L8554">UInt32DigitalInterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface UInt32DigitalInterruptListener {
    void interrupt(int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L8568">UInt32Digital</h5>

<p>The interface methods are:</p>
<pre>public interface UInt32Digital extends Interface{
    String[] getChoices(User user);
    Status write(User user, int value, int mask);
    Status read(User user, int mask);
    Status setInterrupt(User user, int mask, DigitalInterruptReason reason);
    Status getInterrupt(User user, int mask, DigitalInterruptReason reason);
    Status clearInterrupt(User user,int mask);
    Status addInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    Status removeInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    void interruptOccurred(int data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>Get choices.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. The mask
      bits specify the bits to change. All other bits must not be modified.</dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver. Only
      bits from mask are set. All other bits must be set to 0 .</dd>
  <dt style="font-family: courier;">setInterrupt</dt>
    <dd>Allow interrupts for the specified bits. The reason states the
      condition under which an interrupt is raised,</dd>
  <dt style="font-family: courier;">getInterrupt</dt>
    <dd>Get which bits can cause an interrupt for thew specified reason.</dd>
  <dt style="font-family: courier;">clearInterrupt</dt>
    <dd>Disallow interrupts for the specified bits.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h5 id="L8622">AbstractUInt32Digital</h5>
<pre>public abstract class AbstractUInt32Digital
extends AbstractInterface
implements UInt32Digital
{
    protected AbstractUInt32Digital(Device device);
    public String[] getChoices(User user);
    protected void interruptOccurred(int data,DigitalInterruptReason reason);
    public Status setInterrupt(User user, DigitalInterruptReason reason);
    public Status addInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    public Status removeInterruptUser(User user,
        UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    public Status addInterruptUser(User user,
            UInt32DigitalInterruptListener uint32DigitalInterruptListener,int mask);
    public Status removeInterruptUser(User user,
            UInt32DigitalInterruptListener uint32DigitalInterruptListener);
    public Status setInterrupt(User user, int mask, DigitalInterruptReason reason);
    public Status getInterrupt(User user, int mask, DigitalInterruptReason reason);
    public Status clearInterrupt(User user,int mask);
    public void interruptOccurred(int data);
    abstract public Status read(User user, int mask);
    abstract public Status write(User user, int value, int mask);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractUInt32Digital</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getChoices</dt>
    <dd>Returns null. The derived class should implement this if it knows the
      choices.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">setInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">getInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">clearInterrupt</dt>
    <dd>returns Status.error with a not supported message.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Calls the registered listeners.</dd>
</dl>

<h4 style="text-align: center" id="L8674">int32</h4>

<p><span style="font-family: courier;">int32</span> is implemented by a driver
that supports a 32 bit integer. An example is a driver for an ADC (Analog to
Digital Converter). Unless it is more than a 32 bit ADC it can support this
interface by using the low order bits and sign extending the high order
bits..</p>

<h5 id="L8680">Int32InterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Int32InterruptListener {
    void interrupt(int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L8694">Int32</h5>

<p>The interface methods are:</p>
<pre>public interface Int32 extends Interface {
    Status write(User user, int value);
    Status read(User user);
    Status getBounds(User user, int[]bounds);
    Status addInterruptUser(User user,
               Int32InterruptListener int32InterruptListener);
    Status removeInterruptUser(User user,
               Int32InterruptListener int32InterruptListener);
    void interruptOccurred(int data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>This is implemented by a driver if it knows the bounds. For example a
      12 bit unipolor adc would set the bounds as: 
      <pre>    bounds[0] = 0; bounds[1] = 4095;</pre>
    </dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h5 id="L8735">AbstractInt32</h5>

<p>A driver implements int32 by extending the following abstract base class:</p>
<pre>public abstract class AbstractInt32
extends AbstractInterface
implements Int32
{
    protected AbstractInt32(Device device);
    protected void interruptOccurred(int data);
    public Status getBounds(User user, int[] bounds);
    public Status addInterruptUser(User user,
            Int32InterruptListener int32InterruptListener);
    public Status removeInterruptUser(User user,
            Int32InterruptListener int32InterruptListener);
    public Status getBounds(User user, int[] bounds);
    public abstract Status read(User user);
    public abstract Status write(User user, int value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractInt32</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>Calls user.setMessage and returns Status.error.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">getBounds</dt>
    <dd>Calls <span style="font-family: courier;">user.setMessage</span> and
      returns <span style="font-family: courier;">Status.error</span>.</dd>
</dl>

<h4 style="text-align: center" id="L8780">int32Array</h4>

<p><span style="font-family: courier;">int32Array</span> is implemented by a
driver that supports a array of 32 bit integers.</p>

<h5 id="L8786">Int32ArrayInterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Int32ArrayInterruptListener{
    void interrupt(Int32Array int32Array);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L8800">Int32Array</h5>

<p>The implementation must implement PVIntArray, which is used for all I/O. In
addition the following methods are implemented:</p>
<pre>public interface Int32Array extends Interface{
    PVIntArray getPVIntArray();
    Status startRead(User user);
    Status endRead(User user);
    Status startWrite(User user);
    Status endWrite(User user);
    Status addInterruptUser(User user,
        Int32ArrayInterruptListener int32ArrayListener);
    Status removeInterruptUser(User user,
        Int32ArrayInterruptListener int32ArrayListener);
    void interruptOccurred();
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVIntArray</dt>
    <dd>Get the data interface.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>This is called each time the user starts reading. The driver implements
      this method so that it can save a reference to the user while the user is
      performing I/O via the PVIntArray methods, which do not have a user
      argument.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>The user calls this when it is done using the PVIntArray methods. The
      driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>This is called each time the user starts writing. The driver implements
      this method so that it can save a reference to the user while the user is
      performing I/O via the PVIntArray methods, which do not have a user
      argument.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>The user calls this when it is done using the PVIntArray methods. The
      driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h5 id="L8849">AbstractInt32Array</h5>

<p>A driver implements int32Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractInt32Array
extends AbstractArrayInterface
implements Int32Array
{
    protected AbstractInt32Array(PVIntArray pvIntArray,Device device);
    public PVIntArray getPVIntArray();
    public void interruptOccurred();
    public Status addInterruptUser(User user,
            Int32ArrayInterruptListener int32ArrayInterruptListener);
    public Status removeInterruptUser(User user,
            Int32ArrayInterruptListener int32ArrayInterruptListener);
    public Status startRead(User user);
    public Status endRead(User user);
    public Status startWrite(User user);
    public Status endWrite(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractInt32Array</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>Returns Status.success.</dd>
</dl>

<h4 style="text-align: center" id="L8898">float64</h4>

<p><span style="font-family: courier;">float64</span> is implemented by drivers
that support a double value.</p>

<h5 id="L8904">Float64InterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Float64InterruptListener {
    void interrupt(double value);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L8918">Float64</h5>

<p>The interface methods are:</p>
<pre>public interface Float64 extends Interface {
    double[] getDisplayLimits(User user);
    String getUnits(User user);
    Status write(User user, double value);
    Status read(User user);
    Status addInterruptUser(User user,
        Float64InterruptListener float64InterruptListener);
    Status removeInterruptUser(User user,
        Float64InterruptListener float64InterruptListener);
    void interruptOccurred(double data);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getDisplayLimits</dt>
    <dd>Get display limits.</dd>
  <dt style="font-family: courier;">getUnits</dt>
    <dd>Get the units.</dd>
  <dt style="font-family: courier;">write</dt>
    <dd>Write a new value. This must be implemented by the driver. A driver
      should normally call interruptOccurred after writing a value. </dd>
  <dt style="font-family: courier;">read</dt>
    <dd>Read the current value. This must be implemented by the driver.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>An interrupt has occurred.</dd>
</dl>

<h5 id="L8962">AbstractFloat64</h5>

<p>A driver implements int32Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractFloat64
extends AbstractInterface
implements Float64
{
    protected AbstractFloat64(Device device);
    public double[] getDisplayLimits(User user);
    public String getUnits(User user);
    protected void interruptOccurred(double data);
    public Status addInterruptUser(User user,
            Float64InterruptListener float64InterruptListener);
    public Status removeInterruptUser(User user,
            Float64InterruptListener float64InterruptListener);
    public abstract Status read(User user);
    public abstract Status write(User user, double value) ;
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractFloat64</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">getDisplayLimits</dt>
    <dd>return null. Derived class should implement this if it knows
    limits.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
</dl>

<h4 style="text-align: center" id="L8996">float64Array</h4>

<p><span style="font-family: courier;">float64Array</span> is implemented by a
driver that supports a array of doubles.</p>

<h5 id="L9002">Float64ArrayInterruptListener</h5>

<p>The interface implemented by a user that calls addInterruptListener.</p>
<pre>public interface Float64ArrayInterruptListener{
    void interrupt(Float64Array float64Array);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">interrupt</dt>
    <dd>The new value is provided when an interrupt occurs.</dd>
</dl>

<h5 id="L9016">Float64Array</h5>

<p>The implementation must implement PVDoubleArray, which is used for all I/O.
In addition the following methods are implemented:</p>
<pre>public interface Float64Array extends Interface{
    PVDoubleArray getPVDoubleArray();
    Status startRead(User user);
    Status endRead(User user);
    Status startWrite(User user);
    Status endWrite(User user);
    Status addInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayListener);
    Status removeInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayListener);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">getPVDoubleArray</dt>
    <dd>Get the data interface.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>This is called each time the user starts reading. The driver implements
      this method so that it can save a reference to the user while the user is
      performing I/O via the PVDoubleArray methods, which do not have a user
      argument.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>The user calls this when it is done using the PVDoubleArray methods.
      The driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>This is called each time the user starts writing. The driver implements
      this method so that it can save a reference to the user while the user is
      performing I/O via the PVDoubleArray methods, which do not have a user
      argument.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>The user calls this when it is done using the PVDoubleArray methods.
      The driver should remove the reference to the user.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add an interrupt listener. A driver class should not implement this
      method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. A driver should not implement this
    method.</dd>
</dl>

<h5 id="L9060">AbstractFloat64Array</h5>

<p>A driver implements float64Array by extending the following abstract base
class:</p>
<pre>public abstract class AbstractFloat64Array
extends AbstractPVArray implements Float64Array
{
    protected AbstractFloat64Array(
            PVField parent,Array array,int capacity,boolean capacityMutable,
            Device device,String interfaceName);
    public Status endRead(User user);
    public Status endWrite(User user);
    public Status startRead(User user);
    public Status startWrite(User user);
    public void interruptOccurred();
    public String getInterfaceName();
    public Status addInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayInterruptListener);
    public Status removeInterruptUser(User user,
        Float64ArrayInterruptListener float64ArrayInterruptListener);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">AbstractFloat64Array</dt>
    <dd>The constructor that must be called by the derived class.</dd>
  <dt style="font-family: courier;">interruptOccurred</dt>
    <dd>Call all registered interrupt listeners. Called by the derived
    class.</dd>
  <dt style="font-family: courier;">getInterfaceName</dt>
    <dd>Get the name of the interface, i.e. "float64Array". The derived class
      should not implement this method.</dd>
  <dt style="font-family: courier;">addInterruptUser</dt>
    <dd>Add a listener to call when interruptOccurred is called. The derived
      class should not implement this method.</dd>
  <dt style="font-family: courier;">removeInterruptUser</dt>
    <dd>Remove an interrupt listener. The derived class should not implement
      this method.</dd>
  <dt style="font-family: courier;">startRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endRead</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">startWrite</dt>
    <dd>Returns Status.success.</dd>
  <dt style="font-family: courier;">endWrite</dt>
    <dd>Returns Status.success.</dd>
</dl>

<h4 style="text-align: center" id="L9114">GPIB Interfaces</h4>

<p>A driver that implements GPIB inplements both GpibController and GpibDevice.
For the controller it it implement a psuedo device which is accessed via
interface GpibController. The name for this device should be the same as the
port name. For each actual device it implements interface GpibDevice.</p>

<h5 id="L9118">GpibController</h5>

<p><span style="font-family: courier;">gpibController</span> has the
definition:</p>
<pre>public interface GpibSrqHandler {
     public void srqHandler(GpibController controller);
}

public interface GpibController {
    Status ifc(User user);
    Status getBusAddress(User user);
    Status setBusAddress(User user,int address);
    Status isRemote(User user);
    Status isSRQ(User user);
    Status isNDAC(User user);
    Status isSystemController(User user);
    Status isControllerInCharge(User user);
    Status isTalker(User user);
    Status isListener(User user);
    Status setATN(User user,boolean state);
    Status setREN(User user,boolean state);
    Status passControl(User user,int addr);
    Status sendCommand(User user,byte data[]);
    Status enableSRQ (User user,boolean state);
    void registerSrqHandler(GpibSrqHandler srqHandler);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">srqHandler</dt>
    <dd>A user supplied method that is called when the controller detects an
      SRQ.</dd>
  <dt style="font-family: courier;">ifc</dt>
    <dd>Issue an interface clear.</dd>
  <dt style="font-family: courier;">getBusAddress</dt>
    <dd>Get the bus address on the controller itself.</dd>
  <dt style="font-family: courier;">setBusAddress</dt>
    <dd>Set the bus address for the controller itself. This is required if the
      default bus address for the controller conflicts with the address of a
      device connected to the controller.</dd>
  <dt style="font-family: courier;">isRemote</dt>
    <dd>Is the remote line asserted?</dd>
  <dt style="font-family: courier;">isSRQ</dt>
    <dd>Is SRQ asserted?</dd>
  <dt style="font-family: courier;">isNDAC</dt>
    <dd>Is NDAC asserted?</dd>
  <dt style="font-family: courier;">isSystemController</dt>
    <dd>Is this controller the system controller?</dd>
  <dt style="font-family: courier;">isControllerInCharge</dt>
    <dd>Is this controller the controller in charge?</dd>
  <dt style="font-family: courier;">isTalker</dt>
    <dd>Is talker asserted?</dd>
  <dt style="font-family: courier;">isListener</dt>
    <dd>Is listener asserted?</dd>
  <dt style="font-family: courier;">setATN</dt>
    <dd>Set ATN line</dd>
  <dt style="font-family: courier;">setREN</dt>
    <dd>Set REN line</dd>
  <dt style="font-family: courier;">passControl</dt>
    <dd>Pass control to the specified address.</dd>
  <dt style="font-family: courier;">sendCommand</dt>
    <dd>Send the commands to the controller.</dd>
  <dt style="font-family: courier;">enableSRQ</dt>
    <dd>Allow SRQs.</dd>
  <dt style="font-family: courier;">registerSrqHandler</dt>
    <dd>Register a handler to be called when an SRQ is detected.</dd>
</dl>

<h5 id="L9214">GpibDevice</h5>

<p><span style="font-family: courier;">gpibDevice</span> has the definition:</p>
<pre>public interface GpibDevice {
    Status trigger(User user);
    Status clear(User user);
    Status lock(User user);
    Status unlock(User user);
    boolean getEOI();
    void setEOI(boolean eoi);
    Status getStatusByte(User user);
    Status remote(User user);
    Status local(User user);
}</pre>

<p>where</p>
<dl>
  <dt style="font-family: courier;">trigger</dt>
    <dd>Issue a trigger command.</dd>
  <dt style="font-family: courier;">clear</dt>
    <dd>Issue a clear command.</dd>
  <dt style="font-family: courier;">lock</dt>
    <dd>Lock the device or controller</dd>
  <dt style="font-family: courier;">unlock</dt>
    <dd>Unlock the device or controller</dd>
  <dt style="font-family: courier;">getEOI</dt>
    <dd>Get the current state of EOI</dd>
  <dt style="font-family: courier;">setEOI</dt>
    <dd>Should EOI be asserted when the last byte is sent.</dd>
  <dt style="font-family: courier;">getStatusByte</dt>
    <dd>Get the status byte.</dd>
  <dt style="font-family: courier;">remote</dt>
    <dd>Set the device or controller to remote control.</dd>
  <dt style="font-family: courier;">local</dt>
    <dd>Set the device or controller to locale control.</dd>
</dl>

<h3 id="L9270">Package org.epics.ioc.pdrv.serial</h3>

<h4 style="text-align: center" id="L9272">Overview</h4>

<p>Consult package org.epics.ioc.support.pdrv.serial for an explaination of how
to communicate with a serial device.</p>

<p>This is the first support for talking to serial devices. Currently the only
support is for internet to serial servers like the MOXA boxes. Only very simple
tests have been done. In the future more support, including local serial ports
will be implemented. </p>

<h4 style="text-align: center" id="L9278">Configuration</h4>

<p>A structure IPSerialDriver defines fields for configuring an Internet
Protocol driver.</p>
<pre>&lt;structure name = "IPSerialDriver"&gt;
    &lt;scalar name = "host" type = "string" /&gt;
    &lt;scalar name = "port" type = "int" /&gt;
    &lt;scalar name = "eosInput" type = "string" /&gt;
    &lt;scalar name = "eosOutput" type = "string" /&gt;
&lt;/structure&gt;</pre>

<p>A record must be defined for each port to a vxi11 controller.</p>
<pre>&lt;record name = "???" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.serial.IPSerialDriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;???&lt;/scalar&gt;
    &lt;structure name = "driverParameters" type = "IPSerialDriver" &gt;
        &lt;scalar name = "host"&gt;???&lt;/scalar&gt;
        &lt;scalar name = "port"&gt;???&lt;/scalar&gt;
        &lt;scalar name = "eosInput"&gt;???&lt;/scalar&gt;
        &lt;scalar name = "eosOutput"&gt;???&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following example creates a port and a record instance that sends a
string to serial port of a MOXA UC7408 and reads the response. The MOXA has a
null modem connector attached to the serial port so it just receives what is
sent.</p>
<pre>&lt;record name = "IPSerialPort" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.serial.IPSerialDriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;IPserialPort&lt;/scalar&gt;
    &lt;structure name = "driverParameters" type = "IPSerialDriver" &gt;
        &lt;scalar name = "host"&gt;192.168.1.9&lt;/scalar&gt;
        &lt;scalar name = "port"&gt;4001&lt;/scalar&gt;
        &lt;scalar name = "eosInput"&gt;LFCR&lt;/scalar&gt;
        &lt;scalar name = "eosOutput"&gt;LFCR&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "stringOut"&gt;
    &lt;scalar name = "value" type = "string"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;IPserialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvOctetOutput"/&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "caProcessLink"&gt;
         &lt;scalar name = "pvname"&gt;stringIn&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "stringIn"&gt;
    &lt;scalar name = "value" type = "string"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;IPserialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvOctetInput"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h4 style="text-align: center" id="L9292">Implementation</h4>

<p>The code currently consists of just one implementation module:</p>
<ul>
  <li>IPSerialDriverFactory<br />
    This implements the code for PortDriver, DeviceDriver,and Octet.</li>
</ul>

<p>In the future code will be implemented for local serial ports.</p>

<h3 id="L9305">Package org.epics.ioc.pdrv.vxi11</h3>

<h4 style="text-align: center" id="L9307">Overview</h4>

<p>NOTE: The GPIBController and GPIBDevice commands hane not been tested. Only
minimal testing has been done.</p>

<p>This package describes JavaIOC support for communication with devices that
are accessable via the VXI-11 communication protocal. The VXI-11 standard
consists of the following documents(PDF Format):</p>
<ol>
  <li><a href="vxi-11.pdf">TCP/IP Instrument Protocol Specification</a></li>
  <li><a href="vxi-11_1.pdf">TCP/IP-VXIbus Interface Specification</a></li>
  <li><a href="vxi-11_2.pdf">TCP/IP-IEEE 488.1 Interface Specification</a></li>
  <li><a href="vxi-11_3.pdf">TCP/IP-IEEE 488.2 Instrument Interface
    Specification</a></li>
</ol>

<p>The protocal use the SUN ONC RPC (Remote Procedure Call) network standard.
The complete VXI-11 ONC interface definition is provided in an appendix of the
Protocal Specification. The interface specifications appear in package
org.epics.ioc.pdrv.vxi11.rpc.</p>

<p><a href="http://remotetea.sourceforge.net">Remote Tea</a> is an open sounce
implementation of ONC RPC. The jar file for Remote Tea is included with the
Java IOC. Remote Tea was used to generate, from the ONC interface definitions,
the java files that appear in package org.epics.ioc.pdrv.vxi11.rpc. </p>

<p>The code in this package provides a portDriver driver that uses Remote Tea
and the generated files to interface to VXI-11 devices. It implements the
following interfaces:</p>
<ul>
  <li>Octet<br />
    This is for I/O to/from VXI-11 devices.</li>
  <li>GpibController<br />
    If the deviceName refers to the controller itself then interface
    GpibController is implemented.</li>
  <li>GpibDevice<br />
    This is inplemented for each deviceName</li>
</ul>

<p>VXI-11 allows both primary (PAD) and secondary (SAD) addresses, each of
which must be an integer &gt;=0. The following conventions are used for
deviceNames:</p>
<ul>
  <li>PAD only device<br />
    The deviceName is a non-negative integer. Thus "0", "1", "15" are all legal
    device names.</li>
  <li>PAD and SAD device<br />
    The deviceName is of the form PAD,SAD. Thus "0,1" , "2,127", "4,0" are all
    legal device names.</li>
  <li>The controller itself<br />
    Any string that does not match the above choices. A good choice is
    "controller".</li>
</ul>

<h4 style="text-align: center" id="L9378">Configuration</h4>

<p>A structure vxi11Driver defines fields for configuring a vxi11 driver.</p>
<pre>&lt;structure name = "vxi11Driver"&gt;
    &lt;scalar name = "hostName" type = "string" /&gt;
    &lt;scalar name = "vxiName" type = "string" /&gt;
    &lt;scalar name = "lockTimeout" type = "int" /&gt;
    &lt;scalar name = "eosInput" type = "string" /&gt;
    &lt;scalar name = "eosOutput" type = "string" /&gt;
&lt;/structure&gt;</pre>

<p>NOTE: The only value accepted for eosInput and eosOutput are NL, which is a
new line.</p>

<p>A record must be defined for each port to a vxi11 controller.</p>
<pre>&lt;record name = "???" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.vxi11.DriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;???&lt;/scalar&gt;
    &lt;structure name = "driverParameters" type = "vxi11Driver" &gt;
        &lt;scalar name = "hostName"&gt;???&lt;/scalar&gt;
        &lt;scalar name = "vxiName"&gt;???&lt;/scalar&gt;
        &lt;scalar name = "eosInput"&gt;????&lt;/scalar&gt;
        &lt;scalar name = "eosOutput"&gt;????&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following example creates a port and a record instance that sends a
command to a GPIB device and reads the response, which is a string that has a
float value.</p>
<pre>&lt;record name = "serialPort" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.vxi11.DriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;

    &lt;structure name = "driverParameters" type = "vxi11Driver" &gt;
        &lt;scalar name = "hostName"&gt;192.168.1.10&lt;/scalar&gt;
        &lt;scalar name = "vxiName"&gt;hpib&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "serialToDouble"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "command" type = "pdrvStringNoop"&gt;
            &lt;scalar name = "value"&gt;:FETC?&lt;/scalar&gt;
            &lt;structure name = "output" type = "pdrvOctetOutput"/&gt;
        &lt;/structure&gt;
        &lt;structure name = "input" type = "pdrvStringToScalar"&gt;
            &lt;structure name = "input" type = "pdrvOctetInput"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h4 style="text-align: center" id="L9394">Implementation</h4>

<p>The code consists of two implementation modules:</p>
<ul>
  <li>DriverFactory<br />
    This implemnents the portDriver interfaces: PortDriver, DeviceDriver,
    Octet, GpibController, and GpibDevice.</li>
  <li>VXI11Factory<br />
    This provides access to the RPC Java code created by Remote Tea.</li>
</ul>

<p>The code was split into two modules for code clarity. The design and even
some of the code was taken from Java code that Eric Norum implemented while he
was working at the Canadian Light Source.</p>

<h3 id="L9413">Package org.epics.ioc.support.pdrv</h3>

<h4 style="text-align: center" id="L9415">Overview</h4>

<p>This package contains the general purpose code for support that communicates
with a portDriver. The actual support code, which extends code supplied by this
package, resides in subpackages. This package provides the following:</p>
<dl>
  <dt>portDriverLink</dt>
    <dd>The complete support for a portDriverLink, which is described
    below.</dd>
  <dt>portDriverSupport</dt>
    <dd>The interface definition for PortDriverSupport and an abstract base
      class, which is extended by code that communicates with a portDriver.</dd>
  <dt>portCreate</dt>
    <dd>The complete support for creating port drivers via JavaIOC records.</dd>
  <dt>portDeviceControl</dt>
    <dd>The complete support for a JavaIOC record that controls a port and
      device.</dd>
</dl>

<p>A portDriverLink is a structure field that links to a portDriver. The
structure can have an arbitrary number of fields with support that communicates
with the portDriver. A field of a portDriverLink must not have other types of
support. The support for portDriverLink allocates a User and connects to a port
and to a device.</p>

<p>When a portDriverLink is processed it does the following for each subfield
of the portDriverLink structure. It first calls beginProcess for each
PortDriverSupport. It then calls user.queueRequest. When it is called back, it
calls the queueCallback of each PortDriverSupport. When the last returns it
calls processContinue. When it is called back, it calls the endProcess method
of each PortDriverSupport. It then completes processing.</p>

<p>Thus with one queueRequest multiple PortDriverSupports can access the
portDriver. An example of how this is used is serial support. Consider the
following example:</p>
<pre>&lt;record name = "intToSerial"&gt;
    &lt;scalar name = "value" type = "int"&gt;1000&lt;/scalar&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "command" type = "pdrvScalarCommand"&gt;
            &lt;scalar name = "prefix"&gt;:VOLT:DC:RANG:UPP&lt;/scalar&gt;
            &lt;structure name = "output" type = "pdrvSerialOutput"/&gt;
        &lt;/structure&gt;
        &lt;structure name = "discardResponse" type = "pdrvStringNoop"&gt;
            &lt;structure name = "query" type = "pdrvScalarQuery"&gt;
                &lt;scalar name = "request"&gt;:VOLT:DC:RANG:UPP?&lt;/scalar&gt;
                &lt;structure name = "output" type = "pdrvSerialOutput"/&gt;
                &lt;structure name = "input" type = "pdrvSerialInput"/&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The field named link is a portDriverLink. The structures of type
pdrvScalarCommand, pdrvSerialOutput, pdrvStringNoop, pdrvSerialOutput, and
pdrvSerialInput are all PortDriverSupport code implemented in subpackage
serial. The link support code calls the support for pdrvScalarCommand and for
pdrvStringNoop.</p>

<p>pdrvScalarCommand creates a string that is the prefix followed by
intToSerial.value converted to a string when is field
intToSerial.link.command.command. It then calls the support for
pdrvSerialOutput. Thus the string sent to the portDriver is ":VOLT:DC:RANG:UPP
1000"</p>

<p>pdrbStringNoop calls the support for pdrvScalarQuery, which calls
pdrvSerialOutput and then pdrvSerialInput. The end result is that the string
value "1010.000000" appears in field
intToSerial.link.discardResponse.query.response. I do not know why this
instrument returned this value instead of 1000.</p>

<h4 style="text-align: center" id="L9454">portDriverLink</h4>

<p>The xml definition for structure portDriverLink is:</p>
<pre>&lt;structure name = "portDriverLinkFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.PortDriverLinkFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "portDriverLink"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;portDriverLinkFactory&lt;/auxInfo&gt;
  &lt;scalar name = "portName" type = "string" /&gt;
  &lt;scalar name = "deviceName" type = "string" /&gt;
  &lt;!-- timeout only used for asynchronous ports --&gt;
  &lt;scalar name = "timeout" type = "double"&gt;1.0&lt;/scalar&gt;
  &lt;structure name = "alarm" type = "alarm" /&gt;
&lt;/structure&gt;

&lt;structure name = "portDriverInterruptLink"&gt;
  &lt;scalar name = "portName" type = "string" /&gt;
  &lt;scalar name = "deviceName" type = "string" /&gt;
&lt;/structure&gt;</pre>

<p>An interrupt link is for support code that receives portDriver interrupts.
This support code does not make read/write requests to a portDriver, rather it
is called by portDriver interrupts. This it is handled completely different
than a portDriverLink. </p>

<p>The Java defininitions are:</p>
<pre>interface PortDriverLink {
    User getUser();
    AlarmSupport getAlarmSupport();
    byte[] getByteBuffer();
    byte[] expandByteBuffer(int size);
}

public class PortDriverLinkFactory {
    public static Support create(PVStructure pvStructure);
}

public abstract class AbstractPortDriverInterruptLink extends AbstractSupport
implements RecordProcessRequester,QueueRequestCallback
{
    protected AbstractPortDriverInterruptLink(String supportName,PVStructure pvStructure) ;
    protected static Convert convert = ConvertFactory.getConvert();
    protected static PVProperty pvProperty = PVPropertyFactory.getPVProperty();
    protected String supportName;
    protected PVStructure pvStructure;
    protected String fullName = null;
    protected PVRecord pvRecord = null;
    protected String recordName = null;
    protected RecordProcess recordProcess = null;
    protected PVField valuePVField = null;
    protected AlarmSupport alarmSupport = null;
    protected PVString pvPortName = null;
    protected PVString pvDeviceName = null;
    protected PVBoolean pvProcess = null;
    protected User user = null;
    protected Port port = null;
    protected Trace portTrace = null;
    protected Device device = null;
    protected Trace deviceTrace = null;
    protected SupportProcessRequester supportProcessRequester = null;

    public void initialize(RecordSupport recordSupport);
    public void uninitialize();
    public void start();
    public void stop();

    public boolean isProcess();
    public void callback(Status status, User user);
    public void recordProcessComplete();
    public void recordProcessResult(RequestResult requestResult) {}
}</pre>

<h4 style="text-align: center" id="L9466">portDriverSupport</h4>

<p>AbstractPortDriverSupport is the base class for all non-interrupt
PortDriverSupport code. It does most initialization required by support code
and, very important, it calls beginProcess, queueCallback, and endProcess for
subfields of the structure it supports. The Java defininitions are:</p>
<pre>interface PortDriverSupport extends Support {
    void setPortDriverLink(PortDriverLink portDriverLink);
    void beginProcess();
    void endProcess();
    void queueCallback();
}

public abstract class AbstractPortDriverSupport extends GenericBase
implements PortDriverSupport
{
    protected AbstractPortDriverSupport(String supportName,PVStructure pvStructure);
    protected static Convert convert = ConvertFactory.getConvert();
    protected static PVProperty pvProperty = PVPropertyFactory.getPVProperty();
    protected static final String emptyString = "";
    protected String supportName;
    protected PVStructure pvStructure;
    protected PVRecord pvRecord = null;
    protected String recordName = null;
    protected String fullName = null;
    protected PVField valuePVField = null;
    protected AlarmSupport alarmSupport = null;
    protected PortDriverLink portDriverLink = null;
    protected User user = null;
    protected Port port = null;
    protected Device device = null;
    protected Trace portTrace = null;
    protected Trace deviceTrace = null;
    protected SupportProcessRequester supportProcessRequester = null;

    public void setPortDriverLink(PortDriverLink portDriverLink);

    public void initialize(RecordSupport recordSupport);
    public void uninitialize();
    public void start();
    public void stop();
    public void process(SupportProcessRequester supportProcessRequester);

    public void beginProcess();
    public void endProcess();
    public void queueCallback();
    public void message(String message,MessageType messageType)
}</pre>

<h4 style="text-align: center" id="L9472">Support for PortDriverLink</h4>

<p>Again this package has the complete implementation of PortDriverLink. The
Java defininition is:</p>
<pre>public class PortDriverLinkFactory {
    public static Support create(PVStructure pvStructure);
}</pre>

<h4 style="text-align: center" id="L9478">Port Creation</h4>

<p>A portDriver instance is created via JavaIOC database records that are
created with type "portCreate". A field named "driverParameters" is a structure
containing driver specific confifuration information. The xml definition for
structure portCreate is:</p>
<pre>&lt;structure name = "portCreateFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.PortCreateFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "portCreate"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;portCreateFactory&lt;/auxInfo&gt;
  &lt;scalar name = "factoryName" type = "string" /&gt;
  &lt;scalar name = "portName" type = "string" /&gt;
  &lt;scalar name = "autoConnect" type = "boolean"&gt;true&lt;/scalar&gt;
  &lt;structure name = "priority" type = "scanPriority" /&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "serialPort" type = "portCreate"&gt;
    &lt;scalar name = "factoryName"&gt;org.epics.ioc.pdrv.vxi11.DriverFactory&lt;/scalar&gt;
    &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;

    &lt;structure name = "driverParameters" type = "vxi11Driver" &gt;
        &lt;scalar name = "hostName"&gt;192.168.1.10&lt;/scalar&gt;
        &lt;scalar name = "vxiName"&gt;hpib&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The Java defininition for the factory is:</p>
<pre>public class PortCreateFactory {
    public static Support create(PVStructure pvStructure);
}</pre>

<h4 style="text-align: center" id="L9492">Port and Device Control</h4>

<p>A record instance can be created for a port and device instance. This record
can be used to control options for the port and device. Since these options can
be set after start, they will occur before any records are processed. For
example trace options can be set before the first connect call isissued. The
xml definition for structure portDeviceControl is:</p>
<pre>&lt;structure name = "portDeviceControlFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.PortDeviceControlFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "portDeviceControl"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;portDeviceControlFactory&lt;/auxInfo&gt;
  &lt;scalar name = "message" type = "string" /&gt;
  &lt;scalar name = "portName" type = "string" /&gt;
  &lt;scalar name = "deviceName" type = "string" /&gt;
  &lt;scalar name = "processAtStart" type = "boolean"&gt;false&lt;/scalar&gt;
  &lt;scalar name = "connect" type = "boolean"&gt;false&lt;/scalar&gt;
  &lt;scalar name = "enable" type = "boolean"&gt;true&lt;/scalar&gt;
  &lt;scalar name = "autoConnect" type = "boolean"&gt;truer&lt;/scalar&gt;
  &lt;scalar name = "traceMask" type = "int"&gt;1&lt;/scalar&gt;
  &lt;scalar name = "traceIOMask" type = "int"&gt;0&lt;/scalar&gt;
  &lt;scalar name = "traceIOTruncateSize" type = "int"&gt;80&lt;/scalar&gt;
  &lt;scalar name = "report" type = "boolean"&gt;false&lt;/scalar&gt;
  &lt;scalar name = "reportDetails" type = "int"&gt;3&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "serialDeviceControl" type = "portDeviceControl" &gt;
    &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
    &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
    &lt;scalar name = "traceMask"&gt;0xfff&lt;/scalar&gt;
    &lt;scalar name = "traceIOMask"&gt;0xfff&lt;/scalar&gt;
    &lt;scalar name = "processAtStart"&gt;true&lt;/scalar&gt;
&lt;/record&gt;</pre>

<p>The Java defininitions are:</p>
<pre>public class PortDeviceControlFactory {
    public static Support create(PVStructure pvStructure);
}</pre>

<h4 id="L9506">Package org.epics.ioc.support.pdrv.scalar</h4>

<h5 style="text-align: center" id="L9508">Overview</h5>

<p>This package implements portDriver support for scalars. Currently it only
has support for Int32 and Float64. In the future support will also be provided
for all the ScalarTypes types.</p>

<h5 style="text-align: center" id="L9512">Int32</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "pdrvInt32InputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32Input"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32InputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvInt32InterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32Interrupt" type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32InterruptFactory&lt;/auxInfo&gt;
   &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvInt32AverageFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32Average"  type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32AverageFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvInt32OutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32Output"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32OutputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "syncInt32Out"&gt;
    &lt;scalar name = "value" type = "int"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvInt32Output"/&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "caProcessLink"&gt;
         &lt;scalar name = "pvname"&gt;syncInt32In&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncInt32In"&gt;
    &lt;scalar name = "value" type = "int"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvInt32Input"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncInt32Interrupt"&gt;
    &lt;scalar name = "value" type = "int"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "pdrvInt32Interrupt"&gt;
        &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "process" &gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "syncInt32InAverage"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "scan" type = "scan"&gt;
        &lt;structure name = "type"&gt;&lt;scalar name = "choice"&gt;periodic&lt;/scalar&gt;&lt;/structure&gt;
        &lt;scalar name = "rate"&gt;5.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "pdrvInt32Average"&gt;
        &lt;scalar name = "portName"&gt;syncInt32Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9522">Float64</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "pdrvFloat64InputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Input"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64InputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64InterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Interrupt" type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64InterruptFactory&lt;/auxInfo&gt;
   &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64AverageFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Average" type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64AverageFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64OutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Output"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64OutputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64InputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Input"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64InputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64InterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Interrupt" type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64InterruptFactory&lt;/auxInfo&gt;
   &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64AverageFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Average" type = "portDriverInterruptLink"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64AverageFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64OutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.scalar.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64Output"&gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64OutputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "syncFloat64Out"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvFloat64Output"/&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "caProcessLink"&gt;
         &lt;scalar name = "pvname"&gt;syncFloat64In&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncFloat64In"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvFloat64Input"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncFloat64Interrupt"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "pdrvFloat64Interrupt"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "process" &gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncFloat64InAverage"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "scan" type = "scan"&gt;
        &lt;structure name = "type"&gt;&lt;scalar name = "choice"&gt;periodic&lt;/scalar&gt;&lt;/structure&gt;
        &lt;scalar name = "rate"&gt;5.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "pdrvFloat64Average"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64Port&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9532">Java Definitions</h5>

<p>The Java definitions are:</p>
<pre>public class SupportFactory {
    public static Support create(PVStructure pvStructure);
}

public class BaseInt32Input;
public class BaseInt32Average;
public class BaseInt32Output;
public class BaseInt32Interrupt;
public class BaseFloat64Input;
public class BaseFloat64Average;
public class BaseFloat64Output;
public class BaseFloat64Interrupt;</pre>

<p>The factory creates all the supported types. Each base class is a complete
implementation.</p>

<h4 id="L9540">Package org.epics.ioc.support.pdrv.array</h4>

<h5 style="text-align: center" id="L9542">Overview</h5>

<p>This package implements portDriver support for arrays. Currently it only has
support for Int32 and Float64 arrays. In the future support will also be
provided for all the ScalarArray types.</p>

<h5 style="text-align: center" id="L9546">Int32Array</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "pdrvInt32ArrayInputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32ArrayInput"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32ArrayInputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvInt32ArrayInterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32ArrayInterrupt" type = "portDriverInterruptLink"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32ArrayInterruptFactory&lt;/auxInfo&gt;
  &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvInt32ArrayOutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvInt32ArrayOutput"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvInt32ArrayOutputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "arrayOutput"&gt;
    &lt;array name = "value"  type = "int" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncInt32ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvInt32ArrayOutput"/&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "caProcessLink"&gt;
         &lt;scalar name = "pvname"&gt;syncInt32ArrayInput&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "arrayInput"&gt;
    &lt;array name = "value"  type = "int" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncInt32ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvInt32ArrayInput"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "arrayInterrupt"&gt;
    &lt;array name = "value"  type = "int" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "pdrvInt32ArrayInterrupt"&gt;
        &lt;scalar name = "portName"&gt;syncInt32ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "process" &gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9556">Float64Array</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "pdrvFloat64ArrayInputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64ArrayInput"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64ArrayInputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64ArrayInterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64ArrayInterrupt" type = "portDriverInterruptLink"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64ArrayInterruptFactory&lt;/auxInfo&gt;
  &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvFloat64ArrayOutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.array.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvFloat64ArrayOutput"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvFloat64ArrayOutputFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>An example is:</p>
<pre>&lt;record name = "arrayOutput"&gt;
    &lt;array name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvFloat64ArrayOutput"/&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "caProcessLink"&gt;
         &lt;scalar name = "pvname"&gt;syncFloat64ArrayInput&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "arrayInput"&gt;
    &lt;array name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvFloat64ArrayInput"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "arrayInterrupt"&gt;
    &lt;array name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "pdrvFloat64ArrayInterrupt"&gt;
        &lt;scalar name = "portName"&gt;syncFloat64ArrayPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "process" &gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9566">Java Definitions</h5>

<p>The Java definitions are:</p>
<pre>public class SupportFactory {
    public static Support create(PVStructure pvStructure);
}

public class BaseInt32ArrayInput;
public class BaseInt32ArrayOutput;
public class BaseInt32ArrayInterrupt;
public class BaseFloat64ArrayInput;
public class BaseFloat64ArrayOutput;
public class BaseFloat64ArrayInterrupt;</pre>

<p>The factory creates all the supported types. Each base class is a complete
implementation.</p>

<h4 id="L9574">Package org.epics.ioc.support.pdrv.digital</h4>

<h5 style="text-align: center" id="L9576">Overview</h5>

<p>This package implements portDriver support for digital I/O. This support
needs more work. It should have support that works for a driver that supports
Int32. Currently there is only support for a driver that support interface
Uint32Digital.</p>

<h5 style="text-align: center" id="L9580">UInt32Digital</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "digitalInputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.basic.DigitalFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "digitalOutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.basic.DigitalFactory&lt;/scalar&gt;
&lt;/structure&gt;


&lt;structure name = "digitalState"&gt;
  &lt;scalar name = "name" type = "string" /&gt;
  &lt;scalar name = "value" type = "int" /&gt;
  &lt;structure name = "severity" type = "alarmSeverity" /&gt;
  &lt;scalar name = "message" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "digital"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;scalar name = "value" type = "int" /&gt;
  &lt;structure name = "input" type = "generic"/&gt;
  &lt;!-- each field of states must be as digitalState structure --&gt;
  &lt;!-- supportName can be digitalInput or digitalOutput --&gt;
  &lt;structure name = "states"  /&gt;
&lt;/structure&gt;</pre>

<p>If the value field is an enumerated structure then the support will
automatically give a value to value.choices based on the digitalState.name
fields on the digital.states array.</p>

<p>Some examples for an enumerated value field are:</p>
<pre>&lt;record name = "syncDigitalOut"&gt;
    &lt;scalar name = "value" type = "int"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncDigitalPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvUInt32DigitalOutput"&gt;
            &lt;scalar name = "mask"&gt;15&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "generic"&gt;
        &lt;structure name = "1" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncDigitalIn1&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "2" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncDigitalIn2&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "3" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncDigitalIn3&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "4" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncDigitalIn4&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "5" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncDigitalIn5&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "syncDigitalIn1"&gt;
    &lt;structure name = "value" type = "enumerated"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "digital"&gt;
        &lt;structure name = "link" type = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;syncDigitalPort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "input" type = "pdrvUInt32DigitalInput"&gt;
                &lt;scalar name = "mask"&gt;0x1&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
        &lt;structure name = "states"&gt;
            &lt;auxInfo name = "supportFactory" type = "string"&gt;digitalInputFactory&lt;/auxInfo&gt;
            &lt;structure name = "0" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;off&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
            &lt;structure name = "1" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;on&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;1&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;minor&lt;/scalar&gt;&lt;/structure&gt;
                &lt;scalar name = "message"&gt;on is minor alarm&lt;/scalar&gt;
            &lt;/structure&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" type = "enumeratedAlarm"&gt;
            &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
            &lt;structure name = "changeStateAlarm"&gt;
                 &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
                 &lt;scalar name = "message"&gt;Change State&lt;/scalar&gt;
             &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;record name = "syncDigitalIn2"&gt;
    &lt;structure name = "value" type = "enumerated"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "digital"&gt;
        &lt;structure name = "link" type = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;syncDigitalPort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "input" type = "pdrvUInt32DigitalInput"&gt;
                &lt;scalar name = "mask"&gt;0x2&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
        &lt;structure name = "states"&gt;
            &lt;auxInfo name = "supportFactory" type = "string"&gt;digitalInputFactory&lt;/auxInfo&gt;
            &lt;structure name = "0" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;off&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
            &lt;structure name = "1" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;on&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;1&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;minor&lt;/scalar&gt;&lt;/structure&gt;
                &lt;scalar name = "message"&gt;on is minor alarm&lt;/scalar&gt;
            &lt;/structure&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" type = "enumeratedAlarm"&gt;
            &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
            &lt;structure name = "changeStateAlarm"&gt;
                 &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
                 &lt;scalar name = "message"&gt;Change State&lt;/scalar&gt;
             &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncDigitalIn5"&gt;
    &lt;structure name = "value" type = "enumerated"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "digital"&gt;
        &lt;structure name = "link" type = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;syncDigitalPort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "input" type = "pdrvUInt32DigitalInput"&gt;
                &lt;scalar name = "mask"&gt;0xf&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
        &lt;structure name = "states"&gt;
            &lt;auxInfo name = "supportFactory" type = "string"&gt;digitalInputFactory&lt;/auxInfo&gt;
            &lt;structure name = "0" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;zero&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
            &lt;structure name = "1" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;one&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0x1&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;minor&lt;/scalar&gt;&lt;/structure&gt;
                &lt;scalar name = "message"&gt;one is minor alarm&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "2" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;two&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0x2&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;major&lt;/scalar&gt;&lt;/structure&gt;
                &lt;scalar name = "message"&gt;two is major alarm&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "3" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;three&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0x3&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
            &lt;structure name = "4" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;four&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0x4&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;major&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
            &lt;structure name = "5" type = "digitalState"&gt;
                &lt;scalar name = "name"&gt;eight&lt;/scalar&gt;
                &lt;scalar name = "value"&gt;0x8&lt;/scalar&gt;
                &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
            &lt;/structure&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" type = "enumeratedAlarm"&gt;
            &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
            &lt;structure name = "changeStateAlarm"&gt;
                 &lt;structure name = "severity"&gt;&lt;scalar name = "choice"&gt;none&lt;/scalar&gt;&lt;/structure&gt;
                 &lt;scalar name = "message"&gt;Change State&lt;/scalar&gt;
             &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>Some examples for a boolean value field are:</p>
<pre>&lt;record name = "syncBooleanOut"&gt;
    &lt;scalar name = "value" type = "int"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "outlink" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncBooleanPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "output" type = "pdrvUInt32DigitalOutput"&gt;
            &lt;scalar name = "mask"&gt;32767&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "generic"&gt;
        &lt;structure name = "1" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncBooleanIn1&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "2" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncBooleanIn2&lt;/scalar&gt;
             &lt;scalar name = "wait" type = "boolean"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "3" type = "caProcessLink"&gt;
             &lt;scalar name = "pvname"&gt;syncBooleanIn3&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncBooleanIn1"&gt;
    &lt;scalar name = "value" type = "boolean"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncBooleanPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvUInt32DigitalInput"&gt;
            &lt;scalar name = "mask"&gt;0x1&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" type = "booleanAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;structure name = "falseAlarm"&gt;&lt;scalar name = "choice"&gt;minor&lt;/scalar&gt;&lt;/structure&gt;
      &lt;scalar name = "falseMessage"&gt;false alarm&lt;/scalar&gt;
      &lt;structure name = "trueAlarm"&gt;&lt;scalar name = "choice"&gt;major&lt;/scalar&gt;&lt;/structure&gt;
      &lt;scalar name = "trueMessage"&gt;true alarm&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;

&lt;record name = "syncBooleanIn2"&gt;
    &lt;scalar name = "value" type = "boolean"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;syncBooleanPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "input" type = "pdrvUInt32DigitalInput"&gt;
            &lt;scalar name = "mask"&gt;0x2&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" type = "booleanAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;structure name = "falseAlarm"&gt;&lt;scalar name = "choice"&gt;minor&lt;/scalar&gt;&lt;/structure&gt;
      &lt;scalar name = "falseMessage"&gt;false alarm&lt;/scalar&gt;
      &lt;structure name = "trueAlarm"&gt;&lt;scalar name = "choice"&gt;major&lt;/scalar&gt;&lt;/structure&gt;
      &lt;scalar name = "trueMessage"&gt;true alarm&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9596">Java Definitions</h5>

<p>The Java definitions are:</p>
<pre>public class SupportFactory {
    public static Support create(PVStructure pvStructure);
}

public class BaseUInt32DigitalInput;
public class BaseUInt32DigitalOutput;
public class BaseUInt32DigitalInterrupt;</pre>

<p>The factory creates all the supported types. Each base class is a complete
implementation.</p>

<h4 id="L9604">Package org.epics.ioc.support.pdrv.serial</h4>

<h5 style="text-align: center" id="L9606">Overview</h5>

<p>This package implements portDriver support for serial I/O, i. e. it
interfaces to port drivers that implement interface Serial. It currently
supports the following:</p>
<dl>
  <dt>serialInput</dt>
    <dd>Serial to string.</dd>
  <dt>serialOutput</dt>
    <dd>String to serial.</dd>
  <dt>scalarCommand</dt>
    <dd>Send a command to a serial device.</dd>
  <dt>scalarQuery</dt>
    <dd>Send a request to a serial device, get a response, and convert the
      response to a scalar.</dd>
</dl>

<p>In addition two additional supports are provided.</p>
<dl>
  <dt>BaseStringNoop</dt>
    <dd>This does nothing except call PortDriverSupport for fields in the
      structure it supports.</dd>
  <dt>BaseSerialDiscard</dt>
    <dd>This call Serial.read and just discards what it receives. This is
      useful for devices that respond to writes.</dd>
</dl>

<p>Communication with a serial device normally uses more than one support. Most
communication with a serial device consists of either a command or a query. For
devices that support SCPI (Standard Commands for Programmable Instruments) this
is the normal mode of communication.</p>

<p>An example of a command is:</p>
<pre>&lt;record name = "intToSerial"&gt;
    &lt;scalar name = "value" type = "int"&gt;1000&lt;/scalar&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "command" type = "pdrvScalarCommand"&gt;
            &lt;scalar name = "prefix"&gt;:VOLT:DC:RANG:UPP&lt;/scalar&gt;
            &lt;structure name = "output" type = "pdrvSerialOutput"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>When the record is processed the following happens:</p>
<ul>
  <li>The portDriverLink support issues a queueRequest. When the callback is
    called the embeded PortDriverSupport is called.</li>
  <li>The scalarCommand support gives a value to the string field
    intToSerial.link.command.command. The value is
    intToSerial.link.command.prefix concatenated with the intToSerial.value
    converted to a string.</li>
  <li>The serialOutput support converts intToSerial.link.command.command to a
    byte array and calls the portDriver Serial.write.</li>
</ul>

<p>An example of a query that returns a double value is:</p>
<pre>&lt;record name = "serialToDouble"&gt;
    &lt;scalar name = "value" type = "double"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "query" type = "pdrvScalarQuery"&gt;
            &lt;scalar name = "request"&gt;:FETC?&lt;/scalar&gt;
            &lt;structure name = "output" type = "pdrvSerialOutput"/&gt;
            &lt;structure name = "input" type = "pdrvSerialInput"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>When the record is processed the following happens:</p>

<p></p>
<ul>
  <li>The portDriverLink support issues a queueRequest. When the callback is
    called the embeded PortDriverSupport is called.</li>
  <li>The serialOutput support converts serialToDouble.link.query.request to a
    byte array and calls portDriver Serial.write.</li>
  <li>The serialInput support calls portDriver Serial.read and converts the
    returned byte array to a string anot puts it into
    serialToDouble.link.query.result.</li>
  <li>The scalarQuery support converts tserialToDouble.link.query.result to a
    double and puts it into serialToDouble.value.</li>
</ul>

<p>An example of a query that returns a string value is:</p>
<pre>&lt;record name = "getIDN"&gt;
    &lt;scalar name = "value" type = "string"/&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "link" type = "portDriverLink"&gt;
        &lt;scalar name = "portName"&gt;serialPort&lt;/scalar&gt;
        &lt;scalar name = "deviceName"&gt;3&lt;/scalar&gt;
        &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
        &lt;structure name = "query" type = "pdrvScalarQuery"&gt;
            &lt;scalar name = "request"&gt;*IDN?&lt;/scalar&gt;
            &lt;structure name = "output" type = "pdrvSerialOutput"/&gt;
        &lt;/structure&gt;
        &lt;structure name = "input" type = "pdrvSerialInput"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5 style="text-align: center" id="L9687">UInt32Digital</h5>

<p>The xml definitions are:</p>
<pre>&lt;structure name = "pdrvSerialInputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvSerialInput" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvSerialInputFactory&lt;/auxInfo&gt;
   &lt;scalar name = "size" type = "int"&gt;80&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvSerialInterruptFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvSerialInterrupt" type = "portDriverInterruptLink" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvSerialInterruptFactory&lt;/auxInfo&gt;
   &lt;scalar name = "size" type = "int"&gt;80&lt;/scalar&gt;
   &lt;scalar name = "process" type = "boolean"&gt;false&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvSerialOutputFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvSerialOutput" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvSerialOutputFactory&lt;/auxInfo&gt;
   &lt;scalar name = "size" type = "int"&gt;80&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvStringNoopFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvStringNoop" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvStringNoopFactory&lt;/auxInfo&gt;
   &lt;scalar name = "value" type = "string"/&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvScalarCommandFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvScalarCommand" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvScalarCommandFactory&lt;/auxInfo&gt;
   &lt;scalar name = "prefix" type = "string"/&gt;
   &lt;scalar name = "command" type = "string"/&gt;
&lt;/structure&gt;

&lt;structure name = "pdrvScalarQueryFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvScalarQuery" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvScalarQueryFactory&lt;/auxInfo&gt;
   &lt;scalar name = "request" type = "string"/&gt;
   &lt;scalar name = "prefix" type = "string"/&gt;
   &lt;scalar name = "response" type = "string" /&gt;
&lt;/structure&gt;


&lt;structure name = "pdrvSerialDiscardFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.ioc.support.pdrv.serial.SupportFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure name = "pdrvSerialDiscard" &gt;
   &lt;auxInfo name = "supportFactory" type = "string"&gt;pdrvSerialDiscardFactory&lt;/auxInfo&gt;
   &lt;scalar name = "size" type = "int"&gt;80&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<h5 style="text-align: center" id="L9693">Java Definitions</h5>

<p>The Java definitions are:</p>
<pre>public class SupportFactory {
    public static Support create(PVStructure pvStructure);
}

public class BaseSerialInput;
public class BaseSerialOutput;
public class BaseSerialInterrupt;
public class BaseScalarCommand;
public class BaseScalarQuery;
public class BaseSerialNoop;
public class BaseSerialDiscard;</pre>

<p>The factory creates all the supported types. Each base class is a complete
implementation.</p>
<hr />

<h2 style="text-align: center" id="L9703">Package org.epics.ioc.pvAccess</h2>
<hr />

<h3 id="L9707">pvAccess Server</h3>

<p>This allows a pvAccess client to access JavaIOC records.</p>

<h3 id="L9711">pvAccess client</h3>

<p>This allows code in the JavaIOc to access remote pvAccess servers.</p>
<hr />

<h2 style="text-align: center" id="L9717">Package org.epics.ioc.pvCopy</h2>
<hr />

<h3 style="text-align: center" id="L9721">Overview</h3>

<p><span style="font-weight:bold;">NOTE FOR Casual Users</span>: For users that
just want to create pvRequest arguments for pvAccess skip to the next
section.</p>

<p>This package provides support for copying PVData between a client and
server. For example the client can be a pvAccess client and the server a
pvAccess server. It allows a client to access an arbitrary set of fields of a
PVRecord that exists on the server. This package does not provide support for
transfering the data between client and server but provides support for code
that does, e. g. it can be used by channel access. In the examples below the
data transfer code is called channel access.</p>

<p>The Channel interface provided by pvAccess has create calls for each type of
request, e. g. createChannelGet, createChannelPut, etc. Each of these has an
argument "PVStructure pvRequest". The pvRequest describes two things: 1) The
set of fields of the record to which the channel is connected, and 2) record
and field options. This package provides two services: 1) a utility method
that, given a specially encoded string, creates a pvRequest structure that can
be passed to the Channel create methods. and 2) Implements the mapping between
the client request fields and the record.</p>

<p>The next section describes the utility for creating a pvRequest. This is the
only section of interest to users. The remaining sections are of interest to
developers including developers who create new services.</p>

<p>The third section describes the layout of a pvRequest structure. This is of
interest to developers of client applications that use new services.</p>

<p>The remaining sections describe the code implemented by this package.</p>

<p>This package uses the field offsets provided by PVField and also requires
that user code creates a org.epics.pvData.misc.BitSet.</p>

<p>PVField provides support for locating a field within a PVStructure or
PVRecord via a field offset. PVField provides the methods:</p>
<dl>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every field
      within the PVStructure has a unique offset. The top level structure has
      an offset of 0. The first field within the structure has offset equal to
      1. The other offsets are determined by recursively traversing each
      structure of the tree.</dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then this
      is just offset + 1. If the field is a structure it is the offset of the
      next field after this structure. Thus (nextOffset - offset) is always
      equal to the number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is equal to
      nextFieldOffset - fieldOffset. </dd>
</dl>

<p>A BitSet which has a bit for each field of a top level PVStructure can be
created via:</p>
<pre>    BitSet bitSet = new BitSet(pvStructure.getNumberFields());</pre>

<p>The offsets for bitSet match the fieldOffsets. On the client side of Channel
Access only a BitSet created from the PVStructure is required. On the server
side PVCopy provides a way to map between the field in a PVRecord and the
fields in the PVStructure. A copy of the PVStructure resides on both the
Channel Access client and server. The client and server exchange data via these
two PVStructures. PVCopy maps between the PVStructure and the PVRecord on the
server side of Channel Access. </p>

<p>This package provides the following:</p>
<dl>
  <dt>BitSetUtil</dt>
    <dd>An interface that curently has only one method, compress, which
      optimizes the bit settings for a PVStructure.</dd>
  <dt>PVCopy</dt>
    <dd>An interface for mapping between a PVRecord and a PVStructure that
      contains data for a subset of the fields in the PVRecord.</dd>
  <dt>PVCopyMonitor</dt>
    <dd>An interface for monitoring changes to fields of the PVRecord that have
      a corresponding field in PVStructure.</dd>
  <dt>PVCopyFactory</dt>
    <dd>The factory that implements PVCopy. It accepts a PVStructure that
      describes the set of fields of a PVRecord that should be mapped.</dd>
  <dt>PVShareFactory</dt>
    <dd>A factory that replaces a PVField with an implementation that accesses
      the data from a shared field.</dd>
</dl>

<h3 style="text-align: center" id="L9791">Request String</h3>

<p>Issuing the request:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest(String request,this);</pre>

<p>creates a pvRequest argument for the various create methods provided by
interface Channel. NOTE: The full path is
org.epics.ca.client.CreateRequestFactory. </p>

<h4 id="L9799">Simple Requests</h4>

<p>Before starting lets first give some examples that satisfy clients such as
Synoptic Display, Alarm, and Archive tools. These clients only want access to
some combination of the following fields: value, alarm, timeStamp, display, and
control. If the request is for a record that has these all as top level fields
the request string is just a comma separated list of the field names. For
example:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("value,alarm,timeStamp",this);</pre>

<p>If the record is does not have the desired field at the top level then the
field can still be accessed with a simple string. For example:</p>
<pre>    pvRequest = CreateRequestFactory.createRequest("power.value,alarm,timeStamp,power.display",this);</pre>

<p>Will get the top level alarm and timeStamp and the value and alarm from a
structure named power. Thus the above works for a record that is structured as
follows:</p>
<pre>powerSupply
    alarm
    timeStamp
    power
       value
       display
       ...
    ...</pre>

<p>The only option most clients want is to request that a record be processed
as part of a get or put requests. This is done via requests like the
following:</p>
<pre>    pvRequest = CreateRequestFactory.createRequest("record[process=true]field(value,alarm,timeStamp)",this);</pre>

<h4 id="L9817">Full Request Syntax</h4>

<p>A request is of the form:</p>
<pre>    record[option,...]field(fieldDef,...)putField(fieldDef,...)getField(fieldDef,...)
    OR
    fieldDef,...</pre>

<p>Thus a request consists of record options and sets of field definitions or
just field definitions. A <span style="font-family: Courier">record</span>
option is of the form:</p>
<pre>    record[name=value,...]</pre>

<p>This will generate the equivalent of :</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scaler name = "name" scalarType = "string"&gt;value&lt;/scalar&gt;
         &lt;!-- other options --&gt;
    &lt;/structure&gt;</pre>

<p>A <span style="font-family: Courier">field,putFeld,getField</span> is a
comma separated set of <span style="font-family: Courier">fieldDefs</span>
which are of the form:</p>
<pre>    fullFieldName[option,...]    // options are optional</pre>
or 
<pre>    fieldName{request}     // recursive definition</pre>

<p>A <span style="font-family: Courier">fullFieldName</span> is the full name
of a field in the PVRecord. The name in a generated data structure will have
just the field name. If <span
style="font-family: Courier">fieldName{request}</span> is given then the
generated data structure will have a structure field with subfields. Note that
<span style="font-family: Courier">request</span> is a recursive definition.</p>

<p>If request is null or an empty string than the entire PVRecord is
selected.</p>

<h4 id="L9861">Examples</h4>

<p>The following examples are for either a simple record or for a power supply
record. These are records that have one of the following structures:</p>
<pre>simpleRecord
    value
    alarm
    timeStamp
    display
    .. other fields like input, etc

powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields</pre>

<h5 id="L9867">Simple example</h5>

<p>The following gets the alarm, timeStamp, and power.value.</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("alarm,timeStamp,power.value",this);</pre>

<p>The following does the same thing.</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("field(alarm,timeStamp,power.value)",this);</pre>
<pre></pre>

<p>In either case the PVStructure holding data for the requester will have the
structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it will
not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for the
value field will be given.</p>
<pre>     PVStructure pvRequest = CreateRequestFactory.createRequest{
        "record[process=true]field(alarm,timeStamp,power.value[shareData=true])",this);</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h5 id="L9891">Power Supply Example</h5>

<p>The following:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest(
       "field(alarm,timeStamp"
       + ",power{power.value,power.alarm}"
       + ",current{current.value,current.alarm}"
       + ",voltage{voltage.value,voltage.alarm})",this);</pre>

<p>Defines a client structure as follows:</p>
<pre>top
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3 style="text-align: center" id="L9901">pvRequest</h3>

<h4 id="L9903">PVStructure pvRequest</h4>

<p>pvRequest is a PVStructure that describes 1) record options and 2) field
requests and options. It has the following structure:</p>
<pre>    &lt;structure&gt;
        &lt;structure name = "record"&gt;
            &lt;!-- 0 or more options with the definition--&gt;
            &lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "field"&gt; &lt;!-- or putField and separate definition for getField --&gt;
            &lt;!-- 0 or 1 fieldList definition --&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                fullPVRecordFieldName,...,fullPVRecordFieldName
            &lt;/scalar&gt;
            &lt;!-- 0 or more fieldName definitions of the form --&gt;
            &lt;structure name = "fieldName"&gt;
                 &lt;!-- 0 or 1 definition of --&gt;
                 &lt;structure name = "leaf"&gt;
                     &lt;scalar name = "source" scalarType = "string"&gt;
                          fullPVRecordFieldName
                     &lt;/scalar&gt;
                     &lt;!-- 0 or more options for field --&gt;
                 &lt;/structure&gt;
                 &lt;!-- If not a leaf than 1 or more--&gt;
                 &lt;structure name = "fieldName"&gt;
                     &lt;!-- recursive definition of field--&gt;
                 &lt;/structure&gt;
            &lt;/structure
        &lt;/structure
    &lt;/structure&gt;

     OR
    &lt;structure&gt;
        &lt;!-- 0 or 1 fieldList definition --&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
            fullPVRecordFieldName,...,fullPVRecordFieldName
        &lt;/scalar&gt;
        &lt;!-- 0 or more fieldName definitions of the form --&gt;
        &lt;structure name = "fieldName"&gt;
            &lt;!-- 0 or 1 definition of --&gt;
            &lt;structure name = "leaf"&gt;
                &lt;scalar name = "source" scalarType = "string"&gt;
                    fullPVRecordFieldName
                &lt;/scalar&gt;
                &lt;!-- 0 or more options for field --&gt;
            &lt;/structure&gt;
            &lt;!-- If not a leaf than 1 or more--&gt;
            &lt;structure name = "fieldName"&gt;
                &lt;!-- recursive definition--&gt;
            &lt;/structure&gt;
        &lt;/structure
    &lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">record</span></dt>
    <dd>The options that apply to the entire record.</dd>
  <dt><span style="font-family: Courier">option</span></dt>
    <dd>This is of the form 
      <pre>&lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;</pre>
    </dd>
  <dt><span style="font-family: Courier">field</span></dt>
    <dd>Definitions that select fields of the PVRecord and options for the
      fields. This definition is recursive.</dd>
  <dt><span style="font-family: Courier">fieldList</span></dt>
    <dd>A comma separated list of fullPVRecordFieldNames. Each will become a
      single field in the structure created by PVCopy with a field name that is
      the same as the field name of the corresponding fullPVRecordFieldName.
      For example if the fullPVFieldName = "power.value" then the field name is
      "value". </dd>
  <dt><span style="font-family: Courier">fieldName</span></dt>
    <dd>The field name that will appear in the PVStructure that is a copy of
      the fields selected from the PVRecord. </dd>
  <dt><span style="font-family: Courier">leaf</span></dt>
    <dd>This definition is a leaf element in the pvRequest structure. The field
      name in the copy structure will be fieldName. The field type will be is
      same as the type of fullPVRecordFieldName. This it could be a
    structure.</dd>
  <dt><span style="font-family: Courier">fullPVRecordFieldName</span></dt>
    <dd>The full fieldname of PVRecord to which the field of copy will map.</dd>
</dl>

<p>Note:</p>
<ul>
  <li>The definition is recursive , i.e. an arbitarily complex structure can be
    defined.</li>
  <li>If options are required for a field than fieldList can not be used.</li>
  <li>If a pvRequest with no fields is specified than all fields if the target
    PVRecord will appear in the PVCopy.</li>
</ul>

<p>Two examples of options are process and shareData.</p>

<p>Process is a record option:</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;</pre>

<p>For example if process is an option to createGet then the record will be
processed before data is fetched. NOTE: scalarType boolean is also
supported.</p>

<p>The following is an example of a field option:</p>
<pre>   &lt;structure name = "field"&gt;
       ...
       &lt;structure name = "value"&gt;
           &lt;structure name = "leaf"&gt;
              &lt;scalar name = "source" scalarType = "string"&gt;value&lt;/scalar&gt;
              &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
           &lt;/structure&gt;
       &lt;/structure&gt;
       ...
   &lt;/structure&gt;</pre>

<p>This is a request to share the actual data rather than creating a copy.</p>

<p>A pvRequest structure can be created via the PVDataCreate interface
implemented by PVDataCreateFactory or by a call to
CreateRequestFactory.createRequest.</p>

<h4 id="L9984">Examples</h4>

<p>The following examples are for the simple and powerSupply records described
in the previous section.</p>

<h5 id="L9988">Simple example</h5>

<h6 id="L9990">The quickest Way</h6>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       alarm,timeStamp,power.value
    &lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following shows how example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvRequest,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvRequest.appendPVField(pvString);
 </pre>

<h6 id="L10000">Using the field notation</h6>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp,power.value
        &lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how the example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvField.appendPVField(pvString);
    pvRequest.appendPVField(pvField);
 </pre>

<p>In either case (quickest way or using the field notation) the PVStructure
holding data for the requester will have the structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it will
not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for the
value field will be given.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "record"&gt;
        &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp
        &lt;/scalar&gt;
        &lt;structure name = "value"&gt;
            &lt;scalar name = "leaf" scalarType = "string"&gt;power.value&lt;/scalar&gt;
            &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h5 id="L10022">Power Supply Example</h5>

<p>The following structure defines a request for alarm, timeStamp, power,
current, and voltage. Power, current, and voltage will each be a structure with
two fields: value and alarm.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;alarm,timeStamp&lt;/scalar&gt;
        &lt;structure name = "power"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                power.value,power.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "current"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                current.value,current.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "voltage"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                voltage.value,voltage.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how this can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVString pvString = (PVString)pvDataCreate.createPVField(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp");
    pvField.appendPVField(pvString);
    PVStructure pvStructure = pvDataCreate.createPVStructure(pvField, "power", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList",ScalerType.pvString);
    pvString.put("power.value,power.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "current", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("current.value,current.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "voltage", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("voltage.value,voltage.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvRequest.appendField(pvField);</pre>

<p>In either case the resulting structure that appears to the client has the
form:</p>
<pre>pvData
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3 style="text-align: center" id="L10036">PVCopy</h3>

<p>This is the interface for mapping between a PVStructure that contain a copy
of the data for a subset of the fields in a PVRecord. Note that this interface
is NOT for a single PVStructure but for a single PVRecord and a single
Structure introspection interface that describes a subset of the fields in the
PVRecord. For example if a server supports monitor queues then the server will
allocate a PVStructure for each queue element but will create a single
PVCopy.</p>
<pre>    interface PVCopy {
        PVRecord getPVRecord();
        Structure getStructure();
        PVStructure createPVStructure();
        int getCopyOffset(PVField recordPVField);
        int getCopyOffset(PVStructure recordPVStructure,PVField recordPVField);
        PVField getRecordPVField(int structureOffset);
        void initCopy(PVStructure pvCopy, BitSet bitSet,boolean recordLocked);
        void updateCopySetBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        void updateCopyFromBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        boolean updateRecord(PVStructure pvCopy,BitSet bitSet,boolean lockRecord);
        PVCopyMonitor createPVCopyMonitor(PVCopyMonitorRequester pvCopyMonitorRequester);
    }</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getPVRecord</span></dt>
    <dd>Get the PVRecord to which this PVCopy is attached</dd>
  <dt><span style="font-family: Courier">getStructure</span></dt>
    <dd>Get the introspection interface which describes the subset of the
      fields in the PVRecord.</dd>
  <dt><span style="font-family: Courier">createPVStructure</span></dt>
    <dd>Create a PVStructure which can hold a subset of the data from the
      PVRecord. A client may require multiple PVStructures. For example if a
      monitor request supports a queue than a PVStructure is required for each
      queue element. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVField
  recordPVField)</span></dt>
    <dd>Given a PVField from the record determine the offset within the
      PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getCopyOffset(PVStructure
  recordPVStructure,PVField recordPVField)</span></dt>
    <dd>Given a recordPVField within a recordPVStructure determine the offset
      within the PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt><span style="font-family: Courier">getRecordPVField</span></dt>
    <dd>Given an offset within a PVStructure return the corresponding PVField
      in the PVRecord.</dd>
  <dt><span style="font-family: Courier">initCopy</span></dt>
    <dd>Initialize PVStructure with the current data from the PVRecord. The
      bitSet will have offset 0 set to 1 and all other bits set to 0. </dd>
  <dt><span style="font-family: Courier">updateCopySetBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. The BitSet shows which fields in
      PVStructure have changed.</dd>
  <dt><span style="font-family: Courier">updateCopyFromBitSet</span></dt>
    <dd>Update PVStructure from PVRecord. Only fields that have the offset in
      bitSet set to true are modified.</dd>
  <dt><span style="font-family: Courier">updateRecord</span></dt>
    <dd>Update the fields in PVRecord with data from PVStructure. Only fields
      that have the offset in bitSet set to true are modified. </dd>
  <dt><span style="font-family: Courier">createPVCopyMonitor</span></dt>
    <dd>Create a PVCopyMonitor. See next section.</dd>
</dl>

<h3 style="text-align: center" id="L10111">PVCopyMonitor</h3>

<p>PVCopyMonitor is a PVListener for the PVRecord to which PVCopy is attached.
It updates two bitSets when it receives PVListener.dataPut callbacks. changeBit
shows all fields that have changed between calls to switchBitSets.
overrunBitSet shows all fields that have changed value more than once between
calls to switchBitSets. It notifies the PVCopyMonitorRequester when data has
changed. </p>
<pre>interface PVCopyMonitorRequester {
    void dataChanged();
    void unlisten();
}

interface PVCopyMonitor {
    void startMonitoring(BitSet changeBitSet, BitSet overrunBitSet);
    void stopMonitoring();
    void switchBitSets(BitSet newChangeBitSet,BitSet newOverrunBitSet, boolean lockRecord);
}</pre>

<p>PVCopyMonitorRequester is the interface implemented by the caller that calls
PVCopy.createPVCopyMonitor:</p>
<dl>
  <dt><span style="font-family: Courier">dataChanged</span></dt>
    <dd>Data being monitored has changed.</dd>
  <dt><span style="font-family: Courier">unlisten</span></dt>
    <dd>PVCopyMonitor has been told to unlisten so not more monitors will
      occur. </dd>
</dl>

<p>PVCopyMonitor is the interface returned by a call to
PVCopy.createPVCopyMonitor.</p>
<dl>
  <dt><span style="font-family: Courier">startMonitoring</span></dt>
    <dd>Start monitoring.</dd>
  <dt><span style="font-family: Courier">stopMonitoring</span></dt>
    <dd>Stop monitoring.</dd>
  <dt><span style="font-family: Courier">switchBitSets</span></dt>
    <dd>If the pvStructure is not shared all fields that changeBitSet shows
      were changed are copied from the corresponding PVField of the PVRecord to
      the PVField of the PVStructure. Then the bitSets are replaced by the new
      bitSets. Note that a client needs just two instances of the bitSets and
      can just cycle between the two sets. Even if the PVStructure is shared
      this method is important since the caller will not miss data changes. It
      is illegal to call this if startMonitoring was called with no
    arguments.</dd>
</dl>

<h3 style="text-align: center" id="L10153">PVCopyFactory</h3>

<h4 id="L10155">Java Definition</h4>
<pre>    class PVCopyFactory {
        static PVCopy create(PVRecord pvRecord,PVStructure pvRequest,String structureName);
    }</pre>

<p><span style="font-family: Courier">create</span> has the arguments</p>
<dl>
  <dt><span style="font-family: Courier">pvRecord</span></dt>
    <dd>The PVRecord to which the server is attached.</dd>
  <dt><span style="font-family: Courier">pvRequest</span></dt>
    <dd>A PVStructure which describes the fields of PVRecord to which the
      server wants access. It is described below.</dd>
  <dt><span style="font-family: Courier">structureName</span></dt>
    <dd>This must be one of: "field", "putField", or "getField"</dd>
  <dt><span style="font-family: Courier">request</span></dt>
    <dd>As defined in previous examples.</dd>
  <dt><span style="font-family: Courier">requester</span></dt>
    <dd>Definition is in org.epics.pvData.pv.Requester.</dd>
</dl>

<p><span style="font-family: Courier">createRequest</span> is an easy way to
create a pvRequest structure to pass to <span
style="font-family: Courier">create</span>. It is described above.</p>

<h3 style="text-align: center" id="L10201">PVShare</h3>

<p>This is a factory that replaces a scalar or scalarArray field with a version
that shares the data from another field. When a get or put is issued the get or
put method of the shared PVField is called.</p>
<pre>class PVShareFactory {
    public static PVScalar replace(PVScalar pvNow,PVScalar pvShare);
    public static PVArray replace(PVArray pvNow,PVArray pvShare);
}</pre>
<hr />

<h2 style="text-align: center" id="L10209">Package org.epics.ioc.monitor</h2>
<hr />

<h3 style="text-align: center" id="L10213">Overview</h3>

<p>Package org.epics.pvData.monitor defines the monitor interfaces as seen by a
client. See that package overview for details. This package implements the
monitoring interfaces for a PVRecord.</p>

<p>The implementation uses PVCopy and PVCopyMonitor which are implemented in
package org.epics.ioc.pvCopy. When PVCopyMonitor tells monitor that changes
have occurred, monitor applies the appropriate algorithm to each changed field
and if any algorithm says to raise a monitor a monitor is sent to the
client.</p>

<p>This package implements support for the following monitor algorithms:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued whenever a put is issued to the field. This is the
      default unless the record defines deadbands for a field. An exception is
      the top level timeStamp which by default is made onChange and monitor
      will not be raised.</dd>
  <dt>onChange</dt>
    <dd>This provides two options: 1) A monitor is raised whenever a field
      changes value, and 2) A monitor will never be raised for the field.</dd>
  <dt>deadband</dt>
    <dd>The field must be a numeric scalar. Whenever the absolute or percentage
      value of the field changes by more than a deadband a monitor is issued.
      The record instance can also define deadbands.</dd>
  <dt>periodic</dt>
    <dd>A monitor is issued at a periodic rate if a put was issued to any field
      being monitored.</dd>
</dl>

<h3 style="text-align: center" id="L10242">Implementing New Monitor
Algorithms</h3>

<p>This section discusses how to implement new monitor algorithms in addition
to the onPut, onChange, etc, implemented by this package.</p>

<p>The monitor algorithm must register by calling:</p>
<pre>    MonitorFactory.registerMonitorAlgorithmCreater(MonitorAlgorithmCreate monitorAlgorithmCreate)</pre>

<p>The implementation must implement interfaces <span
style="font-family: Courier">MonitorAlgorithmCreate</span> and <span
style="font-family: Courier">MonitorAlgorithm</span> which are described
below.</p>

<h4 id="L10258">MonitorFactory</h4>

<p>This is a request to create a monitor.</p>
<pre>class MonitorFactory {
    static Monitor create(PVRecord pvRecord,
        MonitorRequester monitorRequester,PVStructure pvRequest);
    static void registerMonitorAlgorithmCreater(MonitorAlgorithmCreate monitorAlgorithmCreate)
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">create</span></dt>
    <dd>Create a monitor. The arguments are: 
      <dl>
        <dt><span style="font-family: Courier">pvRecord</span></dt>
          <dd>The record being monitored.</dd>
        <dt><span style="font-family: Courier">monitorRequester</span></dt>
          <dd>The monitor requester. This is the code to which monitot events
            will be delivered.</dd>
        <dt><span style="font-family: Courier">pvRequest</span></dt>
          <dd>The request options</dd>
      </dl>
    </dd>
  <dt><span
  style="font-family: Courier">registerMonitorAlgorithmCreater</span></dt>
    <dd>Called by code that implements a monitor algorithm.</dd>
</dl>

<h4 id="L10298">MonitorAlgorithm</h4>

<p>The following are implemented by code that implements a monitor
algorithm.</p>
<pre>interface MonitorAlgorithmCreate {
    String getAlgorithmName();
    MonitorAlgorithm create(
            PVRecord pvRecord,
            MonitorRequester monitorRequester,
            PVField fromPVRecord,
            PVStructure pvOptions);
}

interface MonitorAlgorithm  {
    String getAlgorithmName();
    boolean causeMonitor();
    void monitorIssued();
}</pre>

<p>where</p>
<dl>
  <dt><span style="font-family: Courier">getAlgorithmName</span></dt>
    <dd>return the name of the algorithm.</dd>
  <dt><span style="font-family: Courier">causeMonitor</span></dt>
    <dd>Called to see if a change to this field should cause a monitor</dd>
  <dt><span style="font-family: Courier">monitorIssued</span></dt>
    <dd>Called after a monitor has been issued.</dd>
</dl>
<hr />

<h2 style="text-align: center" id="L10327">Package org.epics.ioc.caV3</h2>
<hr />

<h3 style="text-align: center" id="L10331">Overview</h3>

<p>This package provides support for Channel Access Version 3. The server
allows an existing Channel Access client to access a javaIOC database. The
client allows the javaIOC to communicate with a Version 3 server, e.g. a
javaIOC database can have links to records in a V3 IOC database.</p>

<p>In order to be available to a javaIOC, each must be started via the
appropriate factory. This is just a call to the start method. For example:</p>
<pre>    org.epics.ioc.caV3.ClientFactory.start();</pre>

<p>The client must be started before the IOC is started and the server after.
The javaIOC overview provides instructions for using XMLToDatabase to start
everything.</p>

<p>Both the client and server use the JCA/CAJ support provided by <a
href="http://jca.cosylab.com">cosylab</a>. In addition the server uses the CAS
support that comes with the latest versions of JCA/CAJ.</p>

<h3 style="text-align: center" id="L10346">Server</h3>

<h4 id="L10348">Syntax</h4>

<p>A V3 client can access any field of a javaIOC record that is a scalar, an
array of scalars, or an enumerated structure. A boolean field appears as a
DBR_ENUM with choices = {"false","true"}.</p>

<p>A pvName has the form:</p>
<pre>    recordName.name.name...{options}</pre>

<p>where</p>
<dl>
  <dt><span
  style="font-family: Courier New,Courier,monospace;">recordName</span></dt>
    <dd>The name of a javaIOC record</dd>
  <dt><span
  style="font-family: Courier New,Courier,monospace;">name.name...</span></dt>
    <dd>Each name is a fieldName or propertyName or index as described in
      package org.epics.ioc.pv. The final field must a scalar, an array of
      scalars, or an enumerated structure.</dd>
  <dt><span
  style="font-family: Courier New,Courier,monospace;">options</span></dt>
    <dd>options are of the form "name=value". The options are described
    below.</dd>
</dl>

<p>The following examples use the channel access utility shell commands that
come with EPICS base. The database is the example/exampleDB.xml that comes with
the javaIOC. </p>
<pre>    caput double 6</pre>

<p>This writes the value 6 to the value field of a record named double.</p>
<pre>    caput double.{process=true} 5</pre>

<p>This writes the value 5 to record double and also requests that the record
be processed. The value is written before the record is processed.</p>
<pre>     caget -d 20 double.{process=true}</pre>

<p>This gets the value field of record double. The record is processed.</p>
<pre>    caput powerSupplyArray.supply.1.power{process=true} 2</pre>

<p>This writes the value 2 to the power.value field of the second supply of the
powerSupplyArray record.</p>

<h4 id="L10395">Get and Put Options</h4>

<p>The currently supported options are:</p>
<pre>    process=true
    shareData=true</pre>

<p>For get the record is processed before the get and for put the record is
processed after the put. In order for either to work, the record must not
already have a recordProcessor assigned to it.</p>

<h4 id="L10403">monitor options</h4>

<p>Currently no options are supported. </p>

<h3 style="text-align: center" id="L10407">Client</h3>

<h4 id="L10409">Overview</h4>

<p>The client code implements a ChannelProvider that communicates with Channel
Access version 3 IOCs. It allows access to all the V3 data types. The provider
name is "caV3". </p>

<p>The channelName is of the form recordName.fieldName, where fieldName is
optional. See naming conventions below for details.</p>

<p>The client code implements the standard ChannelProvider interface as defined
by cajV4. This means that it also implements interface Channel. However only
the features that make sense for caV3 are implemented. </p>

<p>For Channel the implementation of the following methods is:</p>
<dl>
  <dt><span style="font-family: courier;">getField</span></dt>
    <dd>Returns a Structure. The structure has a field named "value", which is
      related to the fieldName of the channel. The type of the value field
      depends on the caV3 native type. If the type is DBR_ENUM then the value
      field will be an enumerated structure. For the other DBR types the value
      field will be either a scalar or an array depending of the DBR type. The
      scalarType of the field will match the DBR type. For all types the
      Structure will have fields timeStamp and alarm, which are the standard
      timeStamp and alarm structures. If the native DBR Type is numeric then
      the Structure will also have structure fields for control and
    display.</dd>
  <dt><span style="font-family: courier;">getChannelProcess</span></dt>
    <dd>Not supported.</dd>
  <dt><span style="font-family: courier;">createChannelArray</span></dt>
    <dd>Not supported.</dd>
  <dt><span style="font-family: courier;">createChannelGet</span></dt>
    <dd>Supported. Also support for alarm, timeStamp, display, and control.</dd>
  <dt><span style="font-family: courier;">createChannelPut</span></dt>
    <dd>Supported but no support for properties.</dd>
  <dt><span style="font-family: courier;">createChannelPutGet</span></dt>
    <dd>Not supported.</dd>
  <dt><span style="font-family: courier;">createMonitor</span></dt>
    <dd>Supported. Also support for alarm and timeStamp. Note that a single get
      request is made after connection so that enum choices and control and
      display information can be obtained. For a numeric value field support
      for display and control is implemented. Note that the display and control
      information will not change. This matches the caV3 semantics.</dd>
</dl>

<p></p>

<h4 id="L10464">Naming conventions.</h4>

<p>A PV Name (Process Variable Name) must be of the form:</p>
<pre>    recordName.fieldName</pre>

<p>where</p>
<dl>
  <dt>recordName</dt>
    <dd>Is the name of a record in a V3 IOC database.</dd>
  <dt>fieldName</dt>
    <dd>Must be a valid caV3 fieldname like VAL or RVAL. It is optional since
      it is optional for v3.</dd>
</dl>

<p>The pvRequest passed to createChannelGet, createChannelPut, and
createMonitor must define a request that makes sense for a v3 record. For all
three the request should include the definition for a value field, which is
associated with the fieldName of the pvName. For all it is OK to attach to a
record which has a VAL field that is a DBR_ENUM. In this case the value can be
retrieved as an enumerated structure or just the index or string value can be
retrieved.</p>

<p>The following request structure will get the value, alarm, and timeStamp:</p>
<pre>&lt;structure name = "request"&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       value,alarm,timeStamp
    &lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following will access the index of an DBR_ENUM:</p>
<pre>&lt;structure name = "request"&gt;
     &lt;scalar name = "value" scalarType = "string"&gt;value.index&lt;/scalar&gt;
     &lt;scalar name = "alarm" scalarType = "string"&gt;alarm&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following will access the choice of an DBR_ENUM:</p>
<pre>&lt;structure name = "request"&gt;
     &lt;scalar name = "value" scalarType = "string"&gt;value.choice&lt;/scalar&gt;
     &lt;scalar name = "alarm" scalarType = "string"&gt;alarm&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<h4 id="L10497">Data Types Supported</h4>

<p>The V3 data types are supported via a corresponding javaIOC data type. A V3
<span style="font-family: Courier New,Courier,monospace;">char</span> is a
javaIOC <span style="font-family: Courier New,Courier,monospace;">byte</span>.
The types <span style="font-family: Courier New,Courier,monospace;">short, int,
float, and doubl</span>e are common to both. A V3 <span
style="font-family: Courier New,Courier,monospace;">string</span> becomes a
javaIOC <span
style="font-family: Courier New,Courier,monospace;">String</span>. Arrays of
byte,short,...,string are also supported. A V3 <span
style="font-family: Courier New,Courier,monospace;">ENUM</span> becomes a
javaIOC enumerated structure. V3 properties (status, severity, timeStamp,
display limits, and control limits) become standard pvData structures (alarm,
timeStamp, display, and control).</p>

<h4 id="L10519">Implementation Overview</h4>

<p>The implementation consists of the following classes.</p>
<dl>
  <dt>ClientFactory</dt>
    <dd>This implements ChannelProvider. It creates instances of BaseV3Channel
      when a client calls createChannel. It creates a JCA Context that is used
      for all channels. It also listens for JCA Context Exceptions and
      Messages. In spawns a thread that issues a JCA poll request at regular
      intervals.</dd>
  <dt>BaseV3Channel</dt>
    <dd>This implements the Channel interface. It creates a JCA Channel and
      handles the JCA connection events. It does NOT implement
      createChannelProcess, createChannelArray, or createChannelPutGet.</dd>
  <dt>BaseV3ChannelStructure</dt>
    <dd>This handles conversion between caV3 data and pvAccess data..</dd>
  <dt>BaseV3ChannelPut</dt>
    <dd>Implements a put request.</dd>
  <dt>BaseV3ChannelGet</dt>
    <dd>Implements a get request.</dd>
  <dt>BaseV3ChannelMonitor</dt>
    <dd>Implements a monitor request. Note that it issues a single get to
      obtain enumerated choices and display and control information.</dd>
</dl>
</body>
</html>
