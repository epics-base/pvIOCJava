<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS pvIOCJava</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
  /*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     span.opt { color: grey }
     span.nterm { font-style:italic }
     span.term { font-family:courier }
     span.user { font-family:courier }
     span.user:before { content:"<" }
     span.user:after { content:">" }
     .nonnorm { font-style:italic }
     p.ed { color: #AA0000 }
     span.ed { color: #AA0000 }
     p.ed.priv { display: inline; }
     span.ed.priv { display: inline; }
  /*]]>*/</style>
  <!-- Script that generates the Table of Contents -->
  <script type="text/javascript"
  src="http://epics-pvdata.sourceforge.net/script/tocgen.js">
 </script>
</head>

<body>

<div class="head">
<h1>EPICS pvIOCJava</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date. -->

<h2 class="nocount">EPICS v4 Working Group, Working Draft, 12-Mar-2013</h2>
<dl>
  <dt>Latest version:</dt>
    <dd><a
      href="pvIOCJava.html">pvIOCJava.html</a>
    </dd>
  <dt>This version:</dt>
    <dd><a
      href="pvIOCJava_20130312.html">pvIOCJava_20130312.html</a>
    </dd>
    <dt>Previous version:</dt>
    <dd><a
      href="pvIOCJava_20121002.html">pvIOCJava_20121002.html</a>
    </dd>
  <dt>Editors:</dt>
    <dd>Marty Kraimer, BNL</dd>
</dl>
</div>

<h2 class="nocount">Abstract</h2>

<p>pvIOCJava is the Java implementation of a pvIOC, which is one of a related
set of products:<br />
<a href="http://epics-pvdata.sourceforge.net/relatedDocumemntsV4.html">relatedDocumentsV4.html</a>
</p>

<h2 class="nocount">Status of this Document</h2>

<p>This is the 12-Mar-2013 version of the Java implementation of pvIOC. It is a
complete implementation of pvIOC as currently defined.</p>
<p>This version is part of the effort to unbundle <b>swtshell</b>
and <b>portDriver</b> and make them seperate projects.
<b>portDriver</b> needs more work before it works as a separate project.
<b>swtshell</b> now works as an unbundled product.
The documentation for both projects has been removed from this project
but not the code. When both are working the code will also be removed.</p>
<p><b>swtshell</b> now only works as a remote shell.
In order to keep all the functionality of the local shell some
additional support had to be implemented in this project.
The main change since the last version was to implement this additional
support. The other changes were to fix some problems encountered
while developing the additional support.</p>
<p>This document requires lots of work to make it easier to understand.</p>

<div id="toc">
<h2 class="nocount" style="page-break-before: always">Table of Contents</h2>
</div>

<div id="contents" class="contents">

<div>
<h2>Introduction</h2>

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This document is the project and package overviews for pvIOCJava. The
javaDOC is available at <a href="./html/index.html">JavaDoc</a></p>

<p><b>NOTE</b> Originally epics-pvdata was called javaIOC and consisted of a
single eclipse project named javaIOC. This project is the IOC portion of the
original javaIOC.</p>

<p>A pvIOCJ is a network accessable smart real time database. A database has
memory resident records which can link to hardware or to other records. A
record has a top level PVStructure, which is a structured set of fields. A
record can be processed, i.e. asked to do something. Each field has an object
which implements interface PVField that provides access to the field's data.
Each field of a record can optionally have associated support, which is defined
by a Java interface called Support. One of the methods of Support is named
process. When a process request is made the process method of each field
support is called. Support is what makes the database a "smart" database.</p>

<p>The pvIOCJava project uses project pvDataJava, which provides the data, and
pvAccessJava, which provides network support for pvData. This package assumes
that you are familiar with pvDataJava and pvAccessJava.</p>

<p>An Extensible Markup Language (XML) parser is provided for creating a
PVDatabase. pvIOCJava adds support that allows a PVDatabase to become a smart
soft realtime database. pvIOCJava attaches support code to every record and
optionally to any field of a record. The support is configured via xml
definitions. A structure defining support provides the name of a Java factory
that creates support for a field.</p>

<p>A simple example of a record instance is :</p>
<pre>&lt;record recordName = "simple"&gt;
  &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<p>When the ioc adds a new record to the database it looks for support attached
to the record. If it does not find any, it assigns generic support. The simple
example without defaults would be:</p>
<pre>&lt;record recordName = "simple" &gt;
  &lt;auxInfo name = "supportFactory" scalarType =   
     "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;scalar name = "value" scalarType = "double"/&gt;
&lt;/record&gt;</pre>

<p>The definition for generic is:</p>
<pre>&lt;structure structureName = "genericFactory"&gt;
  &lt;scalar name = "supportFactory" scalarType = "string"&gt;
     org.epics.pvioc.support.basic.GenericFactory&lt;/scalar&gt;
&lt;/structure&gt;
&lt;structure structureName = "generic"&gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;genericFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<p>Thus generic is a structure that has no fields and support named generic.
</p>

<p>The overview portion of this document has four parts:</p>
<ul>
  <li>Part I is a brief description of pvIOCJava.</li>
  <li>Part II describes pvIOCJava Data Model. The model: 
    <ul>
      <li>Supports general purpose tools.</li>
      <li>Can be used to implement network based services.</li>
      <li>Is used by pvIOCJava support code.</li>
    </ul>
  </li>
  <li>Part III is a description of the Database Definitions that come with
    pvIOCJava.</li>
  <li>Part IV is a description of specific packages that belong to the
    pvIOCJava.</li>
</ul>

<h2>Part I: pvIOCJava - Brief Description</h2>

<p>Part I describes pvIOCJava. Detailed descriptions of pvIOCJava packages are
provided with each package.</p>

<h3>Overview Of Part I</h3>

<p><a href="http://www.anl.gov/epics">EPICS</a> is a set of Open Source
software tools, libraries and applications developed collaboratively and used
worldwide to create distributed soft real-time control systems for large
scientific instruments such as a particle accelerators, telescopes, etc. An IOC
(Input/Output Controller) is a network node that controls and/or monitors a
collection of devices. An IOC contains a memory resident real time database.
The real time database has a set of "smart" records. </p>

<p>pvIOCJava is a JAVA implementation of an IOC. It has many similarities to a
EPICS V3 ( the 3.13 and 3.14 releases of EPICS base) but extends the data types
to support structures and arrays and allows any field to optionally have
support.</p>

<h4>Getting Started</h4>

<p>pvIOCJava is developed as an eclipse project. The following assumes that you
have eclipse installed and have imported pvIOCJava into a project named
"pvIOCJava".</p>

<p>In order to use the examples in the pvIOCJava, the environment variables
IOCNAME, PVDATA, and JAVAIOC must be defined. For example on linux define:</p>
<pre>export IOCNAME=laptop
export PVDATA=${HOME}/hg/pvDataJava
export javaIOC=${HOME}/hg/pvIOCJava</pre>

<p>Package <b>org.epics.pvioc</b> has a Java program,
<b>org.epics.pvioc.javaIOC</b>, that does the following:</p>
<ul>
  <li>Is a pvIOC.</li>
  <li>Reads and installs structures and records into the running pvIOC.</li>
  <li>Dumps the resulting structure and record definitions.</li>
  <li>Starts servers.</li>
  <li>Runs forever as a standalone process.</li>
  <li>Invokes swtshell, which is a Graphical User Interface (GUI) shell that
    interacts with a running pvIOC.
     <b>WARNING</b> In the near future this will no longer be supported.
      <b>swtshell</b> is now supported as a separate project that only
      works as a remote shell.
  </li 
 >
</ul>

<p>The arguments to JavaIOC can be any combination of:</p>
<ul>
  <li>-structures <br />
    followed by filenames of files containing XML structure definitions.<br />
  </li>
  <li>-records <br />
    followed by filenames of files containing XML record definitions.<br />
  </li>
  <li>-dumpStructures<br />
    dump the structure, create, and support definitions</li>
  <li>-dumpRecords<br />
    dump the record instances</li>
  <li>-server <br />
    followed by a filenames. Each field is a list of servers to start.
  </li>
  <li>-run<br/>
     Run forever as a standalone process.</li>
  <li>-swtshell<br />
    Start swtshell.</li>
</ul>

<p>For example:</p>
<pre>-structures xml/structures.xml \
-records example/exampleDB.xml \
-dumpStructures \
-dumpRecords</pre>

<p>Reads a set of files creating structures and records and then dumps the
structures and records.</p>

<p>As a first example specify the arguments as:</p>
<pre>    -server server/pvAccessClient.txt server/caV3Client.txt \
    -structures xml/structures.xml \   
    -records example/exampleDB.xml \  
    -server server/pvAccessServer.txt \ 
    -run</pre>

<p>This:</p>
<ul>
  <li>Starts channel access client support for both pvAccess and caV3. pvAccess
    supports pvData. caV3 supports V3 channel access, i.e. it can communicate
    with a V3 epics IOC.</li>
  <li>Loads a set of structures then a set of record instances.</li>
  <li>Starts the pvAccess server. This allows pvAccess clients to access this
    javaIOC. </li>
  <li>Starts running forever.</li>
</ul>
<p>Project:
<a
      href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/swtshellJava/raw-file/tip/documentation/swtshellJava.html">
      swtshellJava.html</a>
is a remote shell for interacting with a pvAccess server. In particular an instance of a
pvIOCJava.
The <b>swtshell</b> project has files to start an example instance of a pvIOCJava and examples
of using <b>swtshell</b> itself. Please see it for getting started.</p>


<p>The remainder of this document gives an overview of pvOCJava:</p>
<ul>
  <li>Java interfaces for accessing records and fields.</li>
  <li>Record processing<br />
    A pvIOCJava has a "smart" real time database. A record instance can have
    associated support code. In addition each field can optionally have
    support. </li>
  <li>Example database definitions and record instances.</li>
</ul>

<h4>Status and Remaining Tasks</h4>

<p>pvIOCJava has both client and server Channel Access support for both caV3
and pvAccess. pvAccess fully supports network access to pvData. Support for
caV3 means that an existing EPICS channel accesss client can access any
primitive field (or an array of primitives) of a javaIOC record and that a
javaIOC record can link to an EPICS IOC.</p>

<p>The existing features means that pvIOCJava is now ready for use at least as
a soft IOC.</p>

<p>The following components are desirable.</p>
<ul>
  <li>Message Server<br />
    javaIOC interfaces provide methods for sending messages to requesters.
    Currently the requesters just write the messages to System.out.
    There is also support for a record that traps all messages and makes them avaliable
    to a pvAccess client. The client can just monitor the record,</li>
  <li>portDriver<br />
    This is in the process of being unbundled from pvIOCJava.
    It needs lots of additional  hardware drivers. Some support is already available but lots needs to be
    done.</li>
</ul>

<p>Additional components are also desirable:</p>
<ul>
  <li>VDCT - A Visual Database Configuration Tool. Cosylab is implementing a
    version of VDCT that supports pvData.</li>
  <li>Access Security - Based on V3 Access Security but extended to properly
    support a javaIOC.</li>
  <li>A javaIOC replacement for the sCalc and arrayCalc that come with
  synAPPS.</li>
  <li>etc, etc.</li>
</ul>

<p>Thus lots of work has been done but lots of work remains.</p>

<h3>Package Summary</h3>

<p>Documentation is provided via javaDOC. This document is the overview for
both pvIOCJava itself and for the various Java packages in pvIOCJava.</p>

<p>The following top level directorys have xml and txt files for starting
JavaIOC:</p>
<dl>
  <dt>xml</dt>
    <dd>This directory and the structures subdirectory contains the xml
      structure definitions for the javaIOC. It also loads the xml definitions
      from pvData.</dd>
  <dt>example</dt>
    <dd>This directory contains the example xml files.</dd>
  <dt>xmltest</dt>
    <dd>This directory has xml files for testing.</dd>
  <dt>service</dt>
    <dd>The text files for stating the pvAccess and caV3 servers.</dd>
</dl>

<p>The packages that currently exists are:</p>
<dl>
  <dt>org.epics.pvioc</dt>
    <dd>This package has the javaIOC class.</dd>
  <dt>org.epics.pvioc.database </dt>
    <dd>This package describes and implements the PVDatabase.</dd>
  <dt>org.epics.pvioc.support</dt>
    <dd>This package provides the framework for processing IOC database
      records. The subpackages of this package provide support that uses the
      framework. Each record instance must have associated support and each
      field of a record instance can optionally have support. </dd>
  <dt>org.epics.pvioc.install</dt>
    <dd>This package provides the code that installs structure and records into
      a javaIOC. It allows new structures or records to be installed into a
      running IOC.</dd>
  <dt>org.epics.pvioc.pvCopy</dt>
    <dd>This package describes and implements support for creating a
      PVStructure that contains a copy of a subset of the fields in a PVRecord.
      It is used by pvAccess.</dd>
  <dt>org.epics.pvioc.monitor</dt>
    <dd>This package describes and implements support for monitoring a subset
      of the fields in a PVRecord. It is a companion to pvCopy and is used by
      pvAccess.</dd>
  <dt>org.epics.pvioc.support.basic</dt>
    <dd>This provides basic support such as noop, generic, etc.</dd>
  <dt>org.epics.pvioc.support.alarm</dt>
    <dd>This provides support for alarms.</dd>
  <dt>org.epics.pvioc.support.caLink</dt>
    <dd>This provides for channel access links, i.e. it allows records to
      get/put/monitor data in other records.</dd>
  <dt>org.epics.pvioc.support.dbLink</dt>
    <dd>This provides for database links, i.e. it allows records to
      get/put/monitor data in other records in this javaIOC.</dd>
  <dt>org.epics.pvioc.support.calc</dt>
    <dd>The provides support for calculations. A calcaulator is support that
      produces a result that is assigned to a value field. Included is support
      named expressionCalculator, which supports scalar expressions that have
      standard Java syntax.</dd>
  <dt>org.epics.pvioc.support.rpc</dt>
    <dd>This provides remote procedure call support for pvAccess channel access
      clients. It provides the special features described in the documentation provided
     with the <b>swtshell</b> project.
    </dd>
  <dt>org.epics.pvioc.support.device</dt>
    <dd>This contains examples of support for "device" abstractions.</dd>
  <dt>org.epics.pvioc.caV3</dt>
    <dd>This package is Channel Access V3, e.g. channel access Version 3.
      The actual work is done by project <b>pvAccessJava</b>.
     </dd>
  <dt>org.epics.pvioc.pvAccess</dt>
    <dd>This package connects pvAccess to the javaIOC. It implements a Channe;
      as described by pvAccess. It can be used directly by other records in the
      same javaIOC for the pvAccess faculities or can be used by remote
      pvAccess to access records in this javaIOC.</dd>
  <dt>org.epics.pvioc.util</dt>
  This package provides utility code for a javaIOC: 
  <dt>Scan Field Support</dt>
    <dd>Support for accessing the scan field of a record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
  <dt>IOCFactory</dt>
    <dd>A factory for creating and initializing IOC records. This can be used
      at IOC initialization or for on-line add of new record instances.</dd>
</dl>
<dl>
  <dt>org.epics.pvioc.pdrv</dt>
    <dd>This and associated packages implement portDriver, which is support for accessing and
      controlling hardware. <b>NOTE:</b> This is being moved to a separate project.</dd>
</dl>

<h3>Database Syntax For javaIOC</h3>

<p>The syntax for both structure and record definitions is XML based. In
addition XML based macro substitution and include is supported. Project pvData
describes the XML syntax. This section gives definitions for a javaIOC
application.</p>

<p>Support is defined via a structure definition. Support is assigned to a
field via an auxInfo attached to the field. For example the definition for
alarm support is:</p>
<pre>&lt;structure structureName = "alarmSupportFactory"&gt;
  &lt;scalar name = "supportFactory" scalarType = "string"&gt;
     org.epics.pvioc.support.alarm.AlarmSupportFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure structureName = "alarm" extends = "org.epics.pvdata.alarm" &gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;alarmSupportFactory&lt;/auxInfo&gt;
&lt;/structure&gt;</pre>

<h3>Channel Access</h3>

<p>Channel Access for pvData is implemented as a separate eclipse project named
pvAccess. See it for details. This project provides the code that implements
the pvAccess Channel interface. It can be used by local records directly or by
the server for remote pvAccess..</p>

<p>This project provides both client and server support for epics V3 channel
access.</p>

<p>For channel access this project has the following features.</p>
<ul>
  <li>Support for attaching pvIOCJava to pvAccess.</li>
  <li>An EPICS V3 Channel Access server is available. Thus Channel Access
    clients can access a javaIOC database.</li>
  <li>EPICS V3 Channel Access client code is implemented by pvAccessJava. This
    allows the javaIOC to communicate with an EPICS IOC.</li>
  <li>Link support is implemented. 
    <ul>
      <li>Get, Put, and PutGet are all supported. Each can optionally process
        the record. Each can access a group of fields in a record instance.
        Structure and Array fields can be accessed.</li>
      <li>MonitorNotify is supported. In this case the client is notified of
        changes but must issue a get to retrieve the data</li>
      <li>Monitor is supported. A monitor includes the data which has changed.
        Any group of fields within a record instance can be monitored.
        Structure and Array fields can be monitored including an entire record
        instance. For appropriate field types onPut, onChange, absoluteChange,
        and percentChange are all supported.</li>
    </ul>
  </li>
</ul>

<h3>Record Processing</h3>

<p>Package org.epics.pvioc.support describes and implements code directly
related to record processing. The package overview has a section "Record
Processing: Theory of Operation" that provides a description of record
processing.</p>

<p>Sub-packagea of org.epics.pvioc.support describe and implement all the
support code that comes with pvIOCJava. Applications can add additional
support.</p>

<p>When a set of pvIOC record instances are created and initialized, a
recordProcess object is created for each record instance. The primary function
of recordProcess is to call record support code, which may in turn call field
support code. RecordProcess has methods for the following: </p>
<ul>
  <li>Lifetime Management: initialize, start, stop, uninitialize<br />
    recordProcess just calls the support methods with the same name.</li>
  <li>Processing</li>
  <li>timeStamp support:<br />
    Get/Set methods for a timeStamp.</li>
  <li>trace<br />
    A record instance can generate diagnostic message while processing.</li>
</ul>

<p>The primary purpose of recordProcess is to be the "gatekeeper" for record
processing. Only one object can process a record. A record can be declared to
be self processed which allows an arbitrary number of clients to request
processing. The default is self process true. Methods are available to request
being the record processor and to request processing. A process can be
synchronous or asynchronous. An asynchronous operation is an operation that
blocks, e.g. file I/O. recordProcess provides methods that allow asynchronous
support but that only lock a record instance while the record is being
accessed. </p>

<p>Whenever any field of a record is being accessed or whenever anything is
done that can modify the state of a record, the record must be locked. In most
cases recordProcess automatically takes care of locking and unlocking.</p>

<p>Each record instance must have associated support and each field of a record
can optionally have support.</p>

<p>Support implements interface Support:</p>

<p></p>
<pre>    public interface Support extends Requester {
        String getSupportName();
        SupportState getSupportState();
        PVRecordField getPVRecordField();
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
    }</pre>

<p>where</p>
<dl>
  <dt>Requestor, getSupportName, getSupportState, getPVRecordField</dt>
    <dd>See package org.epics.pvioc.support for details.</dd>
  <dt>initialize</dt>
    <dd>Initialization related to the record itself. Support must not connect
      to another record or to hardware.</dd>
  <dt>start</dt>
    <dd>Support can connect to other record or hardware.</dd>
  <dt>stop</dt>
    <dd>Disconnect from other record or hardware.</dd>
  <dt>uninitialize</dt>
    <dd>Remove any connection to the record.</dd>
  <dt>process</dt>
    <dd>Do whatever the support should do for record processing.</dd>
</dl>

<p>The primary purpose of a support module is to help with record processing.
Most support does something with a "value" field. For example the support for a
channel access input link will get a value and put it in the "value" field.</p>

<p>Typical support code does the following core functions:</p>
<ul>
  <li>initialize<br />
    Find the "value" field. Most support modules look for a field named
    "value".<br />
    Many support modules also provide support for other fields, which are
    identified by name. For example if a support module supports alarms it
    looks for a field "alarm".</li>
  <li>process<br />
    This is the core of record processing. What happens is up to the support
    module. For example it can interact with hardware. The channel access
    support reads or write other records.</li>
</ul>

<p>There is no separate concept of record support. Record support just happens
to be the support called by recordProcess, i.e. it is the highest level support
for a record instance. The record support that comes with javaIOC is also
designed to also be structure support, i.e. support for a structure field
embeded within a record.</p>

<p>Support code should not be aware of specific structure types. A support
modules works with some set of fields that it locates at initialization. While
processing it uses the PV interfaces to access the fields. Thus support is
generic. If a structure has the fields required by the support then the support
can be used to help support that structure.</p>

<p>An extreme example is generic support. This can used for a record itself or
for any field that is a stucture. All that it does is look at all the fields in
the structure that it supports. For each field that has support it calls the
support.</p>

<h3>Database Examples</h3>

<p>javaIOC/xml the structure definitions for the javaIOC. It also includes the
xml definitions from pvData. Applications can add new structure definitions and
support. This section just gives a few example of using these database
definitions. The complete set of definitions are described in the second part
of this document.</p>

<p>The following are a few examples of record instances. The examples uses the
following support</p>
<ul>
  <li>generic</li>
</ul>
<ul>
  <li>powerSupplyCurrent</li>
</ul>
<dl>
    <dd>Requires fields power, voltage, and current. When it processes it
      computes current from power and voltage.</dd>
</dl>
<ul>
  <li>linearConvertInput</li>
</ul>
<dl>
    <dd>Implements linear conversion from a rawValue to engineering units.</dd>
</dl>
<ul>
  <li>linearConvertOutput</li>
</ul>
<dl>
    <dd>Implements linear conversion from engineering units to a rawValue.</dd>
</dl>
<ul>
  <li>caLink</li>
</ul>
<dl>
    <dd>javaIOC implements channel access links between records</dd>
</dl>

<h4>Record Instance Examples</h4>

<h5>doubleInput</h5>

<p>The following creates a record instance of type double. It is an input
record because input is initialized to a Channel Access inputLink.</p>
<pre>&lt;record recordName = "doubleInput"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "input" extends = "caInputLink"&gt;
        &lt;scalar name = "pvname"&gt;counter&lt;/scalar&gt;
        &lt;scalar name = "request"&gt;value,alarm&lt;/scalar&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5>doubleOutput</h5>

<p>The following creates a record instance of type double. It is an output
record because output is initialized to a Channel Access outputLink.</p>
<pre>&lt;record recordName = "doubleOutput"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "output" extends = "caOutputLink"&gt;
        &lt;scalar name = "pvname"&gt;someOutput&lt;/scalar&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5>ai</h5>

<p>The following creates an instance of an aiRecord. The raw ADC value is read
via channelAccess support and converted via linearConvertInput support.</p>
<pre>&lt;record recordName = "ai"&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "input" extends = "linearConvertInput"&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "deviceHigh"&gt;2047&lt;/scalar&gt;
            &lt;scalar name = "deviceLow"&gt;-2048&lt;/scalar&gt;
            &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "input" extends = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;somePort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "input" extends = "pdrvInt32Input"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;    
&lt;/record&gt;</pre>

<h5>ao</h5>

<p>The following creates an instance of an aoRecord. The value is converted via
linearConvertOutput support to a rawValue which is written via portDriver
support.</p>
<pre>&lt;record recordName = "ao"&gt;
    &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "output" extends = "linearConvertOutput"&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "deviceHigh"&gt;2047&lt;/scalar&gt;
            &lt;scalar name = "deviceLow"&gt;-2048&lt;/scalar&gt;
            &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "output" extends = "portDriverLink"&gt;
            &lt;scalar name = "portName"&gt;somePort&lt;/scalar&gt;
            &lt;scalar name = "deviceName"&gt;0&lt;/scalar&gt;
            &lt;scalar name = "timeout"&gt;.2&lt;/scalar&gt;
            &lt;structure name = "output" extends = "pdrvInt32Output"/&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<h5>psSimple</h5>

<p>The following creates a powerSupply instance that does no input or output.
The power.value must be set via channel access.</p>
<pre>&lt;record recordName = "psSimple" &gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage"&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "current"&gt;
       &lt;auxInfo name = "supportFactory" scalarType =
          "string"&gt;org.epics.pvioc.genericFactory&lt;/auxInfo&gt;
       &lt;scalar name = "value" scalarType = "double"&gt;
         &lt;auxInfo name = "supportFactory" scalarType =
            "string"&gt;org.epics.pvioc.powerSupplyFactory&lt;/auxInfo&gt;
       &lt;/scalar&gt;
    &lt;/structure&gt;
     &lt;structure name = "power"&gt;
      &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "scan" extends = "scan"&gt;
        &lt;scalar name = "processAfterStart"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5>psLinked</h5>

<p>The following creates a powerSupply record that gets its voltage and writes
its current via channel access.</p>
<pre>&lt;record recordName = "psLinked" &gt;
   &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
        &lt;structure name = "input" extends = "caInputLink"&gt;
            &lt;scalar name = "pvname"&gt;adcVoltageSupported&lt;/scalar&gt;
            &lt;scalar name = "process"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "current" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" &gt;
           &lt;auxInfo name = "supportFactory" scalarType =
              "string"&gt;org.epics.pvioc.powerSupplyFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;structure name = "output" extends = "caOutputLink"&gt;
            &lt;scalar name = "pvname"&gt;current&lt;/scalar&gt;
            &lt;scalar name = "request"&gt;record[process=true]&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "power"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5>psEmbeded</h5>

<p>The following creates a powerSupply record that gets its voltage and writes
its current via embeded support.</p>
<pre>&lt;record recordName = "psEmbeded"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "voltage" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
        &lt;structure name = "alarm" extends = "alarm" /&gt;
        &lt;structure name = "input" extends = "linearConvertInput"&gt;
            &lt;structure name = "linearConvert"&gt;
                &lt;scalar name = "deviceHigh"&gt;4095&lt;/scalar&gt;
                &lt;scalar name = "deviceLow"&gt;0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "input" extends = "caInputLink"&gt;
                &lt;scalar name = "pvname"&gt;adcVoltageEmbeded&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "current" extends = "generic"&gt;
        &lt;scalar name = "value" scalarType = "double"&gt;
            &lt;auxInfo name = "supportFactory" scalarType =
               "string"&gt;org.epics.pvioc.powerSupplyFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;structure name = "alarm" extends = "alarm" /&gt;
        &lt;structure name = "output" extends = "linearConvertOutput"&gt;
            &lt;structure name = "linearConvert"&gt;
                &lt;scalar name = "deviceHigh"&gt;4095&lt;/scalar&gt;
                &lt;scalar name = "deviceLow"&gt;0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsLow"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "engUnitsHigh"&gt;10.0&lt;/scalar&gt;
            &lt;/structure&gt;
            &lt;structure name = "output" extends = "caOutputLink"&gt;
                &lt;scalar name = "pvname"&gt;dacCurrentEmbeded&lt;/scalar&gt;
                &lt;scalar name = "request"&gt;record[process=true]&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "power"&gt;
        &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<h2>Part II: javaIOC Data Model</h2>
<p>This discussion has been moved to a separate document. See
<a> href = "http://epics-pvdata.sourceforge.net/informative/pvRequest.html">pvRequest.html</a>

<h2>Part III: javaIOC - Database Definition</h2>

<p>Part III describes the Database Definitions provided with the javaIOC.</p>

<h3>Overview Of Part III</h3>

<p>The create, and support definitions implemented by javaIOC are defined. In
addition a set of structure definitions that use the support are provided. A
brief summary is:</p>
<dl>
  <dt>xml</dt>
    <dd>This directory has a file <b>structures.xml</b> ,which includes all the
      definitions from xml/structure, and a file <b>records.xml</b> , which
      includes all the definitions from xml/record. </dd>
  <dt>xml/structure</dt>
    <dd>This directory has the following files. 
      <dl>
        <dt>analog.xml</dt>
          <dd>Support for analog I/O.</dd>
        <dt>calc.xml</dt>
          <dd>Support for calculations.</dd>
        <dt>caLink.xml</dt>
          <dd>Support for links to other records.</dd>
        <dt>commonFields.xml</dt>
          <dd>Contains definitions for the commonly defined fields.</dd>
        <dt>control.xml</dt>
          <dd>Defines control characteristics.</dd>
        <dt>dbLink.xml</dt>
          <dd>Support for links to other records in the same javaIOC.</dd>
        <dt>deadband.xml</dt>
          <dd>Support for monitor deadbands.</dd>
        <dt>delay.xml</dt>
          <dd>Support that implements an asynchronous delay when the process
            method is called. It is normally only used for testing.</dd>
        <dt>event.xml</dt>
          <dd>Support that announces an event when the process method is
          called.</dd>
        <dt>generic.xml</dt>
          <dd>Support code that can be used to support many records and or
            structures. It just looks for fields that have associated support
            and calls the support.</dd>
        <dt>supportState.xml</dt>
          <dd>Defines the current state of support for a record or field.</dd>
        <dt>rpc.xml</dt>
          <dd>Defines support for RPC records implemented by the javaIOC.</dd>
      </dl>
    </dd>
</dl>

<p>This package overview does not discuss the algorithms implemented by the
support implementations. See package org.epics.pvioc.support and sub-packages
for details.</p>

<h3>javaIOC/xml/structures.xml</h3>

<h4>structures.xml</h4>

<p>This file includes all definitions needed for the support provided by
javaIOC.</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.pvioc.*" /&gt;
&lt;include addPath = "${JAVAIOC}/xml/structure" /&gt;
&lt;package name = "org.epics.pvioc" /&gt;
&lt;include href = "deadband.xml" /&gt;
&lt;include href = "generic.xml" /&gt;
&lt;include href = "commonFields.xml" /&gt;
&lt;include href = "control.xml" /&gt;
&lt;include href = "supportState.xml" /&gt;
&lt;include href = "caLink.xml" /&gt;
&lt;include href = "dbLink.xml" /&gt;
&lt;include href = "analog.xml" /&gt;
&lt;include href = "event.xml" /&gt;
&lt;include href = "calc.xml" /&gt;
&lt;include href = "delay.xml" /&gt;
&lt;include href = "rpc.xml" /&gt;
&lt;include href = "powerSupply.xml" /&gt;
&lt;include href = "portDriver.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/xml/structure" /&gt;
&lt;/database&gt;</pre>

<h4>records.xml</h4>

<p>This file includes RPC record definition and support provided by the
javaIOC.</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.pvioc.*" /&gt;
&lt;include addPath = "${JAVAIOC}/xml/record" /&gt;
&lt;package name = "org.epics.pvioc" /&gt;
&lt;include href = "rpc.xml" /&gt;
&lt;include removePath = "${JAVAIOC}/xml/record" /&gt;
&lt;/database&gt;</pre>

<p>The single record is:</p>
<pre>&lt;database&gt;
&lt;import name = "org.epics.pvioc.*" /&gt;
&lt;import name = "org.epics.pvdata.*" /&gt;
&lt;record recordName = "${IOCNAME}recordListRPC" extends = "recordList" /&gt;
&lt;record recordName = "${IOCNAME}structureListRPC" extends = "structureList" /&gt;
&lt;record recordName = "${IOCNAME}iocShowRPC" extends = "iocShow" /&gt;
&lt;record recordName = "${IOCNAME}recordShowRPC" extends = "recordShow" /&gt;
&lt;record recordName = "${IOCNAME}supportStateSetRPC" extends = "supportStateSet" /&gt;
&lt;/database&gt;</pre>

<p>These two files crate a set of RPC records for a javaIOC. The record types
are defined in structure/rpc.xml below.</p>

<h3>xml/structure/analog.xml</h3>

<p>This is the support for analog I/O. See org.epics.pvioc.support.basic for
details</p>

<h4>linearConvert</h4>

<p>Structure linearConvert is for linear conversions. The slope and intercept
can be specified directly or can be computed from the other four fields.
Normally the record instance defines engUnitsLow and engUnitsHigh and support
code provides values for deviceHigh and deviceLow but other combinations are
also permitted. Structure linearConvert has the fields:</p>
<dl>
  <dt>engUnitsLow</dt>
    <dd>Engineering units value for deviceLow.</dd>
  <dt>engUnitsHigh</dt>
    <dd>Engineering units value for deviceHigh.</dd>
  <dt>deviceHigh</dt>
    <dd>Highest possible raw value.</dd>
  <dt>deviceLow</dt>
    <dd>Lowest possible raw value.</dd>
  <dt>slope</dt>
    <dd>Slope for converting raw value to engineering units.</dd>
  <dt>intercept</dt>
    <dd>Intrercept for converting raw value to engineering units.</dd>
</dl>

<h4>linearConvertInput</h4>

<p>Structure linearConvertInput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to get the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that inputs the raw value.</dd>
</dl>

<h4>linearConvertOutput</h4>

<p>Structure linearConvertOutput is for converting a raw value to an
enginerering units value. It has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>The place to put the raw value.</dd>
  <dt>linearConvert</dt>
    <dd>The structure defining the conversion.</dd>
  <dt>input</dt>
    <dd>A structure that outputs the raw value.</dd>
</dl>

<h4>incrementalDouble</h4>

<p>This is for rate limited output. The output value incrementally reaches the
desired value. The structure has the fields:</p>
<dl>
  <dt>desiredValue</dt>
    <dd>The desired value.</dd>
  <dt>input</dt>
    <dd>A structure for reading the desired value.</dd>
  <dt>incrementalOutput</dt>
    <dd>If false the output is set to the desired value if it falls within the
      control limits.</dd>
  <dt>rateOfChange</dt>
    <dd>Rate of change per process if incrementalInput is true.</dd>
  <dt>units</dt>
    <dd>units.</dd>
  <dt>controlLimit</dt>
    <dd>control limits. The output value is forced to be within the control
      limits.</dd>
</dl>

<h3>xml/structure/calc.xml</h3>

<p>This is the support for calculations. See org.epics.pvioc.support.calc for
details. Note that expressionCalculator is the default calculator.. </p>

<h3>xml/structure/caLink.xml</h3>

<p>This is the support for a links to other records. See
org.epics.pvioc.support.ca for details.</p>

<h4>caProcessLink</h4>

<p>Structure caProcessLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
</dl>

<h4>caMonitorLink</h4>

<p>Structure caMonitorLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
  <dt>queueSize</dt>
    <dd>Must be greater than 1. The default is 2.</dd>
  <dt>reportOverrun</dt>
    <dd>If the data queue is overrun should it be reported by setting status
      and severity?</dd>
  <dt>process</dt>
    <dd>Should the record containing the link be processed after the monotered
      data is read.</dd>
  <dt>request</dt>
    <dd>Specifies the fields to monitor and options.</dd>
</dl>

<h4>caMonitorNotifyLink</h4>

<p>Structure caMonitorNotifyLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>type</dt>
    <dd>A monitorType menu.</dd>
  <dt>deadband</dt>
    <dd>If monitorType is absoluteChange or percentageChange this is the
      deadband for reporting monitors.</dd>
  <dt>onlyWhileProcessing</dt>
    <dd>Look only for changes while record is being processed.</dd>
</dl>

<h4>caInputLink</h4>

<p>Structure caInputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider</dd>
  <dt>request</dt>
    <dd>Specifies the fields to get and options. If a requested field is alarm
      than this record inherits the alarm from the linked record.</dd>
</dl>

<h4>caOutputLink</h4>

<p>Structure caOutputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>providerName</dt>
    <dd>The name of the channelProvider.</dd>
  <dt>request</dt>
    <dd>Field to put and options.</dd>
</dl>

<h3>xml/structure/dbLink.xml</h3>

<h4>dbProcessLink</h4>

<p>Structure dbProcessLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
</dl>

<h4>caInputLink</h4>

<p>Structure caInputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>request</dt>
    <dd>fields to get and options.</dd>
</dl>

<h4>caOutputLink</h4>

<p>Structure caOutputLink has the fields:</p>
<dl>
  <dt>pvname</dt>
    <dd>recordName.fieldName of link</dd>
  <dt>alarm</dt>
    <dd>alarm for problems with link</dd>
  <dt>request</dt>
    <dd>field to put and options.</dd>
</dl>

<h3>xml/structures/commonFields.xml</h3>

<p>This file contains database definitions for fields scan and timeStamp.</p>

<p>Definitions for the following structuress:</p>
<dl>
  <dt>scanPriority</dt>
    <dd>The scan priorities: lowest,...,highest</dd>
  <dt>scanType</dt>
    <dd>An enumerated structure that defines the scan types: 
      <dl>
        <dt>passive</dt>
          <dd>A record that is neither periodically or event scanned. Something
            elase can make it process. For example another record with a
            process link.</dd>
        <dt>event</dt>
          <dd>An event scanned record. In this case an eventName is also
            assigned to the record.</dd>
        <dt>periodioc</dt>
          <dd>A periodically scanned record. In this case a rate is also
            assigned to the record.</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt>scan</dt>
    <dd><dl>
        <dt>priority</dt>
          <dd>The thread priority for a periodic and event scanning.</dd>
        <dt>type</dt>
          <dd>Scan type, i.e. passive, event, or periodic</dd>
        <dt>rate</dt>
          <dd>Periodic scan rate in seconds</dd>
        <dt>eventName</dt>
          <dd>The event name for event scanned records.</dd>
        <dt>singleProcessRequester</dt>
          <dd>Is only a single requester allowed to request processing? The
            default is false..</dd>
        <dt>processAfterStart</dt>
          <dd>determines if the record instance should be processed one time
            after the record enters the ready state. If the value is true than
            recordProcess attempts to process the record immeriately after it
            becomes ready. The attempt is only successfull if no record
            processor is registered of if the record has been initialized to be
            processSelf.</dd>
        <dt>maxConsecutiveActive</dt>
          <dd>The periodic and event scanners will generate a message if they
            find the record active maxConsecutiveActive times.</dd>
      </dl>
    </dd>
</dl>

<h3>xml/structures/control.xml</h3>

<p>This is a structure and support for control limits.</p>

<h3>xml/structure/delay.xml</h3>

<p>This is the support that delays before completing. It is used for testing.
See org.epics.pvioc.support.basic for details.</p>

<h3>xml/structure/event.xml</h3>

<p>This is the support for announcing events. See org.epics.pvioc.support.basic
for details.</p>

<h3>xml/structure/generic.xml</h3>

<p>Generic is the default support for many record types. It just calls the
support for any fields that have support. See org.epics.pvioc.support.basic for
details.</p>

<h3>xml/structure/portDriver</h3>

<p>This is the support for portDriver. See org.epics.pvioc.support.pdrv and
org.epics.pvioc.portDriver for details.</p>

<h4>portDriver.xml</h4>

<p>This includes portDriver related files.</p>
<dl>
  <dt>portDriver/arraySupport.xml</dt>
  <dt>portDriver/digitalSupport.xml</dt>
  <dt>portDriver/scalarSupport.xml</dt>
  <dt>portDriver/serialSupport.xml</dt>
  <dt>portDriver/support.xml</dt>
  <dt>portDriver/drivers.xml</dt>
</dl>

<h3>xml/structure/rpc.xml</h3>

<p>This contains for RPC records and support:</p>

<h4>recordList</h4>

<p>This provides a list of record names selected via a regular expression. See
swtshell for an example of how a client issues a request.</p>

<h4>structureList</h4>

<p>This provides a list of structure names selected via a regular expression.
See swtshell for an example of how a client issues a request.</p>

<h4>iocShow</h4>

<p>This provides information about tjhe javaIOC: badRecords, threads, and
memory usage. It also provides the ability to ask java to garbage collect.</p>

<h4>recordShow</h4>

<p>This provides the following features:</p>
<dl>
  <dt>trace</dt>
    <dd>Trace can be turned on or off for a record instance.</dd>
  <dt>enable</dt>
    <dd>Processing of a record instance can be enabled or disabled.</dd>
  <dt>timeProcess</dt>
    <dd>If no record processor is registered foe the record or if it is
      selfProcessd a request can be made to measure how many times per second
      the record can be processed..</dd>
  <dt>releaseProcessor</dt>
    <dd>A request can be made to release the record processor. THIS IS A
      DANGEROUS OPERATION. It should only be issued if the record processor
      fails. </dd>
</dl>

<h4>supportStateSet</h4>

<p>This allows a client to set the support state for a record.</p>

<h2>Part IV: pvIOCJava - Package Descriptions</h2>

<p>The following sections provide documentation for packages that belong to
pvIOCJava.</p>

<h2>Package org.epics.pvioc</h2>

<h3>Overview</h3>

<p>This package has a single class called pvIOCJava. It's purpose is to start a
pvIOCJava.</p>

<p>NOTE: The environment variables IOCNAME, PVDATA, PVACCESS. and JAVAIOC
should be defined.</p>

<p>pvIOCJava is developed as part of an eclipse project. It uses two other
eclipse projects: pvDataJava and pvAccessJava. One way to start it is to check
out the eclipse projects and then run JavaIOC as a java application. The
following assumes that you have eclipse installed and have imported pvIOCJava
into a project named "pvIOCJava". In addition project pvDataJava and
pvAccessJava must also exist as eclipse projects.</p>

<p>JavaIOC does the following:</p>
<ul>
  <li>Reads xml files containing structure and record definitions.</li>
  <li>Dumps the resulting structure and record definitions.</li>
  <li>Starts servers.</li>
  <li>Starts running the javaIOC. There are two options: 
    <ul>
      <li>Invokes swtshell, which is a Graphical User Interface (GUI) shell
        that interacts with a running JavaIOC</li>
      <li>Run without a shell.</li>
    </ul>
  </li>
</ul>

<p>The arguments to JavaIOC can be any combination of:</p>
<ul>
  <li>-structures<br />
    followed by filenames of files containing XML structure definitions.</li>
  <li>-records<br />
    followed by filenames of files containing XML record definitions.</li>
  <li>-dumpStructures<br />
    dump the structure, create, and support definitions</li>
  <li>-dumpRecords<br />
    dump the record instances</li>
  <li>-server 
    <p>followed by filenames. Each field is a list of servers to start. See
    javaIOC/server for a list of the server files supplied by javaIOC
    itself.</p>
  </li>
  <li>-run<br />
    Stop processing arguments and run forever.</li>
  <li>-swtshell<br />
    Start swtshell. This will also stop processing arguments.</li>
</ul>

<h3>Starting pvIOCJava with eclipse</h3>

<p>Open the src tree and the select org.epics.pvioc.JavaIOC and then run as
Java Application. If this is the first time or it is not the configuration
desired then stop the running JavaIOC.</p>

<p>With the run menu select "run configurations". Then select Arguments. Then
add the desired arguments as described above and then run. </p>

<h3>Starting JavaIOC without eclipse</h3>

<p>JavaIOC can also be started without eclipse. In the same directory have a
file named source and files that start JavaIOC. The following is an example
that works on linux or macOS.</p>

<h4>source</h4>

<p>This is a sample source file:</p>
<pre>pwd=$PWD
# The following assumes that pvDataJava, pvAccessJava, and pvIOCJava
# are eclipse projects in $HOME/hg
export WORKSPACE=$HOME/hg
export PVDATA=${WORKSPACE}/pvDataJava
export PVACCESS=${WORKSPACE}/pvAccessJava
export JAVAIOC=${WORKSPACE}/pvIOCJava
export CLASSPATH=${CLASSPATH}:${PVDATA}/bin
export CLASSPATH=${CLASSPATH}:${PVACCESS}/bin
export CLASSPATH=${CLASSPATH}:${JAVAIOC}/bin
export CLASSPATH=${CLASSPATH}:${JAVAIOC}jar/CAJ.jar
export CLASSPATH=${CLASSPATH}:${JAVAIOC}jar/JCA.jar
# The following MUST be changed to locate the release of swt on your system
export CLASSPATH=${CLASSPATH}:/usr/lib/eclipse/swt.jar</pre>

<h4>example</h4>

<p>The following is the contents of a file named startExample</p>
<pre>#! /bin/bash
source source
java \ 
     -server \
     org.epics.pvioc.JavaIOC \
     -structures ${JAVAIOC}/xml/structures.xml \
     -records  ${JAVAIOC}/example/exampleDB.xml \
     -server ${JAVAIOC}/server/pvAccessServer.txt \
     -swtshell </pre>

<p>To start the example just type:</p>
<pre>./startExample</pre>

<h2>Package org.epics.pvioc.xml</h2>

<h3>Overview</h3>

<p>One way to create structures and records for a PVDatabase is via
XMLToPVDatabaseFactory, which parses structure and record definitions from an
xml file, creates structure and record instances and adds then to a PVDatabase.
This overview first defines the xml syntax and then interfaces and code for
reading the xml files.</p>

<h3>Database XML Syntax</h3>

<h4>database</h4>
A pvIOCJava database file is an XML file with the following structure: 
<pre> &lt;?xml version="1.0" ?&gt;
&lt;database
   
&lt;/database&gt;</pre>

<h4>auxInfo</h4>

<p>An auxInfo defines additional information for a record, structure, or field.
It is for use by applications that require additional information for a field.
An arbitrary number of auxInfo can be created for any field. </p>

<p>An auxInfo is defined as follows:</p>
<pre>&lt;auxInfo name = "auxInfoName" scalarType = "scalarType"&gt;
   value
&lt;/auxInfo&gt;</pre>

<p>where:</p>
<dl>
  <dt>auxInfoName</dt>
    <dd>The auxInfo name.</dd>
  <dt>scalarType</dt>
    <dd>The type as described below.</dd>
  <dt>value</dt>
    <dd>The value as described below.</dd>
</dl>

<p>The following auxInfo is supported for every field:</p>
<pre>    &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;
         value
    &lt;/auxInfobu&gt;</pre>

<p>value must be the name of a structure that provides the name of a factory
that will provide the PVField implementation.</p>

<h4>structure and record</h4>

<p>Structure definitions exist so that a structure field of a record can be
initialized with the fields of a previously defined structure definition. A
structure is defined as follows:</p>
<pre>&lt;structure structureName = "structureName" extends = "otherStructureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt>structureName</dt>
    <dd>The structure name.</dd>
  <dt>otherStructureName</dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current structure will be initialized to have all
      attributes and fields of the other structure. The current structure can
      changed the attributes and fields and can append additional fields to the
      structure.</dd>
  <dt>field</dt>
    <dd>Zero or more fields can be defined. Each field must have a unique name.
      Order is important.</dd>
</dl>

<p>A record is a structure instance which has a record instance name. A record
is defined as follows:</p>
<pre>&lt;record recordName = "recordName" extends = "structureName" &gt;
     &lt;!-- sequence of field --&gt;
&lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt>recordName</dt>
    <dd>The record name. If the record with this name already exists then this
      definition can modify fields in the existing record but structureName
      must not be defined. recordName which must be specified,is a string with
      a combination of the following characters: 
      <ul>
        <li>0-9 A-Z a-z _ - : ; [ ]</li>
        <li>Any Unicode/UTF-8 character outside of the Basic Latin set</li>
      </ul>
    </dd>
  <dt>structureName</dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current record will be initialized to have all attributes
      and fields of the structure. The record can changed the attributes and
      fields and can append additional fields to the structure. The name should
      follow the same convention that Java uses for package names. See the next
      section for details.</dd>
</dl>

<h4>package and import</h4>

<p>These two elements are both related to structures defined in the previous
section.</p>
<pre>&lt;package name = "packageName" /&gt;
&lt;import name = "packageName" /&gt;</pre>

<p>For both the packageName is of the form:</p>
<pre>     name.name...
     or for import
     name.name...*</pre>

<p>package applys to the structureName in a structure definition: For example
the following:</p>
<pre>&lt;package name = "org.epics.pvdata" /&gt;
&lt;structure structureName = "alarm"&gt;
  &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;structure structureName = "org.epics.pvdata.alarm"&gt;
   &lt;!-- field definitions --&gt;
&lt;/structure&gt;</pre>

<p>import applys to extends structureNames in structure, record, and field
structure definitions. For example the following:</p>
<pre>&lt;import name = "org.epics.pvdata.*" /&gt;
&lt;import name = "org.me.myStuff.*" /&gt;
&lt;record recordName = "xxx" extends = "myStructure"&gt;
    &lt;structure name = "alarm" extends = "alarm"&gt;
&lt;/record&gt;</pre>

<p>Is the same as:</p>
<pre>&lt;record recordName = "xxx" extends = "org.me.myStuff.myStructure"&gt;
    &lt;structure name = "alarm" extends = "org.epics.pvdata.alarm"&gt;
&lt;/record&gt;</pre>
<pre></pre>

<h4>Field definition</h4>

<p>A field of a record or structure can have one of the following tag names:
scalar, scalarArray, or structure,.</p>

<p>A scalar field is defined as follows:</p>
<pre>  &lt;scalar name = "fieldName" scalarType = "scalarType"&gt;
     value
  &lt;/scalar&gt;</pre>

<p>where:</p>
<dl>
  <dt>fieldName</dt>
    <dd>The name of the field.</dd>
  <dt>scalarType</dt>
    <dd>The scalar type as defined below.</dd>
  <dt>value</dt>
    <dd>The value. The syntax is described below where scalar types are
    defined.</dd>
</dl>

<p>An array field is defined as follows:</p>
<pre>  &lt;array name = "fieldName" scalarType = "scalarType"
   capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset"&gt;
     arrayValues
  &lt;/array&gt;</pre>

<p>where:</p>
<dl>
  <dt>fieldName</dt>
    <dd>The name of the field.</dd>
  <dt>scalarType</dt>
    <dd>The element type as defined below.</dd>
  <dt>capacity,capacityMutable,length,offset</dt>
    <dd>Each is these is optional.</dd>
  <dt>arrayValues</dt>
</dl>

<p>arrayValues is a comma separated set of values appropriate to the element
type. It can optionally be enclosed in []. Examples: </p>
<pre>     &lt;array name = "field0" scalarType = "double"&gt;
         2.3,5e10,66.0
     &lt;/array&gt;
     &lt;array name = "field1" scalarType = "double"&gt;
         [2.3,5e10,66.0]
     &lt;/array&gt;</pre>

<p>For all array elementTypes except string the convert library will remove all
white space so white space is permitted. If the elementType is string then
white space is not removed. Also each array element is not allowed to have the
character ','. What to do? Should also allow other escape sequences like \n,
etc.</p>

<p>A structure field is defined as follows:</p>
<pre>  &lt;structure name = "fieldName" extends = "structureName"&gt;
     &lt;!-- sequence of field --&gt;
  &lt;/structure&gt;</pre>

<p>where:</p>
<dl>
  <dt>fieldName</dt>
    <dd>The name of the field.</dd>
  <dt>structureName</dt>
    <dd>Optional. If given it must be the name of an already defined structure
      definition. The current record will be initialized to have all attributes
      and fields of the structure. The record can change the attributes and
      field values and append additional fields appended to the instance
      structure.</dd>
</dl>

<h4>Scalar Types</h4>

<p>The scalar types are:</p>
<dl>
  <dt>boolean</dt>
  <dt>byte</dt>
  <dt>short</dt>
  <dt>int</dt>
  <dt>long</dt>
  <dt>ubyte</dt>
  <dt>ushort</dt>
  <dt>uint</dt>
  <dt>ulong</dt>
  <dt>float</dt>
  <dt>double</dt>
  <dt>string</dt>
</dl>

<p>Thus all Java primitive types except char are support and are implemented
via the corresponding Java type. Type string is implemented as a Java String.
</p>

<p><b>NOTE: </b> Since Java does not support unsigned integers, each unsigned
integer type is implements as the corresponding signed type. The only exception
is the Convert facility. It does implement the proper conversions between
unsigned types and other types.</p>

<p>For example </p>
<pre>     
    &lt;scalar name = "value", scalarType = "double" /&gt;
    &lt;scalar name = "rawValue" scalarType = "int" /&gt;
    &lt;scalar name = "description" scalarType = "string" /&gt;</pre>

<p>value for scalar fields must be specified as follows:</p>
<dl>
  <dt>boolean</dt>
    <dd>Must be true or false.</dd>
  <dt>byte</dt>
    <dd>A valid Java long literal value that is cast to a byte</dd>
  <dt>short</dt>
    <dd>A valid Java long literal value that is cast to a short</dd>
  <dt>int</dt>
    <dd>A valid Java long literal value that is cast to a int</dd>
  <dt>long</dt>
    <dd>A valid Java long literal value</dd>
  <dt>float</dt>
    <dd>A valid Java float literal value</dd>
  <dt>double</dt>
    <dd>A valid Java double literal value</dd>
  <dt>string</dt>
    <dd>A valid Java string literal value</dd>
  <dt>structure</dt>
    <dd>If this is the first time the field is being crated than an extends
      must also be specified. The field will hold a PVStructure with a
      structure defined by extends. This value is just definitions for fields
      in the structure.</dd>
</dl>

<p>NOTE about byte, short, int. The syntax allows unsigned instead of signed
values for hex values. For example the following is legal syntax although Java
would complain.</p>
<pre>    &lt;scalar name = "mask" scalarType = "byte"&gt;0xff&lt;/scalar&gt;</pre>

<h4>Enumerated Structure</h4>

<p>An enumerated structure is a structure that extends <b>enumerated</b>.
It has:</p>
<ol>
  <li>Has exactly two fields.</li>
  <li>The first field is named <b>index</b> and has scalarType int</li>
  <li>The second field is named <b>choices</b> and is an array with element
    type string</li>
</ol>

<p>If the current structure is an enumerated structure then the following
syntax is allowed:</p>
<pre>    &lt;scalar name = "choice"&gt;someChoice&lt;/scalar&gt;</pre>

<p>where someChoice must be one of the elements of choices. This results in the
index field being initialized to the correct value. </p>

<h4>Examples</h4>

<p>If <b>fieldName</b> does not exist then a new field can be created and
appended to the end of the current structure. In this case a new field will be
appended to the end of the structure in which this field appears. </p>

<p>For example:</p>
<pre>&lt;record recordName = "simple" &gt;
  &lt;scalar name = "value" scalarType = "double" /&gt;
&lt;/record&gt;</pre>

<p>Because the record definition does not specify a scalarType =
"structureName", it starts with the generic structure, which has no fields. A
field with name value does not exist so it is created and appended to the
structure. i.e. the record will have a single field of type double and named
"value".</p>

<p>The following creates a record which has a structure field that represents a
timeStamp..</p>
<pre>&lt;record recordName = "structureField" &gt;
  &lt;structure name = "timeStamp"&gt;
     &lt;scalar name = "secondsSinceEpoch" scalarType = "long"&gt;
     &lt;scalar name = "nanoSeconds" scalarType = "int"&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following creates a record which has a field named output that is an
array of structures:</p>
<pre>&lt;record recordName = "complexExample"&gt;
  &lt;stucture name = "lotsOfStuff" &gt;
     &lt;scalar name = "value" scalarType = "double"&gt;
     &lt;structure name = "output"&gt;
         &lt;structure name = "0"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest0&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
         &lt;structure name = "1"&gt;
            &lt;scalar name = "dest" scalarType = "string"&gt;dest1&lt;/scalar&gt;
            &lt;stucture name = "otherInfo"&gt;
               &lt;!-- other defs --&gt;
            &lt;/structure&gt;
         &lt;/structure&gt;
      &lt;/structure&gt;
  &lt;/structure&gt;
&lt;/record&gt;</pre>

<h4>Field Initialization</h4>

<p>If multiple field instance definitions appear then the last instance
determines how the field is initialized.</p>

<p>The syntax for the initializer depends on the field type.</p>

<h4>Scalar Types</h4>

<p>For scalar types the initializer has the same format as the Java constants
for the type. For example if the type for field value is double:</p>
<pre>    &lt;scalar name = "value"&gt;.98&lt;/scalar&gt;</pre>

<p>Note: For integer data types <b>Long.decode</b> is used to convert a string
to a long, which is then converted to the final integer data type . Thus hex
values are allowed. Java does not allow the sign bit to be set. By converting
first to a long all interger types except long can have the sign bit set. For
example the byte value 0xff is allowed even though Java would raise an
exception if Byte.decode was used. The sign problem does exist for long
values.</p>

<h4>string</h4>

<p>For string types the initializer is a valid Java string constant, which can
optionally be enclosed in quotes. For example:</p>
<pre>    &lt;scalar = "units"&gt;voltage&lt;/scalar&gt;</pre>

<h4>structure scalar</h4>

<p>A structure scalar field is initialized by giving field definitions for any
fields in the associated structure. For example assume that the following
structure definitions have been given:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure scalar field:</p>
<pre>&lt;record recordName = "structureScalarTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "structure" extends = "test.testStructure"&gt;
        &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
        &lt;structure name = "location"&gt;
           &lt;scalar name = "x"&gt;1.0&lt;/scalar&gt;
            &lt;scalar name = "y"&gt;2.0&lt;/scalar&gt;&gt;
        &lt;/structure&gt;
    &lt;/scalar&gt;
&lt;/record&gt;</pre>

<h4>structure</h4>

<p>Structure fields are initialized via a recursive definition of field.</p>

<p>Assume the following structure definitions:</p>
<pre>    &lt;structure structureName = "doubleLimit"&gt;
        &lt;scalar name = "low" type ="double"/&gt;
        &lt;scalar name = "high" type ="double"/&gt;
   &lt;/structure&gt;

   &lt;structure structureName = "control"&gt;
     &lt;structure name = "limit" extends = "doubleLimit" /&gt;
     &lt;scalar name = "minStep" scalarType = "double" /&gt;
   &lt;/structure&gt;</pre>

<p>limit is initilized as follows:.</p>
<pre>    &lt;structure name = "control" extends = "control"&gt;
      &lt;structure name = "limit"&gt;
         &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
         &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
      &lt;/structure&gt;
      &lt;scalar name = "minStep"&gt;.1&lt;/scalar&gt;
   &lt;/structure&gt;</pre>

<p>It is permissible, in a database definition, to define a field to be a
structure without providing a structure name. In this case the default is
"null" which is a structure with no fields.</p>

<p>The default structure and auxInfo can be overridden when a field instance is
defined. The syntax is:</p>
<pre>    &lt;structure name = "fieldName" extends = "structureName"&gt;
       &lt;auxInfo name = "pvReplaceFactory" scalarType = "string"&gt;someFactory&lt;/auxinfo&gt;
    &lt;/structurte&gt;</pre>

<h4>array</h4>
The syntax for a array initializer is: 
<pre>    &lt;array name = "fieldName" scalarType = "scalarType"
    capacity = "capacity" capacityMutable = "true/false" length = "length" offset = "offset" &gt;
        valueList
    &lt;/array&gt;</pre>

<p>where</p>
<dl>
  <dt>capacity</dt>
    <dd>The amount of storage to allocate for the array. This is optional and
      the capacity will be equal to the number of elements initialized. If the
      capacity is given a value &gt; 0 and capacityMutable is not specified
      then capacityMutable is set to true. </dd>
  <dt>capacityMutable</dt>
    <dd>Can the capacity be changed?</dd>
  <dt>length</dt>
    <dd>The initial length for the array.</dd>
  <dt>offset</dt>
    <dd>The offset of the first element being defined.</dd>
  <dt>valueList</dt>
    <dd>A list of values, which is a comma separated set of values.</dd>
  <dt></dt>
</dl>

<p>The following perform the same initialization:</p>
<pre>    &lt;array name = "intArray" scalarType = "double"&gt;
        0.0,1.0,0.0
    &lt;/array&gt;
    &lt;array name = "intArray" scalarType = "double" length = "3"&gt;
        0.0,1.0
    &lt;/array&gt;</pre>

<p>The following initializes an array of structures</p>
<pre>    &lt;complexArray name = "example"&gt;
      &lt;structure name = "structArray" &gt;
        &lt;structure name = "0" extends = "doubleLimit" &gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "1"  extends = "doubleLimit"&gt;
            &lt;scalar name = "low"&gt;-10.0&lt;/scalarmit&gt;
            &lt;scalar name = "high"&gt;10.0&lt;/scalar&gt;
        &lt;/structure&gt;
      &lt;/structure&gt;
    &lt;/array&gt;</pre>

<h5>structureArray</h5>

<p>The first time a structure array field is created an extends must also be
provided. The extended structure is used to create the array elements. For
example assume that the following structures have been defined:</p>
<pre>&lt;structure structureName = "test.point"&gt;
  &lt;scalar name = "x" scalarType = "double" /&gt;
  &lt;scalar name = "y" scalarType = "double" /&gt;
&lt;/structure&gt;

&lt;structure structureName = "test.testStructure"&gt;
    &lt;scalar name = "value" scalarType = "double"&gt;10.0&lt;/scalar&gt;
    &lt;structure name = "location" extends = "test.point" /&gt;
&lt;/structure&gt;</pre>

<p>Then the following creates a structure array</p>
<pre>&lt;record recordName = "structureArrayTest"&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;array name = "value" scalarType = "structure" extends = "test.testStructure" capacity = "2"&gt;
       &lt;structure&gt;
          &lt;scalar name = "value"&gt;100.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;0.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;0.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
        &lt;structure&gt;
          &lt;scalar name = "value"&gt;200.0&lt;/scalar&gt;
          &lt;structure name = "location"&gt;
             &lt;scalar name = "x"&gt;5.0&lt;/scalar&gt;
              &lt;scalar name = "y"&gt;10.0&lt;/scalar&gt;&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       
    &lt;/array&gt;
&lt;/record&gt;</pre>

<h4>Macro Substitution and Include</h4>

<h4>Include</h4>
The XML file can include other files also containing Record Instance
Definitions. Included files can also include other files. The syntax is: 
<pre>    
&lt;include addPath = "path" removePath = "path" href = "filename" /&gt;</pre>

<p>Where</p>
<dl>
  <dt>href</dt>
    <dd>The <b>filename</b>, which must be a valid XML Record Instance file, is
      processed. If any addPaths have been defined the last one specified is
      prefixed to the filename.</dd>
  <dt>addPath</dt>
    <dd>Add a path.</dd>
  <dt>removePath</dt>
    <dd>Remove a path.</dd>
</dl>

<h4>Macro Substitution</h4>

<p>Macro substitution replaces a string of the form "${from}" with some other
text. The syntax is:</p>
<pre>    &lt;substitute from = "fromString" to = "toString" fromTo = "from=to,from=to,..."/&gt;</pre>

<p>Where:</p>
<dl>
  <dt>from</dt>
    <dd><b>fromString</b> is the string that appears in ${from}. If <b>from</b>
      is specified then <b>to</b> must also be specified.</dd>
  <dt>to</dt>
    <dd><b>toString</b> replaces ${from}</dd>
  <dt>toFrom</dt>
    <dd>The attribute value is a series of "from=to" pairs separated by
    commas.</dd>
</dl>

<p>Macro substitution can be performed on the foillowing:</p>
<ol>
  <li>Any attribute value in any element definition.</li>
  <li>The content of any element definition.</li>
</ol>

<p>NOTE: If a substitution is being performed and a substitute is not found
then if the value is found in the system environment table that value is
used.</p>

<h4>Example Include and Macro Substitution</h4>

<p>The following is a template file:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;record recordName = "ai${recordExtension}Record"&gt;
    &lt;scalar name = "value" scalarType = "double"/&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp"&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "input" extends = "linearConvertInput" &gt;
        &lt;structure name = "input" extends = "inputSupport"&gt;
            &lt;scalar name = "pvname"&gt;${pvname}&lt;/scalar&gt;
            &lt;scalar name = "wait"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "linearConvert"&gt;
            &lt;scalar name = "engUnitsLow"&gt;${engUnitsLow}&lt;/scalar&gt;
            &lt;scalar name = "engUnitsHigh"&gt;${engUnitsHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "display" extends = "display" &gt;
        &lt;scalar name = "units"&gt;volts&lt;/scalar&gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;${displayLow}&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;${displayHigh}&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;
se&gt;</pre>

<p>The following creates two instance files from the template:</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;database&gt;
&lt;include addPath = "src/org/epics/ioc/dbAccess/example" /&gt;
&lt;substitute from = "recordExtension" to = "01" /&gt;
&lt;substitute from = "pvname" to = "nameFor01" /&gt;
&lt;substitute from = "displayLow" to = "0.0" /&gt;
&lt;substitute from = "displayHigh" to = "10.0" /&gt;
&lt;substitute from = "engUnitsLow" to = "0.0" /&gt;
&lt;substitute from = "engUnitsHigh" to = "9.0" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;substitute fromTo = "recordExtension=02,pvname=nameFor02" /&gt;
&lt;include href = "protoAiDB.xml" /&gt;
&lt;/database&gt;</pre>

<h3>Database XML Code</h3>

<p>This section describes the Java support for converting files, which have XML
definitions for PVData structures and records, to PVDatabase PVStructures and
PVRecords.</p>

<p>The support has two components:</p>
<ol>
  <li>Include and Substitute<br />
    Support for macro substitution and include.</li>
  <li>XML to PVDatabase<br />
    Support that parsers the PVData XML statements. It uses the Include and
    Substitute support</li>
</ol>

<p>This section first shows the Java Definitions, then it discusses XML to
PVDatabase parsing, and last Include and Substitute.</p>

<h4>Warning About XML element syntax</h4>

<p>This is a warning for utility code that genetrates xml for PVData. The
problem is the special XML characters:</p>
<ul>
  <li>Less than &lt;</li>
  <li>Greater Than &gt;</li>
  <li>Quote "</li>
  <li>Apostrophe ''</li>
  <li>Ampersand &amp;</li>
</ul>

<p>These symbols are part of the xml syntax. This is a problem when the value
for a string is being defined. For example:</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;value&lt;/scalar&gt;</pre>

<p>In order to set value = "a&lt;b" Then one of the following must be
entered.</p>
<pre>    &lt;scalar name = "xxx" elementType = "string"&gt;a&amp;lt;b&lt;/scalar&gt;</pre>

<p>or</p>
<pre>    &lt;scalar name = "xxx" elmentType = "string"&gt;&lt;![CDATA[a&lt;b]]&gt;&lt;/scalar&gt;</pre>

<p>I (Marty Kraimer) do not know how to determine, using SAX, what appears in
the original xml source file. What appears to the ContentHandler callback is
just the converted characters. What to do? One suggestion is that any code that
generates PVData xml should look at all string scalar and scalar array element
values. If any of the special XML characters are present then use
the&lt;![CDATA[value]]&gt; method of encoding the value.</p>

<h4>Java Definitions</h4>
<pre>    class XMLToPVDatabaseFactory {
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            XMLToPVDatabaseListener pvListener,
            IncludeSubstituteXMLListener isListener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        static void convert(PVDatabase pvDatabase, String fileName,Requester requester);
    }

    interface XMLToPVDatabaseListener {
        void startStructure(PVStructure pvStructure);
        void endStructure();
        void startRecord(PVRecord pvRecord);
        void endRecord(); 
        void newStructureField(PVStructure pvStructure);
        void endStructureField();
        void startArray(PVArray pvArray);
        void endArray();
        void startScalar(PVScalar pvScalar);
        void endScalar();
        void startAuxInfo(String name,Map&lt;String,String&gt; attributes);
        void endAuxInfo();
    }

    interface IncludeSubstituteXMLListener {
        void endDocument();
        void startElement(String name, Map&lt;String,String&gt; attributes);
        void element(String content);
        void endElement(String name);
    }

    interface IncludeSubstituteDetailsXMLListener {
        void startElementBeforeSubstitution(String name, Map&lt;String,String&gt; attributes);
        void elementBeforeSubstitution(String content);
        void newSourceFile(String fileName);
        void endSourceFile();
        void addPath(String pathName);
        void removePath(String pathName);
        void substitute(String from,String to);
        void removeSubstitute(String from);
    }
    
    interface IncludeSubstituteXMLReader {
        void parse(String rootElementName,String fileName,Requester requester,
            boolean reportSubstitutionFailure,
            IncludeSubstituteXMLListener listener,
            IncludeSubstituteDetailsXMLListener detailsListener);
        void message(String message,MessageType messageType);
    }

    class IncludeSubstituteXMLReaderFactory {
        static public IncludeSubstituteXMLReader getReader();
    }</pre>

<h4>XML To PVDatabase</h4>

<p>This support processes PVData XML statements. Code that wants to parse
PVData XML statements calls one of the XMLToPVDatabaseFactory.convert methods.
The only difference between the two methods is that the first provides access
to detailed information about parsing while the second only provides
errors..</p>

<h5>XMLToPVDatabaseFactory</h5>

<p>This provides two methods both named convert. The first provides detailed
information about parsing. It is intended for use by VDCT. The second reports
all errors including substitution failues but none of the detailed information.
The arguments for the first method are:</p>
<dl>
  <dt>pvDatabase</dt>
    <dd>The PVDatabase into which structure and record instances are put.</dd>
  <dt>fileName</dt>
    <dd>The name of the XML file.</dd>
  <dt>requester</dt>
    <dd>The Requester interface which must be implemented by the caller.</dd>
  <dt>reportSubstitutionFailure</dt>
    <dd>Should substitution failures be reported?</dd>
  <dt>pvListener</dt>
    <dd>The XMLToPVDatabaseListener interface, which can be null. If
      implemented the caller is notified when PV XML elements have been
    parsed.</dd>
  <dt>isListener</dt>
    <dd>The IncludeSubstituteXMLListener interface, which can be null.
      XMLToPVDatabaseFactory implements it's own version but will also call
      this instance if implemented.See the interface description below for
      details.</dd>
  <dt>detailsListener</dt>
    <dd>The IncludeSubstituteDetailsXMLListener interface, which can be
    null.</dd>
</dl>

<h5>XMLToPVDatabaseListener</h5>

<p>This provides a callback for the beginning and end of the parsing of PVData
XML elements not related to macro substitution and include. It provides the
following methods:</p>
<dl>
  <dt>startStructure</dt>
    <dd>A new structure instance is being created.</dd>
  <dt>endStructure</dt>
    <dd>The definition of the new structure is complete.</dd>
  <dt>startRecord</dt>
    <dd>A new record instance is being created or an existing record is being
      modified.</dd>
  <dt>endRecord</dt>
    <dd>The definition on the new or existing record is complete.</dd>
  <dt>newStructureField</dt>
    <dd>A new structure field is being created.</dd>
  <dt>endStructureField</dt>
    <dd>The definition on the new structure field is complete</dd>
  <dt>startArray</dt>
    <dd>A new array field is being created.</dd>
  <dt>endArray</dt>
    <dd>The definition on the new array field is complete</dd>
  <dt>startScalar</dt>
    <dd>A new scalar field is being created.</dd>
  <dt>endScalar</dt>
    <dd>The definition on the new scalar field is complete</dd>
  <dt>startAuxInfo</dt>
    <dd>A new auxInfo is being created.</dd>
  <dt>endAuxInfo</dt>
    <dd>The definition on the new auxInfo is complete</dd>
</dl>

<h4>Include and Substitution</h4>

<p>This support completely handles all details of Macro Substitution and
Include. The code that calls this support sees only the results of substitution
and include.. This support also implements the SAX2 ContentHandler and
EventHandler interfaces. Instead of the SAX2 interfaces, code that uses this
code must implement at least the IncludeSubstituteXMLListener interface.
Support that wants additional information can also implement the
IncludeSubstituteDetailsXMLListener interface. This code, in addition to macro
substitution, provides a simplified version of what SAX2 provides, which also
means that it does not provide access to all of SAX2. </p>

<p>This code does not understand the complete pvData XML syntax. It only
understands the include, substitute, package, and import elements. Thus it
could be used by code other than XML to PVDatabase but any such code must
realize that it does not provide access to all of SAX2.</p>

<h4>IncludeSubstituteXMLListener</h4>

<p>This interface must be implemented by the caller. It is a simplified version
of the SAX2 ContentHandler. The methods are:</p>
<dl>
  <dt>endDocument</dt>
    <dd>The end of the xml input file. This is NOT called for included
    files.</dd>
  <dt>startElement</dt>
    <dd>The opening tag of an xml element is being processed.</dd>
  <dt>element</dt>
    <dd>The value of an xml element, i.e. what appears between the opening and
      closing tags. Any leading and trailing white space of any element
      fragment is removed.</dd>
  <dt>endElement</dt>
    <dd>The end tag opf an xml element is being processed.</dd>
</dl>

<h5>IncludeSubstituteDetailsXMLListener</h5>

<p>This interface can optionally be implemented by the caller. It provides
details about include and substitution details. The methods are:</p>
<dl>
  <dt>startElementBeforeSubstitution</dt>
    <dd>This is the opening tag of an xml element before any substitutions.</dd>
  <dt>elementBeforeSubstitution</dt>
    <dd>This is an xml element value before any substitutions.</dd>
  <dt>newSourceFile</dt>
    <dd>A new file is being included.</dd>
  <dt>endSourceFile</dt>
    <dd>End of an included file,</dd>
  <dt>addPath</dt>
    <dd>A new addPath</dd>
  <dt>removePath</dt>
    <dd>A addPath is being removed.</dd>
  <dt>substitute</dt>
    <dd>A new substitute is defined.</dd>
  <dt>removeSubstitute</dt>
    <dd>A substitute is being removed.</dd>
</dl>

<h5>IncludeSubstituteXMLReader</h5>

<p>The interface implemented by IncludeSubstituteXMLReaderFactory. It provides
two methods: parse and message. The arguments to parse have already been
describes. The message method adds the location within the input xml files when
this method is called.</p>

<h5>IncludeSubstituteXMLReaderFactory</h5>

<p>The factory that implements macro substitution and include.</p>

<h2>Package org.epics.pvioc.util</h2>

<h3>Overview</h3>

<p>This package provides utility code for a javaIOC:</p>
<dl>
  <dt>Scan Field</dt>
    <dd>Interface that makes it easier to access the scan field of a
    record.</dd>
  <dt>Periodic and Event Scanners</dt>
    <dd>Support for records that are periodic or event scanned.</dd>
</dl>

<h3 style="text-align: center;">Scan Field Support</h3>

<h4>Definitions</h4>
<pre>    public interface ScanField {
        ThreadPriority getPriority();
        PVInt getPriorityIndexPV();
        ScanType getScanType();
        PVInt getScanTypeIndexPV();
        double getRate();
        PVDouble getRatePV();
        String getEventName();
        PVString getEventNamePV();
        boolean getProcessSelf();
        PVBoolean getProcessSelfPV();
        boolean getProcessAfterStart();
        PVBoolean getProcessAfterStartPV();
    }
     
    public enum ScanType {
        passive,
        event,
        periodic;
        public static Enumerated getScanType(PVField dbField);
    }
    
    public class ScanFieldFactory {
        public static ScanField create(PVRecord dbRecord);
    }</pre>

<h4>ScanField</h4>

<p>ScanField is a convenience interface for accessing the scan field of a
record. </p>

<h4>ScanType</h4>

<p>This is a Java enum which defines the scan types:</p>
<dl>
  <dt>passive</dt>
    <dd>This is a record that is not periodically or event scanned. It can be
      processed by another requester. For example database links can request
      processing and Channel Access clients can also request processing.</dd>
  <dt>event</dt>
    <dd>A record can be event scanned. If so the record also has an eventName
      assigned to it. An event announcer, defined below, can declare and event.
      This makes all records with the associated eventName process.</dd>
  <dt>periodic</dt>
    <dd>The record is periodically scanned. A peridically scanned record has a
      rate assigned it it.</dd>
</dl>

<p>The method is:</p>
<dl>
  <dt>getScanType</dt>
    <dd>If dbField has an Enumerated Create interface and if the choices match
      the ScanType enum names than it returns the Enumerated interface.
      Otherwise it returns null.</dd>
</dl>

<h4>ScanFieldFactory</h4>

<p>This is a factory for creating a ScanField.</p>
<dl>
  <dt>create</dt>
    <dd>Create a ScanField.</dd>
</dl>

<h3 style="text-align: center;">Periodic and Event Scanners</h3>

<h4>Definitions</h4>
<pre>    public interface EventAnnounce {
        void announce();
    }
    public interface EventScanner {
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord,String eventName,ThreadPriority scanPriority));
        EventAnnounce addEventAnnouncer(String eventName,String announcer);
        void removeEventAnnouncer(EventAnnounce eventAnnounce,String announcer);
        String show(String eventName);
    }
    
    public interface PeriodicScanner {
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord,double rate,ThreadPriority threadPriority);
        String show(ThreadPriority priority);
        String show(double rate);
        String show(double rate,ThreadPriority priority);
    }
    
    public class ScannerFactory {
         public static PeriodicScanner getPeriodicScanner();
         public static EventScanner getEventScanner();
    }</pre>

<h4>EventAnnounce</h4>

<p>This is the interface for announcing an event. The event scanner implements
this interface. An announcer calls eventScanner.addEventAnnouncer in order to
get an EventAnnounce. The announcer then just calls:</p>
<pre>    eventAnnounce.announce();</pre>

<p>when it wants to announce an event.</p>

<h4>EventScanner</h4>

<p>This is the interface for the event scanning facility implemented by
ScannerFactory. It implements the methods:</p>
<dl>
  <dt>addRecord</dt>
    <dd>Add an event scanned record.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from being event scanned.</dd>
  <dt>addEventAnnouncer</dt>
    <dd>Add an event announcer.</dd>
  <dt>removeEventAnnouncer</dt>
    <dd>Remove an event announcer.</dd>
  <dt>show</dt>
    <dd>report announcers and event scanned records</dd>
</dl>

<h4>PeriodicScanner</h4>

<p>This is the interface for the periodic scanning facility implemented by
ScannerFactory. It implements the methods:</p>
<dl>
  <dt>addRecord</dt>
    <dd>Add a new record to a periodically scanned list.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from being periodically scanned.</dd>
  <dt>show</dt>
    <dd>Show periodically scanned records.</dd>
</dl>

<h2>Package org.epics.pvioc.install</h2>

<h3>Overview</h3>

<p>This package provides code to install structures and records into a javaIOC.
A javaIOC is started via JavaIOC.main. Once started structures and records can
be installed either by JavaIOC or by any thread running as part of the
javaIOC.</p>

<p>A javaIOC has two databases: a PVDatabase and an IOCDatabase. The
PVDatabase, which is described in project pvData, holds the memory resident
data. The IOCDatabase provides access to the PVDatabase and to support code.
Both databases are named master.</p>

<p>New structure instances or record instances can be installed into a running
javaIOC. It is not legal to install both new structures and records at the same
time. Installation is done as follows: New instances are read into a new
PVDatabase named beingInstalled. If any error is detected while reading the
file, nothing more is done, i.e. installation fails. If the beingInstalled
database has only structure definitions the new definitions are merged into
master and installation is complete. If the beingInstalled database has only
record instances then the record instances are initialized and started. If any
record can not be started nothing more is done, i.e. the installation fails. If
all records start then an AfterStart procedure described below is performed. As
part of this procedure the new record instances are merged into master. When
the AfterStart procedure is done installation is done. The InstallFactory
ensures that only one installation at a time is allowed.</p>

<p>This overview describes the following:</p>
<dl>
  <dt>Install</dt>
    <dd>The interface for installing structures and records.</dd>
  <dt>InstallFactory</dt>
    <dd>The factory which implements a single instance of Install.</dd>
  <dt>SupportCreation</dt>
    <dd>Support to create, initialize, and start records.</dd>
  <dt>AfterStart</dt>
    <dd>Support that allows support and servers to perform various functions
      after new records have started but before installation is complete. After
      Start allows unrelated support to execute in parallel.</dd>
</dl>

<h3>Install Factory</h3>

<p>InstallFactory is used to install structure or records into master database
of a javaIOC. Only one set of definitions at a time can be installed.</p>

<h4>Definitions</h4>
<pre>interface Install {
    boolean installStructures(String xmlFile,Requester requester);
    boolean installStructures(PVDatabase pvDatabase,Requester requester);
    boolean installStructure(PVStructure pvStructure,Requester requester);
    boolean installRecords(String xmlFile,Requester requester);
    boolean installRecords(PVDatabase pvDatabase,Requester requester);

    boolean installRecord(PVRecord pvRecord,Requester requester);
}

class InstallFactory {
    public static Install get();
}</pre>

<h4>installStructures</h4>

<p>Three methods are provided. The first install structure definitions from
file. The second installs structure definitions from a PVDatabase. The last
installs a single PVStructure.</p>

<p>The xml file must contain xml structure definitions as described in project
pvData. The file is read into a PVDatabase named beingInstalled. If the file is
read successfully the second installStructures method is called.</p>

<p>The next method attempts to install structures from a PVDatabase. The
pvDatabase must not have any records and must not have any structure that is
already in master. If these checks succeed the new definitions are merged into
master. The return value is (false,true) if the new structures (were not, were)
installed.</p>

<p>The last method installs a PVStructure if the structure does not already
exist in the master.</p>

<h4>installRecords</h4>

<p>Three methods are provided. The first Install record definitions from file.
The second installs records from a PVDatabase. The last installs a single
PVRecord.</p>
<ol>
  <li>The xml file must contain xml record definitions as described in project
    pvData. The file is read into a PVDatabase named beingInstalled. If the
    file is read successfully method 2 is called</li>
  <li>This method attempts to install records from a PVDatabase. The pvDatabase
    must not have any structuress and must not have any record that is already
    in master. If these checks succeed an attempt is made to initialize and
    start the records instances as described below.</li>
  <li>The last method creates a PVDatabase named beingInstalled, adds the
    PVRecord to it, and calls method 2.</li>
</ol>

<h4>Initialize, and Start Record Instances</h4>

<p>PVReplaceFactory.replace is called for the PCDatabase holding the new
records.</p>

<p>An IOCDatabase is created for the PVDatabase holding the new records. </p>

<p>A SupportCreation named beingInstalled is created and the following steps
performed</p>
<dl>
  <dt>createSupport</dt>
    <dd>supportCreation.createSupport is called. If it fails installation
    fails.</dd>
  <dt>initialize</dt>
    <dd>supportCreation.initializeSupport is called. If it fails installation
      fails.</dd>
  <dt>start</dt>
    <dd>An AfterStart is created and then supportCreation.start(afterStart) is
      called. If it fails installation fails. </dd>
  <dt>before merge</dt>
    <dd>afterStart.callRequesters(false) is called.</dd>
  <dt>merge</dt>
    <dd>The beingInstalled databases (PVDatabase and IOCDatabase) are each
      merged into the corresponding master database.</dd>
  <dt>after merge</dt>
    <dd>afterStart.callRequesters(true) is called.</dd>
</dl>

<p>The return value is (false,true) if the new records (were not, were)
installed.</p>

<h3 style="text-align: center;">Support Creation</h3>

<p>A SupportCreation is used to create, initialize, and start record instances.
After it is done it is no longer accessable.</p>

<h4>Definitions</h4>
<pre>public class SupportCreationFactory {
    static public SupportCreation create(
         IOCDatabase supportDatabase,Requester requester);
}

public interface SupportCreation {
    boolean createSupport();
    boolean initializeSupport();
    boolean  startSupport(AfterStart afterStart);
}</pre>

<h4>Factory</h4>

<p>This has the single method which creates a SupportCreation.</p>

<h4>SupportCreation</h4>
<dl>
  <dt>createSupport</dt>
    <dd>Create the support. It first created a RecordProcess and then support
      for fields with support.</dd>
  <dt>initializeSupport</dt>
    <dd>Initialize the support. For each record it calls
      recordProcess.initialize. It returns true if all records are
    initialized.</dd>
  <dt>startSupport</dt>
    <dd>Start the support. For each record it calls recordProcess.start. It
      returns true if all records are started.</dd>
</dl>

<h3 style="text-align: center;">After Start</h3>

<p>After Start is a facility that allows support code and servers like Channel
Access to perform various functions after new records are started but before
installation completes. It is designed so that unrelated functions can execute
in parallel and so that related functions can execute in the order they
require</p>

<p>Code can request to be called back before or after the beingInstalled is
merged into the master. Each request also specifies a priority. A callback
should not block. When it is done it must notify AfterStart that is is done.
All callbacks at a particular priority must complete before the callbacks at
the next lower priority are called.</p>

<p>The start method of Support is defined as:</p>
<pre>    void start(AfterStart afterStart);</pre>

<p>The support code can call afterStart.requestCallback. If so it must
implement interface AfterStartRequester. When AfterStartRequester.callback is
called the support code can do what it wants but should not block. Instead it
should arrage for some other thread to do the work. When done the support code
must call afterStart.done.</p>

<p>Servers, i. e. code that is not attached to a record can call
AfterStartFactory.newAfterStartRegister. An example of a server is Channel
Access. The NewAfterStartRequester is called each time a new AfterStart is
created, i.e. every time a new set of records are being installed. The server
can then call afterStart.requestCallback just like support code.</p>

<h4>Definitions</h4>
<pre>public interface AfterStartNode {}

public interface AfterStartRequester {
    void callback(AfterStartNode node);
}

public class AfterStartFactory {
    public static  AfterStart create();
    public static AfterStartNode allocNode(AfterStartRequester requester);
    public static void newAfterStartRegister(NewAfterStartRequester requester);
    public static void newAfterStartUnregister(NewAfterStartRequester requester);
}

public interface AfterStart {
    void callRequesters(boolean afterMerge);
    void requestCallback(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
    void done(AfterStartNode node);
    void doneAndRequest(AfterStartNode node,boolean afterMerge,ThreadPriority priority);
}


public interface NewAfterStartRequester {
    void callback(AfterStart afterStart);
}</pre>

<h4>AfterStartNode</h4>

<p>Any code that calls afterStart.requestCallback must create an afterStartNode
by calling AfterStartFactory.allocNode. It passes this to
afterStart.requestCallback. A node can only be on one request list at a
time.</p>

<h4>AfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
afterStart.requestCallback. It has a single method which is the callback.</p>

<h4>NewAfterStartRequester</h4>

<p>This is the interface which must be implemented by code that calls
AfterStartFactory.NewAfterStartRegister.</p>

<h4>AfterStartFactory</h4>
<dl>
  <dt>create</dt>
    <dd>Create a new AfterStart. This is called by InstallFactory.</dd>
  <dt>allocNode</dt>
    <dd>This is called by any code that calls afterStart.requestCallback. It
      can be reused as desired but a node can only be on a single request queue
      at any given time. </dd>
  <dt>NewAfterStartRegister</dt>
    <dd>This is called by code that wants to be notified when a new AfterStart
      is created, i.e. when new records are being installed.</dd>
  <dt>NewAfterStartUnregister</dt>
    <dd>Remove a NewAfterStartRequester.</dd>
</dl>

<h4>AfterStart</h4>
<dl>
  <dt>callRequesters</dt>
    <dd>Call requesters. This is called by InstallFactory.</dd>
  <dt>requestCallback</dt>
    <dd>A request to be called back. The ThreadPriority does not choose a
      thread but just a priority.</dd>
  <dt>done</dt>
    <dd>The callback is done.</dd>
  <dt>doneAndRequest</dt>
    <dd>The callback is done but want to be called back again. The new request
      queue must be for a later time then the current queue.</dd>
</dl>

<h2>Package org.epics.pvioc.database</h2>

<h3>Overview</h3>

<p>This package provides everything required to create and access a PVDatabase.
</p>

<p>A PVDatabase consists of :</p>
<ol>
  <li>A set of structures. Each has a unique name and is implemented as a top
    level PVStructure. The primary use of these structures is as "templates"
    for creating structure fields within a PVRecord.</li>
  <li>A set of record instances. Each has a unique name and is implemented as a
    PVRecord.</li>
</ol>

<p>Each PVRecord has a unique record name and has top level PVStructure, which
is a structured set of PVFields. A PVRecord can be:</p>
<dl>
  <dt>processed</dt>
    <dd>A record can be processed. In addition each field of a record can
      optionally have attached support. The database does not implement
      processing but allows other code to attach support to fields and
      recordProcess to a record.</dd>
  <dt>locked</dt>
    <dd>Whenever a record is accessed it can be locked. pvIOCJava requires that
      a record be locked whenever it is accessed.</dd>
  <dt>monitored</dt>
    <dd>Any code can register to be called whenever the data for a field is
      modified. If the code listens for changes to a structure field it is
      notified whenever any scalar or array field in the structure is modified.
      PVField provides a method postPut, which must be called by the code that
      calls the put method of the PVField. Note the caller must call postPut
      because for array fields the array might be written in chunks. Only the
      caller knows when it is done.</dd>
  <dt>a message source</dt>
    <dd>Every PVField has a method message, which can be called by any code
      that has access to the PVField. Code can register to be called whenever a
      message is generated.</dd>
</dl>

<h3>RecordField Interfaces</h3>

<p>Each field of a record has an associated PVRecordField and each structure
field a PVRecordStructure.</p>

<h4>PVRecordField</h4>
<pre>    interface PVRecordField extends Requester{
        Support getSupport();
        void setSupport(Support support);
        PVRecordStructure getParent();
        PVField getPVField();
        void replacePVField(PVField newPvField);
        String getFullFieldName();
        String getFullName();
        PVRecord getPVRecord();
        void renameField(String newName);
        boolean addListener(PVListener pvListener);
        void removeListener(PVListener pvListener);
        void postPut();
    }</pre>

<p>where</p>
<dl>
  <dt>getSupport</dt>
    <dd>Get the attached support. This is null if no support has been
    attached.</dd>
  <dt>setSupport</dt>
    <dd>Set support for the field.</dd>
  <dt>getParent</dt>
    <dd>Get the parent PVRecordStructure for this field.</dd>
  <dt>getPVField</dt>
    <dd>Get the PVField associated with this PVRecordField.</dd>
  <dt>replacePVField</dt>
    <dd>If the associated PVField is being replaced it must be replaced by
      calling this instead if directly replacing the PVfield.</dd>
  <dt>getFullName</dt>
    <dd>This gets recordname plus the full name of the field, i.e.
      recordName.field,field,..</dd>
  <dt>getFullFieldName</dt>
    <dd>This gets the full name of the field, i.e. field,field,..</dd>
  <dt>getPVRecord</dt>
    <dd>Returns the PVRecord to which this field belongs.</dd>
  <dt>renameField</dt>
    <dd>Renames the field name. This must be called rather than directly
      calling PVField.renameField.</dd>
  <dt>addListener</dt>
    <dd>Add A PVListener to this field. Whenever this field or any subfield if
      this field is modified the listener will be notified. PVListener is
      described below. Before a listener can call addListener it must first
      call PVRecord.registerListener. </dd>
  <dt>removeListener</dt>
    <dd>Remove a PVListener.</dd>
  <dt>postPut</dt>
    <dd>This is called by the code that implements the data interface. It is
      called whenever the put method is called.</dd>
</dl>

<h4>PVRecordStructure</h4>

<p>Each structure field has the following interface: Note that it extends
PVRecordField</p>
<pre>    public interface PVRecordStructure extends PVRecordField {
        PVRecordField[] getPVRecordFields();
        PVStructure getPVStructure();
    }</pre>

<p>where</p>
<dl>
  <dt>getPVRecordFields</dt>
    <dd>Get the PVRecordField array.</dd>
  <dt>getPVStructure</dt>
    <dd>Get the PVStructure this field accesses.</dd>
</dl>

<h3>Record Interfaces</h3>

<h4>PVListener</h4>

<p>A PVlistener can attach itself to any field or fields of a record. It will
be notified whenever a put is issued to the field, i.e. the field is modified.
If the field is a structure then the PVListener is notified whenever that field
or any subfield is modified. Please note that PVStructureScalar and
PVStructureArray fields are treated as leaf fields so that the underlying
fields can not have attached listeners.</p>
<pre>    public interface PVListener {
        void dataPut(PVRecordField pvRecordField);
        void dataPut(PVRecordStructure requested,PVRecordField pvRecordField);
        void beginGroupPut(PVRecord pvRecord);
        void endGroupPut(PVRecord pvRecord);
        void unlisten(PVRecord pvRecord);
    }</pre>

<p>where</p>
<dl>
  <dt>dataPut(PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. This is called if the listener has called
      PVRecordField.addListener for pvRecordField.</dd>
  <dt>dataPut(PVRecordStructure requested,PVRecordField pvRecordField)</dt>
    <dd>pvField has been modified. Requested is the field to which the
      requester issued a pvField.addListener. This is called if the listener
      has called PVRecordField.addListener for requested.</dd>
  <dt>beginGroup</dt>
    <dd>A related set of changes is being started.</dd>
  <dt>endGroup</dt>
    <dd>A related set of changes is done.</dd>
  <dt>unlisten</dt>
    <dd>The PVLister is being removed from the record. This is called when the
      record is being destroyed or when the record structure (not the data
      values) is being changed.</dd>
</dl>

<h4>PVRecordClient</h4>

<p>Any client that accesses a PVRecord must call registerClient so that the
client can be notified when the record is being removed from the master
database. The client must imnplement the following interface:</p>
<pre>    public interface PVRecordClient {
        void detach(PVRecord pvRecord);
    }</pre>

<h4>PVRecord</h4>

<p>A PVRecord has a top level PVStructure that provides the following
methods:</p>
<pre>    interface PVRecord extends Requester {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        PVRecordField findPVRecordField(PVField pvField);
        PVRecordStructure getPVRecordStructure();
        String getRecordName();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        void lock();
        void unlock();
        void lockOtherRecord(PVRecord otherRecord);
        void beginGroupPut();
        void endGroupPut();
        void registerListener(PVListener pvListener);
        void unregisterListener(PVListener pvListener);
        boolean isRegisteredListener(PVListener pvListener);
        void removeEveryListener();
        void registerClient(PVRecordClient pvRecordClient);
        void unregisterClient(PVRecordClient pvRecordClient);
        void detachClients();
        int getNumberClients();
    }</pre>

<p>where</p>
<dl>
  <dt>getRecordProcess</dt>
    <dd>Get the record process for the record.</dd>
  <dt>setRecordProcess</dt>
    <dd>Set the record process for the record.</dd>
  <dt>findPVRecordField</dt>
    <dd>Given a PVField find the PVRecordField.</dd>
  <dt>getPVRecordStructure</dt>
    <dd>Get the top level PVRecordStructure for the record.</dd>
  <dt>getRecordName</dt>
    <dd>Returns the record name.</dd>
  <dt>message</dt>
    <dd>This is called by AbstractPVField if it has a RecordField. It can be
      called by other code but most code will not need it.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a message requester</dd>
  <dt>lock</dt>
    <dd>Lock the record. See next sub-section.</dd>
  <dt>unlock</dt>
    <dd>Unlock the record.</dd>
  <dt>lockOtherRecord</dt>
    <dd>While code has a record locked, It can also lock another record. If the
      other record is already locked than this record may be temporily unlocked
      and then relocked. The caller must call the unlock merthod of the other
      record when done with it. The implementation prevents deadlocks BUT code
      must not try to lock more than two records at the same time or deadlocks
      can occur.</dd>
  <dt>beginGroupPut</dt>
    <dd>Begin a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>endGroupPut</dt>
    <dd>End a group of puts. This results in all registered PVListeners being
      called.</dd>
  <dt>registerListener</dt>
    <dd>Register a PVListener. This must be called before calling
      pvRecordField.addListener.</dd>
  <dt>unregisterListener</dt>
    <dd>Unregister a listener. The listener will also be removed from all
      fields to which it is attached.</dd>
  <dt>isRegisteredListener</dt>
    <dd>Id the PVListener registered?</dd>
  <dt>removeEveryListener</dt>
    <dd>This must be called by any code that is deleting or changing the
      structure of a record.</dd>
  <dt>registerClient</dt>
    <dd>Every client that accesses the record must call this so that the client
      can be notified when the record is deleted.</dd>
  <dt>unregisterClient</dt>
    <dd>Client is no longer accessing the record.</dd>
  <dt>detachClients</dt>
    <dd>All client are asked to detach from the record.</dd>
  <dt>getNumberClients</dt>
    <dd>Get the number of registered clients.</dd>
</dl>

<h5>Record Locking</h5>

<p>Whever code access a record it must be locked. The code for accessing a
record should use the following pattern:</p>
<pre>    pvRecord.lock();
    try {
       // access the record
    } finally {
        pvRecord.unlock();
    }</pre>

<p>Depending on the application, for example pvIOCJava, it may be required that
the thread does not block between lock and unlock.</p>

<h3>PVRecord Definition and Creation</h3>

<h4>PVDatabase</h4>

<p>The interface is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String name);
        boolean addRecord(PVRecord pvRecord);
        boolean removeRecord(PVRecord pvRecord);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String name);
        boolean addStructure(PVStructure pvStructure);
        boolean removeStructure(PVStructure pvStructure);
        String[] getStructureNames();
        PVStructure getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is just a convenience mthhod.</dd>
  <dt>getName</dt>
    <dd>Get the name of the database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into the master database.</dd>
  <dt>findRecord</dt>
    <dd>Find a record. Null is returned if the record is not in the
    database.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database. If the record already exists it is not
      modified and false is returned.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database. If the record was not in the
      database false is returned.</dd>
  <dt>getRecordNames</dt>
    <dd>Get an array of the record names.</dd>
  <dt>getRecords</dt>
    <dd>Get a array of all the records.</dd>
  <dt>findStructure</dt>
    <dd>Find a structure. Null is returned if the structure is not in the
      database.</dd>
  <dt>addStructure</dt>
    <dd>Add a structure to the database. If it already exists false is
    returned.</dd>
  <dt>removeStructure</dt>
    <dd>Remove a structure from the database. If it did not exist false is
      returned.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the structure names.</dd>
  <dt>getStructures</dt>
    <dd>Get a array of all the structures.</dd>
  <dt>message</dt>
    <dd>Report a message. If no listeners are registered the messages are sent
      to System.out (info) or System.err (all other message types). If at least
      one requester is present then the messages are given to the requesters
      without writing to System.out or System.err. If the database is the
      master, the message is put of a queue that is emptied by another thread.
      This messages sent to the master do not block.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester to receive messages.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get a list of all records with names that match a regular
    expression.</dd>
  <dt>structureList</dt>
    <dd>Get a list of all structures with names that match a regular
    expression.</dd>
  <dt>recordToString</dt>
    <dd>Get a dump of all records with names that match a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Get a dump of all structures with names that match a regular
    expression.</dd>
</dl>

<h4>PVRecordCreate</h4>

<p>Interface and factory for creating PVrecords and PVStructures.</p>
<pre>    interface PVRecordCreate {
        PVRecord createPVRecord(String recordName,PVStructure pvStructure);
    }

    class PVRecordCreateFactory{
        PVRecordCreate getPVRecordCreate();
    }</pre>

<p>where</p>
<dl>
  <dt>createPVRecord</dt>
    <dd>Create a PVRecord with pvStructure as the top level structure.</dd>
</dl>

<h4>PVReplaceFactory</h4>

<p>Factory that looks for and calls factories that replace the default
implementation of a field.</p>
<pre>    class PVReplaceFactory {
        public static void replace(PVDatabase pvDatabase);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordStructure pvRecordStructure);
        public static void replace(PVDatabase pvDatabase,
            PVRecord pvRecord,PVRecordField pvRecordField);</pre>

<p>where</p>
<dl>
  <dt>replace(PVDatabase pvDatabase)</dt>
    <dd>Look at every field of every record in the database and see if field
      implementation should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordStructure
  pvRecordStructure)</dt>
    <dd>Look at every field of pvStructure and see if the field implementation
      should be replaced.</dd>
  <dt>replace(PVDatabase pvDatabase,PVRecord pvRecord,PVRecordField
  pvRecordField)</dt>
    <dd><p>Look at the field and see if the field implementation should be
      replaced. If it is a structure field also look at the subfields.</p>
    </dd>
</dl>

<h3>PVDatabase</h3>

<p>PVDatabase is an interface for accessing a PVData database. </p>

<p>A PVDatabase contains structures and records. Structures provided an easy
way to create an initial set of subfields of a structure field of record
instances or other structures. When a structure field of a record is defined as
follows:</p>
<pre>    &lt;record name = ... /&gt;
        &lt;!-- other fields --&gt;
        &lt;structure name = "name" extends = "structName" /&gt;
        &lt;!-- ... --&gt;
    &lt;/record&gt;</pre>

<p>Then the fields in the structure are initialized with a copy of the fields
in structure "structName". </p>

<p>The Interface definition is:</p>
<pre>    interface PVDatabase extends Requester{
        PVDatabase getMaster();
        String getName();
        void mergeIntoMaster();
        PVRecord findRecord(String recordName);
        boolean addRecord(PVRecord record);
        boolean removeRecord(PVRecord record);
        String[] getRecordNames();
        PVRecord[] getRecords();
        PVStructure findStructure(String structureName);
        boolean addStructure(PVStructure structure);
        boolean removeStructure(PVStructure structure);
        String[] getStructureNames();
        PVStructure[] getStructures();
        void message(String message, MessageType messageType);
        void addRequester(Requester requester);
        void removeRequester(Requester requester);
        String[] recordList(String regularExpression);
        String[] structureList(String regularExpression);
        String recordToString(String regularExpression);
        String structureToString(String regularExpression);
    }</pre>

<p>where</p>
<dl>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database that is
    processed,</dd>
  <dt>getName</dt>
    <dd>Get the name of this database.</dd>
  <dt>mergeIntoMaster</dt>
    <dd>Merge this database into master. The database must be named
      "beingInstalled". After this returns another beingInstalled database can
      be created.</dd>
  <dt>findRecord</dt>
    <dd>Find a PVRecord. If not found null is returned.</dd>
  <dt>addRecord</dt>
    <dd>Add a record to the database.</dd>
  <dt>removeRecord</dt>
    <dd>Remove a record from the database.</dd>
  <dt>gerRecordNames</dt>
    <dd>Get an array of the names of the current records in the database.</dd>
  <dt>getRecords</dt>
    <dd>Get an array of the current records in the database.</dd>
  <dt>findStructure</dt>
    <dd>Find a PVStructure. If not found null is returned.</dd>
  <dt>addStructure</dt>
    <dd>Add a PVStructure to the database.</dd>
  <dt>removeStructure</dt>
    <dd>Removed a PVStructure from the database.</dd>
  <dt>getStructureNames</dt>
    <dd>Get an array of the names of the current structures in the
    database.</dd>
  <dt>getStructures</dt>
    <dd>Get an array of the current structuress in the database.</dd>
  <dt>message</dt>
    <dd>Called by a PVDatabase to report messages. This gives a way for a
      client to get all messages from all records in a database.</dd>
  <dt>addRequester</dt>
    <dd>Add a requester.</dd>
  <dt>removeRequester</dt>
    <dd>Remove a requester.</dd>
  <dt>recordList</dt>
    <dd>Get an array of record names that satisfy a regular expression.</dd>
  <dt>structureList</dt>
    <dd>Get an array of structure names that satisfy a regular expression.</dd>
  <dt>recordToString</dt>
    <dd>Dumps all records with record names that satisfy a regular
    expression.</dd>
  <dt>structureToString</dt>
    <dd>Dumps all structures with structure names that satisfy a regular
      expression.</dd>
</dl>

<h4>PVDatabaseFactory</h4>

<p>This is a factort that creates a PVDatabase.</p>
<pre>    class PVDatabaseFactory {
        public static PVDatabase create(String name);
        public static PVDatabase getMaster();
        public static PVDatabase getBeingInstalled();
    }</pre>
<dl>
  <dt>create</dt>
    <dd>Create a PVDatabase. If this is a database that is intended to merge
      into master it MUST be named "beingInstalled". If a beingInstalled
      database already exists than an IllegalStateException is thrown.</dd>
  <dt>getMaster</dt>
    <dd>Get the master database. This is the only database than can be
      processed and the only database pvAccess uses.</dd>
  <dt>getBeingInstalled</dt>
    <dd>Get the beingInstalled database. In not present null is returned.</dd>
</dl>

<h2>Package org.epics.pvioc.support</h2>

<h3>Overview</h3>

<p>This package describes how records are processed. Package install describes
how records are initialized and started. During database creation each record
is assigned an instance of RecordProcess, which coordinates record processing.
In addition each record has a Support instance and each field can optionally
have an associated Support instance. </p>

<h4>RecordProcess</h4>

<p>The following interfaces are involved with record processing:</p>
<dl>
  <dt>RecordProcess</dt>
    <dd>An instance is created for each IOC record. It has methods for use by
      any code interested in record processing.</dd>
  <dt>ProcessToken</dt>
    <dd>A token that allocated by RecordProcess and used by
      RecordProcessRequesters.</dd>
  <dt>RecordProcessRequester</dt>
    <dd>Implemented by code that calls recordProcess.process..</dd>
  <dt>ProcessCallbackRequester</dt>
    <dd>Implemented by code that calls
    recordProcess.requestProcessCallback.</dd>
  <dt>ProcessContinueRequester</dt>
    <dd>Implemented by code that calls recordProcess.processContinue.</dd>
</dl>

<h4>Support</h4>

<p>Every pvIOCJava record instance has associated support code and each field
of a record instance can optionally have associated support code. This package
contains: </p>
<dl>
  <dt>Support</dt>
    <dd>The interface which is implemented by every support module.</dd>
  <dt>AbstractSupport</dt>
    <dd>An abstract class that is the base class for every support module.</dd>
</dl>

<p>This package has sub-packages for the support modules implemented by the
javaIOC itself. Other pvIOCJava applications can implement additional support
modules. The sub-packages are:</p>
<dl>
  <dt>basic</dt>
    <dd>Implements the following support: 
      <dl>
        <dt>generic</dt>
          <dd>Generic support for a record type, structure, and an array of
            arrays or structures.</dd>
        <dt>noop</dt>
          <dd>Support that does nothing except complete successfully.</dd>
        <dt>linearConvert</dt>
          <dd>Implements linear conversion for a numeric scalar field.</dd>
        <dt>digital</dt>
          <dd>Support for digital I/O.</dd>
        <dt>incremental</dt>
          <dd>Support for incremental output.</dd>
        <dt>delay</dt>
          <dd>Adds a delay to record processing.</dd>
        <dt>event</dt>
          <dd>Support for a string field that is the name of an event.</dd>
        <dt>processControl</dt>
          <dd>Support for the processControl record type. This is a record type
            that attaches to another record. The scan state of the record can
            be changed, the trace and enable states can be changed, and the
            structure of a sub-field can be changed.</dd>
        <dt>scan</dt>
          <dd>Support for the scan field.</dd>
        <dt>supportArray</dt>
          <dd>Support for an array field where each element is a structure.</dd>
      </dl>
    </dd>
  <dt>ca</dt>
    <dd>Implements support for channel access links, i.e. links to other
      records.</dd>
  <dt>dbLink</dt>
    <dd>Implements support for database links, i.e. links to other records in
      the same javaIOC.</dd>
  <dt>alarm</dt>
    <dd>Raises alarms for value fields.</dd>
  <dt>calc</dt>
    <dd>Support for performing calculations.</dd>
  <dt>device</dt>
    <dd>Examples of support that implements device abstractions.</dd>
  <dt>drv</dt>
    <dd>Support for communicating with portDriver.</dd>
</dl>

<h3>Record Processing Theory of Operation</h3>

<p>A pvIOCJava Database is a "smart" database. Each record has associated
support code and each field of a record can optionally have associated
support.</p>

<p>Each record has an implementation of recordProcess associated with it.
recordProcess can be requested to process the record. It in turn calls the
process method of the support attached to the record. A record is also the top
level structure. The record support process method calls the support for any
field of the top level structure that has associated support. Any support can
call other support.</p>

<h4>Definitions</h4>
<dl>
  <dt>synchronous</dt>
    <dd>Code that does not block, i.e. does not perform actions like waiting
      for I/O to complete.</dd>
  <dt>asynchronous</dt>
    <dd>Code that can block.</dd>
  <dt>record</dt>
    <dd>A record instance.</dd>
  <dt>process</dt>
    <dd>Processing a record instance.</dd>
  <dt>support</dt>
    <dd>Code that is involved with implementing record processing. This code
      can be either synchronous or asynchronous. Support code can invoke other
      support code.</dd>
  <dt>record support</dt>
    <dd>The top level support for a record instance. Support that is attached
      to a structure can also be record support if the structure is the top
      level structure. </dd>
  <dt>recordProcess</dt>
    <dd>During database initialization every record instance is assigned an
      instances of RecordProcess, which coordinates record processing.</dd>
  <dt>process requester</dt>
    <dd>Code that asks recordProcess to process a record. A process requester
      must get a ProcessToken from record process in order to request that a
      record can be processed. A record instance can optionally be set to allow
      only a single process requester, in which case only the first requester
      that asks for a token will receive a token..</dd>
  <dt>active</dt>
    <dd>A record instance is active while a process request is active. A
      request to set a record active will fail if it is already active..</dd>
  <dt>lock</dt>
    <dd>Short for record instance lock. A record must be locked whenever any
      field of a record is accessed. Code executing with a record locked must
      be synchronous. There is no way to detect if code violates this rule so
      code must be implemented carefully.</dd>
</dl>

<h4>Requester Examples</h4>
<dl>
  <dt>Local Channel Access</dt>
    <dd>An example is a channel access server that is accessing IOC database.
      The following are typical requests: 
      <dl>
        <dt>get or put</dt>
          <dd>Just get or put data from a record instance.</dd>
        <dt>process and get</dt>
          <dd>An example is to process a record and get an array of data as
            well as the status, severity, and timeStamp.</dd>
        <dt>put, process, get</dt>
          <dd>A example is to put something into the record, make it process,
            and after processing get some data as well as the status, severity,
            and timeStamp.</dd>
      </dl>
    </dd>
  <dt>Database Links</dt>
    <dd>Links between records in the same IOC. When a database link makes a
      request to process a linked record, the record containing the link MUST
      be unlocked or deadlocks may occur. For efficency requests should be done
      with as few lock/unlock cycles and context switches as possible. In
      particular only asynchronous support should cause a context switch. <br />
      Typical requests are: 
      <dl>
        <dt>process and get</dt>
          <dd>Process and after procsss completes get data and/or severity.</dd>
        <dt>put, process, and get severity</dt>
          <dd>Put data to the linked record, process it, and then get the
            severity.</dd>
      </dl>
    </dd>
</dl>

<h4>RecordProcess Overview</h4>

<p>A record is processed via a call to RecordProcess.process. It in turn calls
the record support process method. Record support optionally calls the process
methods of field support modules. Each support module can optionally call the
process method of support code for subfields. Record support is just like field
support except that it is attached to the record rather than to a subfield of
the record.</p>

<p>Record processing has the following features:</p>
<ul>
  <li>synchronous and asynchronous support 
    <p>Synchronous support is suport that can implemented without blocking.
    Asynchronous support is support that must wait. For example network
    requests must block. Asynchronous support does not cause record processing
    to block. Instead the support code returns without completing and arranges
    some other way to perform it's function. When it is done it again interacts
    with record processing to complete.</p>
    <p>While asynchronous support is active the associated record is active and
    other requests to process the record will fail.</p>
  </li>
  <li>record locking 
    <p>Each record instance has a lock. The lock must be held whenever any
    field in the record is being accessed and whenever there is any
    communication between support code or between support code and
    RecordProcess.</p>
  </li>
  <li>RecordProcsssRequester 
    <p>A record instance can have 0 or more record process requesters. A record
    can optionally be set to allow at most one record process requesters. Code
    that wants to request processing must first request a ProcesssToken. Then
    it can queue requests to call process.</p>
  </li>
  <li>RecordProcess 
    <p>Each record has an instance of RecordProcess. It manages all process
    related activities.</p>
  </li>
</ul>

<p>The methods involved in processing are:</p>
<ul>
  <li>recordProcess 
    <ul>
      <li>queueRequest 
        <p>A process requester calls this method to request processing. When a
        request is taken from the queue, the record is set active and the
        becomeProcessr method implemented by the process requester is called.
        The requester can optionally put data into the record and then calls
        process.</p>
      </li>
      <li>process 
        <p>recordSupport.process is called. The results of processing are sent
        to the requester via the RecordProcessRequester methods. The requester
        can request the record be left active when processing completes.</p>
      </li>
      <li>setInactive 
        <p>Must be called if the requester asked that the record be left active
        when processing completes.</p>
      </li>
      <li>processContinue 
        <p>Called by asynchronous support when it is ready to continue
        processing. The record is locked and
        processContinueRequester.processContinue is called..</p>
      </li>
      <li>requestProcessCallback 
        <p>Any support code called directly or indirectly by process or
        processContinue can call this method.
        processRequestRequester.processCallback is called with the record
        unlocked. Support code that processes other records must only issue the
        process requests via this method or deadlocks can occur.</p>
      </li>
    </ul>
  </li>
  <li>Support - defined in package org.epics.pvioc.support 
    <ul>
      <li>process(SupportProcessRequester supportProcessRequester) 
        <p>This is a method that must be implemented by all support modules.
        When the support is done it calls the supportProcessRequester to report
        completion.</p>
      </li>
    </ul>
  </li>
  <li>RecordProcessRequester 
    <ul>
      <li>becomeProcessor 
        <p>Called as a result of a queueRequest.</p>
      </li>
      <li>canNotProcess 
        <p>The requester has issued a queue request but is not able to process
        the record, for example the record might be disabled.</p>
      </li>
      <li>lostRightToProcess 
        <p>The requester has lost the right to issue queue requests. One reason
        why this could be called is the a recod is dynamically declared to have
        only a single process requester.</p>
      </li>
    </ul>
    <ul>
      <li>recordProcessResult 
        <p>Called with the record locked and all processing is complete.</p>
      </li>
      <li>recordProcessComplete() 
        <p>Called with the record inlocked and processing complete.</p>
      </li>
    </ul>
  </li>
  <li>SupportProcessRequester 
    <ul>
      <li>supportProcessDone(RequestResult requestResult) 
        <p>called by whoever calls support.process. In particular recordSupport
        implements this interface</p>
      </li>
    </ul>
  </li>
  <li>ProcessCallbackRequester 
    <ul>
      <li>processCallback() 
        <p>called by recordProcess with record unlocked.</p>
      </li>
    </ul>
  </li>
  <li>ProcessContinueRequester 
    <ul>
      <li>processContinue() 
        <p>called by recordProcess with record locked.</p>
      </li>
    </ul>
  </li>
</ul>

<h4>Local Channel Access Example</h4>

<p>As an example assume that a channel access server does the following to a
record:</p>
<ul>
  <li>Puts data into the record.</li>
  <li>Processes the record.</li>
  <li>Reads a large array from the record. The array is too big to fit in a
    single network buffer.</li>
</ul>

<p>This can be implemented as follows:</p>
<ul>
  <li>server calls recordSupport.queueRequest. As a result becomeProcessor will
    be called.</li>
  <li>server locks the record, puts data, unlocks the record.</li>
  <li>server calls recordSupport.process and specifies that the record be left
    active.</li>
  <li>When processing is complete recordSupport calls
    server.recordProcessResult and server.recordProcessDone.</li>
  <li>The server gets the array. It may have to access the array multiple times
    because of the network buffer restrictions. It must lock the record as it
    reads each segment.</li>
  <li>The server calls recordSupport.setInactive.</li>
</ul>

<h4>Link Support Example</h4>

<p>As an example assume that a record type double has the following fields:</p>
<dl>
  <dt>value</dt>
    <dd>A PVDouble field, i.e. a field that holds a double value.</dd>
  <dt>input</dt>
    <dd>A PVStructure field which is by default a null structure, i.e. it has
      no fields and no support. A record instance can override this to be any
      structure defined in the master Database Definition Database. The default
      support can also be overridden.</dd>
  <dt>output</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>valueAlarm</dt>
    <dd>Also a null PVStructure field.</dd>
  <dt>supportArray</dt>
    <dd>An array field with the elementType set to structure and the
      supportName set to supportArray.</dd>
  <dt>...</dt>
    <dd>Several other null PVStructure fields are present.</dd>
</dl>

<p>In addition the following support modules are available.</p>
<dl>
  <dt>generic</dt>
    <dd>Support for a structure. For each field in the structure that has
      support, generic calls it. </dd>
  <dt>inputLink</dt>
    <dd>A link support modules that supports channel access input links, i.e. a
      link that gets input from another IOC record.</dd>
  <dt>processLink</dt>
    <dd>A link support modules that supports channel access process links, i.e.
      a link that can request that another record be processed.</dd>
  <dt>outputLink</dt>
    <dd>A link support module that supports channel access output links, i.e. a
      link that can put data to another record.</dd>
  <dt>...</dt>
    <dd>Support modules are also available that can be attached to other null
      PVStructure fields.</dd>
</dl>

<p>Assume a record instance is defined as follows:</p>
<pre>&lt;record name = "double01" type = "generic"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "display" type = "display" /&gt;
    &lt;structure name = "input" type = "inputSupport"&gt;
        &lt;scalar name = "pvname"&gt;recordForInput&lt;/scalar&gt;
        &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;scalar name = "propertyNames"&gt;alarm,display&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "link" type = "generic" &gt;
        &lt;structure name = "process" type = "processSupport"&gt;
            &lt;scalar name = "pvname"&gt;processRecord&lt;/scalar&gt;
            &lt;scalar name = "wait" type = "boolean" &gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "output" type = "outputSupport"&gt;
             &lt;scalar name = "pvname"&gt;outputRecord&lt;/scalar&gt;
             &lt;scalar name = "process"&gt;false&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>When the record is processed, via a call to recordProcess.process, the
following happens:</p>
<ul>
  <li>recordProcess locks the record and prepares the for processing. The
    record will remain active until the record is completely processed.</li>
  <li>recordProcess calls doubleRecord.process, which is actually generic
    support. For this example it will be called doubleRecord so that it is not
    confused with the generic support for field link</li>
  <li>doubleRecord calls inputSupport.process.</li>
  <li>Assuming the recordForInput is local and since process is false, the
    input support just: 
    <ul>
      <li>locks the linked record</li>
      <li>transfers data from the linked record to the double record.</li>
      <li>unlocks the linked record.</li>
      <li>notifys doubleRecord that it has completed.</li>
    </ul>
  </li>
  <li>doubleRecord calls link.process.</li>
  <li>generic calls recordProcess.requestProcessCallback.</li>
  <li>doubleRecord returns.</li>
  <li>recordProcess unlocks the record and calls generic.processCallback.<br />
    generic calls the process method of both processSupport and outputSupport. 
    <p>processSupport does the following:</p>
    <ul>
      <li>calls recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to request that
        the linked record be processed. The request does not block. When
        channel access completes the request it calls the processDone method of
        processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>outputSupport does the following.</p>
    <ul>
      <li>Copies the value field to a private data store. It then calls
        recordProcess.requestProcessCallback</li>
      <li>processCallback is called. It invokes channel access to put the
        private data into the linked record and then process the record. When
        channel access completes the request it calls the processDone method of
        processSupport.</li>
      <li>processDone calls recordProcess.processContinue, which calls the
        processContinue method of processSupport.</li>
      <li>processContinue calls supportProcessRequester.supportProcessDone,
        which is a method of generic.</li>
    </ul>
    <p>generic keeps track of each support it calls. When all have called
    supportProcessDone then supportArray is also done.</p>
  </li>
  <li>generic, when done, calls recordSupport.processContinue.</li>
  <li>recordSupport calls generic.processContinue</li>
  <li>generic calls doubleRecord.supportProcessDone.</li>
  <li>doubleRecord calls recordProcess.supportProcessDone</li>
  <li>recordProcess completes record processing 
    <ul>
      <li>calls recordProcessRequester.recordProcessResult</li>
      <li>unlocks the record and sets the record inactive.</li>
      <li>calls recordProcessRequester.recordProcessComplete.</li>
    </ul>
  </li>
</ul>

<h4>Locking</h4>

<p>The locking strategy is based on the following:</p>
<ul>
  <li>Each record instance has a lock.</li>
  <li>A record must be locked when any field is being accessed.</li>
  <li>A record must be locked while processing. 
    <ul>
      <li>process must be called to start processing</li>
      <li>processContinue must be called before asynchronous support interacts
        with the record or other support.</li>
    </ul>
  </li>
  <li>Whenever possible listeners should be called with no locks taken.</li>
  <li>Locks should always be taken with code that has the form: 
    <pre>record.lock();
try {
     ...

} finally {
    record.unlock();
}
    </pre>
  </li>
  <li>Code must not block while a record is locked.</li>
  <li>Two records can be locked simultaneously via: 
    <pre>record.lockOtherRecord(otherRecord);
try {
     ...

} finally {
    otherRecord.unlock();
}
    </pre>
    While a record is locked another record should never be locked by calling
    it's record.lock directly. Doing so can lead to deadlocks. It is NOT
    permissible to lock more than two records at a time.</li>
</ul>

<h4>Support Overview</h4>

<p>A support module implements the following methods:</p>
<dl>
  <dt>initialize</dt>
    <dd>The support can do any initialization that does not connect outside the
      record.</dd>
  <dt>start</dt>
    <dd>The support can connect outside the record. For example channel access
      support can connect to another record.</dd>
  <dt>stop</dt>
    <dd>The support must terminate outside connections.</dd>
  <dt>uninitialize</dt>
    <dd>The support must undo everything it did during initialization.</dd>
  <dt>process</dt>
    <dd>Implements the semantics of record procession.</dd>
</dl>

<p>The methods initialize, start, stop, and uninitialize provide the ability to
dynamically modify a record.</p>

<p>Support is associated with a structure, record, or field definition via an
auxInfo definition that has a name of "supportFactory". In addition there must
be a structure definition for the factory itself. Look at the xml structure
definitions that come with the javaIOC for examples.</p>

<h3 style="text-align: center;">Record Process</h3>

<h4>Definitions</h4>

<p>The following are the interfaces for record processing:</p>
<pre>    
    public interface RecordProcess {
        // general purpose methods
        boolean isEnabled();
        boolean setEnabled(boolean value);
        boolean isActive();
        PVRecord getRecord();
        boolean isTrace();
        boolean setTrace(boolean value);
        SupportState getSupportState();
        // support lifecycle methods
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        // record process requester methods
        ProcessToken requestProcessToken(RecordProcessRequester recordProcessRequester);
        void releaseProcessToken(ProcessToken processToken);
        void forceInactive();
        String getRecordProcessRequesterName();
        void queueProcessRequest(ProcessToken processToken);
        void process(ProcessToken processToken,
            boolean leaveActive, TimeStamp timeStamp);
        void setInactive(ProcessToken processToken);
        // support processing methods
        void processContinue(
            ProcessContinueRequester processContinueRequester);
        void requestProcessCallback(
            ProcessCallbackRequester processCallbackRequester);
        void setTimeStamp(TimeStamp timeStamp);
        void getTimeStamp(TimeStamp timeStamp);
        // self processing method
    }

    public interface ProcessToken {}

    public interface RecordProcessRequester extends Requester{
        void becomeProcessor();
        void canNotProcess(String reason);
        void lostRightToProcess();
        void recordProcessResult(RequestResult requestResult);
        void recordProcessComplete();
    }

    public interface ProcessCallbackRequester extends Requester{
        void processCallback();
    }

    public interface ProcessContinueRequester {
        void processContinue();
    }
    
    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>An instance of RecordProcess is created for each IOCrecord. Each method
falls into one of the following classes:</p>
<ol>
  <li>General Purpose. These are methods that can be called by any code. If
    necessary a method locks the record while performing its action and unlocks
    before returning.</li>
  <li>Record Support Lifetime. Initialize,start,stop,ininitialize.</li>
  <li>Record Process Requester: These are methods for code that requests record
    processing.</li>
  <li>Support Processing. These are methods for use by support code, i.e. code
    that implements record processing.</li>
</ol>

<h4>RecordProcess - General Purpose Methods</h4>
<dl>
  <dt>isEnabled</dt>
    <dd>Is the record enabled?</dd>
  <dt>setEnabled</dt>
    <dd>When record is disabled then all requests to process the record fail.
      If the record is active when a record is disabled the current process is
      allowed to complete.</dd>
  <dt>isActive</dt>
    <dd>Is the record active, i.e. processing?</dd>
  <dt>getRecord</dt>
    <dd>Get the record instance to which this RecordProcess is attached.</dd>
  <dt>isTrace</dt>
    <dd>Is trace active for this record?</dd>
  <dt>setTrace</dt>
    <dd>Set tracing on or off. When true info messages are sent to
      pvRecord.message whenever any processing related method of RecordProcess
      is called.</dd>
  <dt>getSupportState</dt>
    <dd>Get the current support state.</dd>
</dl>

<h4>RecordProcess - Record Lifetime Methods.</h4>

<p>RecordProcess looks for the fields timeStamp, <b>processAfterStart</b> , and
<b>scan</b>. It handles these fields itself. The record support code must
ignore these fields.</p>
<dl>
  <dt>initialize</dt>
    <dd>Initialize record support. record support, in turn, initializes support
      that it invokes. Initialize should perform any initialiation not
      requiring access aanything outside the record. For example it is not
      permissible to connect to other records. If initialize is successful
      record support enters state <b>SupportState.readyForStart</b></dd>
  <dt>start</dt>
    <dd>Start record support. Again record support calls start for any support
      it invokes. If successful, the support enters state
      <b>SupportState.ready</b>. Until record support is in the ready state any
      attempt to process a record will fail.</dd>
  <dt>stop</dt>
    <dd>Stop record support. Record support calls stop for any support it
      invokes. The support enters state <b>SupportState.readyForStart</b>.</dd>
  <dt>uninitialize</dt>
    <dd>Unitialize record support. It calls unitialize for any support it
      invokes. The support enters state
    <b>SupportState.readyForInitialize</b>.</dd>
</dl>

<h4>RecordProcess - Record Process Requester Methods</h4>

<p>These are methods called by code that wants a record processed.</p>
<dl>
  <dt>requestProcessToken</dt>
    <dd>Called by a code that wants to call queueProcessRequest.</dd>
  <dt>releaseProcessToken</dt>
    <dd>Called by code that no longer wants to call queueRequest.</dd>
  <dt>forceInactive</dt>
    <dd>Called by code that has a ProcessToken but will no longer be allowed to
      call queueProcessRequest.</dd>
  <dt>getRecordProcessRequesterName</dt>
    <dd>Get the name of the recordProcessRequester.</dd>
  <dt>queueProcessRequest</dt>
    <dd>Request to be the record processor. Each record instance can have only
      one record process requester. If a requester is already registered a
      message is sent to the requester and false is returned.</dd>
  <dt>process</dt>
    <dd>Request that the record be processed. If the caller has not called
      setActive the record is prepared for processing. In either case if the
      record is ready record support process is called. If true is returned the
      methods implemented by the recordProcessRequester are called to show the
      results of the process request. If <b>leaveActive</b> is true than when
      the record completes processing it is left active until setInActive is
      called. Until the record becomes inactive another request to process the
      record will fail. Record support is called with the record locked.<br />
      If false is returned the request has failed and
      recordProcessRequester.message is called to provide the reason. If
      recordProcessRequester is null an IllegalStateException is thrown. </dd>
  <dt>setInActive</dt>
    <dd>Call by the record process requester when it is done with processing.
      Calling process with <b>leaveActive</b> true and then calling setInactive
      allows the requester to communicated with other code after the record is
      unlocked but before it becomes inactive.</dd>
</dl>

<h4>RecordProcess - Support Processing methods.</h4>

<p>Methods called by support code which may be record support or support called
directly or indirectly by record support. Except for <b>processContinue</b>
these methods throw an exception unless process or <b>processContinue</b> is
running.</p>
<dl>
  <dt>requestProcessCallback</dt>
    <dd>Request to be called back after record support has returned but before
      RecordProcess.process returns. The callback is made with the record
      unlocked. Thus the callback can request that other records be processed.
      This is the way support code can process other records. If support code
      directly request processing of linked records deadlocks can occur.</dd>
  <dt>processContinue</dt>
    <dd>Request that the processContinue method of the support be called. The
      record will be locked before the support is called. This is the only way
      asynchronous support code should access a record after it's process
      method has returned active.</dd>
  <dt>setTimeStamp</dt>
    <dd>Set the time stamp for the record. If no code calls this while a record
      is being processed, then RecordProcess will set the time stamp if the
      record has a timeStamp field.</dd>
  <dt>getTimeStamp</dt>
    <dd>Get the latest time stamp set by calls to <b>setTimeStamp</b></dd>
</dl>

<h4>RecordProcessRequester</h4>

<p>Methods implemented by code that requests that a record be processed.</p>
<dl>
  <dt>becomeProcessor</dt>
    <dd>Called as a result of queueRequeProcessst. The requester can the call
      process.</dd>
  <dt>canNotProces</dt>
    <dd>Called as a result of queueProcessRequest but the record can not be
      processed. For example it might be disabled.</dd>
  <dt>lostRightToProcess</dt>
    <dd>Called when code that has a ProcessToken will no longer be allowed to
      call queueProcessRequest. This can happen if a record is dynamically set
      to allow only a single process requester.</dd>
  <dt>recordProcessResult</dt>
    <dd>The results of record processing. This is called with the record locked
      so that the process requester can access data from the record.</dd>
  <dt>recordProcessComplete</dt>
    <dd>Processing is complete. This is called with the record unlocked. If the
      process requester called process with leaveActive <b>true</b> then the
      requester must call setInactive.</dd>
</dl>

<h4>ProcessCallbackRequester</h4>

<p>The method implemented by code that calls requestProcessCallback.</p>
<dl>
  <dt>processCallback</dt>
    <dd>The callback to call when the record support process method returns it
      RecordProcess. Any support code that wants to process other records must
      use this interface. The callback is called with the record unlocked.</dd>
</dl>

<h4>ProcessContinueRequester</h4>

<p>The method implemented by code that calls processContinue.</p>
<dl>
  <dt>processContinue</dt>
    <dd>A request to call support with the record locked. This is the only way
      asynchronous support should continue processing.</dd>
</dl>

<h4>RecordProcessFactory</h4>

<p>A factory is provided to create an instance of RecordProcess for a record
instance. It has the method:</p>
<pre>public class RecordProcessFactory {
    static public RecordProcess createRecordProcess(
          RecordSupport recordSupport,PVRecord pvRecord);
}</pre>

<h3>Support</h3>

<p>This section describes the interfaces and abstract base class involved with
support for fields of an IOC record. This also means support for the record
itself.</p>

<h4>Support State</h4>

<p>Before support is ready for processing it must be ready. In addition on-line
add and delete is supported. Thus it is possible to dynamically redefine link
fields, array fields, etc. Unless a support module is in the ready state it's
process method should not be called and if it is it should just report
failure.</p>
<pre>    public enum SupportState {
        readyForInitialize,
        readyForStart,
        ready,
        zombie;
    }

    public static SupportState getSupportState(int value);
    public static Enumerated getSupportState(PVField pvField);</pre>

<p>SupportState has the following values:</p>
<dl>
  <dt>readyForInitialize</dt>
    <dd>Initial state for support. It has been created but has not done
    much.</dd>
  <dt>readyForStart</dt>
    <dd>Support has done any initialization that does not involve connecting to
      other records and/or support.</dd>
  <dt>ready</dt>
    <dd>Support is ready for processing.</dd>
  <dt>zombie</dt>
    <dd>Support is being removed and can never again process.</dd>
</dl>

<h4>Support</h4>

<p>The following are used by support code, i.e. record support, link support,
and any other support code that is involved with record processing:</p>
<pre>    
    public interface Support extends Requester {
        String getSupportName();
        SupportState getSupportState();
        PVField getPVField();
        void initialize();
        void start(AfterStart afterStart);
        void stop();
        void uninitialize();
        void process(SupportProcessRequester supportProcessRequester);
    }

    public interface SupportProcessRequester {
        void supportProcessDone(RequestResult requestResult);
    }</pre>

<p>Support has the methods:</p>
<dl>
  <dt>getSupportName</dt>
    <dd>Get the support name.</dd>
  <dt>getRequesterName</dt>
    <dd>A requester method to get the name of the support.</dd>
  <dt>message</dt>
    <dd>A Requester method. This is called to pass messages to the support.</dd>
  <dt>getSupportState</dt>
    <dd>Get the support state.</dd>
  <dt>getPVField</dt>
    <dd>Get the PVField interface for the field that is being supported. For
      record support this will be the record itself. </dd>
  <dt>initialize</dt>
    <dd>Perform initialization that does not involve accessing other records
      and/or support.</dd>
  <dt>start</dt>
    <dd>Connect to other records and/or support.</dd>
  <dt>stop</dt>
    <dd>Disconnect from other records and/or support and be ready to again
      start.</dd>
  <dt>uninitialize</dt>
    <dd>Remove all internal state are prepare to again initialize.</dd>
  <dt>process</dt>
    <dd>Process.</dd>
</dl>

<p>Every Support module must implement the methods initialize, start, stop, and
uninitialize. Initialize performs initialization related to the record instance
being supported but can not access anything outside the record. Start completes
all initialization including linking to the outside, e.g. to other records.
Stop must remove all access to the outside. Uninitialize must remove all access
to the record instance being supported.</p>

<p>SupportProcessRequester has the method:</p>
<dl>
  <dt>supportProcessDone</dt>
    <dd>The callback to call when support is done . Any support code that wants
      to process other records must implement this interface. This MUST be
      called with either process or processContinue running.</dd>
</dl>

<h4>Record Support</h4>

<p>Every record instance has an attached RecordSupport:</p>
<pre>    public interface RecordSupport {
        RecordProcess getRecordProcess();
        void setRecordProcess(RecordProcess recordProcess);
        Support getSupport(PVField pvField);
        void setSupport(PVField pvField,Support support);
    }</pre>

<h3>AbstractSupport</h3>

<h4>AbstractSupport</h4>

<h4>Definitions</h4>
<pre>    public abstract class AbstractSupport implements Support {
        protected AbstractSupport(String name,PVRecordField pvRecordField);
        // methods from Requester
        public String getRequesterName();
        public void message(String message, MessageType messageType);
        // methods that are rarely overridden
        public SupportState getSupportState();
        public PVField getPVField();
        // following normally overridden
        public void initialize();
        public void start(AfterStart afterStart);
        public void stop();
        public void uninitialize();
        public void process(SupportProcessRequester supportProcessRequester);
        // following must always be called when support state changes
        protected void setSupportState(SupportState state);
        // following is for use by support code
        protected boolean checkSupportState(
            SupportState expectedState,String message);
    }</pre>

<p>All support code should extend AbstractSupport. Abstract Support implements
all Support methods. Thus support code only has to override the methods it
needs.</p>
<dl>
  <dt>AbstractSupport</dt>
    <dd>The constructor which must be called by the derived support
    constructor.</dd>
  <dt>getRequesterName</dt>
    <dd>The returns the name passed to constructor.</dd>
  <dt>message</dt>
    <dd>Calls pvField.message.</dd>
  <dt>getSupportState</dt>
    <dd>Gets the current support state.</dd>
  <dt>getPVField</dt>
    <dd>Returns pvField.</dd>
  <dt>initialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt>start</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state ready.</dd>
  <dt>stop</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForStart.</dd>
  <dt>unintialize</dt>
    <dd>Normally overridden. The default version always succeeds, i.e. enters
      state readyForInitialize.</dd>
  <dt>process</dt>
    <dd>Normally overridden. The default version just calls
      supportProcessRequester.supportProcessDone(RequestResult.success);</dd>
  <dt>setSupportState</dt>
    <dd>This must be called by support whenever it changes state.</dd>
  <dt>checkSupportState</dt>
    <dd>Checks that the state is the expected state and generates an error
      message if it isn't.</dd>
</dl>

<h3>Package org.epics.pvioc.support.rpc</h3>

<h4>Overview</h4>

<p>This package provides support for remote procedure calls from a channel
access client. Two types of RPCs are possible:</p>
<dl>
  <dt>putProcessGet</dt>
    <dd>This is used if the PVStructure for the data returned by a request
      always has the same structure.</dd>
  <dt>channelRPC</dt>
    <dd>This is used if a new PVStructure must be send for each request.</dd>
</dl>

<h5>putProcessGet RPC</h5>

<p>A RPC is implemented via a structure that has the following fields:</p>
<dl>
  <dt>arguments</dt>
    <dd>A structure that has a set of fields that are defined by the
      implementation. It defines the arguments required by the RPC. </dd>
  <dt>result</dt>
    <dd>Also a structure that has a set of fields that are defined by the
      implementation. It contains the results.</dd>
</dl>

<p>The client issues a putGet with process request. The put contains the
arguments and the get retrieves the result.</p>

<p>javaIOC/xml/structure/rpc.xml has the definitions for the structures
required by the support provided by this package. The following sections
provide a brief description of the arguments and result for each support.</p>

<h5>channelRPC</h5>

<p>A ChannelRPC allows a different PVStructure to be passed to the server and
returned to the client for each request.</p>

<h4>ExampleChannelRPC</h4>

<p>This is an example of how to implement support for a record that supports a
ChannelRPC request. See the package description for org.epics.pvaccess.client
for details about ChannelRPC.</p>

<p>The example uses the record instance that is in
test/channelRPC/channelRPCDB.xml :</p>
<pre>&lt;record recordName = "exampleChannelRPC"&gt;
    &lt;scalar name = "factoryRPC" scalarType = "string"&gt;org.epics.pvioc.support.rpc.ExampleChannelRPCFactory&lt;/scalar&gt;
    &lt;structure name = "element"&gt;
        &lt;scalar name = "value" scalarType = "double"/&gt;
        &lt;structure name = "alarm" extends = "alarm"/&gt;
        &lt;structure name = "timeStamp" extends = "timeStamp"/&gt;
    &lt;/structure&gt;
&lt;/record&gt;
&lt;/database&gt;</pre>

<p>Note that factoryName field. It must give the name of the factory that
creates an object that implements interface RPCServer. The example create a
PVStructure that has size subfields each of which is a clone of element. Look
at the source code for details.</p>
<pre></pre>

<h4>RecordList</h4>

<p>This returns a list of the names of a set of records specified by a regular
expression. The arguments are:</p>
<dl>
  <dt>database</dt>
    <dd>A scalar string that specifies the name of the database, e. g.
    master.</dd>
  <dt>regularExpression</dt>
    <dd>A scalar string that is the regular expression. The expression ".*"
      will return a list of all the records in the database.</dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>status</dt>
    <dd>A scalar string that is used to report errors.</dd>
  <dt>names</dt>
    <dd>An array wih element type of string. It contains the record names.</dd>
</dl>

<h4>StructureList</h4>

<p>This returns a list of the names of a set of structures specified by a
regular expression. The arguments are:</p>
<dl>
  <dt>database</dt>
    <dd>A scalar string that specifies the name of the database, e. g.
    master.</dd>
  <dt>regularExpression</dt>
    <dd>A scalar string that is the regular expression. The expression ".*"
      will return a list of all the structures in the database.</dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>status</dt>
    <dd>A scalar string that is used to report errors.</dd>
  <dt>names</dt>
    <dd>An array wih element type of string. It contains the structure
    names.</dd>
</dl>

<h4>IocShow</h4>

<p>This provides some useful commands for getting information about a
pvIOCJava. The arguments are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>showBadRecords</dt>
          <dd>This gets a list of all records than have something unusual about
            them.</dd>
        <dt>showThreads</dt>
          <dd>This provides a list of the names of all the threads created by
            ThreadCreate.</dd>
        <dt>showMemory</dt>
          <dd>Produces a report of memory usage by Java.</dd>
        <dt>garbageCollect</dt>
          <dd>Asks java to collect garbage and then get memory usage.</dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>value</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h4>RecordShow</h4>

<p>This provides some useful commands for getting information about a record
The arguments are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>showState</dt>
          <dd>Get the state of the record.</dd>
        <dt>setTraceOn</dt>
          <dd>Set trace on for the record.</dd>
        <dt>setTraceOff</dt>
          <dd>Set trace off for the record.</dd>
        <dt>timeProcess</dt>
          <dd>Time how many times per second the record can be processed. This
            will only succeed if the record does not already have a record
            process requester.</dd>
        <dt>setEnableOn</dt>
          <dd>Enable the record.</dd>
        <dt>setEnableOff</dt>
          <dd>Disable the record. This prevents the record from processing.</dd>
        <dt>releaseProcessor</dt>
          <dd>Release the current record processor. This should only be used as
            a last attempt to fee a record with a record process requester that
            crashed.</dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>value</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h4>SupportStateSet</h4>

<p>This allows the support state of a record to be changed The arguments
are:</p>
<dl>
  <dt>command</dt>
    <dd>This is an enumerated structure that has the following choices: 
      <dl>
        <dt>idle</dt>
          <dd>A do nothing request.</dd>
        <dt>initialize</dt>
          <dd>Initialize the record. The record must be in the
            readyForInitialize state.</dd>
        <dt>start</dt>
          <dd>Start the record. It must be in the readyForStart state.</dd>
        <dt>stop</dt>
          <dd>Stop the record and put it in the readyForStart state. It must be
            in the ready state. </dd>
        <dt>uninitialize</dt>
          <dd>Uninitialize the record and put it in the readyForeInitialize
            state. It must be in the ready or readyForStart state. </dd>
      </dl>
    </dd>
</dl>

<p>The result fields are:</p>
<dl>
  <dt>message</dt>
    <dd>A scalar string that provides the result for the request.</dd>
</dl>

<h3>Package org.epics.pvioc.support.basic</h3>

<h4>Overview</h4>

<p>This package contains a set of modules that provide basic support
services.</p>

<p>The following factories are provided:</p>
<dl>
  <dt>GenericFactory</dt>
    <dd>Generic support for a structure or for an array with elementType of
      array or structure.</dd>
  <dt>NoopFactory</dt>
    <dd>Support for all fields that just acts like it always succeeds
      successfully.</dd>
  <dt>ScanFactory</dt>
    <dd>Complete support for the scan field which is defined in comon.xml</dd>
  <dt>Support for linear conversions.</dt>
    <dd><dl>
        <dt>LinearConvertInputFactory</dt>
          <dd>Support for linear conversion of input fields.</dd>
        <dt>LinearConvertOutputFactory</dt>
          <dd>Support for linear conversion of output fields.</dd>
      </dl>
    </dd>
  <dt>ControlLimit</dt>
    <dd>Enforce control limits.</dd>
  <dt>IncrementalFactory</dt>
    <dd>Support for incremental outputs.</dd>
  <dt>EventFactory</dt>
    <dd>Support for a string field that is the name of an event.</dd>
  <dt>DelayFactory</dt>
    <dd>It just causes an asynchronous delay before completing
    successfully.</dd>
</dl>

<h4>Generic Support</h4>
<pre>    public class GenericFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>
Generic Support is used for many record/structure definitions . It is often
used because it just looks for fields that have associated support and calls
the support. It also has a few conventions so that it works with a variety of
support modules. It implements the following semantics: 
<dl>
  <dt>scan,timeStamp</dt>
    <dd>It does not call the support for field scan or timeStamp because
      recordProcess handles these fields.</dd>
  <dt>alarm</dt>
    <dd>If field alarm is present and has AlarmSupport then it is handled
      properly.</dd>
  <dt>fields with associated support.</dt>
    <dd>For each field with support, the support methods are called, i.e.
      initialize,start,stop,uninitialize, and process. For process, by default,
      generic waits for each support to finish before it calls the next
      support. For a stucture subfield the default can be changed by appending
      a boolean scalar field to the structure and setting the value to
    false.</dd>
</dl>

<p>The generic support does not force the support for input to do input, the
support for output to do output, etc. The generic support merely calls support
if it exists. The generic support also does not check the types of any fields
but looks for support and calls it if it exists. Thus the generic support can
be used for many different types of data and many different types of
support.</p>

<h4>Noop Support</h4>
<pre>    public class NoopFactory {
        public static Support create(PVRecordField pvRecordField);
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>This can be used for record types that just hold data. It can also be used
to provide support for any field. The support acts as though it is synchronous.
All Support methods are implemented by just extending AbstractSupport without
overriding any methods.</p>

<h4>ScanFactory</h4>

<p>Support is provided for the scan field. This support is called by
recordProcess. The support handles all the fields in structure scan:</p>

<p>The following definitions are provided:</p>
<pre>    public class ScanFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<h4>Control Limit</h4>

<p>This is code to enforce control limits. It handles the following type of
definitions:</p>
<pre>&lt;record name = "aoIncremental"&gt;
    &lt;scalar name = "value" type = "double"&gt;
        &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;controlLimitFactory&lt;/auxInfo&gt;
    &lt;/scalar&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "control" type = "control" &gt;
        &lt;structure name = "limit"&gt;
            &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
            &lt;scalar name = "high"&gt;8.0&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;</pre>

<h4>Linear Conversion</h4>

<p>Support is available for input and output linear conversions. The xml
definitions for linear conversions are:</p>

<h5>linearConversion</h5>

<p>The structure linearConversion defines the fields used for linear
conversions. The fields slope and intercept are the values used to convert a
rawValue to engineering units. The rawValue is an integer value usually read
from an ADC (Analog to Digital Convertor). The slope and intercept can be
specified directly of calculated from the low and high engineering and device
values. If the later method is chosen the engUnitsLow and engUnitsHigh must be
provided. deviceLow and deviceHigh are either provided automatically by support
of must be provided. The following are the fields in structure
lineraConversion:</p>
<dl>
  <dt>engUnitsLow</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceHigh.</dd>
  <dt>engUnitsHigh</dt>
    <dd>A double equal to the engineering units value corresponding to the
      value for deviceLow.</dd>
  <dt>deviceHigh</dt>
    <dd>An int equal to the maximum value for the rawValue.</dd>
  <dt>deviceLow</dt>
    <dd>An int equal to the minimum value for the rawValue.</dd>
  <dt>slope</dt>
    <dd>The slope for the linear conversion.</dd>
  <dt>intercept</dt>
    <dd>The intercept for the linear conversion.</dd>
</dl>

<h5>LinearConvertInputFactory</h5>
<pre>    public class LinearConvertFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is the factory that implements linear input conversion, i.e. it
converts a rawValue to engineering units. The auxInfo must have supportName
"linearConvertInputFactory" .A field for linear conversion for input is a
structure containing the following fields:</p>
<dl>
  <dt>rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt>linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt>input</dt>
    <dd>The link for reading the rawValue. If a field named is defined and has
      support the support is called.</dd>
</dl>

<h5>LinearConvertOutputFactory</h5>
<pre>    public class LinearConvertFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is the factory that implements linear output conversion, i.e. it
converts a value in engineering units to a rawValue.The auxInfo must have
supportName "linearConvertOutputFactory". A field for linear conversion for
output is a structure containing the following fields:</p>
<dl>
  <dt>rawValue</dt>
    <dd>The raw value which is obtained via the support attached to the input
      field or by a put to this field.</dd>
  <dt>linearConvert</dt>
    <dd>The structure providing the conversion parameters.</dd>
  <dt>output</dt>
    <dd>The link for reading the rawValue. If a field named is defined and has
      support the support is called.</dd>
</dl>

<h4>Incremental Support</h4>

<p>This is support for incremental outputs.For example it supports a record
that has the following structure:</p>
<pre>&lt;record name = "aoIncremental"&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "desired" type = "incrementalDouble" &gt;
        &lt;scalar name = "value"&gt;
            &lt;auxInfo name = "pvReplaceFactory" type = "string"&gt;controlLimitFactory&lt;/auxInfo&gt;
        &lt;/scalar&gt;
        &lt;scalar name = "rateOfChange"&gt;.02&lt;/scalar&gt;
        &lt;scalar name = "incremental"&gt;true&lt;/scalar&gt;
        &lt;structure name = "control" type = "control" &gt;
            &lt;structure name = "limit"&gt;
                &lt;scalar name = "low"&gt;0.0&lt;/scalar&gt;
                &lt;scalar name = "high"&gt;8.0&lt;/scalar&gt;
            &lt;/structure&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>This uses the Java definitions:</p>
<pre>    
    public class IncrementalFactory {
        public static Support create(PVField pvField);
    }</pre>

<p>This supports the following fields:</p>
<dl>
  <dt>value</dt>
    <dd>The value field.</dd>
  <dt>desired.value</dt>
    <dd>This must be a double field. When this field changes the support
      changes the value field until it has the desired value. If control limits
      are specified then the desired value is forced to be within the control
      limits. If incrementalOutput is true then each time the record is
      processed the value field is changed by rateOfChange until the desired
      value is reached.</dd>
  <dt>incremental</dt>
    <dd>This field is optional. If the record/structure has a field named then
      it must be have type boolean. If not present the default is true. If this
      has the value true the output is adjusted by rateOfChange otherwise the
      value field is changed in one step to the desired value.</dd>
  <dt>rateOfChange</dt>
    <dd>If incrementalOutput is true this is the amount the value will change
      each time the record is processed.</dd>
</dl>

<h4>Event Support</h4>
<pre>    public class EventFactory {
        public static Support create(PVField pvField);
    }</pre>

<p>EventFactory implements record or structure support for announcing a scan
event. The event name is given in the field:</p>
<dl>
  <dt>value</dt>
    <dd>This must be a string field named located in the parent of this field,
      which is normally the value field itself.</dd>
</dl>

<p>Whenever the record is processed eventScanner.announce is called, i.e. the
support announces an event. All event scanned records with the event name
associated with the value field are processed. Each time process is called, the
event support checks to see if the event name has changed.</p>

<h4 style="text-align: center;">DelaySupport</h4>

<p>This is link support that simulates asynchronous support. It uses a
configStructure that has the definition:</p>
<pre>&lt;structure name = "delayFactory"&gt;
 &lt;scalar name = "supportFactory" type = "string"&gt;
   org.epics.pvioc.support.basic.DelayFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "delay"&gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;delayFactory&lt;/auxInfo&gt;
  &lt;!-- min, max, inc are delay in milliseconds --&gt;
  &lt;scalar name = "min" type = "long" /&gt;
  &lt;scalar name = "max" type = "long" /&gt;
  &lt;scalar name = "inc" type = "long" /&gt;
&lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt>min</dt>
    <dd>The minimum delay</dd>
  <dt>max</dt>
    <dd>The maximum delay</dd>
  <dt>inc</dt>
    <dd>The delay increment between process requests</dd>
</dl>

<p>Each time process is called it delays a number of milliseconds determined by
min,max, and inc. It starts with a delay on min. Each time it proceses it
increases the delay by inc until it reaches max. It then goes back to a delay
of min.</p>

<p>The factory definition is:</p>
<pre>    public class DelaySupportFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<h3>Package org.epics.pvioc.support.calc</h3>

<h4>Overview</h4>

<p>This package provides support for calculations. A calculation computes a
result that is assigned to the value field. This package provides:</p>
<ol>
  <li>ExpressionCalculator<br />
    This is support for an expression that has the same syntax as a Java scalar
    expression. For example: 
    <pre>      a + b*c * Math.sin(d)
    </pre>
    For such expressions a complete expression factory is provided. </li>
  <li>Calculation Intrastructure Support<br />
    CalcArgArray support,AbstractCalculatorSupport, and the Database
    Definitions related to calculations. </li>
</ol>

<p>Basic calculation support is described first and then
ExpressionCalculator.</p>

<h4>Basic Calculation Support</h4>

<h5>Database Definitions for Calculations</h5>

<p>xml/structure/calx.xml defines the following:</p>
<pre>&lt;structure name = "calcArgsFactory"&gt;
  &lt;scalar name = "supportFactory" type = "string"&gt;
     org.epics.pvioc.support.calc.CalcArgsFactory&lt;/scalar&gt;
&lt;/structure&gt;

&lt;structure name = "calcArg" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;!-- instance must define value --&gt;
  &lt;scalar name = "name" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "expressionCalculator" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;expressionCalculatorFactory&lt;/auxInfo&gt;
  &lt;scalar name = "expression" type = "string" /&gt;
&lt;/structure&gt;

&lt;structure name = "calculation" &gt;
  &lt;auxInfo name = "supportFactory" type = "string"&gt;genericFactory&lt;/auxInfo&gt;
  &lt;structure name = "calcArgs"&gt;
     &lt;!-- each field of calcArgs must be a calcArg structure --&gt;
     &lt;auxInfo name = "supportFactory" type = "string"&gt;calcArgsFactory&lt;/auxInfo&gt;
  &lt;/structure&gt;
  &lt;structure name = "calculator" type = "expressionCalculator" /&gt;
  &lt;structure name = "alarm" type = "alarm" /&gt;
&lt;/structure&gt;</pre>

<p>calculation is the structure used for calculations. The parent of
<b>calculation</b> must have a field with the name value and must have a type
compatible with the calculator. </p>

<p>Structure calculation has the fields: </p>
<dl>
  <dt>calcArgs</dt>
    <dd>A field is a sequence of structures with each being a <b>calcArg</b>
      structure and the support calcArgArray. If the calculator uses any
      arguments from calcArgs this must be present. The name assigned to a
      calcArg field is the argument name for the calculation.</dd>
  <dt>calculator</dt>
    <dd>This field has support that implements the calculation. The default
      support and structure name is expressionCalculator. This field must be
      present and must have support.</dd>
  <dt>alarm</dt>
    <dd>This is present so that a record can be put in alarm if a calculation
      finds problems.</dd>
</dl>

<p>calcArg is a structure that must contain at least the field</p>
<dl>
  <dt>value</dt>
    <dd>This must be defined in record instances with a type that is compatible
      with the expression.</dd>
  <dt>other</dt>
    <dd>Other fields can also be defined. For example a field named
      <b>input</b> can be defined as a structure with associated support that
      puts data into the <b>value</b> field.</dd>
</dl>

<p>expressionCalculator is the default structure for the calculator field of
structure calculation. It is the structure required by support
<b>expressioncalculator</b>. It has a single field:</p>
<dl>
  <dt>expression</dt>
    <dd>The expression using Java syntax.</dd>
  <dt></dt>
</dl>

<p>Support calcArgsFactory is the support for field calcArgs. Support
expressionCalculator is the support described in the next section.</p>

<h5>Performing Calculations</h5>

<p>A calculation is performed by a calculation support. The following is done.
When the calculation support, which is generic, is called it calls the
calcArgArray support and the calculator support. For each element of
calcArgArray, the calcArgArray support calls The support for any subfields that
have support. The calcArgArray support extends Support to provide the
additional method</p>
<pre>    PVField getPVField(String argName);</pre>

<p>which is used by the calculator support to get arguments. The calculator
support uses the calcArgArray values to compute the calculated value.</p>

<h5>calcArgs</h5>

<p>This support implements support for a structure than is a sequence of
calcArg structures, which has the fields:</p>
<dl>
  <dt>value</dt>
    <dd>A value for this argument. NOTE that record instances must define a
      value specifying the type required by the calculation expression.</dd>
  <dt>other</dt>
    <dd>Other fields can be defined. For example a field input which is a link
      for obtaining the value for this argument. If no additional field
      specified then no input is read and the value field can just be set by
      the user.</dd>
</dl>

<h4>ExpressionCalculator</h4>

<p>This is support for an expression that has the form of a valid java
expression.</p>

<h5>Simple Examples</h5>

<p>The following example is a counter, i.e. each time the record is processed
the value field is incremented by 1.</p>
<pre>&lt;record name = "reallySimpleCounter"&gt;
    &lt;scalar name = "value" type = "byte" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
      &lt;structure name = "calculator"&gt;
        &lt;scalar name="expression"&gt;value+1&lt;/scalar&gt;
      &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The following is an example that has arguments min, max, and inc. Each time
the record is processed the current value is incremented by inc. If the result
is less than or equal to max it becomes the new value; otherwise value is set
to max. Note that &lt; must be given as the xml escape sequence for &lt; , i.e.
&amp;lt;</p>
<pre>&lt;record name = "counter"&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "min"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "max"&gt;
            &lt;scalar name = "value" type = "double" &gt;10.0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "inc"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.5&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;(value+inc)&amp;lt;=max ? value+inc : min&lt;/scalar&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;    
&lt;/record&gt;</pre>

<p>The next example computes the sin of an argument given in radians:</p>
<pre>&lt;record name = "sin"&gt;
    &lt;scalar name = "value" type = "double" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "a"&gt;
            &lt;scalar name = "value" type = "double" &gt;0.5&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;
             Math.sin(Math.PI*a)
         &lt;/scalar&gt;
       &lt;/structure&gt;
    &lt;/structure&gt;   
&lt;/record&gt;</pre>

<p>The last example demonstrates the use of the ?: operator:</p>
<pre>&lt;record name = "check"&gt;
    &lt;scalar name = "value" type = "boolean" /&gt;
    &lt;structure name = "alarm" type = "alarm" /&gt;
    &lt;structure name = "timeStamp" type = "timeStamp" /&gt;
    &lt;structure name = "input" type = "calculation" &gt;
       &lt;structure name = "calcArgs"&gt;
          &lt;structure name = "a"&gt;
            &lt;scalar name = "value" type = "byte" &gt;0&lt;/scalar&gt;
          &lt;/structure&gt;
          &lt;structure name = "b"&gt;
            &lt;scalar name = "value" type = "byte" &gt;1&lt;/scalar&gt;
          &lt;/structure&gt;
       &lt;/structure&gt;
       &lt;structure name = "calculator"&gt;
         &lt;scalar name = "expression"&gt;
            (a-b)==0 ? true : false
         &lt;/scalar&gt;
       &lt;/structure&gt;    &lt;/structure&gt;
&lt;/record&gt;</pre>

<h5>Expression Syntax</h5>

<p>A expression is has the form of a valid Java scalar expression. The result
of the expression is assigned to the value field.</p>

<p>The precedence is the same as the Java precedence. For example the
following:</p>
<pre>   a + b*c + Math.sin(e*f)</pre>
Is the same as: 
<pre>   ((a + (b*c)) + Math.sin((e*f)))</pre>

<h5>Expression Arguments</h5>

<p>An argument can be one of the following:</p>
<dl>
  <dt>variable</dt>
    <dd>The argument is one of the calcArgArray names.</dd>
  <dt>value</dt>
    <dd>The "value" appears as an argument than the argument is the value field
      itself. Note that this is the first value field found searching up the
      parent tree.</dd>
  <dt>boolean constant</dt>
    <dd>The argument is "true" or "false"</dd>
  <dt>string constant</dt>
    <dd>A argument enclosed in "" is a string constant.</dd>
  <dt>integer constant</dt>
    <dd>The argument is a valid java integer constant. It becomes an int
      constant unless it is terminated with the character L, which means it is
      a long integer constant. The value can also be given as a valid hex
      integer, e.g. 0x0fff. </dd>
  <dt>real constant</dt>
    <dd>The argument is a valid java real constant, i.e. it is either a float
      or double constant.</dd>
  <dt>Math constant</dt>
    <dd>The argument is either Math.PI or Math.E</dd>
</dl>

<h5>Unary Operators</h5>

<p>The supported unary operators are:</p>
<dl>
  <dt>+</dt>
    <dd>Unary plus. The argument can be any numeric type.</dd>
  <dt>-</dt>
    <dd>Unary minus. The argument can be any numeric type.</dd>
  <dt>~</dt>
    <dd>Bitwise Complement. The argument can be any integer type.</dd>
  <dt>!</dt>
    <dd>Boolean not. The argument must be boolean.</dd>
</dl>

<h5>Binary Operators</h5>

<p>The supported binary operators are:</p>
<dl>
  <dt>*</dt>
    <dd>Multiplication. The argument can be any numeric type.</dd>
  <dt>/</dt>
    <dd>Division. The argument can be any numeric type.</dd>
  <dt>%</dt>
    <dd>Remainder. The argument can be an integer type.</dd>
  <dt>+</dt>
    <dd>Binary plus. The arguments can be any numeric type.</dd>
  <dt>+</dt>
    <dd>String concatenation. The first argument must be a string.</dd>
  <dt>-</dt>
    <dd>Binary minus. The arguments can be any numeric type.</dd>
  <dt>&lt;&lt;</dt>
    <dd>Left shift. The arguments must be an integer type.</dd>
  <dt>&gt;&gt;</dt>
    <dd>Right shift sign extended. The arguments must be an integer type.</dd>
  <dt>&gt;&gt;&gt;</dt>
    <dd>Right shift zero extended. The arguments must of an integer type.</dd>
  <dt>&lt;</dt>
    <dd>Less than. The arguments must be numeric.</dd>
  <dt>&lt;=</dt>
    <dd>Less than or equal. The arguments must be numeric.</dd>
  <dt>&gt;</dt>
    <dd>Greater than. The arguments must be numeric.</dd>
  <dt>&gt;=</dt>
    <dd>Greater than or equal. The arguments must be numeric.</dd>
  <dt>==</dt>
    <dd>Equal. The arguments can be any supported type.</dd>
  <dt>!=</dt>
    <dd>Not equal. The arguments can be any supported type.</dd>
  <dt>&amp; </dt>
    <dd>Integer and. The arguments must be integer.</dd>
  <dt>&amp; </dt>
    <dd>Boolean and. The arguments must be boolean.</dd>
  <dt>^</dt>
    <dd>Bitwise XOR. The arguments must be integer.</dd>
  <dt>^</dt>
    <dd>Boolean XOR. The arguments must be boolean.</dd>
  <dt>|</dt>
    <dd>Bitwise or. The arguments must be integer.</dd>
  <dt>|</dt>
    <dd>Boolean or. The arguments must be boolean.</dd>
  <dt>&amp;&amp;</dt>
    <dd>Conditional and. The arguments must be boolean.</dd>
  <dt>||</dt>
    <dd>Conditional or. The arguments must be boolean.</dd>
</dl>

<h5>Ternary Operator</h5>

<p>The ternary operator ?: is supported.</p>

<h5>Math Functions</h5>

<p>All the functions defined in java.lang.Math are supported.</p>

<h5>Constant optimization</h5>

<p>If the arguments of an operator are all constants then the result is
determioned during initialization and the operation not performed when the
record is processed.</p>

<h5>Test</h5>

<p>test/calc contains tests for ExpressionCalculator. After the test is
initialized use the swtshell to bring up the introspectDatabase screen. Select
the showBadRecordss button. No records should appear except possibly active
records. The only records without checks are random, calcSimpleCounter, and
calcCounter. These can be checked manually. For random issue get with process
requests. For calcSimpleCounter and calcCounter just monitor the records.</p>

<h4>Package org.epics.pvioc.support.calc.example</h4>

<p>This package gives some examples of how to extend AbstractCalculatorSupport.
It has the following examples:</p>
<dl>
  <dt>arrayIncrement</dt>
    <dd>The value field must be an array of doubles. When process is called 1
      is added to each element of the array.</dd>
  <dt>booleanArrayToggle</dt>
    <dd>The value field must be an array of boolean. When process is called
      each array element is toggled between false and true.</dd>
  <dt>arrayAdd</dt>
    <dd>It has arguments named a and b. The fields a, b, and value must each be
      a double array. When process is called it sets value equal to a + b.</dd>
</dl>

<h3>Package org.epics.pvioc.support.alarm</h3>

<h4>Overview</h4>

<p>Support is provided for the alarm field itself and raising alarms for the
primitive types and for an enumerated structure.</p>

<p>The next section describes the xml syntax for attaching alarm support to a
value field and raising alarms for the value field. The remaining sections
describe the support. </p>

<p>An alarm is defind as follows:</p>
<pre>&lt;structure structureName = "alarm"&gt;
  &lt;scalar name = "severity" scalarType = "int" /&gt;
  &lt;scalar name = "status" scalarType = "int" /&gt;
  &lt;scalar name = "message" scalarType = "string" /&gt;
&lt;/structure&gt;</pre>

<p>Thus an alarm is defined by a structure that has two fields:</p>
<dl>
  <dt>severity</dt>
    <dd>An integer that represents a severity index. org.epics.pvdata.property
      has definitions for AlarmSeverity, Alarm, and AlarmFactory that
      implements a enum where the severity is the index. </dd>
  <dt>status</dt>
    <dd>An integer that represents a status index. org.epics.pvdata.property
      has definitions for AlarmStatus, Alarm, and AlarmFactory that implements
      a enum where the status is the index. </dd>
  <dt>message</dt>
    <dd>A string field named message.</dd>
</dl>

<p>The following factories are provided:</p>
<dl>
  <dt>AlarmSupportFactory</dt>
    <dd>Complete support for field alarm.</dd>
  <dt>BooleanAlarmFactory</dt>
    <dd>Alarm support for boolean fields.</dd>
  <dt>ByteAlarmFactory</dt>
    <dd>Alarm support for byte fields.</dd>
  <dt>ShortAlarmFactory</dt>
    <dd>Alarm support for short fields.</dd>
  <dt>IntAlarmFactory</dt>
    <dd>Alarm support for int fields.</dd>
  <dt>LongAlarmFactory</dt>
    <dd>Alarm support for long fields.</dd>
  <dt>FloatAlarmFactory</dt>
    <dd>Alarm support for float fields.</dd>
  <dt>DoubleAlarmFactory</dt>
    <dd>Alarm support for double fields.</dd>
  <dt>EnumeratedAlarmFactory</dt>
    <dd>Alarm support for enum field..</dd>
</dl>

<h4>XML definitions For alarms</h4>

<p>Support for raising alarms is provided for all the primitive types and for
an enumerated structure. Each can be defined for any field of a record that has
the corresponding type and has the field name "value". A record instance can
have multiple fields with associated alarm support. Since a structure can have
only one field named value, the top level of a structure can only have a single
alarm support but each substructure can also have alarm support. Three basic
types of support are provided: numeric, boolean, and enumerated. Each is
discussed in a separate section below.</p>

<h5>Numeric Scalar</h5>

<p>Support is provided for all the numeric scalar types: byte, short, long,
float, and double. The following desription is for double but the support for
the other types is similar.</p>

<p>The structures associated with doubleAlarm are :</p>
<pre>&lt;structure structureName = "doubleAlarm" &gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.pvioc.doubleAlarmFactory&lt;/auxInfo&gt;
  &lt;scalar name = "active" scalarType = "boolean" /&gt;
  &lt;scalar name = "lowAlarmLimit" scalarType = "double" /&gt;
  &lt;scalar name = "lowWarningLimit" scalarType = "double" /&gt;
  &lt;scalar name = "highWarningLimit" scalarType = "double" /&gt;
  &lt;scalar name = "highAlarmLimit" scalarType = "double" /&gt;
  &lt;scalar name = "lowAlarmSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "lowWarningSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "highWarningSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "highAlarmSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "hystersis" scalarType = "double" /&gt;
&lt;/structure&gt;</pre>

<p>The doubleAlarm structure must appear in a structure at the same level as a
double scalar field named value. There must be an alarm field at the same
level.:q</p>

<p></p>

<p>An example for a double field is:</p>
<pre>&lt;record recordName = "simpleCounter" &gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;scalar name = "value" scalarType = "int" /&gt;
    &lt;structure name = "input" extends = "calculation" &gt;
      &lt;structure name = "calculator"&gt;
        &lt;scalar name ="expression"&gt;(value+1)&amp;lt;=10 ? value+1 : 0&lt;/scalar&gt;
      &lt;/structure&gt;
    &lt;/structure&gt;
    &lt;structure name = "valueAlarm" extends = "intAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;scalar name = "lowAlarmLimit"&gt;2&lt;/scalar&gt;
      &lt;scalar name = "lowAlarmSeverity"&gt;2&lt;/scalar&gt;
      &lt;scalar name = "lowWarningLimit"&gt;4&lt;/scalar&gt;
      &lt;scalar name = "lowWarningSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "highWarningLimit"&gt;8&lt;/scalar&gt;
      &lt;scalar name = "highWarningSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "highAlarmLimit"&gt;10&lt;/scalar&gt;
      &lt;scalar name = "highAlarmSeverity"&gt;2&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>This example reproduces the semantics of alarm support for an EPICS V3 ai
record but the details are different. The above xml definition is for a record
instance but it could also apply to a substructure of a record if record is
replaced by structure in the above example. What is important is that the
structure has fields named value and alarm and that a structure field that
extends doubleAlarm is defined.</p>

<h5>Boolean</h5>

<p>A example of attaching alarm support to a boolean record or structure is:</p>
<pre>&lt;record recordName = "booleanExample"&gt;
    &lt;scalar name = "value" scalarType = "boolean"/&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "valueAlarm" extends = "booleanAlarm"&gt;
      &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
      &lt;scalar name = "falseSeverity"&gt;1&lt;/scalar&gt;
      &lt;scalar name = "trueSeverity"&gt;2&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The booleanAlarm structure also has a fields named changeOfStateAlarm and
changeOfStateMessage. It semantics should be easy to see.</p>

<h5>Enumerated</h5>

<p>Before explaining the example let's first define the structure associated
with enumerated alarm support.</p>
<pre>&lt;structure structureName = "enumeratedAlarm"&gt;
  &lt;auxInfo name = "supportFactory" scalarType = "string"&gt;org.epics.pvioc.enumeratedAlarmFactory&lt;/auxInfo&gt;
  &lt;scalar name = "active" scalarType = "boolean" /&gt;
  &lt;array name = "stateSeverity" scalarType = "int" /&gt;
  &lt;scalar name = "changeStateSeverity" scalarType = "int" /&gt;
&lt;/structure&gt;</pre>

<p>An enumerated structure appears in a structure at the same level as an
enumerated field named value. It has the fields:</p>
<dl>
  <dt>active</dt>
    <dd>Is alarm processing active?</dd>
  <dt>stateSeverity</dt>
    <dd>An array of alarmSeverity values. There must be exactly 1 for each
      element of the value field.</dd>
  <dt>changeStateSeverity</dt>
    <dd>The alarm severity for change of state.</dd>
</dl>

<p>The following shows how to create a record with enumerated alarms.</p>
<pre>&lt;record recordName = "enumerated"&gt;
     &lt;structure name = "value" extends = "enumerated"&gt;
       &lt;array name = "choices"&gt;zero,one,two,three,four&lt;/array&gt;
    &lt;/structure&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "valueAlarm" extends = "enumeratedAlarm"&gt;
            &lt;scalar name = "active"&gt;true&lt;/scalar&gt;
            &lt;scalar name = "changeStateSeverity"&gt;0&lt;/scalar&gt;
            &lt;array name = "stateSeverity"&gt;2,1,0,1,2&lt;/array&gt;
    &lt;/structure&gt;

&lt;/record&gt;</pre>

<h4>Alarm Support</h4>

<p>AlarmSupport is support for a field named which must have type structure and
the structure must be an alarm structure. Within the structure hierarchy of a
record multiple alarm fields can exist. Some support, e.g. generic, calls the
support for the alarm field defined in the top level structure (defined in
common.xml). If multiple alarm fields reside in a record then the top level
alarm field, which is what the outside world normally accesses has a severity
at least as great as any of the lower level alarms.</p>
<pre>interface AlarmSupport extends Support{
    void beginProcess();
    void endProcess();
    boolean setAlarm(String message, AlarmSeverity severity,AlarmStatus status);
    Alarm getAlarm();
}

class AlarmSupportFactory {
    public static Support create(PVRecordStructure,pvRecordStructure)
    public static AlarmSupport getAlarmSupport(PVRecordField pvRecordField);
}</pre>

<p>AlarmSupport provides the methods:</p>
<dl>
  <dt>Support</dt>
    <dd>Standard support methods..</dd>
  <dt>beginProcess</dt>
    <dd>This is called when a field begins processing. It must be called by
      support for the structure that has alarm as a subfield. Support generic
      calls it.</dd>
  <dt>endProcess</dt>
    <dd>This is called when a record finishes processing.It must be called by
      support for the structure that has alarm as a subfield. Support generic
      calls it. If setAlarm was not called since beginProcess was called than
      it makes sure that the severity is noAlarm. If the severity and/or
      message was changed during record processing it calls postPut.</dd>
  <dt>setAlarm</dt>
    <dd>While a record is processing code, normally another support module, can
      call setAlarm. This method changes the new message, severity, and status
      only if the severity passed to setAlarm is greater than the current new
      severity or if this is the first call since the record started
    processing.</dd>
  <dt>getAlarm</dt>
    <dd>Get the Alarm interface. This interface is defined in
      org.epics.pvdata.property.</dd>
</dl>

<p>AlarmFactory provides the static methods:</p>
<dl>
  <dt>create</dt>
    <dd>Create support for a alarm field. This is called by
    SupportCreation.</dd>
  <dt>getAlarmSupport</dt>
    <dd>Get the alarm support for the field or return null if none is
    found.</dd>
</dl>

<h4>Value Alarms</h4>

<p>Support is provided for alarms for the following types of fields: boolean,
numeric, and enumerated.</p>

<h5>Boolean Alarms</h5>
<pre>    public class BooleanAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>This provides support for reporting alarms for boolean fields. The
configurationStructure must be a structure booleanAlarm, which has the
fields:</p>
<dl>
  <dt>active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt>falseAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is false.</dd>
  <dt>trueAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      is true.</dd>
  <dt>changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h5>Numeric Alarms</h5>
<pre>    public class ByteAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class ShortAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class IntAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class LongAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class FloatAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }
    public class DoubleAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>The above factories provide alarm support for the associated type of field,
e.g. FloatAlarmFactory provides alarm support for a field of type float. The
support for each type except that float and double also support hystersis: If
value goes into alarm this is the amount it must come out of alarm before the
alarm severity is modified. This prevents alarm .</p>

<h5>Enumerated Alarms</h5>
<pre>    public class EnumeratedAlarmFactory {
        public static Support create(PVRecordStructure pvRecordStructure);
    }</pre>

<p>The above factory provides support for an enumerated structure field.</p>

<p>The enumeratedAlarm structure has the following fields:</p>
<dl>
  <dt>active</dt>
    <dd>A boolean field. If (false,true) then alarm conditions (are not,are)
      checked.</dd>
  <dt>stateSeverity</dt>
    <dd>An array of stateSeverity alarmSeverity menu definitions. When the
      process method is called the value field is the index for this array. The
      corresponding alarmSeverity menu is found and it determines the alarm
      severity.</dd>
  <dt>changeStateAlarm</dt>
    <dd>An alarmSeverity menu. This specifies the severity if the value field
      changes.</dd>
</dl>

<h3>Package org.epics.pvioc.support.caLink</h3>

<h4>Overview</h4>

<p>This is support for channel access links. It is implemented by making client
calls to CAJv4. It provides an implementation of support for the following:</p>
<dl>
  <dt>caProcessLink</dt>
    <dd>Support that requests that another record process without transfering
      any data.</dd>
  <dt>caInputLink</dt>
    <dd>Support that 1) optionally requests that another record process, and 2)
      transfers data from the other record this record..</dd>
  <dt>caOutputLink</dt>
    <dd>Support that 1) transfers data to another record, and 2) optionally
      requests that the other record process.</dd>
  <dt>caMonitorLink</dt>
    <dd>Support for monitoring another record. A monitor returns data.</dd>
  <dt>caMonitorNotifyLink</dt>
    <dd>Support for monitoring another record. A monitor does not return
    data.</dd>
</dl>

<h4>Data Types Supported</h4>

<p>Each requires that other support code, e.g. record support knows how to call
them.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.pvioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.pvioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.pvioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the pvname.</dd>
</dl>

<h4>Support Structure Definition</h4>

<p>Look at the structure definitions in javaIOC/dbd/structures/caLink.xml for a
description of how the various structures are defined.</p>

<p>The following is an example of a definition for using caInputLink.</p>
<pre>&lt;record recordName = "exampleInput"&gt;
    &lt;scalar name = "value" scalarType = "double"/&gt;
    &lt;structure name = "alarm" extends = "alarm" /&gt;
    &lt;structure name = "timeStamp" extends = "timeStamp" /&gt;
    &lt;structure name = "display" extends = "display" /&gt;
    &lt;structure name = "input" extends = "caInputLink"&gt;
        &lt;scalar name = "providerName"&gt;pvAccess&lt;/scalar&gt;
        &lt;scalar name = "pvname"&gt;targetRecord&lt;/scalar&gt;
        &lt;scalar name = "request" scalarType = "string"&gt;value,alarm,display&lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/record&gt;</pre>

<p>The request must provide a request definition as defined in package
org.epics.pvdata.pvCopy. It can be given as either a scalar string or as a
structure. The example above uses the easiest method, which is to define a
scalar string field. The value of the field is a comma separated list of top
level fields in the record to which the support is attached. The example asks
to get the value, alarm, and display from the target record.</p>

<h3>Package org.epics.pvioc.support.dbLink</h3>

<h4>Overview</h4>

<p>This is support for channel access links. It is implemented by making client
calls to org.epics.pvioc.dbLink. It provides an implementation of support for
the following:</p>
<dl>
  <dt>dbProcessLink</dt>
    <dd>Support that requests that another record process without transfering
      any data.</dd>
  <dt>dbInputLink</dt>
    <dd>Support that 1) optionally requests that another record process, and 2)
      transfers data from the other record this record..</dd>
  <dt>dbOutputLink</dt>
    <dd>Support that 1) transfers data to another record, and 2) optionally
      requests that the other record process.</dd>
</dl>

<h4>Data Types Supported</h4>

<p>Each requires that other support code, e.g. record support knows how to call
them.</p>

<p>The types of data that can be transfered are.</p>
<ul>
  <li>Both valueType and linkType are scalars and they are copy compatible as
    defined by org.epics.pvioc.pvAccess.Convert.isCopyScalarCompatible.</li>
  <li>Both are type Type.pvArray and are copy compatible as defined by
    org.epics.pvioc.pvAccess.Convert.isCopyArrayCompatible.</li>
  <li>Both are Type.pvStructure and are copy compatible as defined by
    org.epics.pvioc.pvAccess.Convert.isCopyStructureCompatible.</li>
</ul>

<p>where</p>
<dl>
  <dt>valueType</dt>
    <dd>The Type for the value field.</dd>
  <dt>linkType</dt>
    <dd>The Type for the pvname.</dd>
</dl>

<p>Look at the structure definitions in javaIOC/dbd/structures/dbLink.xml for a
description of how the various structures are defined.</p>

<h3>Package org.epics.pvioc.support.device</h3>

<h4>Overview</h4>
This package will have support for device abstractions. For now it only has a
power supply example. 

<h4>Power Supply Support</h4>
<pre>    public class PowerSupplyFactory {
        public static Support create(PVStructure pvStructure);
    }</pre>

<p>This is an example of support for a power supply. Given a voltage and power
it computes the current. It supports fields for reading the voltage and for
writing the current. The complete set of fields it suppports are:</p>
<dl>
  <dt>voltage</dt>
    <dd>This is required. It must be a structure containing a scalar double
      field named value and an alarm field.</dd>
  <dt>current</dt>
    <dd>This is required. It must be a structure containing a scalar double
      field named value and an alarm field.</dd>
  <dt>power</dt>
    <dd>This is required. It must be a a structure containing a scalar double
      field named value and an alarm field.</dd>
</dl>


<h2>Package org.epics.pvioc.pvAccess</h2>

<h3>pvAccess Server</h3>

<p>This allows a pvAccess client to access pvIOCJava records.</p>

<h3>pvAccess client</h3>

<p>This allows code in the JavaIOc to access remote pvAccess servers.</p>

<h2>Package org.epics.pvioc.pvCopy</h2>

<h3>Overview</h3>

<p><b>NOTE FOR Casual Users:</b> For users that just want to create pvRequest
arguments for pvAccess skip to the next section.</p>

<p>This package provides support for copying PVData between a client and
server. For example the client can be a pvAccess client and the server a
pvAccess server. It allows a client to access an arbitrary set of fields of a
PVRecord that exists on the server. This package does not provide support for
transfering the data between client and server but provides support for code
that does, e. g. it can be used by channel access. In the examples below the
data transfer code is called channel access.</p>

<p>The Channel interface provided by pvAccess has create calls for each type of
request, e. g. createChannelGet, createChannelPut, etc. Each of these has an
argument "PVStructure pvRequest". The pvRequest describes two things: 1) The
set of fields of the record to which the channel is connected, and 2) record
and field options. This package provides two services: 1) a utility method
that, given a specially encoded string, creates a pvRequest structure that can
be passed to the Channel create methods. and 2) Implements the mapping between
the client request fields and the record.</p>

<p>The next section describes the utility for creating a pvRequest. This is the
only section of interest to users. The remaining sections are of interest to
developers including developers who create new services.</p>

<p>The third section describes the layout of a pvRequest structure. This is of
interest to developers of client applications that use new services.</p>

<p>The remaining sections describe the code implemented by this package.</p>

<p>This package uses the field offsets provided by PVField and also requires
that user code creates a org.epics.pvdata.misc.BitSet.</p>

<p>PVField provides support for locating a field within a PVStructure or
PVRecord via a field offset. PVField provides the methods:</p>
<dl>
  <dt>getFieldOffset</dt>
    <dd>Get offset of the PVField field within top level structure. Every field
      within the PVStructure has a unique offset. The top level structure has
      an offset of 0. The first field within the structure has offset equal to
      1. The other offsets are determined by recursively traversing each
      structure of the tree.</dd>
  <dt>getNextFieldOffset</dt>
    <dd>Get the next offset. If the field is a scalar or array field then this
      is just offset + 1. If the field is a structure it is the offset of the
      next field after this structure. Thus (nextOffset - offset) is always
      equal to the number of fields within the field. </dd>
  <dt>getNumberFields</dt>
    <dd>Get the total number of fields in this field. This is equal to
      nextFieldOffset - fieldOffset. </dd>
</dl>

<p>A BitSet which has a bit for each field of a top level PVStructure can be
created via:</p>
<pre>    BitSet bitSet = new BitSet(pvStructure.getNumberFields());</pre>

<p>The offsets for bitSet match the fieldOffsets. On the client side of Channel
Access only a BitSet created from the PVStructure is required. On the server
side PVCopy provides a way to map between the field in a PVRecord and the
fields in the PVStructure. A copy of the PVStructure resides on both the
Channel Access client and server. The client and server exchange data via these
two PVStructures. PVCopy maps between the PVStructure and the PVRecord on the
server side of Channel Access. </p>

<p>This package provides the following:</p>
<dl>
  <dt>BitSetUtil</dt>
    <dd>An interface that curently has only one method, compress, which
      optimizes the bit settings for a PVStructure.</dd>
  <dt>PVCopy</dt>
    <dd>An interface for mapping between a PVRecord and a PVStructure that
      contains data for a subset of the fields in the PVRecord.</dd>
  <dt>PVCopyMonitor</dt>
    <dd>An interface for monitoring changes to fields of the PVRecord that have
      a corresponding field in PVStructure.</dd>
  <dt>PVCopyFactory</dt>
    <dd>The factory that implements PVCopy. It accepts a PVStructure that
      describes the set of fields of a PVRecord that should be mapped.</dd>
  <dt>PVShareFactory</dt>
    <dd>A factory that replaces a PVField with an implementation that accesses
      the data from a shared field.</dd>
</dl>

<h3>Request String</h3>

<p>Issuing the request:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest(String request,this);</pre>

<p>creates a pvRequest argument for the various create methods provided by
interface Channel. NOTE: The full path is
org.epics.pvaccess.client.CreateRequestFactory. </p>

<h4>Simple Requests</h4>

<p>Before starting lets first give some examples that satisfy clients such as
Synoptic Display, Alarm, and Archive tools. These clients only want access to
some combination of the following fields: value, alarm, timeStamp, display, and
control. If the request is for a record that has these all as top level fields
the request string is just a comma separated list of the field names. For
example:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("value,alarm,timeStamp",this);</pre>

<p>If the record is does not have the desired field at the top level then the
field can still be accessed with a simple string. For example:</p>
<pre>    pvRequest = CreateRequestFactory.createRequest("power.value,alarm,timeStamp,power.display",this);</pre>

<p>Will get the top level alarm and timeStamp and the value and alarm from a
structure named power. Thus the above works for a record that is structured as
follows:</p>
<pre>powerSupply
    alarm
    timeStamp
    power
       value
       display
       ...
    ...</pre>

<p>The only option most clients want is to request that a record be processed
as part of a get or put requests. This is done via requests like the
following:</p>
<pre>    pvRequest = CreateRequestFactory.createRequest("record[process=true]field(value,alarm,timeStamp)",this);</pre>

<h4>Full Request Syntax</h4>

<p>A request is of the form:</p>
<pre>    record[option,...]field(fieldDef,...)putField(fieldDef,...)getField(fieldDef,...)
    OR
    fieldDef,...</pre>

<p>Thus a request consists of record options and sets of field definitions or
just field definitions. A record option is of the form:</p>
<pre>    record[name=value,...]</pre>

<p>This will generate the equivalent of :</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scaler name = "name" scalarType = "string"&gt;value&lt;/scalar&gt;
         &lt;!-- other options --&gt;
    &lt;/structure&gt;</pre>

<p>A field,putFeld,getField is a comma separated set of fieldDefs which are of
the form:</p>
<pre>    fullFieldName[option,...]    // options are optional</pre>
or 
<pre>    fieldName{request}     // recursive definition</pre>

<p>A fullFieldName is the full name of a field in the PVRecord. The name in a
generated data structure will have just the field name. If
<b>fieldName{request}</b> is given then the generated data structure will have
a structure field with subfields. Note that request is a recursive
definition.</p>

<p>If request is null or an empty string than the entire PVRecord is
selected.</p>

<h4>Examples</h4>

<p>The following examples are for either a simple record or for a power supply
record. These are records that have one of the following structures:</p>
<pre>simpleRecord
    value
    alarm
    timeStamp
    display
    .. other fields like input, etc

powerSupply
    alarm
    timeStamp
    power
       value
       alarm
       .. other fields
    voltage
       value
       alarm
       .. other fields
    current
       value
       alarm
       .. other fields
    .. other fields</pre>

<h5>Simple example</h5>

<p>The following gets the alarm, timeStamp, and power.value.</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("alarm,timeStamp,power.value",this);</pre>

<p>The following does the same thing.</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest("field(alarm,timeStamp,power.value)",this);</pre>
<pre></pre>

<p>In either case the PVStructure holding data for the requester will have the
structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it will
not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for the
value field will be given.</p>
<pre>     PVStructure pvRequest = CreateRequestFactory.createRequest{
        "record[process=true]field(alarm,timeStamp,power.value[shareData=true])",this);</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h5>Power Supply Example</h5>

<p>The following:</p>
<pre>    PVStructure pvRequest = CreateRequestFactory.createRequest(
       "field(alarm,timeStamp"
       + ",power{power.value,power.alarm}"
       + ",current{current.value,current.alarm}"
       + ",voltage{voltage.value,voltage.alarm})",this);</pre>

<p>Defines a client structure as follows:</p>
<pre>top
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3>pvRequest</h3>

<h4>PVStructure pvRequest</h4>

<p>pvRequest is a PVStructure that describes 1) record options and 2) field
requests and options. It has the following structure:</p>
<pre>    &lt;structure&gt;
        &lt;structure name = "record"&gt;
            &lt;!-- 0 or more options with the definition--&gt;
            &lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "field"&gt; &lt;!-- or putField and separate definition for getField --&gt;
            &lt;!-- 0 or 1 fieldList definition --&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                fullPVRecordFieldName,...,fullPVRecordFieldName
            &lt;/scalar&gt;
            &lt;!-- 0 or more fieldName definitions of the form --&gt;
            &lt;structure name = "fieldName"&gt;
                 &lt;!-- 0 or 1 definition of --&gt;
                 &lt;structure name = "leaf"&gt;
                     &lt;scalar name = "source" scalarType = "string"&gt;
                          fullPVRecordFieldName
                     &lt;/scalar&gt;
                     &lt;!-- 0 or more options for field --&gt;
                 &lt;/structure&gt;
                 &lt;!-- If not a leaf than 1 or more--&gt;
                 &lt;structure name = "fieldName"&gt;
                     &lt;!-- recursive definition of field--&gt;
                 &lt;/structure&gt;
            &lt;/structure
        &lt;/structure
    &lt;/structure&gt;

     OR
    &lt;structure&gt;
        &lt;!-- 0 or 1 fieldList definition --&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
            fullPVRecordFieldName,...,fullPVRecordFieldName
        &lt;/scalar&gt;
        &lt;!-- 0 or more fieldName definitions of the form --&gt;
        &lt;structure name = "fieldName"&gt;
            &lt;!-- 0 or 1 definition of --&gt;
            &lt;structure name = "leaf"&gt;
                &lt;scalar name = "source" scalarType = "string"&gt;
                    fullPVRecordFieldName
                &lt;/scalar&gt;
                &lt;!-- 0 or more options for field --&gt;
            &lt;/structure&gt;
            &lt;!-- If not a leaf than 1 or more--&gt;
            &lt;structure name = "fieldName"&gt;
                &lt;!-- recursive definition--&gt;
            &lt;/structure&gt;
        &lt;/structure
    &lt;/structure&gt;</pre>

<p>where</p>
<dl>
  <dt>record</dt>
    <dd>The options that apply to the entire record.</dd>
  <dt>option</dt>
    <dd>This is of the form 
      <pre>&lt;scalar name = "optionName" scalarType = "string"&gt;value&lt;/scalar&gt;</pre>
    </dd>
  <dt>field</dt>
    <dd>Definitions that select fields of the PVRecord and options for the
      fields. This definition is recursive.</dd>
  <dt>fieldList</dt>
    <dd>A comma separated list of fullPVRecordFieldNames. Each will become a
      single field in the structure created by PVCopy with a field name that is
      the same as the field name of the corresponding fullPVRecordFieldName.
      For example if the fullPVFieldName = "power.value" then the field name is
      "value". </dd>
  <dt>fieldName</dt>
    <dd>The field name that will appear in the PVStructure that is a copy of
      the fields selected from the PVRecord. </dd>
  <dt>leaf</dt>
    <dd>This definition is a leaf element in the pvRequest structure. The field
      name in the copy structure will be fieldName. The field type will be is
      same as the type of fullPVRecordFieldName. This it could be a
    structure.</dd>
  <dt>fullPVRecordFieldName</dt>
    <dd>The full fieldname of PVRecord to which the field of copy will map.</dd>
</dl>

<p>Note:</p>
<ul>
  <li>The definition is recursive , i.e. an arbitarily complex structure can be
    defined.</li>
  <li>If options are required for a field than fieldList can not be used.</li>
  <li>If a pvRequest with no fields is specified than all fields if the target
    PVRecord will appear in the PVCopy.</li>
</ul>

<p>Two examples of options are process and shareData.</p>

<p>Process is a record option:</p>
<pre>    &lt;structure name = "record"&gt;
         &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;</pre>

<p>For example if process is an option to createGet then the record will be
processed before data is fetched. NOTE: scalarType boolean is also
supported.</p>

<p>The following is an example of a field option:</p>
<pre>   &lt;structure name = "field"&gt;
       ...
       &lt;structure name = "value"&gt;
           &lt;structure name = "leaf"&gt;
              &lt;scalar name = "source" scalarType = "string"&gt;value&lt;/scalar&gt;
              &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
           &lt;/structure&gt;
       &lt;/structure&gt;
       ...
   &lt;/structure&gt;</pre>

<p>This is a request to share the actual data rather than creating a copy.</p>

<p>A pvRequest structure can be created via the PVDataCreate interface
implemented by PVDataCreateFactory or by a call to
CreateRequestFactory.createRequest.</p>

<h4>Examples</h4>

<p>The following examples are for the simple and powerSupply records described
in the previous section.</p>

<h5>Simple example</h5>

<h6>The quickest Way</h6>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       alarm,timeStamp,power.value
    &lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following shows how example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvRequest,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvRequest.appendPVField(pvString);</pre>

<h6>Using the field notation</h6>

<p>The following structure defines a request for three fields: alarm,
timeStamp, and power.value</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp,power.value
        &lt;/scalar&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how the example can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVArrayString pvString = (PVString)pvDataCreate.createPVScalar(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp,power.value");
    pvField.appendPVField(pvString);
    pvRequest.appendPVField(pvField);</pre>

<p>In either case (quickest way or using the field notation) the PVStructure
holding data for the requester will have the structure:</p>
<pre> top
     alarm           // from record.alarm
     timeStamp       // from record.timeStamp
     value           // from record.power.value</pre>

<p>Note that if the actual record does not have a requested field than it will
not be present in the structure returned to the client.</p>

<p>The following is the same except that a record option and an option for the
value field will be given.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "record"&gt;
        &lt;scalar name = "process" scalarType = "string"&gt;true&lt;/scalar&gt;
    &lt;/structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;
           alarm,timeStamp
        &lt;/scalar&gt;
        &lt;structure name = "value"&gt;
            &lt;scalar name = "leaf" scalarType = "string"&gt;power.value&lt;/scalar&gt;
            &lt;scalar name = "shareData" scalarType = "string"&gt;true&lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The options are to process the record and to share the value data with the
power.value field in the PVRecord.</p>

<h5>Power Supply Example</h5>

<p>The following structure defines a request for alarm, timeStamp, power,
current, and voltage. Power, current, and voltage will each be a structure with
two fields: value and alarm.</p>
<pre>&lt;structure&gt;
    &lt;structure name = "field"&gt;
        &lt;scalar name = "fieldList" scalarType = "string"&gt;alarm,timeStamp&lt;/scalar&gt;
        &lt;structure name = "power"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                power.value,power.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "current"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                current.value,current.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
        &lt;structure name = "voltage"&gt;
            &lt;scalar name = "fieldList" scalarType = "string"&gt;
                voltage.value,voltage.alarm
            &lt;/scalar&gt;
        &lt;/structure&gt;
    &lt;/structure&gt;
&lt;/structure&gt;</pre>

<p>The following shows how this can be done by directly calling
pvDataCreate.</p>
<pre>    PVStructure pvRequest = pvDataCreate.createPVStructure(null, "", new Field[0]);
    PVStructure pvField = pvDataCreate.createPVStructure(pvRequest,"field", new Field[0]);
    PVString pvString = (PVString)pvDataCreate.createPVField(pvField,"fieldList",ScalerType.pvString);
    pvString.put("alarm,timeStamp");
    pvField.appendPVField(pvString);
    PVStructure pvStructure = pvDataCreate.createPVStructure(pvField, "power", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList",ScalerType.pvString);
    pvString.put("power.value,power.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "current", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("current.value,current.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvStructure = pvDataCreate.createPVStructure(pvField, "voltage", new Field[0]);
    pvString = (PVString)pvDataCreate.createPVField(pvStructure,"fieldList"ScalerType.pvString);
    pvString.put("voltage.value,voltage.alarm");
    pvStructure.appendPVField(pvString)
    pvField.appendPVField(pvStructure);
    pvRequest.appendField(pvField);</pre>

<p>In either case the resulting structure that appears to the client has the
form:</p>
<pre>pvData
   alarm          // from record.alarm
   timeStamp      // from record.timeStamp
   power          // appears because of pvRequest
      value       // from record.power.value
      alarm       // from record.power.alarm
   current        // appears because of pvRequest
      value       // from record.current.value
      alarm       // from record.current.alar.
   voltage        // appears because of pvRequest
      value       // from record.voltage.value
      alarm       // from record.voltage.alarm</pre>

<h3>PVCopy</h3>

<p>This is the interface for mapping between a PVStructure that contain a copy
of the data for a subset of the fields in a PVRecord. Note that this interface
is NOT for a single PVStructure but for a single PVRecord and a single
Structure introspection interface that describes a subset of the fields in the
PVRecord. For example if a server supports monitor queues then the server will
allocate a PVStructure for each queue element but will create a single
PVCopy.</p>
<pre>    interface PVCopy {
        PVRecord getPVRecord();
        Structure getStructure();
        PVStructure createPVStructure();
        int getCopyOffset(PVField recordPVField);
        int getCopyOffset(PVStructure recordPVStructure,PVField recordPVField);
        PVField getRecordPVField(int structureOffset);
        void initCopy(PVStructure pvCopy, BitSet bitSet,boolean recordLocked);
        void updateCopySetBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        void updateCopyFromBitSet(PVStructure copyPVStructure,BitSet bitSet,boolean lockRecord);
        boolean updateRecord(PVStructure pvCopy,BitSet bitSet,boolean lockRecord);
        PVCopyMonitor createPVCopyMonitor(PVCopyMonitorRequester pvCopyMonitorRequester);
    }</pre>

<p>where</p>
<dl>
  <dt>getPVRecord</dt>
    <dd>Get the PVRecord to which this PVCopy is attached</dd>
  <dt>getStructure</dt>
    <dd>Get the introspection interface which describes the subset of the
      fields in the PVRecord.</dd>
  <dt>createPVStructure</dt>
    <dd>Create a PVStructure which can hold a subset of the data from the
      PVRecord. A client may require multiple PVStructures. For example if a
      monitor request supports a queue than a PVStructure is required for each
      queue element. </dd>
  <dt>getCopyOffset(PVField recordPVField)</dt>
    <dd>Given a PVField from the record determine the offset within the
      PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt>getCopyOffset(PVStructure recordPVStructure,PVField recordPVField)</dt>
    <dd>Given a recordPVField within a recordPVStructure determine the offset
      within the PVStructure where the copy of the data is located.
      PVStructure.getSubField(offset) can be called to locate the PVField
      within the PVStructure. </dd>
  <dt>getRecordPVField</dt>
    <dd>Given an offset within a PVStructure return the corresponding PVField
      in the PVRecord.</dd>
  <dt>initCopy</dt>
    <dd>Initialize PVStructure with the current data from the PVRecord. The
      bitSet will have offset 0 set to 1 and all other bits set to 0. </dd>
  <dt>updateCopySetBitSet</dt>
    <dd>Update PVStructure from PVRecord. The BitSet shows which fields in
      PVStructure have changed.</dd>
  <dt>updateCopyFromBitSet</dt>
    <dd>Update PVStructure from PVRecord. Only fields that have the offset in
      bitSet set to true are modified.</dd>
  <dt>updateRecord</dt>
    <dd>Update the fields in PVRecord with data from PVStructure. Only fields
      that have the offset in bitSet set to true are modified. </dd>
  <dt>createPVCopyMonitor</dt>
    <dd>Create a PVCopyMonitor. See next section.</dd>
</dl>

<h3>PVCopyMonitor</h3>

<p>PVCopyMonitor is a PVListener for the PVRecord to which PVCopy is attached.
It updates two bitSets when it receives PVListener.dataPut callbacks. changeBit
shows all fields that have changed between calls to switchBitSets.
overrunBitSet shows all fields that have changed value more than once between
calls to switchBitSets. It notifies the PVCopyMonitorRequester when data has
changed. </p>
<pre>interface PVCopyMonitorRequester {
    void dataChanged();
    void unlisten();
}

interface PVCopyMonitor {
    void startMonitoring(BitSet changeBitSet, BitSet overrunBitSet);
    void stopMonitoring();
    void switchBitSets(BitSet newChangeBitSet,BitSet newOverrunBitSet, boolean lockRecord);
}</pre>

<p>PVCopyMonitorRequester is the interface implemented by the caller that calls
PVCopy.createPVCopyMonitor:</p>
<dl>
  <dt>dataChanged</dt>
    <dd>Data being monitored has changed.</dd>
  <dt>unlisten</dt>
    <dd>PVCopyMonitor has been told to unlisten so not more monitors will
      occur. </dd>
</dl>

<p>PVCopyMonitor is the interface returned by a call to
PVCopy.createPVCopyMonitor.</p>
<dl>
  <dt>startMonitoring</dt>
    <dd>Start monitoring.</dd>
  <dt>stopMonitoring</dt>
    <dd>Stop monitoring.</dd>
  <dt>switchBitSets</dt>
    <dd>If the pvStructure is not shared all fields that changeBitSet shows
      were changed are copied from the corresponding PVField of the PVRecord to
      the PVField of the PVStructure. Then the bitSets are replaced by the new
      bitSets. Note that a client needs just two instances of the bitSets and
      can just cycle between the two sets. Even if the PVStructure is shared
      this method is important since the caller will not miss data changes. It
      is illegal to call this if startMonitoring was called with no
    arguments.</dd>
</dl>

<h3>PVCopyFactory</h3>

<h4>Java Definition</h4>
<pre>    class PVCopyFactory {
        static PVCopy create(PVRecord pvRecord,PVStructure pvRequest,String structureName);
    }</pre>

<p>create has the arguments</p>
<dl>
  <dt>pvRecord</dt>
    <dd>The PVRecord to which the server is attached.</dd>
  <dt>pvRequest</dt>
    <dd>A PVStructure which describes the fields of PVRecord to which the
      server wants access. It is described below.</dd>
  <dt>structureName</dt>
    <dd>This must be one of: "field", "putField", or "getField"</dd>
  <dt>request</dt>
    <dd>As defined in previous examples.</dd>
  <dt>requester</dt>
    <dd>Definition is in org.epics.pvdata.pv.Requester.</dd>
</dl>

<p>createRequest is an easy way to create a pvRequest structure to pass to
<b>create</b>. It is described above.</p>

<h3>PVShare</h3>

<p>This is a factory that replaces a scalar or scalarArray field with a version
that shares the data from another field. When a get or put is issued the get or
put method of the shared PVField is called.</p>
<pre>class PVShareFactory {
    public static PVScalar replace(PVScalar pvNow,PVScalar pvShare);
    public static PVArray replace(PVArray pvNow,PVArray pvShare);
}</pre>

<h2>Package org.epics.pvioc.monitor</h2>

<h3>Overview</h3>

<p>Package org.epics.pvdata.monitor defines the monitor interfaces as seen by a
client. See that package overview for details. This package implements the
monitoring interfaces for a PVRecord.</p>

<p>The implementation uses PVCopy and PVCopyMonitor which are implemented in
package org.epics.pvioc.pvCopy. When PVCopyMonitor tells monitor that changes
have occurred, monitor applies the appropriate algorithm to each changed field
and if any algorithm says to raise a monitor a monitor is sent to the
client.</p>

<p>This package implements support for the following monitor algorithms:</p>
<dl>
  <dt>onPut</dt>
    <dd>A monitor is issued whenever a put is issued to the field. This is the
      default unless the record defines deadbands for a field. An exception is
      the top level timeStamp which by default is made onChange and monitor
      will not be raised.</dd>
  <dt>onChange</dt>
    <dd>This provides two options: 1) A monitor is raised whenever a field
      changes value, and 2) A monitor will never be raised for the field.</dd>
  <dt>deadband</dt>
    <dd>The field must be a numeric scalar. Whenever the absolute or percentage
      value of the field changes by more than a deadband a monitor is issued.
      The record instance can also define deadbands.</dd>
  <dt>periodic</dt>
    <dd>A monitor is issued at a periodic rate if a put was issued to any field
      being monitored.</dd>
</dl>

<h3>Implementing New Monitor Algorithms</h3>

<p>This section discusses how to implement new monitor algorithms in addition
to the onPut, onChange, etc, implemented by this package.</p>

<p>The monitor algorithm must register by calling:</p>
<pre>    MonitorFactory.registerMonitorAlgorithmCreater(MonitorAlgorithmCreate monitorAlgorithmCreate)</pre>

<p>The implementation must implement interfaces <b>MonitorAlgorithmCreate</b>
and <b>MonitorAlgorithm</b> which are described below.</p>

<h4>MonitorFactory</h4>

<p>This is a request to create a monitor.</p>
<pre>class MonitorFactory {
    static Monitor create(PVRecord pvRecord,
        MonitorRequester monitorRequester,PVStructure pvRequest);
    static void registerMonitorAlgorithmCreater(MonitorAlgorithmCreate monitorAlgorithmCreate)
}</pre>

<p>where</p>
<dl>
  <dt>create</dt>
    <dd>Create a monitor. The arguments are: 
      <dl>
        <dt>pvRecord</dt>
          <dd>The record being monitored.</dd>
        <dt>monitorRequester</dt>
          <dd>The monitor requester. This is the code to which monitot events
            will be delivered.</dd>
        <dt>pvRequest</dt>
          <dd>The request options</dd>
      </dl>
    </dd>
  <dt><b>registerMonitorAlgorithmCreater</b></dt>
    <dd>Called by code that implements a monitor algorithm.</dd>
</dl>

<h4>MonitorAlgorithm</h4>

<p>The following are implemented by code that implements a monitor
algorithm.</p>
<pre>interface MonitorAlgorithmCreate {
    String getAlgorithmName();
    MonitorAlgorithm create(
            PVRecord pvRecord,
            MonitorRequester monitorRequester,
            PVField fromPVRecord,
            PVStructure pvOptions);
}

interface MonitorAlgorithm  {
    String getAlgorithmName();
    boolean causeMonitor();
    void monitorIssued();
}</pre>

<p>where</p>
<dl>
  <dt>getAlgorithmName</dt>
    <dd>return the name of the algorithm.</dd>
  <dt>causeMonitor</dt>
    <dd>Called to see if a change to this field should cause a monitor</dd>
  <dt>monitorIssued</dt>
    <dd>Called after a monitor has been issued.</dd>
</dl>

<h2>Package org.epics.pvioc.caV3</h2>

<h3>Overview</h3>

<p>This package provides support for Channel Access Version 3. The server
allows an existing Channel Access client to access a javaIOC database. The
client allows the javaIOC to communicate with a Version 3 server, e.g. a
javaIOC database can have links to records in a V3 IOC database.</p>

<p>In order to be available to a javaIOC, each must be started via the
appropriate factory. This is just a call to the start method. For example:</p>
<pre>    org.epics.pvioc.caV3.ClientFactory.start();</pre>

<p>The client must be started before the IOC is started and the server after.
The javaIOC overview provides instructions for using XMLToDatabase to start
everything.</p>

<p>Both the client and server use the JCA/CAJ support provided by <a
href="http://jca.cosylab.com">cosylab</a>. In addition the server uses the CAS
support that comes with the latest versions of JCA/CAJ.</p>

<h3>Server</h3>

<h4>Syntax</h4>

<p>A V3 client can access any field of a javaIOC record that is a scalar, an
array of scalars, or an enumerated structure. A boolean field appears as a
DBR_ENUM with choices = {"false","true"}.</p>

<p>A pvName has the form:</p>
<pre>    recordName.name.name...{options}</pre>

<p>where</p>
<dl>
  <dt>recordName</dt>
    <dd>The name of a javaIOC record</dd>
  <dt>name.name...</dt>
    <dd>Each name is a fieldName or propertyName or index as described in
      package org.epics.pvioc.pv. The final field must a scalar, an array of
      scalars, or an enumerated structure.</dd>
  <dt>options</dt>
    <dd>options are of the form "name=value". The options are described
    below.</dd>
</dl>

<p>The following examples use the channel access utility shell commands that
come with EPICS base. The database is the example/exampleDB.xml that comes with
the javaIOC. </p>
<pre>    caput double 6</pre>

<p>This writes the value 6 to the value field of a record named double.</p>
<pre>    caput double.{process=true} 5</pre>

<p>This writes the value 5 to record double and also requests that the record
be processed. The value is written before the record is processed.</p>
<pre>     caget -d 20 double.{process=true}</pre>

<p>This gets the value field of record double. The record is processed.</p>
<pre>    caput powerSupplyArray.supply.1.power{process=true} 2</pre>

<p>This writes the value 2 to the power.value field of the second supply of the
powerSupplyArray record.</p>

<h4>Get and Put Options</h4>

<p>The currently supported options are:</p>
<pre>    process=true
    shareData=true</pre>

<p>For get the record is processed before the get and for put the record is
processed after the put. In order for either to work, the record must not
already have a recordProcessor assigned to it.</p>

<h4>monitor options</h4>

<p>Currently no options are supported. </p>

<h3>Client</h3>

<p><b>NOTE: </b>The client code is implemented by pvAccess.</p>

<h4>Overview</h4>

<p>The client code implements a ChannelProvider that communicates with Channel
Access version 3 IOCs. It allows access to all the V3 data types. The provider
name is "caV3". </p>

<p>The channelName is of the form recordName.fieldName, where fieldName is
optional. See naming conventions below for details. <b>MARTY SYNTAX FOR
fieldName IS LIKE request</b></p>

<p>The client code implements the standard ChannelProvider interface as defined
by cajV4. This means that it also implements interface Channel. However only
the features that make sense for caV3 are implemented. </p>

<p>For Channel the implementation of the following methods is:</p>
<dl>
  <dt>getField</dt>
    <dd>Returns a Structure. The structure has a field named "value", which is
      related to the fieldName of the channel. The type of the value field
      depends on the caV3 native type. If the type is DBR_ENUM then the value
      field will be an enumerated structure. For the other DBR types the value
      field will be either a scalar or an array depending of the DBR type. The
      scalarType of the field will match the DBR type. For all types the
      Structure will have fields timeStamp and alarm, which are the standard
      timeStamp and alarm structures. If the native DBR Type is numeric then
      the Structure will also have structure fields for control and
    display.</dd>
  <dt>getChannelProcess</dt>
    <dd>Not supported.</dd>
  <dt>createChannelArray</dt>
    <dd>Not supported.</dd>
  <dt>createChannelGet</dt>
    <dd>Supported. Also support for alarm, timeStamp, display, and control.</dd>
  <dt>createChannelPut</dt>
    <dd>Supported but no support for properties.</dd>
  <dt>createChannelPutGet</dt>
    <dd>Not supported.</dd>
  <dt>createMonitor</dt>
    <dd>Supported. Also support for alarm and timeStamp. Note that a single get
      request is made after connection so that enum choices and control and
      display information can be obtained. For a numeric value field support
      for display and control is implemented. Note that the display and control
      information will not change. This matches the caV3 semantics.</dd>
</dl>

<p></p>

<h4>Naming conventions.</h4>

<p>A PV Name (Process Variable Name) must be of the form:</p>
<pre>    recordName.fieldName</pre>

<p>where</p>
<dl>
  <dt>recordName</dt>
    <dd>Is the name of a record in a V3 IOC database.</dd>
  <dt>fieldName</dt>
    <dd>Must be a valid caV3 fieldname like VAL or RVAL. It is optional since
      it is optional for v3.</dd>
</dl>

<p>The pvRequest passed to createChannelGet, createChannelPut, and
createMonitor must define a request that makes sense for a v3 record. For all
three the request should include the definition for a value field, which is
associated with the fieldName of the pvName. For all it is OK to attach to a
record which has a VAL field that is a DBR_ENUM. In this case the value can be
retrieved as an enumerated structure or just the index or string value can be
retrieved.</p>

<p>The following request structure will get the value, alarm, and timeStamp:</p>
<pre>&lt;structure name = "request"&gt;
    &lt;scalar name = "fieldList" scalarType = "string"&gt;
       value,alarm,timeStamp
    &lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following will access the index of an DBR_ENUM:</p>
<pre>&lt;structure name = "request"&gt;
     &lt;scalar name = "value" scalarType = "string"&gt;value.index&lt;/scalar&gt;
     &lt;scalar name = "alarm" scalarType = "string"&gt;alarm&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<p>The following will access the choice of an DBR_ENUM:</p>
<pre>&lt;structure name = "request"&gt;
     &lt;scalar name = "value" scalarType = "string"&gt;value.choice&lt;/scalar&gt;
     &lt;scalar name = "alarm" scalarType = "string"&gt;alarm&lt;/scalar&gt;
&lt;/structure&gt;</pre>

<h4>Data Types Supported</h4>

<p>The V3 data types are supported via a corresponding javaIOC data type. A V3
<b>char</b> is a javaIOC <b>byte</b>. The types <b>short, int, float, and
double</b> are common to both. A V3 <b>string</b> becomes a javaIOC
<b>String</b>. Arrays of byte,short,...,string are also supported. A V3
<b>ENUM</b> becomes a javaIOC enumerated structure. V3 properties (status,
severity, timeStamp, display limits, and control limits) become standard pvData
structures (alarm, timeStamp, display, and control).</p>
</div>
</div>
</body>
</html>
