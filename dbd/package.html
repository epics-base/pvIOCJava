<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS JavaIOC: Database Model</title>
</head>

<body>
<h1 style="text-align: center">EPICS JavaIOC: Database Model<br />
2007.09.06</h1>
<hr />

<h2 style="text-align: center">Summary</h2>
<hr />

<p>The Database Model supports general purpose client tools. A set of
structures are defined that support the data model. A recordType supports the
data model if it follows a few simple guidelines.</p>

<p>The model can briefly be described as follows: Clients access fields in a
structure. A field meant for general purpose clients is considered a property
and the field name is the property name. The structure normally has a field
named "value". It is usually a data field, i.e. a scalar type or an array
with the elementType being scalar. All other fields of the structure support
the value. Typical property fields are timeStamp, alarm, display, control,
and history.</p>
<hr />

<h2 style="text-align: center">Background</h2>
<hr />

<p>Currently the Java IOC Database Definitions include property definitions.
For example recordType double is defined something like:</p>
<pre>&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;field name = "value" type = "double" &gt;
    &lt;property name = "alarm" associatedField = "alarm" /&gt;
    &lt;property name = "display" associatedField = "display" /&gt;
    &lt;property name = "timeStamp" associatedField = "timeStamp" /&gt;
  &lt;/field&gt;
  &lt;field name = "alarm" type = "structure" structureName = "alarm"
      supportName = "alarm" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/recordType&gt;</pre>

<p>The above says that field "value" has the associated properties. The
associatedField indicates where to find the associated data. </p>

<p>During the meeting at DESY the idea of property was discussed by Matthias,
Matej, and myself. The property definitions go away. The above becomes:</p>
<pre>&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;field name = "value" type = "double" /&gt;
  &lt;field name = "alarm" type = "structure" structureName = "alarm"
      supportName = "alarm" /&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/recordType&gt;</pre>

<p>The entire record is an object that has properties and one of the
properties happens to be "value". A property is identified by name.</p>

<p>This document discusses removing the existing property definitions while
keeping the ability to have generic records, structures, and support. </p>

<p>Before proceeding, however, I want to mention one other thing that came up
in the discussion at DESY. Matej distinguished between a property and a
characteristic. A property can change value but a characteristic is
immutable. Thus in the above value, alarm, and timeStamp are properties but
display is a characteristic. But as we know from EPICS HOPR and LOPR,
characteristics can change. Thus the javaIOC does not distinguish between a
property and a characteristic.</p>
<hr />

<h2 style="text-align: center">JavaIOC Data Model</h2>
<hr />

<h3>Basic Concept</h3>

<p>A javaIOC structure follows the javaIOC Data Model if it has a set of
fields that have names and types that support the data model. It can have
additional fields, that can also be considered properties. The following
field names have special meaning, i.e. are properties for general purpose
clients.</p>
<dl>
  <dt>value</dt>
    <dd>This is normally defined since most general purpose clients expect
      this property. All other fields in the structure support or describe
      the value field. The type can any supported type but is usually one of
      the following: 
      <dl>
        <dt>scalar</dt>
          <dd>One of boolean, byte, short, int, long, float, double, or
          string</dd>
        <dt>scalar array</dt>
          <dd>An array with the elementType being a scalar type</dd>
        <dt>enumerated structure</dt>
          <dd>A structure that includes fields named index, choice, and
            choices. index is an int that selects a choice. choice is the
            currently selected choice. choices is an array of strings that
            defines the complete set of choices.</dd>
        <dt>other</dt>
          <dd>Other structure or array types can also be defined if clients
            and support code agree on the meaning. Some examples are: 1) A
            structure defining a 2D matrix, 2) A structure defining an image,
            3) A structure that simulates a remote method, ...</dd>
      </dl>
    </dd>
  <dt>timeStamp</dt>
    <dd>The timeStamp. The type MUST be a timeStamp structure. Also if the
      javaIOC structure does not have a timeStamp then a search up the parent
      tree is made to find a timeStamp.</dd>
  <dt>alarm</dt>
    <dd>The alarm. The type MUST be an alarm structure. Also if the javaIOC
      structure does not have a alarm then a search up the parent tree is
      made to find a alarm.</dd>
  <dt>display</dt>
    <dd>A display structure as described below. It provides display
      characteristics for the value field.</dd>
  <dt>control</dt>
    <dd>A control structure as described below. It provides control
      characteristics for the value field.</dd>
  <dt>history</dt>
    <dd>A history structure as described below. It provides a history buffer
      for the value field.</dd>
  <dt>other</dt>
    <dd>Other standard properties can be defined.</dd>
</dl>

<p>In addition the javaIOC structure can have additional fields that support
the value field but are not recognized by most general purpose client tools.
Typical examples are:</p>
<dl>
  <dt>input</dt>
    <dd>A field with support that changes the value field. This can be
      anything. It can be a channel access link. It can obtain a value from
      hardware. Etc.</dd>
  <dt>valueAlarm</dt>
    <dd>A field with support that looks for alarm conditions based on the
      value.</dd>
  <dt>output</dt>
    <dd>A field with support that reads the current value and sends it
      somewhere else. This can be anything. It can be a channel access link.
      It can write a value to hardware. Etc.</dd>
</dl>

<h4>device records</h4>
The model allows for device records. A device record has fields that are
structures that support the javaIOC data model. For example a powerSupport
record can have fields power, voltage, current that each support the javaIOC
data model. 

<h3>structure null</h3>

<p>Any field except value can be a structure with a null structure as the
default. If a record instance does not override the default than code must
act as if the field does not exist. If a record instance does override the
field than it must replace the structure with a structure that supports the
data model.</p>

<h3>PV Access</h3>

<p>Currently the javaIOC defines an interface PVAccess, which locates fields
named "field.field...". This will be changed to act as follows:</p>
<ul>
  <li>The user starts with a string of the form "field.field...". It can be
    empty, i.e. "", which means the record instance itself. If not empty to
    must be a structure within a record instance.</li>
  <li>The user can ask for properties by name, i.e. "name". The code will
    return an interface to the data only if it finds the field and the field
    is not a null structure. Note again that it will look up the parent tree
    for timeStamp and alarm. </li>
  <li>The user can also ask for specific fields of a property field. For
    example a user can ask for alarm.severity instead of just asking for
    alarm.</li>
  <li>It will provide a method getPropertys that will return an array of
    interfaces to all the fields that are found EXCEPT the value field. It
    will not return an interface to a null structure.</li>
</ul>

<h3>example</h3>

<p>The following example is for a structure and record type with the value
field being of type double.</p>

<h4>common.xml</h4>

<p>This has definitions for fields that are common to most record types.</p>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
    &lt;field name = "scan" type = "structure" structureName = "scan"
         supportName = "scan" /&gt;
    &lt;field name = "processAfterStart" type = "boolean" default = "false" /&gt;
&lt;/DBDefinition&gt;</pre>
<dl>
  <dt>scan</dt>
    <dd>This defines how the record is processed, i.e. passive, periodic, or
      event</dd>
  <dt>processAfterStart</dt>
    <dd>Should the record instance be processed once after the record has
      been started.</dd>
</dl>

<h4>doubleCommon.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
  &lt;field name = "alarm" type = "structure" /&gt;
  &lt;field name = "timeStamp" type = "structure"/&gt;
  &lt;field name = "value" type = "double" ?&gt;
  &lt;field name = "input" type = "structure" /&gt;
  &lt;field name = "valueAlarm" type = "structure" /&gt;
  &lt;field name = "output" type = "structure" /&gt;
  &lt;field name = "display" type = "structure" /&gt;
  &lt;field name = "control" type = "structure" /&gt;
  &lt;field name = "history" type = "structure" /&gt;
&lt;/DBDefinition&gt;</pre>
<dl>
  <dt>alarm</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "alarm".</dd>
  <dt>timeStamp</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "timeStamp".</dd>
  <dt>value</dt>
    <dd>The value field. Note that by default this is the only field that is
      not a null structure.</dd>
  <dt>input</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by defining structureName and supportName so that it
      connects to support that does a put to the value field. The javaIOC
      provides support for channel access links and for connecting to
      hardware via portDriver. Other support can also be implemented.</dd>
  <dt>valueAlarm</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "doubleAlarm".</dd>
  <dt>output</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by defining structureName and supportName so that it
      connects to support that gets the value field and sends it somewhere.
      The javaIOC provides support for channel access links and for
      connecting to hardware via portDriver. Other support can also be
      implemented.</dd>
  <dt>display</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "display".</dd>
  <dt>control</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "control".</dd>
  <dt>history</dt>
    <dd>By default this is a null structure. A record/structure instance can
      overide this by setting structureName = "doubleHistory".</dd>
</dl>

<h4>doubleRecord.xml</h4>
<pre>&lt;?xml version="1.0" ?&gt;
&lt;DBDefinition&gt;
&lt;structure name = "double" supportName = "generic" &gt;
  &lt;include href = "doubleCommon.xml" /&gt;
&lt;/structure&gt;

&lt;recordType name = "double" supportName = "generic" &gt;
  &lt;include href = "common.xml" /&gt;
  &lt;include href = "doubleCommon.xml" /&gt;
  &lt;field name = "supportArray" type = "array"
     elementType = "structure" supportName = "supportArray" /&gt;
&lt;/recordType&gt;
&lt;/DBDefinition&gt;</pre>

<p>Both a structure and a recordType are defined. The only difference is the
the recordType has fields scan and processAfterStart. The structure can be
embeded in device records. The recordType is for record instances.</p>

<h4>Example double record instance</h4>

<p>The following defines an analog input record instance.</p>
<pre>&lt;record name = "ai" type = "double" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;alarm structureName = "alarm" /&gt;
    &lt;input structureName = "linearConvertInput"&gt;
        &lt;linearConvert&gt;
            &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
            &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
            &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
            &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
        &lt;/linearConvert&gt;
        &lt;input supportName = "pdrvInt32Input" structureName = "pdrvSupport"&gt;
            &lt;portName&gt;somePort&lt;/portName&gt;
            &lt;addr&gt;0&lt;/addr&gt;
            &lt;timeout&gt;.2&lt;/timeout&gt;
            &lt;size&gt;20&lt;/size&gt;
        &lt;/input&gt;        
    &lt;/input&gt;
    &lt;display structureName = "display" &gt;
        &lt;units&gt;volts&lt;/units&gt;
        &lt;limit&gt;
            &lt;low&gt;0.0&lt;/low&gt;
            &lt;high&gt;10.0&lt;/high&gt;
        &lt;/limit&gt;
    &lt;/display&gt;
&lt;/record&gt;</pre>

<p>NOTES:</p>
<ul>
  <li>timeStamp<br />
    Since structureName = "timeStamp" is defined the record instance has a
    timeStamp. If this was not defined the record would not have a
  timeStamp.</li>
  <li>alarm<br />
    Since structureName = "alarm" is defined the record instance has an
    alarm. If this was not defined the record would not have an alarm.</li>
  <li>input<br />
    Input is obtained via support linearConvertInput and portDriver.
    pdrvInt32Input reads an integer value via portDriver and puts it into
    input.value. linearConvertInput reads input.value, converts it to
    engineering units, and puts the result into value.</li>
  <li>display<br />
    Several of the display fields are initialized.</li>
</ul>

<h3>powerSupply example</h3>

<h4>Database Definition</h4>
<pre>&lt;DBDefinition&gt;
&lt;include addPath = "dbd" /&gt;

&lt;recordType name = "powerSupply" supportName = "generic" &gt;
    &lt;include href = "common.xml" /&gt;
    &lt;field name = "alarm" type = "structure" structureName = "alarm" /&gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp"/&gt;
    &lt;field name = "voltage" type = "structure" /&gt;
    &lt;field name = "power" type = "structure" &gt;&gt;
    &lt;field name = "current" type = "structure" /&gt;
&lt;/recordType&gt;

&lt;support name = "powerSupply"
   factoryName = "org.epics.ioc.support.PowerSupplyFactory" /&gt;

&lt;/DBDefinition&gt;</pre>

<p>NOTES:</p>
<ul>
  <li>timeStamp<br />
    Since structureName = "timeStamp" every record instance will have a
    timeStamp.</li>
  <li>alarm<br />
    Since structureName = "alarm" every record instance will have an
  alarm.</li>
  <li>voltage<br />
    Since this is a null structure each record instance must overide the
    definition.</li>
  <li>power<br />
    Since this is a null structure each record instance must overide the
    definition.</li>
  <li>current<br />
    Since this is a null structure each record instance must overide the
    definition.</li>
  <li>Client access<br />
    A generic client would access &lt;recordname&gt;.voltage or
    &lt;recordname&gt;.power or &lt;recordname&gt;.current. A client that
    understands powerSupply could just access &lt;recordname&gt;.</li>
</ul>

<h4>Example powerSupply instance</h4>

<p>The following defines a power supply instance that gets it's voltage from
an adc and sets the current via a dac.</p>
<pre>&lt;record name = "ps" type = "powerSupply" &gt;
    &lt;timeStamp structureName = "timeStamp" /&gt;
    &lt;voltage structureName = "double" supportName = "generic" &gt;
         &lt;alarm structureName = "alarm" /&gt;
          &lt;input structureName = "linearConvertInput"&gt;
              &lt;linearConvert&gt;
                  &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
                  &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
                  &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                  &lt;engUnitsHigh&gt;10.0&lt;/engUnitsHigh&gt;
              &lt;/linearConvert&gt;
              &lt;input supportName = "pdrvInt32Input" structureName = "pdrvSupport"&gt;
                   &lt;portName&gt;someDriver&lt;/portName&gt;
                   &lt;addr&gt;0&lt;/addr&gt;
                   &lt;timeout&gt;.2&lt;/timeout&gt;
                   &lt;size&gt;20&lt;/size&gt;
              &lt;/input&gt;        
         &lt;/input&gt;
         &lt;display structureName = "display" &gt;
             &lt;units&gt;volts&lt;/units&gt;
             &lt;limit&gt;
                 &lt;low&gt;0.0&lt;/low&gt;
                 &lt;high&gt;10.0&lt;/high&gt;
             &lt;/limit&gt;
         &lt;/display&gt;
    &lt;/voltage&gt;
    &lt;power structureName = "double" supportName = "powerSupply" /&gt;
    &lt;current structurName = "double" supportName = "generic" &gt;
         &lt;alarm structureName = "alarm" /&gt;
          &lt;output structureName = "linearConvertOutput"&gt;
              &lt;linearConvert&gt;
                  &lt;deviceHigh&gt;2047&lt;/deviceHigh&gt;
                  &lt;deviceLow&gt;-2048&lt;/deviceLow&gt;
                  &lt;engUnitsLow&gt;0.0&lt;/engUnitsLow&gt;
                  &lt;engUnitsHigh&gt;2.0&lt;/engUnitsHigh&gt;
              &lt;/linearConvert&gt;
              &lt;output supportName = "pdrvInt32Output" structureName = "pdrvSupport"&gt;
                   &lt;portName&gt;someDriver&lt;/portName&gt;
                   &lt;addr&gt;1&lt;/addr&gt;
                   &lt;timeout&gt;.2&lt;/timeout&gt;
                   &lt;size&gt;20&lt;/size&gt;
              &lt;/output&gt;        
         &lt;/output&gt;
         &lt;display structureName = "display" &gt;
             &lt;units&gt;volts&lt;/units&gt;
             &lt;limit&gt;
                 &lt;low&gt;0.0&lt;/low&gt;
                 &lt;high&gt;2.0&lt;/high&gt;
             &lt;/limit&gt;
         &lt;/display&gt;
    &lt;/current&gt;
&lt;/record&gt;</pre>

<p>NOTES:</p>
<ul>
  <li>voltage<br />
    The voltage supports the javaIOC data model. It has it's own alarm but
    uses the timeStamp of the record instance. It gets a value for
    voltage.value via portDriver and linearConvertInput. </li>
  <li>power<br />
    The power supports the javaIOC data model. In the above example no
    additional properties besides value are defined but they could be
    defined. The support named powerSupply will get the power.value and
    voltage.value. From this it will compute and put current.value. </li>
  <li>current<br />
    The current supports the javaIOC data model. It has it's own alarm but
    uses the timeStamp of the record instance. It uses linearConvertOutput to
    convert current.value to current.output.value which is then written to
    hardware via portDriver. </li>
</ul>
<hr />

<h2 style="text-align: center">Definitions for Standard Properties</h2>
<hr />

<p>The following are the proposed set of structures for standard properties
for general purpose client tools. </p>

<h3>timeStamp</h3>
<pre>&lt;structure name = "timeStamp"&gt;
  &lt;field name = "secondsPastEpoch" type = "long" /&gt;
  &lt;field name = "nanoSeconds" type = "int" /&gt;
&lt;/structure&gt;</pre>

<h3>alarm</h3>
<pre>&lt;structure name = "alarm" supportName = "alarm" &gt;
  &lt;field name = "severity" type = "structure" structureName = "alarmSeverity" /&gt;
  &lt;field name = "message" type = "string" /&gt;
  &lt;field name = "ackTransient" type = "boolean" /&gt;
  &lt;field name = "ackSeverity" type = "structure" structureName = "alarmSeverity" /&gt;
&lt;/structure&gt;</pre>

<h3>display</h3>
<pre>&lt;structure name = "display"&gt;
    &lt;field name = "description" type = "string" /&gt;
    &lt;field name = "format" type = "string" /&gt;
    &lt;field name = "units" type = "string" /&gt;
    &lt;field name = "resolution" type = "int" /&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
&lt;/structure&gt;</pre>

<h3>control</h3>
<pre>&lt;structure name = "control"&gt;
    &lt;field name = "limit" type = "structure" structureName = "doubleLimit" /&gt;
    &lt;field name = "minStep" type = "double" /&gt;
&lt;/structure&gt;</pre>

<h3>history</h3>

<p>The following describes the structures for history for a double value
field. Definitions will also appear for booleanHistory, byteHistory, ...,
stringHistory.</p>
<pre>&lt;structure name = "doubleHistory" &gt;
    &lt;field name = "timeStamp" type = "structure" structureName = "timeStamp" /&gt;
    &lt;field name = "value" type = "double" /&gt;
    &lt;field name = "alarm" type = "structure"
         structureName = "alarm" supportName = "null" /&gt;
&lt;/structure&gt;

&lt;structure name = "history" supportName = "doubleHistory" &gt;
    &lt;field name = "size" type = "int" /&gt;
    &lt;!-- other fields are needed. TODO --&gt;
    &lt;!-- support will make this an array of doubleHistory structures --&gt;
    &lt;field name = "data" type = "array" elementType = "structure" /&gt;
&lt;/structure&gt;</pre>
</body>
</html>
